<!-- vscode-markdown-toc -->
* 1. [é¢˜ç›®](#)
	* 1.1. [100-Same Tree](#SameTree)
	* 1.2. [101-Symmetric tree](#Symmetrictree)
	* 1.3. [102-Binary Tree Level Order Traversal](#BinaryTreeLevelOrderTraversal)
	* 1.4. [103. Binary Tree Zigzag Level Order Traversal](#BinaryTreeZigzagLevelOrderTraversal)
	* 1.5. [104-Maximum Depth of Binary](#MaximumDepthofBinary)
	* 1.6. [105-ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„](#-1)
	* 1.7. [106-ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](#-1)
	* 1.8. [107-Binary Tree Level Order Traversal II](#BinaryTreeLevelOrderTraversalII)
	* 1.9. [108 Convert Sorted Array to Binary Search Tree](#ConvertSortedArraytoBinarySearchTree)
	* 1.10. [109é¢˜. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘](#-1)
	* 1.11. [110-Balanced Binary Tree](#BalancedBinaryTree)
	* 1.12. [111-Minimum Depth of Binary Tree](#MinimumDepthofBinaryTree)
	* 1.13. [112-Path Sum](#PathSum)
	* 1.14. [113. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„](#-1)
	* 1.15. [114é¢˜. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](#-1)
	* 1.16. [115. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Distinct Subsequences](#DistinctSubsequences)
	* 1.17. [116. Populating Next Right Pointers in Each Node](#PopulatingNextRightPointersinEachNode)
	* 1.18. [117 Populating Next Right Pointers in Ea (å¯è·³è¿‡)](#PopulatingNextRightPointersinEa)
	* 1.19. [118-Pascal's Triangle](#PascalsTriangle)
	* 1.20. [119-Pascal's Triangle II](#PascalsTriangleII)
	* 1.21. [120 ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Triangle](#Triangle)
	* 1.22. [121. Best Time to Buy and Sell Stock  121-ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº](#BestTimetoBuyandSellStock121-)
	* 1.23. [122-ã€è´ªå¿ƒğŸ§¡ã€‘ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II 122-Best Time to Buy and Sell Stock II](#II122-BestTimetoBuyandSellStockII)
	* 1.24. [123-ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III](#III)
	* 1.25. [124. Binary Tree Maximum Path Sum](#BinaryTreeMaximumPathSum)
	* 1.26. [125 ã€å›æ–‡ğŸŒˆã€‘Valid Palindrome](#ValidPalindrome)
	* 1.27. [126. (bfså¥½éš¾æš‚æ—¶æ”¾å¼ƒ) Word Ladder II](#bfsWordLadderII)
	* 1.28. [127. Word Ladder](#WordLadder)
	* 1.29. [128. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Longest Consecutive Sequence](#LongestConsecutiveSequence)
	* 1.30. [129 Sum Root to Leaf Numbers](#SumRoottoLeafNumbers)
	* 1.31. [130. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Surrounded Regions 130-è¢«å›´ç»•çš„åŒºåŸŸ](#SurroundedRegions130-)
	* 1.32. [131 ã€å›æ–‡ğŸŒˆã€‘åˆ†å‰²å›æ–‡ğŸŒˆä¸²](#-1)
	* 1.33. [132. ã€åŠ¨æ€ğŸš€è§„åˆ’ + å›æ–‡ğŸŒˆã€‘Palindrome Partitioning II](#PalindromePartitioningII)
	* 1.34. [133. Clone Graph](#CloneGraph)
	* 1.35. [134. Gas Station](#GasStation)
	* 1.36. [138 Copy List with Random Pointer](#CopyListwithRandomPointer)
	* 1.37. [136 ã€ä½è¿ç®—ğŸ˜œã€‘Single Number](#SingleNumber)
	* 1.38. [137 ã€ä½è¿ç®—ğŸ˜œã€‘Single Number II](#SingleNumberII)
	* 1.39. [139 ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ…ã€‘Word Break](#WordBreak)
	* 1.40. [140 Word Break II](#WordBreakII)
	* 1.41. [141-Linked List Cycle](#LinkedListCycle)
	* 1.42. [142 Linked List Cycle II](#LinkedListCycleII)
	* 1.43. [143 Reorder List](#ReorderList)
	* 1.44. [144-Preorder with stack](#Preorderwithstack)
	* 1.45. [144-Binary Tree Preorder Traversal](#BinaryTreePreorderTraversal)
	* 1.46. [145-Postorder with stack](#Postorderwithstack)
	* 1.47. [145-Binary Tree Postorder Traversal](#BinaryTreePostorderTraversal)
	* 1.48. [146 ã€æ„é€ ğŸ°ã€‘LRU Cache](#LRUCache)
	* 1.49. [147 Insertion Sort List](#InsertionSortList)
	* 1.50. [148. Sort List](#SortList)
	* 1.51. [149. Max Points on a Line](#MaxPointsonaLine)
	* 1.52. [150. Evaluate Reverse Polish Notation](#EvaluateReversePolishNotation)
	* 1.53. [151. Reverse Words in a String](#ReverseWordsinaString)
	* 1.54. [152 ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ä¹˜ç§¯æœ€å¤§å­æ•°ç»„](#-1)
	* 1.55. [153-å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼](#-1)
	* 1.56. [154 Find Minimum in Rotated Sorted Arr](#FindMinimuminRotatedSortedArr)
	* 1.57. [155-ã€æ„é€ ğŸ°ã€‘Min Stack](#MinStack)
	* 1.58. [160-Intersection of Two Linked Lists](#IntersectionofTwoLinkedLists)
	* 1.59. [162. Find Peak Element](#FindPeakElement)
	* 1.60. [165. Compare Version Numbers](#CompareVersionNumbers)
	* 1.61. [166. Fraction to Recurring Decimal](#FractiontoRecurringDecimal)
	* 1.62. [167-Two Sum II - Input array is sorted](#TwoSumII-Inputarrayissorted)
	* 1.63. [168-Excel Sheet Column Title](#ExcelSheetColumnTitle)
	* 1.64. [169. ã€ä½è¿ç®—ğŸ˜œã€‘Majority Element](#MajorityElement)
	* 1.65. [171. Excel Sheet Column Number](#ExcelSheetColumnNumber)
	* 1.66. [172-Factorial Trailing Zeroes](#FactorialTrailingZeroes)
	* 1.67. [173 ã€æ„é€ ğŸ°ã€‘Binary Search Tree Iterator](#BinarySearchTreeIterator)
	* 1.68. [174 Dungeon Game](#DungeonGame)
	* 1.69. [179 Largest Number](#LargestNumber)
	* 1.70. [186. Reverse Words in a String II](#ReverseWordsinaStringII)
	* 1.71. [187 ã€ä½è¿ç®—ğŸ˜œã€‘Repeated DNA Sequences](#RepeatedDNASequences)
	* 1.72. [188 ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Best Time to Buy and Sell Stock IV](#BestTimetoBuyandSellStockIV)
	* 1.73. [189. Rotate Array](#RotateArray)
	* 1.74. [190. ã€ä½è¿ç®—ğŸ˜œã€‘Reverse Bits](#ReverseBits)
	* 1.75. [191 Number of 1 Bits](#Numberof1Bits)
	* 1.76. [198. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘House Robber 198-æ‰“å®¶åŠ«èˆ](#HouseRobber198-)
	* 1.77. [199 Binary Tree Right Side View](#BinaryTreeRightSideView)
	* 1.78. [200 ã€ğŸ’å¹¶æŸ¥é›†ã€‘å²›å±¿æ•°é‡](#-1)
	* 1.79. [201 ã€ä½è¿ç®—ğŸ˜œã€‘Bitwise AND of Numbers Range](#BitwiseANDofNumbersRange)
	* 1.80. [202. å¿«ä¹æ•° Happy Number](#HappyNumber)
	* 1.81. [203. Remove Linked List Elements](#RemoveLinkedListElements)
	* 1.82. [204-Count Primes](#CountPrimes)
	* 1.83. [205. isomorphic strings](#isomorphicstrings)
	* 1.84. [206-Reverse Linked List](#ReverseLinkedList)
	* 1.85. [207-è¯¾ç¨‹è¡¨](#-1)
	* 1.86. [208. ã€æ„é€ ğŸ°ã€‘Implement Trie (Prefix Tree)](#ImplementTriePrefixTree)
	* 1.87. [209-é•¿åº¦æœ€å°çš„å­æ•°ç»„](#-1)
	* 1.88. [210. Course Schedule II 210-è¯¾ç¨‹è¡¨II](#CourseScheduleII210-II)
	* 1.89. [211 Add and Search Word](#AddandSearchWord)
	* 1.90. [212. ã€æ„é€ ğŸ° + å›°éš¾ã€‘Word Search II](#WordSearchII)
	* 1.91. [213.ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ House Robber II 213-æ‰“å®¶åŠ«èˆII](#HouseRobberII213-II)
	* 1.92. [216. Combination Sum III 216-ç»„åˆæ€»å’Œ III](#CombinationSumIII216-III)
	* 1.93. [217. Contains Duplicate](#ContainsDuplicate)
	* 1.94. [218. The Skyline Problem](#TheSkylineProblem)
	* 1.95. [219. Contains Duplicate II](#ContainsDuplicateII)
	* 1.96. [220 Contains Duplicate III](#ContainsDuplicateIII)
	* 1.97. [221-ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘æœ€å¤§æ­£æ–¹å½¢](#-1)
	* 1.98. [222. Count Complete Tree Nodes](#CountCompleteTreeNodes)
	* 1.99. [223. Rectangle Area](#RectangleArea)
	* 1.100. [224](#-1)
	* 1.101. [225-ã€æ„é€ ğŸ°ã€‘Implement Stack using Queues](#ImplementStackusingQueues)
	* 1.102. [226-ç¿»è½¬äºŒå‰æ ‘](#-1)
	* 1.103. [227 Basic Calculator II](#BasicCalculatorII)
	* 1.104. [228 Summary Ranges](#SummaryRanges)
	* 1.105. [229. Majority Element II](#MajorityElementII)
	* 1.106. [230 Kth Smallest Element in a B](#KthSmallestElementinaB)
	* 1.107. [231. ã€ä½è¿ç®—ğŸ˜œã€‘Power of Two](#PowerofTwo)
	* 1.108. [232-ã€æ„é€ ğŸ°ã€‘Implement Queue using Stacks](#ImplementQueueusingStacks)
	* 1.109. [234. ã€å›æ–‡ğŸŒˆã€‘Palindrome Linked List](#PalindromeLinkedList)
	* 1.110. [235. Lowest Common Ancestor of a Binary Search Tree](#LowestCommonAncestorofaBinarySearchTree)
	* 1.111. [236-äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](#-1)
	* 1.112. [237. Delete Node in a Linked List](#DeleteNodeinaLinkedList)
	* 1.113. [238 ã€å‰ç¼€å’ŒğŸ¨ã€‘Product of Array Except Self](#ProductofArrayExceptSelf)
	* 1.114. [239. ã€æœ€å°å †ğŸŒµ + æ»‘åŠ¨çª—å£ğŸ”¹ã€‘Sliding Window Maximum](#SlidingWindowMaximum)
	* 1.115. [240. äºŒç»´æ•°ç»„çš„æŸ¥æ‰¾](#-1)
	* 1.116. [242. Valid Anagram](#ValidAnagram)
	* 1.117. [243. Shortest Word Distance](#ShortestWordDistance)
	* 1.118. [246. Strobogrammatic Number](#StrobogrammaticNumber)
	* 1.119. [257-äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](#-1)
	* 1.120. [258. Add Digits](#AddDigits)
	* 1.121. [260-ã€ä½è¿ç®—ğŸ˜œã€‘åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— III](#III-1)
	* 1.122. [263 Ugly Number](#UglyNumber)
	* 1.123. [264. ã€åŠ¨æ€ğŸš€è§„åˆ’ + 3æŒ‡é’ˆã€‘Ugly Number II](#UglyNumberII)
	* 1.124. [268 ã€ä½è¿ç®—ğŸ˜œã€‘Missing Number](#MissingNumber)
	* 1.125. [270. Closest Binary Search Tree Value](#ClosestBinarySearchTreeValue)
	* 1.126. [274 H-Index](#H-Index)
	* 1.127. [278. First Bad Version](#FirstBadVersion)
	* 1.128. [279 ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ…ã€‘Perfect Squares](#PerfectSquares)
	* 1.129. [282. Expression Add Operators](#ExpressionAddOperators)
	* 1.130. [283. Move Zeros](#MoveZeros)
	* 1.131. [284 Peeking Iterator](#PeekingIterator)
	* 1.132. [287 Find the Duplicate Number](#FindtheDuplicateNumber)
	* 1.133. [289. ã€ä½è¿ç®—ğŸ˜œã€‘Game of Life](#GameofLife)
	* 1.134. [290. Word Pattern](#WordPattern)
	* 1.135. [297. Serialize and Deserialize Binary Tree](#SerializeandDeserializeBinaryTree)
	* 1.136. [299. Bulls and Cows](#BullsandCows)
	* 1.137. [300 ã€åŠ¨æ€ğŸš€è§„åˆ’ + äºŒåˆ†ã€‘Longest Increasing Subsequence æœ€é•¿ä¸Šå‡å­åºåˆ—](#LongestIncreasingSubsequence)
	* 1.138. [301. Remove Invalid Parentheses](#RemoveInvalidParentheses)
	* 1.139. [303 ã€æ„é€ ğŸ°ã€‘åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„ä¸å¯å˜](#-1)
	* 1.140. [304. ã€æ„é€ ğŸ°ã€‘Range Sum Query 2D](#RangeSumQuery2D)
	* 1.141. [309. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Best Time to Buy and Sell Stock with Cooldown 309-æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ](#BestTimetoBuyandSellStockwithCooldown309-)
	* 1.142. [305 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Number of Island](#NumberofIsland)
	* 1.143. [310 Minimum Height Trees](#MinimumHeightTrees)
	* 1.144. [312 Burst Balloons](#BurstBalloons)
	* 1.145. [315. Count of Smaller Numbers After Self](#CountofSmallerNumbersAfterSelf)
	* 1.146. [316 ã€è´ªå¿ƒğŸ§¡ã€‘Remove Duplicate Letters](#RemoveDuplicateLetters)
	* 1.147. [318ã€ä½è¿ç®—ğŸ˜œã€‘](#-1)
	* 1.148. [319](#-1)
	* 1.149. [321. Create Maximum Number](#CreateMaximumNumber)
	* 1.150. [322. ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + dfsã€‘Coin Change](#dfsCoinChange)
	* 1.151. [324](#-1)
	* 1.152. [326. Power of Three](#PowerofThree)
	* 1.153. [328. å¥‡å¶é“¾è¡¨ (Odd Even Linked List)](#OddEvenLinkedList)
	* 1.154. [329. ã€åŠ¨æ€ğŸš€è§„åˆ’ + dfsã€‘Longest Increasing Path in a Matrix](#dfsLongestIncreasingPathinaMatrix)
	* 1.155. [332 Reconstruct Itinerary](#ReconstructItinerary)
	* 1.156. [334 Increasing Triplet Subseque](#IncreasingTripletSubseque)
	* 1.157. [337 House Robber III](#HouseRobberIII)
	* 1.158. [338 ã€ä½è¿ç®—ğŸ˜œã€‘Counting Bits](#CountingBits)
	* 1.159. [342. ã€ä½è¿ç®—ğŸ˜œã€‘Power of Four](#PowerofFour)
	* 1.160. [343-æ•´æ•°æ‹†åˆ†](#-1)
	* 1.161. [344. Reverse String](#ReverseString)
	* 1.162. [345. Reverse Vowels of a String](#ReverseVowelsofaString)
	* 1.163. [346 Moving Average from Data Stream](#MovingAveragefromDataStream)
	* 1.164. [347. ã€æœ€å°å †ğŸŒµã€‘Top K Frequent Elements](#TopKFrequentElements)
	* 1.165. [349. Intersection of Two Arrays](#IntersectionofTwoArrays)
	* 1.166. [350. ã€åŠ¨æ€ğŸš€è§„åˆ’ + åŒæŒ‡é’ˆ + å“ˆå¸Œè¡¨ã€‘Intersection of Two Arrays II](#IntersectionofTwoArraysII)
	* 1.167. [ 351 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Android Unlocking Pattern](#351AndroidUnlockingPattern)
	* 1.168. [355. è®¾è®¡æ¨ç‰¹ Design Twitter](#DesignTwitter)
	* 1.169. [359 Logger Rate Limiter](#LoggerRateLimiter)
	* 1.170. [367. Valid Perfect Square](#ValidPerfectSquare)
	* 1.171. [368 Largest Divisible Subset](#LargestDivisibleSubset)
	* 1.172. [371ã€ä½è¿ç®—ğŸ˜œã€‘](#-1)
	* 1.173. [373. Find K Pairs with Smallest SumsæŸ¥æ‰¾å’Œæœ€å°çš„kå¯¹æ•°å­—](#FindKPairswithSmallestSumsk)
	* 1.174. [374. Guess Number Higher or Lower](#GuessNumberHigherorLower)
	* 1.175. [376-æ‘†åŠ¨åºåˆ—](#-1)
	* 1.176. [377. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Combination Sum IV](#CombinationSumIV)
		* 1.176.1. [ç±»ä¼¼é¢˜ç›®ï¼š416é¢˜ï¼Œ494é¢˜ï¼Œä¸å¯ä»¥é‡å¤ï¼Œ377é‡å¤](#416494377)
	* 1.177. [378-ã€æœ€å°å †ğŸŒµã€‘æœ‰åºçŸ©é˜µä¸­ç¬¬Kå°çš„å…ƒç´ ](#K)
	* 1.178. [380 Insert Delete GetRandom O(1)](#InsertDeleteGetRandomO1)
	* 1.179. [382 Linked List Random Node](#LinkedListRandomNode)
	* 1.180. [383 Ransom Note](#RansomNote)
	* 1.181. [386](#-1)
	* 1.182. [387. First Unique Character in a String](#FirstUniqueCharacterinaString)
	* 1.183. [389. ã€ä½è¿ç®—ğŸ˜œã€‘Find the Difference](#FindtheDifference)
	* 1.184. [391. Perfect Rectangle](#PerfectRectangle)
	* 1.185. [392. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Is Subsequence](#IsSubsequence)
	* 1.186. [393. UTF-8 Validation](#UTF-8Validation)
	* 1.187. [394 Decode String](#DecodeString)
	* 1.188. [395 Longest Substring with At Least K](#LongestSubstringwithAtLeastK)
	* 1.189. [399. ã€ğŸ’å¹¶æŸ¥é›† + floyd ğŸŒã€‘Evaluate Division](#floydEvaluateDivision)
	* 1.190. [402 Remove K Digits](#RemoveKDigits)
	* 1.191. [404. Sum of Left Leaves](#SumofLeftLeaves)
	* 1.192. [405 ã€ä½è¿ç®—ğŸ˜œã€‘Convert a Number to Hexadecimal](#ConvertaNumbertoHexadecimal)
	* 1.193. [406. Queue Reconstruction by Height](#QueueReconstructionbyHeight)
	* 1.194. [408. Valid Word Abbreviation](#ValidWordAbbreviation)
	* 1.195. [409. ã€å›æ–‡ğŸŒˆã€‘Longest Palindrome](#LongestPalindrome)
	* 1.196. [410. Split Array Largest Sum](#SplitArrayLargestSum)
	* 1.197. [412. Fizz Buzz](#FizzBuzz)
	* 1.198. [413-ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ç­‰å·®æ•°åˆ—åˆ’åˆ†](#-1)
	* 1.199. [414. Third Maximum Number](#ThirdMaximumNumber)
	* 1.200. [415-Add Strings](#AddStrings)
	* 1.201. [416. ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + dfs(startI)æ— forå¾ªç¯ã€‘Partition Equal Subset Sum](#dfsstartIforPartitionEqualSubsetSum)
		* 1.201.1. [ç›¸ä¼¼é¢˜ç›®ï¼š494é¢˜](#494)
	* 1.202. [417. ã€æ„é€ ğŸ°ã€‘Pacific Atlantic Water Flow](#PacificAtlanticWaterFlow)
	* 1.203. [419. Battleships in a Board](#BattleshipsinaBoard)
	* 1.204. [421 Maximum XOR of Two Numbers in an Array](#MaximumXORofTwoNumbersinanArray)
	* 1.205. [423 Reconstruct Original Digits from English](#ReconstructOriginalDigitsfromEnglish)
	* 1.206. [424. æ›¿æ¢åçš„æœ€é•¿é‡å¤å­—ç¬¦ Longest Repeating Character Replacem](#LongestRepeatingCharacterReplacem)
	* 1.207. [429. N-ary Tree Level Order Traversal](#N-aryTreeLevelOrderTraversal)
	* 1.208. [430 Flatten a Multilevel Doubly Linked List](#FlattenaMultilevelDoublyLinkedList)
	* 1.209. [432. All O`one Data Structure](#AllOoneDataStructure)
	* 1.210. [435-Non-overlapping Intervals](#Non-overlappingIntervals)
	* 1.211. [436 Find Right Interval](#FindRightInterval)
	* 1.212. [437 ã€å‰ç¼€å’ŒğŸ¨ã€‘Path Sum III](#PathSumIII)
	* 1.213. [438. ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘Find All Anagrams in a String](#FindAllAnagramsinaString)
	* 1.214. [441 Arranging Coins](#ArrangingCoins)
	* 1.215. [442 Find All Duplicates in an Array](#FindAllDuplicatesinanArray)
	* 1.216. [443. String Compression](#StringCompression)
	* 1.217. [445-Add Two Numbers II](#AddTwoNumbersII)
	* 1.218. [447. Number of Boomerangs](#NumberofBoomerangs)
	* 1.219. [448. Find All Numbers Disappeared in an Array](#FindAllNumbersDisappearedinanArray)
	* 1.220. [449. Serialize and Deserialize BST](#SerializeandDeserializeBST)
	* 1.221. [450. Delete Node in a BST](#DeleteNodeinaBST)
	* 1.222. [451 Sort Characters By Frequency](#SortCharactersByFrequency)
	* 1.223. [454 4Sum II](#SumII)
	* 1.224. [452. ã€è´ªå¿ƒğŸ§¡ã€‘Minimum Number of Arrows to Burst Balloons](#MinimumNumberofArrowstoBurstBalloons)
	* 1.225. [455-Assign Cookies](#AssignCookies)
	* 1.226. [456 132 Pattern](#Pattern)
	* 1.227. [458 Poor Pigs](#PoorPigs)
	* 1.228. [459 Repeated Substring Pattern](#RepeatedSubstringPattern)
	* 1.229. [460. ã€æ„é€ ğŸ°ã€‘LFU Cache / O(1)](#LFUCacheO1)
	* 1.230. [461 ã€ä½è¿ç®—ğŸ˜œã€‘Hamming Distance](#HammingDistance)
	* 1.231. [463 Island Perimeter](#IslandPerimeter)
	* 1.232. [464. Can I Win](#CanIWin)
	* 1.233. [466. ç»Ÿè®¡é‡å¤ä¸ªæ•° Count The Repetitions](#CountTheRepetitions)
	* 1.234. [468 Validate IP Address](#ValidateIPAddress)
	* 1.235. [470. Implement Rand10() Using Rand7()](#ImplementRand10UsingRand7)
	* 1.236. [475. Heaters](#Heaters)
	* 1.237. [476. ã€ä½è¿ç®—ğŸ˜œã€‘Number Complement](#NumberComplement)
	* 1.238. [477. ã€ä½è¿ç®—ğŸ˜œã€‘Total Hamming Distance](#TotalHammingDistance)
	* 1.239. [478 Generate Random Point in a Circle](#GenerateRandomPointinaCircle)
	* 1.240. [480. ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘Sliding Window Median](#SlidingWindowMedian)
	* 1.241. [484 Find Permutation](#FindPermutation)
	* 1.242. [485. Max Consecutive Ones](#MaxConsecutiveOnes)
	* 1.243. [486. Predict the Winner](#PredicttheWinner)
	* 1.244. [490 The Maze](#TheMaze)
	* 1.245. [494. ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + dfs(startI)æ— forå¾ªç¯ã€‘Target Sum](#dfsstartIforTargetSum)
	* 1.246. [495 Teemo Attacking](#TeemoAttacking)
	* 1.247. [496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I (Next Greater Element I)](#INextGreaterElementI)
	* 1.248. [497 Random Point in Non-overlapping](#RandomPointinNon-overlapping)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name=''></a>é¢˜ç›®

###  1.1. <a name='SameTree'></a>100-Same Tree 

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7ti?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1vf4y1R7Ue?spm_id_from=333.999.0.0)

> python:

```py
self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

```py
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        return str(p)==str(q)
```



> scala

```scala
object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        if (p == null && q == null) {
        true
        } else if (p == null || q == null) {
        false
        } else if (p.value == q.value) {
        isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        } else {
        false
        }
    }
}


object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
     if (p!=null && q!=null) {
       p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
     } else {
       p == q
     }
   }
} 

object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        (p,q) match {
          case (p,q) if (p!=null && q!=null) => p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
          case (p,q) => p==q
        }
    }
  }
```

###  1.2. <a name='Symmetrictree'></a>101-Symmetric tree

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1VJ41197KD?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7eb?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1xv41167z8?spm_id_from=333.999.0.0)

> Python è¿­ä»£ï¼šå…¶å®å°±æ˜¯å±‚åºéå†ï¼Œç„¶åæ£€æŸ¥æ¯ä¸€å±‚æ˜¯ä¸æ˜¯å›æ–‡ğŸŒˆæ•°ç»„

```py
class Solution(object):
    def isSymmetric(self, root):
        layer = [root]
        
        while(layer):
            nextLayer = []
            vals = []
            for node in layer:
                if not node # æœ‰ä¸€ç§æƒ…å†µæ˜¯[None]
                    vals.append(None)
                    continue
                nextLayer.append(node.left)
                nextLayer.append(node.right)
                
                vals.append(node.val)
                
            if vals != vals[::-1]:
                return False
            layer = nextLayer
            
        return True
```

> Python é€’å½’ï¼š

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def twoSym(node1, node2):
            if node1 and node2 and node1.val == node2.val: 
                return twoSym(node1.left, node2.right) and twoSym(node1.right, node2.left)
            elif not node1 and not node2:
                return True
            else:
                return False
        return twoSym(root.left, root.right)
```

> scala:

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def symmetric(nodeA: TreeNode, nodeB: TreeNode): Boolean = {
        if(nodeA == null && nodeB == null){
            true
        }else if(nodeA !=null && nodeB != null){
            if(nodeA.value != nodeB.value){
                false
            }else{
                symmetric(nodeA.left, nodeB.right) && symmetric(nodeA.right, nodeB.left)
            }
        }else{
            false
        }
    }
    
    def isSymmetric(root: TreeNode): Boolean = {
        if(root == null){
            true
        } else{
            symmetric(root.left, root.right)
        }
    }
}

```

###  1.3. <a name='BinaryTreeLevelOrderTraversal'></a>102-Binary Tree Level Order Traversal

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1W54y197Lc?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV14T4y1u7Wk?spm_id_from=333.999.0.0)

> python queue

```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)): # å½“å‰å±‚çš„ä¸ªæ•°!!!
                node=queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res


from collections import deque
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        if not root:
            return []

        queue = deque([root]) 
        res = []
        
        while queue: 
            level = [] 
            for _ in range(len(queue)): 
                node = queue.popleft() 
                level.append(node.val) 
                if node.left:
                    queue.append(node.left) 
                if node.right:
                    queue.append(node.right) 
            res.append(level) 
        return res
```


> python é€’å½’


```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []

        def bfs(node, level):
            if node: 
                if len(res) < level + 1:
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level+1)
                bfs(node.right, level+1)

        bfs(root, 0)
        return res

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        dic = collections.defaultdict(list)

        def bfs(node, level):
            if node:
                dic[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0) 
        return [*dic.values()]
```

> scala queue

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val buffer =  scala.collection.mutable.Queue[TreeNode]()
        val res =  scala.collection.mutable.ListBuffer[List[Int]]()

        if(root == null) return List[List[Int]]()
        buffer.enqueue(root)
	
        while(buffer.nonEmpty) {
          val cur = scala.collection.mutable.ListBuffer[Int]()
          for ( _ <- 0 until buffer.size) {
            val node = buffer.dequeue
            cur.append(node.value)
            if(node.left != null) buffer.enqueue(node.left)
            if(node.right != null) buffer.enqueue(node.right)
        }
        res += cur.toList
        }
        res.toList
    }
}
```

> scala é€’å½’

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val oderMap = scala.collection.mutable.Map[Int, List[Int]]()
        bfs(root, 1, oderMap)
        oderMap.values.toList
    }
    def bfs(node: TreeNode, level: Int, map: scala.collection.mutable.Map[Int, List[Int]]): Unit = {
        if (node != null) {
            val l = map.get(level)
                .map(_ :+ node.value)
                .getOrElse(List(node.value))

            map(level) = l
            bfs(node.left, level + 1, map)
            bfs(node.right, level + 1, map)
        }
    }
}
```

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        bfs(if(root == null) List() else List(root), List())
    }

    // @annotation.tailrec
    // @annotation.tailrec å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œä¸‹é¢è¿™ä¸ªå‡½æ•°æ˜¯é€’å½’çš„ï¼Œåœ¨æ ˆæ¡¢çš„ç®¡ç†ä¸Šï¼Œå¸Œæœ›ç¼–è¯‘å™¨èƒ½æ‰€æœ‰ä¼˜åŒ–ã€‚
    def bfs(queue: List[TreeNode], ans: List[List[Int]]): List[List[Int]] = {
        if(queue.isEmpty) ans
        else{
        bfs(queue.flatMap(n => List(n.left, n.right)).filter(_ != null), ans :+ queue.map(n => n.value))
        }
    }
}
```

###  1.4. <a name='BinaryTreeZigzagLevelOrderTraversal'></a>103. Binary Tree Zigzag Level Order Traversal

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1NE411M7Fm?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV15h411Z7h5?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1GA411W7NY?spm_id_from=333.999.0.0)

> python é˜Ÿåˆ—

```py
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: 
            return []

        queue = [root]
        res = []
        indexflag = 1 
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        queue = [root]
        res = []
        indexflag = 1 
        while queue and queue[0]: # æˆ–è€…
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

# python åŒç«¯duque
from collections import deque
class Solution:
    def zigzagLevelOrder(self, root):
        queue = deque([root])
        res = []
        flag = True # flag
        while queue and queue[0]:
            level = []
            for _ in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            if flag: # flag
                res.append(level)
            else:
                res.append(level[::-1])  # [::-1]åè½¬
            flag = bool(1-flag) # flag
        return res
```

é€’å½’

```py
class Solution:
    def zigzagLevelOrder(self, root):
        res = []
        def bfs(node, level):
            if node:
                if level >= len(res):
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0)
        for i in range(1, len(res), 2): # flagï¼Œå„ä¸¤ä¸ªé€†åº
            res[i] = res[i][::-1]
        return res
```

###  1.5. <a name='MaximumDepthofBinary'></a>104-Maximum Depth of Binary

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1AJ411Q7xG?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7eK?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1u54y1D7Nx?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1tK41137GM?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

```scala
object Solution1 {
    def maxDepth(root: TreeNode): Int = {
        if (root == null) return 0
        math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}

object Solution {
    def maxDepth(root: TreeNode): Int = root match {
        case null => 0
        case x: TreeNode => Math.max((1 + maxDepth(x.left)), (1 + maxDepth(x.right)))
    }
}

object Solution2 {
    def maxDepth(root: TreeNode): Int = {
        if(root == null) return 0
        var depth = 0
        val queue = scala.collection.mutable.Queue[TreeNode]()
        queue.enqueue(root)

        while(queue.nonEmpty) {
            depth += 1
            for(_ <- 0 until queue.size){
                val node = queue.dequeue
                if(node.left != null) queue.enqueue(node.left)
                if(node.right != null) queue.enqueue(node.right)
            }
        }   
        depth
    }
}
```

###  1.6. <a name='-1'></a>105-ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1uv411B73D?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1x54y1d7e8?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1ry4y1U7ZR?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV14A411q7Nv?spm_id_from=333.999.0.0)

> PYTHON é€’å½’

```py
class Solution:
    def buildTree(self, preorder, inorder):
        if inorder:
            root = TreeNode(preorder.pop(0))
            i = inorder.index(root.val)
            root.left = self.buildTree(preorder, inorder[: i])
            root.right = self.buildTree(preorder, inorder[i + 1:])
            return root

class Solution:
    def buildTree(self, preorder, inorder):
        if preorder: # ä¹Ÿå¯ä»¥
        if inorder:
          root = TreeNode(preorder.pop(0))
          i = inorder.index(root.val)
          root.left = self.buildTree(preorder[:i], inorder[:i])
          root.right = self.buildTree(preorder[i:], inorder[i+1:])
          return root

```

###  1.7. <a name='-1'></a>106-ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1r5411W7d2?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1jh411Z7y8?spm_id_from=333.999.0.0)

```py
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if inorder:
            root = TreeNode(postorder.pop())
            i = inorder.index(root.val)
            root.left = self.buildTree(inorder[:i], postorder[:i])
            root.right = self.buildTree(inorder[i+1:], postorder[i:])
            return root
```

###  1.8. <a name='BinaryTreeLevelOrderTraversalII'></a>107-Binary Tree Level Order Traversal II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1eJ411z7d6?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7aP?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1yK411n76R?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1qA411i7P4?spm_id_from=333.999.0.0)


```py
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res[::-1]
```

###  1.9. <a name='ConvertSortedArraytoBinarySearchTree'></a>108 Convert Sorted Array to Binary Search Tree 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1F7411H7tH?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1JJ411q74U?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7FR?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Wa411c7tS?spm_id_from=333.999.0.0)

> python

```py
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if nums:
            mid = len(nums) // 2
            root = TreeNode(nums[mid])
            root.left = self.sortedArrayToBST(nums[:mid])
            root.right = self.sortedArrayToBST(nums[mid+1:])
            return root
```

scala ä¸­æ²¡æœ‰è¿™ç§å½¢å¼çš„å†™æ³• nums[:mid]ï¼Œnums[mid+1:]

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def formTree(nums: Array[Int], begin: Int, end: Int): TreeNode = {
        var mid = begin + Math.ceil((end - begin)/2).toInt
        TreeNode(
            nums(mid), 
            if(mid <= begin) null else formTree(nums, begin, mid-1), 
            if(mid >= end) null else formTree(nums, mid+1, end)
        )
    }
    
    def sortedArrayToBST(nums: Array[Int]): TreeNode = {
        if(nums.isEmpty){
            null
        }else{
            formTree(nums, 0, nums.size - 1)
        }
    }
}

```

###  1.10. <a name='-1'></a>109é¢˜. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘

https://www.bilibili.com/video/BV19a4y157U8?spm_id_from=333.999.0.0

https://www.bilibili.com/video/BV1ff4y197dS?spm_id_from=333.999.0.0

å½“é€’å½’çš„æ˜¯ä¸€ä¸ªé“¾è¡¨`å¤´`æ—¶ï¼Œéœ€è¦åˆ‡æ–­

```py
class Solution:
    def sortedListToBST(self, head) -> TreeNode:
        if not head:
            return None
        if not head.next:
            return TreeNode(head.val)

        fast = head
        slow = head
        pre =  head

        while fast and fast.next:
            pre = slow # preåˆ‡æ–­
            slow = slow.next
            fast = fast.next.next
        mid = TreeNode(slow.val)
        # print(head.val,node.val,last.val)
        mid.right = self.sortedListToBST(slow.next) # ä»mid+1åˆ°tail
        pre.next = None # preåˆ‡æ–­
        mid.left = self.sortedListToBST(head) # ä»headåˆ°mid-1ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨findMidæ–¹ç¨‹é‡Œé¢ï¼Œéœ€è¦å¯¹Listè¿›è¡Œåˆ‡åˆ†
        return mid
```

https://www.bilibili.com/video/BV19K411T73P?p=2&spm_id_from=pageDriver

å½“é€’å½’çš„æ˜¯ä¸€ä¸ªé“¾è¡¨`å¤´å°¾`æ—¶ï¼Œä¸éœ€è¦åˆ‡æ–­

```py
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getMedian(head: ListNode, tail: ListNode) -> ListNode:
            fast = slow = head
            while fast != tail and fast.next != tail:
                fast = fast.next.next
                slow = slow.next
            return slow
        
        def buildTree(left: ListNode, right: ListNode) -> TreeNode:
            if left == right:
                return None
            mid = getMedian(left, right)
            root = TreeNode(mid.val)
            root.left = buildTree(left, mid) # ä»headåˆ°mid-1ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨findMidæ–¹ç¨‹é‡Œé¢ï¼Œéœ€è¦å¯¹Listè¿›è¡Œåˆ‡åˆ†
            root.right = buildTree(mid.next, right) # ä»mid+1åˆ°tail
            return root
        
        return buildTree(head, None)
```

###  1.11. <a name='BalancedBinaryTree'></a>110-Balanced Binary Tree

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1NJ411v7b1?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7Lb?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1sV411b7hR?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            return max(height(root.left), height(root.right)) + 1

        if not root:
            return True
        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)
        # æ³¨æ„ï¼šå·¦å³ä¸¤ä¸ªå­æ ‘ä¹Ÿå¿…é¡»balanced


å…¶å®å°±æ˜¯äºŒå‰æ ‘å…ˆåºéå†å’Œååºéå†çš„åŒºåˆ«ï¼Œæ¯ç§éå†æ–¹å¼éƒ½æœ‰å®ƒçš„ç”¨æ­¦ä¹‹åœ°ã€‚

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        ans = True
        
        def postorder(root):
            nonlocal ans
            if not root or not ans:
                return 0
            leftH = postorder(root.left)
            rightH = postorder(root.right)
            if abs(leftH-rightH) > 1:
                ans = False
            return max(leftH, rightH) + 1
        
        postorder(root)
        return ans

å¿…é¡»ç”¨

nonlocal + ans

å¦‚ä¸‹è¿”å›é”™è¯¯ç»“æœ postorder(root,bol)

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        bol = True
        
        def postorder(root,bol):
            if not root or not bol:
                return 0
            leftH = postorder(root.left,bol)
            rightH = postorder(root.right,bol)
            if abs(leftH-rightH) > 1:
                bol = False
            return max(leftH, rightH) + 1
        
        postorder(root,bol)
        return bol
```

###  1.12. <a name='MinimumDepthofBinaryTree'></a>111-Minimum Depth of Binary Tree

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1E7411k7KY?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7Vi?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1XZ4y1G7xM?spm_id_from=333.999.0.0)

é€’å½’

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root:
            if root.left and root.right:
                return 1+min(self.minDepth(root.left),self.minDepth(root.right))
            elif root.left:
                return 1+self.minDepth(root.left) #è¾ƒé«˜ä¸€å±‚çš„å€¼
            elif root.right:
                return 1+self.minDepth(root.right) #è¾ƒé«˜ä¸€å±‚çš„å€¼
            else:
                return 1
        else:
            return 0
```

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        # å¦‚æœ æ²¡æœ‰ root
        if not root:
            return 0
        # å¦‚æœ åªæœ‰ root
        elif not root.left and not root.right:
            return 1
        else:
        # å¦‚æœ root æœ‰ å­æ ‘
            minDepth = float('inf')
            if root.left:
                minDepth = min(self.minDepth(root.left), minDepth) 
            if root.right:
                minDepth = min(self.minDepth(root.right), minDepth) 
            return minDepth + 1
```

é˜Ÿåˆ—

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        que = collections.deque([(root, 1)]) # æ³¨æ„è¿™ä¸ªå†™æ³•ï¼š[(root, 1)] çš„æ‹¬å·
        while que:
            node, depth = que.popleft()
            if not node.left and not node.right:
                return depth
            if node.left: 
                que.append((node.left, depth + 1)) # æ³¨æ„è¿™ä¸ªå†™æ³•ï¼š(node.left, depth + 1) çš„æ‹¬å·
            if node.right:
                que.append((node.right, depth + 1))
        
        return 0
```

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        bfs(if(root == null) List() else List(root), 0)
    }
    
    @annotation.tailrec
    def bfs(queue: List[TreeNode], res: Int): Int = {
        if(queue.isEmpty) res
        // node has no child 
        else if(queue.exists(t => t.left == null && t.right == null)) res + 1
        else bfs(queue.flatMap(t => List(t.left, t.right)).filter(_ != null), res + 1)
    }
}

object Solution1 {
    def minDepth(root: TreeNode): Int = {
        if (root == null) return 0
        val left = minDepth(root.left) 
        val right = minDepth(root.right) 

        if (left == 0 || right == 0) left + right + 1 else math.min(left, right) + 1
        
    }
}

object Solution1_2 {
    def minDepth(root: TreeNode): Int = {
        if(root == null) 0
        else if(root.left == null) minDepth(root.right) + 1
        else if(root.right == null) minDepth(root.left) + 1
        else minDepth(root.right) + 1 min minDepth(root.left) + 1
    
    }
}
```

é˜Ÿåˆ—

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        if(root == null) return 0
        val que = scala.collection.mutable.Queue[TreeNode]()
        var depth = 0
        var flag = true
        que.enqueue(root)
        
        while(que.nonEmpty && flag){
            depth += 1
            for(_ <- 0 until que.size; if flag){
                val node = que.dequeue
                if(node.left == null && node.right == null) flag = false
                else {
                    if(node.left != null) que.enqueue(node.left)
                    if(node.right != null) que.enqueue(node.right)
                } 
            } 
        }
        depth
        
    }
} 
```

###  1.13. <a name='PathSum'></a>112-Path Sum

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1T7411r7Yr?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1pb411e7r7?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1uK411T7kX?spm_id_from=333.999.0.0)

é€’å½’

```py
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if root is None:
            return False
        if root.val==targetSum:
            return True
        return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)
```

```py
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que = collections.deque([(root, root.val)])
        while que:
            node, tmp = que.popleft()
            if not node.left and not node.right:
                if tmp == sum:
                    return True
                continue
            if node.left:
                que.append((node.left,node.left.val + tmp))
            if node.right:
                que.append((node.right,node.right.val + tmp))
        return False
```

###  1.14. <a name='-1'></a>113. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1P54y1i73U?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1k54y177fu?spm_id_from=333.999.0.0)

```py
# æ³¨æ„æ¯”è¾ƒè¿™ä¸¤ä¸ªå†™æ³•
# è·¯å¾„è®°å¿†ï¼Œè®¡ç®—æ•ˆç‡å¥½åƒæ›´ğŸ˜•
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        path = []
        
        def dfs(node, tsum):
            if not node:
                return
            
            path.append(node.val)
            tsum -= node.val # å¯¹äºæ¯ä¸€ä¸ªnodeï¼Œå½“å‰nodeçš„sum = æ€»å’Œsum - rootçš„å€¼
            
            if not node.left and not node.right and tsum == 0: # ç»“æŸæ¡ä»¶
                res.append(path[:])
            dfs(node.left, tsum)
            dfs(node.right, tsum)
            
            path.pop()
        
        dfs(root, targetSum)
        return res
```

```py
# æ³¨æ„æ¯”è¾ƒè¿™ä¸¤ä¸ªå†™æ³•
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        
        def dfs(node, path, tsum):
            
            if not node:
                return 
            
            tsum -= node.val # å¯¹äºæ¯ä¸€ä¸ªnodeï¼Œå½“å‰nodeçš„sum = æ€»å’Œsum - rootçš„å€¼
            
            if not node.left and not node.right and tsum == 0: # ç»“æŸæ¡ä»¶
                res.append(path + [node.val]) # å¯ä»¥ä¸éœ€è¦æ·±æ‹·è´
                
            dfs(node.left, path + [node.val], tsum)
            dfs(node.right, path + [node.val], tsum)
        
        dfs(root, [], targetSum)
        return res

class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res=[]

        def dfs(node,path,tsum):

            if node is None:
                return

            if node.val == tsum and node.left is None and node.right is None:
                res.append(path[:] + [node.val])  # éœ€è¦æ·±æ‹·è´

            dfs(node.left,path + [node.val], tsum-node.val)
            dfs(node.right,path + [node.val], tsum-node.val)
            
        dfs(root,[],targetSum)
        return res
```

###  1.15. <a name='-1'></a>114é¢˜. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

https://www.bilibili.com/video/BV1T7411A7S8?from=search&seid=15731266160913668837&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6tma3pncods0.png" width="80%">

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5csg54lu3lw0.png" width="50%">

é€’å½’

```py
class Solution(object):
    def flatten(self, root):
        if not root:
            return
        #æŠŠå­æ ‘å¤‡ä»½ä¸€ä¸‹
        tmpleft = root.left
        tmpright = root.right
        root.left = None #è®°å¾—æŠŠå·¦å­æ ‘ç½®ç©º
        #å…ˆæŠŠå·¦å³å­æ ‘æ‹ç›´
        self.flatten(tmpleft)
        self.flatten(tmpright)
        if tmpleft:
            root.right = tmpleft #æŠŠæ‹ç›´çš„å·¦å­æ ‘æ”¾åˆ°å³è¾¹
            while tmpleft.right: #æ‰¾åˆ°ç°åœ¨å³å­æ ‘çš„æœ€åä¸€ä¸ªnode
                tmpleft = tmpleft.right 
            tmpleft.right = tmpright #å·¦å­æ ‘æ¥ä¸Šå³å­æ ‘
```

stack: å…ˆçœ‹144é¢˜

```py
class Solution:
    def flatten(self, root: TreeNode) -> None:
        if not root:
            return
        
        stack = [root]
        pre = None # ç©¿é’ˆå¼•çº¿
        
        while stack:
            cur = stack.pop()
            if pre:
                pre.left = None # ç©¿é’ˆå¼•çº¿
                pre.right = cur # ç©¿é’ˆå¼•çº¿
            left, right = cur.left, cur.right
            if right:
                stack.append(right)
            if left:
                stack.append(left)
            pre = cur # ç©¿é’ˆå¼•çº¿

        return root

class Solution:
    def flatten(self, root: TreeNode) -> None:
        preorderList = list()
        stack = list()
        node = root

        while node or stack:
            while node:
                preorderList.append(node)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        
        n = len(preorderList)
        for i in range(1, n):
            prev, curr = preorderList[i - 1], preorderList[i] # ç©¿é’ˆå¼•çº¿
            prev.left = None # ç©¿é’ˆå¼•çº¿
            prev.right = curr # ç©¿é’ˆå¼•çº¿
```


###  1.16. <a name='DistinctSubsequences'></a>115. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Distinct Subsequences

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1EW411d7PC?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV185411G7F6?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        for i in range(sN+1):
            for j in range(tN+1):
                if j == 0:  
                    dp[i][j] = 1
                elif i == 0:  
                    dp[i][j] = 0
                elif s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
Python3:

class SolutionDP2:
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(s), len(t)
        if n1 < n2:
            return 0

        dp = [0 for _ in range(n2 + 1)]
        dp[0] = 1

        for i in range(1, n1 + 1):
            prev = dp[:] # æ·±æ‹·è´ä¸€ä¸‹
            end = i if i < n2 else n2 # å‰ªæï¼Œä¿è¯sçš„é•¿åº¦å¤§äºç­‰äºt, å› ä¸ºå¯¹äºä»»æ„iï¼Œi > n1, dp[i] = 0, æ²¡å¿…è¦è·Ÿæ–°çŠ¶æ€ã€‚ 
            for j in range(1, end + 1):
                if s[i - 1] == t[j - 1]:
                    dp[j] = prev[j - 1] + prev[j]
                else:
                    dp[j] = prev[j]
        return dp[-1]
```

###  1.17. <a name='PopulatingNextRightPointersinEachNode'></a>116. Populating Next Right Pointers in Each Node

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1b4411R7G4?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1zQ4y1M75t?spm_id_from=333.999.0.0)

```py
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        
        que = [root]
        while que:
            n = len(que)
            pre = Node(0) # æŒ‡é’ˆ
            for _ in range(n):
                node = que.pop(0)
                if pre:
                    pre.next = node
                pre = node

                if node.left:
                    que.append(node.left)
                if node.right:
                    que.append(node.right)
        
        return root

class Solution:
    # å±‚æ¬¡éå†
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        que = deque([root])
        while que:
            n = len(que)
            for i in range(n):        # æ¯ä¸€å±‚nå›ºå®š
                cur = que.popleft()
                if i < n - 1:         # åªè¦ä¸æ˜¯æœ€åä¸€ä¸ªï¼Œå°±è¿ä¸Š
                    cur.next = que[0] # åªè¦ä¸æ˜¯æœ€åä¸€ä¸ªï¼Œå°±è¿ä¸Š
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            
        return root
```

```py
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if root:
            l,r=root.left,root.right
            while l:
                l.next=r
                l,r=l.right,r.left
            self.connect(root.left)
            self.connect(root.right)
        return root
```

###  1.18. <a name='PopulatingNextRightPointersinEa'></a>117 Populating Next Right Pointers in Ea (å¯è·³è¿‡)

[å°æ˜](https://www.bilibili.com/video/BV1np4y1r7fQ?spm_id_from=333.999.0.0)

çœ‹ä¸æ‡‚ï¼Œæ‡µé€¼äº†

```py
# çœ‹ä¸æ‡‚ï¼Œæ‡µé€¼äº†

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        dummy = Node()
        dummy.next = root
        while dummy.next:
            curp = dummy.next
            dummy.next = None
            pre = dummy
            while curp:
                for cur in [curp.left, curp.right]:
                    if cur:
                        pre.next = cur
                        pre = cur
                curp = curp.next
        return root

# python éé€’å½’æ–¹æ³•ï¼Œå¸¸æ•°ç©ºé—´ï¼Œä»é¡¶åˆ°ä¸‹ï¼Œé€å±‚è¿æ¥
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        first = root # left_mostè¡¨ç¤ºå½“å‰å±‚çš„æœ€å·¦è¾¹èŠ‚ç‚¹
        while first: # æ¯æ¬¡å¾ªç¯è¿æ¥å½“å‰å±‚çš„ä¸‹ä¸€å±‚
            dummy = pre = Node(0) # headè¡¨ç¤ºä¸‹ä¸€å±‚çš„è™šæ‹Ÿå¤´éƒ¨
            cur = first
            while cur : # éå†å½“å‰å±‚ï¼Œå°†ä¸‹ä¸€å±‚è¿æ¥
                if cur.left :
                    pre.next = cur.left
                    pre = pre.next
                if cur.right :
                    pre.next = cur.right
                    pre = pre.next
                cur = cur.next
            first = dummy.next
        return root
```


###  1.19. <a name='PascalsTriangle'></a>118-Pascal's Triangle

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1T741167KS?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Cb411e7tJ?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1D54y147NY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generate(self, numRows):
        res = []
        for i in range(numRows):
            curlevel = [1]*(i+1)
            if i >= 2:
                for n in range(1,i):
                    curlevel[n] = pre[n-1]+pre[n]
                    # å¤´å°¾ä¸º1ï¼Œä¸­é—´çš„ç¬¬jä¸ªä¸ºä¸Šä¸€å±‚çš„ç¬¬j-1ä¸ªå’Œjä¸ªçš„å’Œ
            res += [curlevel]
            pre = curlevel
        return res
        
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        for i in range(numRows):
            level = []
            for j in range(0, i + 1):
                if j == 0 or j == i:
                    level.append(1)
                else:
                    level.append(res[i - 1][j] + res[i - 1][j - 1])
            res.append(level)
        return res
```

```py
åº“å‡½æ•°é‡æ‹³å‡ºå‡»ï¼
å®ƒæœ¬è´¨ä¸Šè¯„ä¼°ä¸ºn! /(k! *(n-k)! )å®ƒä¹Ÿè¢«ç§°ä¸ºäºŒé¡¹å¼ç³»æ•°
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        return [[comb(i, j) for j in range(i + 1)] for i in range(numRows)]
```

```scala
object Solution {
    def generate(numRows: Int): List[List[Int]] = {
        var output = List.empty[List[Int]]
        var curr = 1
        if(numRows == 0){
            output
        }else{
            while(curr <= numRows){
                curr match{
                    case 1 => output = List(List(1))
                    case _ => {
                        val prev = output(curr-2)
                        val begin = 0
                        val end = curr - 1
                        val row = 
                        (0 to curr-1)
                        .map(i => if(i == begin || i == end) 1 else prev(i)+prev(i-1))
                        .toList
                        
                        output = output :+ row
                    }
                }
                curr += 1
            }
        }
        output
    }
}

```

###  1.20. <a name='PascalsTriangleII'></a>119-Pascal's Triangle II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV187411B7Hj?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qb411e7hA?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ni4y1g7Lv?spm_id_from=333.999.0.0)

```py
class Solution3:
    def generate(self, rowIndex):
        for i in range(rowIndex + 1):
            # ç”¨ 1 å…ˆå¡«å……æ¯è¡Œæ‰€æœ‰å…ƒç´ 
            curlevel = [1] * (i + 1)
            # ç”±ä¸Šä¸€è¡Œå¾ªç¯ç”Ÿæˆå½“å‰è¡Œå…ƒç´ ï¼ˆé™¤ä¸¤ç«¯ï¼‰
            for j in range(1, i):
                curlevel[j] = pre[j - 1] + pre[j]
            pre = curlevel
        return curlevel

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        res = [1]
        for i in range(rowIndex):
            res.append(0)
            j = i + 1
            while j > 0:
                res[j] = res[j] + res[j - 1]
                j -= 1
        return res
```

###  1.21. <a name='Triangle'></a>120 ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Triangle

[å°æ˜](https://www.bilibili.com/video/BV1m54y1L7Af?spm_id_from=333.999.0.0)

```py
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        i = len(triangle) - 2
        while i >= 0:
            subi = i
            while subi >= 0:
                triangle[i][subi] += min(triangle[i+1][subi],triangle[i+1][subi+1])
                subi -= 1
            i -= 1
        return triangle[0][0]
```

```scala
object Solution {
    def minimumTotal(triangle: List[List[Int]]): Int = {
        val depth = triangle.size
        val dp = triangle.last.toArray
        for(i <- (depth - 2) to 0 by -1; j <- triangle(i).indices) {
            dp(j) = triangle(i)(j) + (dp(j) min dp(j + 1)) 
        }
        dp(0)
    }
}
```

###  1.22. <a name='BestTimetoBuyandSellStock121-'></a>121. Best Time to Buy and Sell Stock  121-ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1oW411C7UB?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1cZ4y1K7HP?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1D7411s7A1?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qb411e7by?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV16z4y1Z7jD?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1hA411t76C?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        minprice = 1e9
        for price in prices:
            maxprofit = max(maxprofit,price - minprice)
            minprice = min(minprice,price)
        return maxprofit
```

```scala
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices.foldLeft((Int.MaxValue, 0)){
            case ((minPriceSoFar, maxProfit), price) => (minPriceSoFar min price, maxProfit max (price - minPriceSoFar))
        }._2
    }
}
```

###  1.23. <a name='II122-BestTimetoBuyandSellStockII'></a>122-ã€è´ªå¿ƒğŸ§¡ã€‘ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II 122-Best Time to Buy and Sell Stock II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV12K411A7rL?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1d7411x78d?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qb411e7iq?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Fk4y1R7ve?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV17i4y1L7LG?spm_id_from=333.999.0.0)

```py
æˆ‘çš„å†™æ³•ï¼š

è´ªå¿ƒç®—æ³•ï¼Œä¸€æ¬¡éå†ï¼Œåªè¦ä»Šå¤©ä»·æ ¼å°äºæ˜å¤©ä»·æ ¼å°±åœ¨ä»Šå¤©ä¹°å…¥ç„¶åæ˜å¤©å–å‡ºï¼Œæ—¶é—´å¤æ‚åº¦O(n)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
                # preprice = 1e9 æ˜¯é”™è¯¯çš„ï¼Œæ¯”å¦‚[1,2,3,4,5] ä¼šè¿”å›2ï¼Œåº”è¯¥è¿”å›4
                preprice = price
            else:
                preprice = price
        return maxprofit

# ç®€åŒ–ä¸º
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
            preprice = price
        return maxprofit
```

```py

å…¶ä»–å†™æ³•ï¼š

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        return sum([prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i] > 0])



class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                ans += prices[i] - prices[i-1]
        return ans
```

```scala
/**
* my first commitment
* greedy alg
* time complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices.length > 1){
            prices.sliding(2).collect{ case arr: Array[Int] if arr(1) > arr(0)=> arr}
    .foldLeft(0){(sum, arr) => 
      sum + arr(1) - arr(0)}
        } else {
            0
        }
    }
}

/**
* greedy alg: one line pass
*/

object Solution1-2 {
  def maxProfit(prices: Array[Int]): Int = {
    if(prices.length > 1) prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum else 0
  }
}

//Alternate solution
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices
            .foldLeft(0,Int.MaxValue)((t, current) => (t._1 + 0.max(current-t._2), current))
            ._1
    }
}
 
  object Solution {
    def maxProfit(prices: Array[Int]): Int = {
      if (prices.isEmpty) return 0
      else (0 until prices.length-1).foldLeft(0)(
        (profit,i) =>{
          if (prices(i)<prices(i+1)) profit+prices(i+1)-prices(i) else profit
        }
      )
    }
  }

```

###  1.24. <a name='III'></a>123-ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Xp4y1k7aD?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1rk4y117z8?spm_id_from=333.999.0.0)

```py
# æˆ‘çš„å†™æ³•ï¼š
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        profit1 = profit2 = 0
        buy1 = buy2 = prices[0]
        for i in range(1,n):
            # å®é™…ä¸Šï¼Œæ˜¯ä»å–å‡ºé‚£å¤©å¼€å§‹ç®—ï¼Œä¹Ÿå°±æ˜¯ç¬¬äºŒå¤©
            buy1 = min(buy1,prices[i])
            profit1 = max(profit1,prices[i]-buy1)
            buy2 = min(buy2,prices[i]-profit1)  # buy2[i]-profit1[i-1] ç›¸å½“äºä¸€ä¸ªè™šæ‹Ÿçš„ä¹°å…¥ä»·æ ¼
            profit2 = max(profit2,prices[i]-buy2)
        return profit2

## æœªè¿›è¡Œç©ºé—´ä¼˜åŒ–
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy1 = [0] * n
        sell1 = [0] * n
        buy2 = [0] * n
        sell2 = [0] * n
        buy1[0] = buy2[0] = -prices[0]
        sell1[0] = sell2[0] = 0
        for i in range(1, n):
            buy1[i]  = max(buy1[i-1], -prices[i]) 
            sell1[i] = max(sell1[i-1], buy1[i-1] + prices[i])
            buy2[i]  = max(buy2[i-1], sell1[i-1] - prices[i])
            sell2[i] = max(sell2[i-1], buy2[i-1] + prices[i])
        return sell2[-1]
```

```scala
object Solution3{
    def maxProfit(prices: Array[Int]): Int = {
        val r = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case (acc, px) =>
                val (buy1, sell1, buy2, sell2) = acc
                val newBuy1 = buy1 max - px
                val newSell1 =  sell1 max (buy1 + px)
                val newBuy2 = buy2 max (sell1 - px)
                val newSell2 = sell2 max (buy2 + px)
                (newBuy1, newSell1, newBuy2, newSell2)
        }
        r._2 max r._4
    }
}

object Solution3-1 {
    def maxProfit(prices: Array[Int]): Int = {
        val (buy1, sell1, buy2, sell2) = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case ((buy1, sell1, buy2, sell2), cost) =>
                (
                    buy1 max -cost,
                    sell1 max (buy1 + cost),
                    buy2 max (sell1 - cost),
                    sell2 max (buy2 + cost)
                )
        }
        sell1 max.sell2
    }
}
```

###  1.25. <a name='BinaryTreeMaximumPathSum'></a>124. Binary Tree Maximum Path Sum

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ct411r7qw?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1CT4y1g7bR?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1qT4y1J71C?spm_id_from=333.999.0.0)

```py
æˆ‘çš„æ€è€ƒï¼š
        # æœ‰ä¸¤ç§æƒ…å†µï¼š
        # node.val å¾€ä¸Šå›æ”¶, æ„æˆé€’å½’
        return max(left,right) + node.val
        # node.val ä¸å¾€ä¸Šå›æ”¶, å·¦ä¸­å³
        res = max(left+right + node.val, res)

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = -1e9
        # left = right = 0
        def dfs(node) -> int:
            nonlocal res # ä¹Ÿå¯ä»¥å†™æˆ self.res
            if not node:
                return 0
            # if node.left:
            left = max(dfs(node.left), 0)     # æ­£è´Ÿæ€§ï¼šleft ä¸ºè´Ÿï¼Œå°±ä¸å›æ”¶
            # if node.right:
            right = max(dfs(node.right), 0)   # æ­£è´Ÿæ€§ï¼šright ä¸ºè´Ÿï¼Œå°±ä¸å›æ”¶
            # æœ‰ä¸¤ç§æƒ…å†µï¼šnode.val ä¸å¾€ä¸Šå›æ”¶, å·¦ä¸­å³
            res = max(left + right + node.val, res)
            # æœ‰ä¸¤ç§æƒ…å†µï¼šnode.val å¾€ä¸Šå›æ”¶, æ„æˆé€’å½’
            return max(left,right) + node.val # æ­£è´Ÿæ€§ï¼šnode.valå¿…é¡»å›æ”¶
        dfs(root)
        return res
```

```scala
object Solution1 {
    def maxPathSum(root: TreeNode): Int = {
        dfs(root)._1
    }

    def dfs(node: TreeNode): (Int, Int) = {
      if (node == null) return (Int.MinValue, 0)
      
      val (leftSoFar, leftEndingHere) = dfs(node.left)
      val (rightSoFar, rightEndingHere) = dfs(node.right)

      val maxSoFar = leftSoFar max rightSoFar max (node.value + leftEndingHere + rightEndingHere)

      val maxEndingHere = 0 max (node.value + (leftEndingHere max rightEndingHere))
      (maxSoFar, maxEndingHere)
    }
}
```

###  1.26. <a name='ValidPalindrome'></a>125 ã€å›æ–‡ğŸŒˆã€‘Valid Palindrome

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1d7411n7cF?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qb411e7ML?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV17h411Z7ey?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

isalnum() æ–¹æ³•æ£€æµ‹å­—ç¬¦ä¸²æ˜¯å¦ç”±å­—æ¯å’Œæ•°å­—ç»„æˆã€‚

isalpha() æ–¹æ³•æ£€æµ‹å­—ç¬¦ä¸²æ˜¯å¦åªç”±å­—æ¯ç»„æˆã€‚

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s) - 1
        while left < right:
            # æ˜“é”™ç‚¹ï¼šif not s[left].isalnum(): æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸ºå­˜åœ¨è¿ç»­å¤šä¸ªâ€œéæ•°å­—çš„æƒ…å†µâ€
            while left < right and not s[left].isalnum(): 
                left += 1
            while left < right and not s[right].isalnum(): 
                right -= 1
            if s[left].lower() == s[right].lower():
                left += 1
                right -= 1
            else:
                return False
        return True
```

pythonç‰›é€¼çš„ä¸€è¡Œä»£ç ï¼š

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        sgood = "".join(ch.lower() for ch in s if ch.isalnum())
        return sgood == sgood[::-1]

class Solution:
    def isPalindrome(self, s):
        s = ''.join(filter(str.isalnum,s)).lower()
        return s==s[::-1]

ç»ƒä¹ ä¸€ä¸‹æ­£åˆ™

import re
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s=re.sub('[^a-zA-Z0-9]','',s)
        s=s.lower()
        return s==s[::-1]
```


```scala

/**
* two pointer comparison
* memo
*  1. alphanumeric = letters + numerals
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def isPalindrome(s: String): Boolean = {
      val newString = s.filter(_.isLetterOrDigit).toLowerCase
      isPalindrome(newString, 0, newString.length - 1)
    }
    @annotation.tailrec
    def isPalindrome(s: String, left: Int, right: Int): Boolean = {
      if (left > right) return true
      if (s(left) == s(right)) isPalindrome(s, left + 1, right - 1)
      else false
    }
}
```


###  1.27. <a name='bfsWordLadderII'></a>126. (bfså¥½éš¾æš‚æ—¶æ”¾å¼ƒ) Word Ladder II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yt411Y7gH?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV16K4y1j7hX?spm_id_from=333.999.0.0)

```py
# dfs
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList):
        if endWord not in wordList:
            return []

        allpath = []
        visited = {beginWord}

        def findWords(target,words):
            res = []
            for word in words:
                n = len(target)
                for i in range(n):
                    if target[i] == word[i]: 
                        n -= 1
                if n == 1: 
                    res.append(word)
            return res


        def dfs(path,middlelist):
            nonlocal allpath
            if not middlelist:
                return
            if endWord in middlelist:
                path.append(endWord)
                allpath.append(path)
                return 
            for item in middlelist:
              if item not in path:
                dfs(path+[item],findWords(item,wordList))
        dfs([beginWord],findWords(beginWord,wordList))
        return allpath
    
if __name__ == "__main__":
  s = Solution()
  res = s.findLadders("hit","cog",["hot","dot","dog","lot","log","cog"])
  print('res:',res)

# res: [['hit', 'hot', 'dot', 'dog', 'cog'], 
# ['hit', 'hot', 'dot', 'lot', 'log', 'cog'], 
# ['hit', 'hot', 'lot', 'dot', 'dog', 'cog'], 
# ['hit', 'hot', 'lot', 'log', 'cog']]
```

```py
import collections
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList):
        if endWord not in wordList:
            return []
        lookup = collections.defaultdict(list)
        L = len(beginWord)
        for word in wordList:
            for i in range(L):
                lookup[word[:i] + '*' + word[i+1:]].append(word)
        
        res = []
        que = [(beginWord, 1, [[beginWord]])] # ç»ˆç‚¹ï¼Œé•¿åº¦ï¼Œpath
        visited = {beginWord:[[beginWord]]}
        mindepth = len(wordList) + 1  # å‰ªæ
        print(visited)
        while que:
            cur, depth, paths = que.pop(0)
            if depth > mindepth: continue  # å‰ªæ           
            for i in range(L):
                dummyword = cur[:i] + '*' + cur[i+1:]
                for word in lookup[dummyword]:
                    if word == endWord:
                        for path in paths:
                            mindepth = depth  # å‰ªæ
                            res.append(path + [endWord])
                    elif word not in visited:
                        newPaths = [path+[word] for path in paths]
                        visited[cur] = newPaths
                        que.append((word, depth+1, newPaths))

        return res
    
if __name__ == "__main__":
  s = Solution()
  res = s.findLadders("hit","cog",["hot","dot","dog","lot","log","cog"])
  print('res:',res)
```

```py
æŠŠå•è¯åˆ°é€šé…ä¸²çš„è·¯å¾„ç”Ÿæˆï¼Œå†æŠŠé€šé…ä¸²åˆ°å•è¯çš„è·¯å¾„ç”Ÿæˆï¼Œ
ç„¶åå†å•å‘å®½æœï¼Œå†™åŒå‘å°±æ›´å¤æ‚äº†ï¼Œå•å‘é€Ÿåº¦ä¹Ÿé©¬é©¬è™è™å§ï¼Œ148msã€‚ py

import collections
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList) :
        lookup = collections.defaultdict(list)
        for word in wordList + [beginWord]:
            w = [*word]
            for i, c in enumerate(word):
                w[i] = '.'
                dummyword = ''.join(w)
                lookup[dummyword].append(word)
                lookup[word].append(dummyword)
                w[i] = c
        if endWord in lookup:
            que, visited = {beginWord: [[beginWord]]}, {beginWord}
            while que:
                # queæ˜¯è¾¾åˆ°çš„ç‚¹ä¸è·¯å¾„çš„æ˜ å°„
                if endWord in que:
                    return [*que[endWord]]
                tmp = collections.defaultdict(set)
                
                for i in que:
                    for dummyword in lookup[i]:
                        for w in lookup[dummyword]:
                            if w not in visited:
                                tmp[w].update((*path, w) for path in que[i]) #çœ‹ä¸æ‡‚æ›´æ–°pathè·¯å¾„ğŸ˜‚
                que = tmp
                visited.update(que.keys())
        return []
```

###  1.28. <a name='WordLadder'></a>127. Word Ladder

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yt411Y7Me?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1BK4y157k1?spm_id_from=333.999.0.0)

```py
(å‹æ ¹æ²¡æƒ³åˆ°ç”¨è™šæ‹ŸèŠ‚ç‚¹çš„æ–¹æ³•ï¼Œç”¨äº†æœ€è ¢çš„éå†a-zçš„æ–¹æ³•ã€‚æ²¡æƒ³åˆ°ç«Ÿç„¶èƒ½é€šè¿‡= =)

é™„ä¸Šæˆ‘çš„ä½æ•ˆpythonä»£ç ï¼Œä»…ä¾›å‚è€ƒã€‚

from collections import deque
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList):
        lookup = set(wordList)
        visited = set(['beginWord'])
        queue = deque([(beginWord, 1)])
        while queue:
            pop, depth = queue.popleft()
            if pop == endWord:
                return depth
            for i in range(len(pop)):
                for j in range(97, 123):
                    char26word = pop[:i] + chr(j) + pop[i+1:]
                    if char26word not in visited and char26word in lookup:
                        queue.append((char26word, depth + 1))
                        visited.add(char26word)
        return 0
```

```py
è¿˜æœ‰ä¸ªæ›´å·§å¦™çš„æƒ³æ³•ï¼Œå°† word çš„æŸä¸€ä½æ”¹ä¸º '*' ä½œä¸º word çš„ keyã€‚

ä¾‹å¦‚ hit çš„ key ä¸º '*it'ã€'h*t'ã€'hi*'ã€‚

åœ¨ wordList ä¸­æ‰¾åˆ° key ç›¸åŒçš„å•è¯ï¼Œå³æ˜¯èƒ½è½¬æ¢çš„å•è¯ã€‚

äºæ˜¯æå‰å°† wordList çš„å•è¯æŒ‰ key å­˜åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œå°±å¯ä»¥è¿›ä¸€æ­¥å‡å°‘æœç´¢èŒƒå›´åˆ° len(word)ã€‚

from collections import deque
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        lookup = defaultdict(list)
        genKey = lambda w: [w[:i] + '*' + w[i+1:] for i in range(len(w))]
        for word in wordList:
            for dummyword in genKey(word):
                lookup[dummyword].append(word)
        queue, visited = deque([(beginWord, 1)]), {beginWord}
        while queue:
            word, depth = queue.popleft()
            for dummyword in genKey(word):
                for nextword in lookup[dummyword]:
                    if nextword not in visited:
                        if nextword == endWord:
                            return depth+1
                        visited.add(nextword)
                        queue.append([nextword, depth+1])
        return 0
```

###  1.29. <a name='LongestConsecutiveSequence'></a>128. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Longest Consecutive Sequence

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14t411Y7cg?spm_id_from=333.999.0.0)

[ä¸€ä¿©ä¸‰å››äº”](https://www.bilibili.com/video/BV1LJ41137r2?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

###  1.30. <a name='SumRoottoLeafNumbers'></a>129 Sum Root to Leaf Numbers

[å°æ˜](https://www.bilibili.com/video/BV1VK411H7o5?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        sums = 0
        def dfs(node,cur):
            nonlocal sums
            if not node:
                return
            else:
                cur = cur*10 + node.val
                if not node.left and not node.right: # æ˜“é”™ç‚¹ï¼šä¸è¦å¿½è§†äº†è¿™ç§æƒ…å†µ
                    sums += cur
                    return
                else:
                    dfs(node.right,cur)
                    dfs(node.left,cur)
        dfs(root,0)
        return sums # åœ¨æ ¹èŠ‚ç‚¹å¤„curä¸º0ï¼Œè€Œä¸æ˜¯sums


å…¶ä»–å†™æ³•ï¼š

class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        ans = 0
        
        def dfs(root, acc):
            nonlocal ans
            if not root.left and not root.right:
                ans += acc * 10 + root.val
                return
            if root.left:
                dfs(root.left, acc*10+root.val)
            if root.right:
                dfs(root.right, acc*10+root.val)
        dfs(root, 0)
        return ans

```

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        if not root:
            return 0

        sums = 0
        que = collections.deque([(root,root.val)])
        
        while que:
            node, num = que.popleft()
            left, right = node.left, node.right
            if not left and not right:
                sums += num
            else:
                if left:
                    que.append((left, num * 10 + left.val))
                if right:
                    que.append((right, num * 10 + right.val))
        return sums
```

###  1.31. <a name='SurroundedRegions130-'></a>130. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Surrounded Regions 130-è¢«å›´ç»•çš„åŒºåŸŸ

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1dE411f7U4?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV18y4y1j7JH?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1pV411k7TH?spm_id_from=333.999.0.0)


```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        f = {}
        def find(x):
            f.setdefault(x,x)
            if f[x]!=x:
                f[x] = find(f[x])
            return f[x]
        def union(x,y):
            f[find(y)] = find(x)
        if not board or not board[0]:
            return
        row,col = len(board),len(board[0])
        dummy = row*col
        for i in range(row):
            for j in range(col):
                if board[i][j] == "O":
                    if i == 0 or i == row - 1 or j == 0 or j == col - 1:
                        union(i * col + j, dummy)
                    else:
                        for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                            if board[i + x][j + y] == "O":
                                union(i * col + j, (i + x) * col + (j + y))
                                
        for i in range(row):
            for j in range(col):
                if find(dummy) == find(i * col + j):
                    board[i][j] = "O"
                else:
                    board[i][j] = "X"
```


```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m = len(board)
        n = len(board[0])
        que = collections.deque()

        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1: # æ˜“é”™ç‚¹ï¼šm å’Œ n ä¸è¦å†™åäº†
                    if board[i][j] == 'O':
                        que.append((i,j))

        while que:
            x,y = que.popleft()
            board[x][y] = 'A'
            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                # æ˜“é”™ç‚¹ï¼šx+dx å’Œ x ä¸è¦å†™åäº†
                if 0 <= x+dx < m-1 and 0 <= y+dy < n-1 and board[x+dx][y+dy] == 'O': # æ˜“é”™ç‚¹ï¼š'O'ä¸è¦å†™æˆ0
                    board[x+dx][y+dy] = 'A'
                    que.append((x+dx,y+dy))

        for i in range(m):
            for j in range(n):
                # æ˜“é”™ç‚¹ï¼š== å’Œ = ä¸è¦å†™åäº†
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == 'A':
                    board[i][j] = 'O'

        return board
```

å¦ä¸€ç§å†™æ³•

```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        
        n, m = len(board), len(board[0])

        def dfs(x, y):
            if not 0 <= x < n or not 0 <= y < m or board[x][y] != 'O':
                return
            
            board[x][y] = "A"
            dfs(x + 1, y)
            dfs(x - 1, y)
            dfs(x, y + 1)
            dfs(x, y - 1)
        
        for i in range(n):
            dfs(i, 0)
            dfs(i, m - 1)
        
        for i in range(m - 1):
            dfs(0, i)
            dfs(n - 1, i)
        
        for i in range(n):
            for j in range(m):
                if board[i][j] == "A":
                    board[i][j] = "O"
                elif board[i][j] == "O":
                    board[i][j] = "X"
```



###  1.32. <a name='-1'></a>131 ã€å›æ–‡ğŸŒˆã€‘åˆ†å‰²å›æ–‡ğŸŒˆä¸²

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1dK411p7eU?spm_id_from=333.999.0.0)

```py
# é€’å½’è§£æ³•
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def backtrack(startIndex):
            if startIndex == len(s):
                res.append(path[:])
                return
            
            for end in range(startIndex, len(s)):
                seg = s[startIndex:end+1]
                if seg == seg[::-1]:
                    path.append(seg)
                    backtrack(end+1)
                    path.pop()
            
        path = []
        res = []
        backtrack(0)
        return res

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)

        res = []
        path = []

        @cache
        def isPalindrome(i: int, j: int) -> int:
            if i >= j:
                return 1
            return isPalindrome(i + 1, j - 1) if s[i] == s[j] else -1

        def backtrack(startIndex: int):
            if startIndex == n:
                res.append(path[:])
                return
            
            for end in range(startIndex, n):
                if isPalindrome(startIndex, end) == 1:
                    path.append(s[startIndex:end+1])
                    backtrack(end + 1)
                    path.pop()

        backtrack(0)
        isPalindrome.cache_clear()
        return res

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        # ------------------------ èƒŒä¸€èƒŒ ------------------------
        n = len(s)
        isPalinDP = [[True] * n for _ in range(n)]
        
        for start in range(n - 1, -1, -1): # start æŒ‡å‘ å€’æ•°ç¬¬äºŒä½, start å‘å‰æ‰«æ
            for end in range(start + 1, n): # end æŒ‡å‘ å€’æ•°ç¬¬ä¸€ä½, end å‘åæ‰«æ
                isPalinDP[start][end] = (s[start] == s[end]) and isPalinDP[start + 1][end - 1] 
        # ------------------------ èƒŒä¸€èƒŒ ------------------------

        res = []
        path = []

        def backtrack(startIndex: int):
            if startIndex == n:
                res.append(path[:])
                return
            
            for end in range(startIndex, n):
                if isPalinDP[startIndex][end]:
                    path.append(s[startIndex:end+1])
                    backtrack(end + 1)
                    path.pop()

        backtrack(0)
        return res



class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def backtrack(start):
            if start == len(s):
                ans.append(tmp[:])
                return
            
            for end in range(start+1, len(s)+1):
                seg = s[start:end]
                if seg == seg[::-1]:
                    tmp.append(seg)
                    backtrack(end)
                    tmp.pop()
            
        tmp = []
        ans = []
        backtrack(0)
        return ans


```

```py

python3 ç”¨å›æº¯é€’å½’çš„æ–¹æ³•å»è¯•æ¢æ¯ä¸€ç§å¯èƒ½æ€§ å¯¹äºä¸€ä¸ªå­—ç¬¦ä¸²sï¼Œ

æœ‰len(s)ç§æ–¹æ³•æŠŠå®ƒåˆ†æˆå·¦å³ä¸¤ä¸ªéƒ¨åˆ†ï¼ˆåˆ†å‰²æ–¹æ³•çœ‹ä»£ç ï¼‰ï¼Œ

å‡å¦‚å·¦ä¾§çš„ä¸æ˜¯å›æ–‡ğŸŒˆï¼Œåˆ™èˆå¼ƒè¿™æ¬¡å°è¯•ï¼›

å‡å¦‚å·¦ä¾§çš„æ˜¯å›æ–‡ğŸŒˆä¸²ï¼Œåˆ™æŠŠå³ä¾§çš„è¿›è¡Œé€’å½’çš„åˆ†å‰²ï¼Œå¹¶è¿”å›å³ä¾§çš„åˆ†å‰²çš„æ‰€æœ‰æƒ…å†µ

class Solution:
    @cache
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        res = []
        if n == 0:
            res.append([])

        for i in range(1, n+1):
            if s[:i] != s[:i][::-1]:
                continue
            left = [s[:i]]
            rights = self.partition(s[i:])
            for right in rights:
                res.append(left+right)
        return res


class Solution(object):
    def partition(self, s):

        n = len(s)
        res = []

        
        if n == 0:
            return [[]]
        if n == 1:
            return [[s]]


        for i in range(1, n+1):
            if s[:i] != s[:i][::-1]:
                continue
            left = [s[:i]]
            rights = self.partition(s[i:])
            for right in rights:
                res.append(left+right)
        return res


ä¸éœ€è¦é¢„å¤„ç†ï¼Œæ²¡æœ‰é€’å½’ï¼Œç„¶åä»£ç ç®€æ´çš„åŠ¨æ€ğŸš€è§„åˆ’

æˆ‘çœŸç‰›é€¼

class Solution:
    def partition(self, s: str):
        
        n = len(s)
        res = [[s[0]]]
        
# ä¸‹ä¸€ä¸ªä½ç½®çš„åˆ†å‰²ç»“æœ = å‰ä¸€ä¸ªä½ç½®æ‰€æœ‰åˆ†å‰²ç»“æœ + å½“å‰ä½ç½®çš„å­—æ¯s[i]å¾—åˆ°çš„ç»“æœ 
        for char in s[1:]:
            for path in res[:]: # ä¸€å®šè¦å†™æˆres[:],è€Œä¸æ˜¯res
                
# + åˆ¤æ–­å‰ä¸€ä¸ªä½ç½®æ¯ä¸ªåˆ†å‰²ç»“æœä¸­æœ€åä¸€ä¸ªå›æ–‡ğŸŒˆä¸²å’Œå½“å‰å­—æ¯s[i]æ˜¯å¦ç»„æˆå›æ–‡ğŸŒˆä¸²å¾—åˆ°çš„ç»“æœ --> ä¹Ÿå°±æ˜¯å¶æ•°ä¸ªå›æ–‡ğŸŒˆ
                if len(path[-1]) == 1 and path[-1] == char:
                    res.append(path[:-1] + [char + char])
                    
# + åˆ¤æ–­å‰ä¸€ä¸ªä½ç½®æ¯ä¸ªåˆ†å‰²ç»“æœä¸­æœ€åä¸¤ä¸ªå›æ–‡ğŸŒˆä¸²å’Œå½“å‰å­—æ¯s[i]æ˜¯å¦ç»„æˆå›æ–‡ğŸŒˆä¸²å¾—åˆ°çš„ç»“æœ --> ä¹Ÿå°±æ˜¯å¥‡æ•°ä¸ªå›æ–‡ğŸŒˆ
                if len(path) > 1 and len(path[-2]) == 1 and path[-2] == char:
                    res.append(path[:-2] + [char + path[-1] + char])
                    
                path.append(char)
        return res
```

###  1.33. <a name='PalindromePartitioningII'></a>132. ã€åŠ¨æ€ğŸš€è§„åˆ’ + å›æ–‡ğŸŒˆã€‘Palindrome Partitioning II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1NJ411v7k9?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1944y1C71s?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5d4nophqby00.webp" width="70%">

```py
è¾“å…¥
"aab"

[0, inf, inf]
[0, 0, inf]
[0, 0, 1]

class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        isPalinDP = [[True] * n for _ in range(n)]
        
        for start in range(n - 1, -1, -1): # start æŒ‡å‘ å€’æ•°ç¬¬äºŒä½, start å‘å‰æ‰«æ
            for end in range(start + 1, n): # end æŒ‡å‘ å€’æ•°ç¬¬ä¸€ä½, end å‘åæ‰«æ
                isPalinDP[start][end] = (s[start] == s[end]) and isPalinDP[start + 1][end - 1] 

        cutDP = [float("inf")] * n
        for endcut in range(n):
            # å¦‚æœå‰ä¸€å°æ®µæ˜¯å›æ–‡ğŸŒˆ
            if isPalinDP[0][endcut]:
                cutDP[endcut] = 0
            # å¦‚æœå‰ä¸€å°æ®µä¸æ˜¯å›æ–‡ğŸŒˆï¼Œåˆ™ä»startå¼€å§‹ç»§ç»­æ‹†åˆ†
            else:
                for startcut in range(endcut):
                    if isPalinDP[startcut + 1][endcut]:
                        cutDP[endcut] = min(cutDP[endcut], cutDP[startcut] + 1) # åŠ¨æ€è½¬ç§»ï¼Œå°† cutDP[start] + 1å¤„çš„è½¬ç§»è¿‡æ¥
        
        return cutDP[n - 1]
```

###  1.34. <a name='CloneGraph'></a>133. Clone Graph

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1wA411T7SM?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV18i4y1c7FE?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV12K411A7Zb?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1hzav19bp1wg.png" width="70%">

https://www.bilibili.com/video/BV1Cy4y127Di?from=search&seid=15236791324980694232&spm_id_from=333.337.0.0

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6d4fzq5ov200.png)


```py
class Solution(object):

    def __init__(self):
        self.visited = {}

    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node
        # é€’å½’ç»“æŸæ¡ä»¶ï¼š
        # å¦‚æœè¯¥èŠ‚ç‚¹å·²ç»è¢«è®¿é—®è¿‡äº†ï¼Œåˆ™ç›´æ¥ä»å“ˆå¸Œè¡¨ä¸­å–å‡ºå¯¹åº”çš„å…‹éš†èŠ‚ç‚¹è¿”å›
        if node in self.visited:
            return self.visited[node]
        # å…‹éš†èŠ‚ç‚¹ï¼Œæ³¨æ„åˆ°ä¸ºäº†æ·±æ‹·è´æˆ‘ä»¬ä¸ä¼šå…‹éš†å®ƒçš„é‚»å±…çš„åˆ—è¡¨
        cloneNode = Node(node.val, [])
        # å“ˆå¸Œè¡¨å­˜å‚¨
        self.visited[node] = cloneNode
        # éå†è¯¥èŠ‚ç‚¹çš„é‚»å±…å¹¶æ›´æ–°å…‹éš†èŠ‚ç‚¹çš„é‚»å±…åˆ—è¡¨
        if node.neighbors:
            cloneNode.neighbors = [self.cloneGraph(n) for n in node.neighbors] # é€’å½’åœ¨è¿™é‡Œï¼Œneighborsé‡Œé¢æ˜¯ğŸ˜
        return cloneNode
```

```py
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        def dfs(nod): # dfsçš„æœ¬è´¨åœ¨äºèµ‹å€¼
            VisitDic[nod] = Node(nod.val)
            # å¯¹nodeçš„neighbors,å¦‚æœåœ¨ç›®å½•é‡Œé¢ï¼Œè¿”å›è¿™äº›é‚»å±…çš„å€¼nod.val,å¦åˆ™dfs
            VisitDic[nod].neighbors = [dfs(n) if n not in VisitDic else VisitDic[n] for n in nod.neighbors] # é€’å½’åœ¨è¿™é‡Œï¼Œneighborsé‡Œé¢æ˜¯ğŸ˜
            return VisitDic[nod]
        VisitDic = {}
        return dfs(node) if node else None

# bfsæ¨¡æ¿åŠ ä¸€ä¸ªdictè®°å½•å³å¯ï¼

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        visited = {}
        def dfs(nod,visited):
            if not nod:
                return None # dfs è¿”å›çš„æ˜¯neighbors
            elif nod in visited:
                # æ˜“é”™ç‚¹ï¼šreturn nod
                return visited[nod]
            else:
                visited[nod] = Node(nod.val)
                for neigh in nod.neighbors:
                    visited[nod].neighbors.append(dfs(neigh,visited))
            return visited[nod]
        return dfs(node,visited) # æ˜“é”™ç‚¹ï¼šä¸€å®šè¦è¿”å›
```

```py
ç±»ä¼¼çš„ä¸‰ç§å†™æ³•ï¼š

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack ä¸¤æ­¥éª¤
        nodecp = Node(node.val)
        visited = {node:nodecp}
        stack = [node]
        while stack:
            tmp = stack.pop() #
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack ä¸¤æ­¥éª¤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) # ğŸ˜ æ³¨æ„ï¼Œappendæ˜¯å­—å…¸å†…çš„neighï¼Œä¹Ÿå°±æ˜¯ Node(node.val)
        return nodecp

ç±»ä¼¼çš„ä¸‰ç§å†™æ³•ï¼š


class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack ä¸¤æ­¥éª¤
        visited = {}
        visited[node] = Node(node.val)
        stack = [node]
        while stack:
            tmp = stack.pop() 
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack ä¸¤æ­¥éª¤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) 
        return visited[node]

ç±»ä¼¼çš„ä¸‰ç§å†™æ³•ï¼š

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack ä¸¤æ­¥éª¤
        visited = {}
        stack = [node]
        while stack:
            tmp = stack.pop() 
            if tmp not in visited: # è¿™è¡Œå¿…é¡»è¦æœ‰
                visited[tmp] = Node(tmp.val)
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack ä¸¤æ­¥éª¤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) 
        return visited[node]
```


###  1.35. <a name='GasStation'></a>134. Gas Station

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1BC4y1472f?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1754y1176F?spm_id_from=333.999.0.0)

```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        start = 0
        curSum = 0
        totalSum = 0
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            if curSum < 0:
                curSum = 0
                start = i + 1
        if totalSum < 0: return -1
        return start
```

###  1.36. <a name='CopyListwithRandomPointer'></a>138 Copy List with Random Pointer

[å°æ˜](https://www.bilibili.com/video/BV1BN411R7a8?spm_id_from=333.999.0.0)

###  1.37. <a name='SingleNumber'></a>136 ã€ä½è¿ç®—ğŸ˜œã€‘Single Number

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1g7411a7bf?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Sp4y1D7M3?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qb411e7PU?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1pa4y1t7tr?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

```py
class Solution:
    def singleNumber(self, nums):
        a = 0
        for num in nums:
            a = a ^ num
        return a

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)
```

```scala
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        nums.reduce(_^_)
    }
}
```

###  1.38. <a name='SingleNumberII'></a>137 ã€ä½è¿ç®—ğŸ˜œã€‘Single Number II

[å°æ˜](https://www.bilibili.com/video/BV1Hv411B7rd?spm_id_from=333.999.0.0)

æ–¹æ³•äºŒï¼šä¾æ¬¡ç¡®å®šæ¯ä¸€ä¸ªäºŒè¿›åˆ¶ä½

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1ro27dupbn40.webp)

```py
ç»†èŠ‚ï¼š

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœä½¿ç”¨çš„è¯­è¨€å¯¹ã€Œæœ‰ç¬¦å·æ•´æ•°ç±»å‹ã€å’Œã€Œæ— ç¬¦å·æ•´æ•°ç±»å‹ã€æ²¡æœ‰åŒºåˆ†ï¼Œ

é‚£ä¹ˆå¯èƒ½ä¼šå¾—åˆ°é”™è¯¯çš„ç­”æ¡ˆã€‚

è¿™æ˜¯å› ä¸ºã€Œæœ‰ç¬¦å·æ•´æ•°ç±»å‹ã€ï¼ˆå³ int ç±»å‹ï¼‰çš„ç¬¬ 31 ä¸ªäºŒè¿›åˆ¶ä½ï¼ˆå³æœ€é«˜ä½ï¼‰æ˜¯è¡¥ç æ„ä¹‰ä¸‹çš„ç¬¦å·ä½ï¼Œå¯¹åº”ç€ -2^{31}

è€Œã€Œæ— ç¬¦å·æ•´æ•°ç±»å‹ã€ç”±äºæ²¡æœ‰ç¬¦å·ï¼Œç¬¬ 31 ä¸ªäºŒè¿›åˆ¶ä½å¯¹åº”ç€ 2^{31}

å› æ­¤åœ¨æŸäº›è¯­è¨€ï¼ˆä¾‹å¦‚ Python ï¼‰ä¸­éœ€è¦å¯¹æœ€é«˜ä½è¿›è¡Œç‰¹æ®Šåˆ¤æ–­ã€‚

æ—¶é—´å¤æ‚åº¦ï¼šO(nlogC)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ï¼ŒC æ˜¯å…ƒç´ çš„æ•°æ®èŒƒå›´

ç©ºé—´å¤æ‚åº¦ï¼šO(1)

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            total = sum((num >> i) & 1 for num in nums)
            if total % 3:
                # Python è¿™é‡Œå¯¹äºæœ€é«˜ä½éœ€è¦ç‰¹æ®Šåˆ¤æ–­
                if i == 31:
                    ans -= (1 << i)
                else:
                    ans |= (1 << i)
        return ans

è¿™ä¸ªè§£æ³•çœ‹ä¸æ‡‚ï¼Œæ”¾å¼ƒï¼š


æ—¶é—´å¤æ‚åº¦ï¼šO(nlogC)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ï¼ŒC æ˜¯å…ƒç´ çš„æ•°æ®èŒƒå›´

ç©ºé—´å¤æ‚åº¦ï¼šO(1)

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ones, twos = 0, 0
        for num in nums:
            ones = ones ^ num & ~ twos
            twos = twos ^ num & ~ ones
        return ones
```





###  1.39. <a name='WordBreak'></a>139 ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ…ã€‘Word Break

[å°æ˜](https://www.bilibili.com/video/BV1p54y1k7vf?spm_id_from=333.999.0.0)

```py
# python åŠ¨æ€ğŸš€è§„åˆ’

# ä» i = 0 å¼€å§‹åˆ†æï¼ši = 0ï¼Œ éå† j in range(1, n+1)ï¼Œ 

# å³éå†æ‰€æœ‰ä»¥ s[0]å¼€å¤´çš„ç»„åˆï¼ŒæŠŠç¬¬ä¸€ä¸ªå•è¯å¯èƒ½çš„æƒ…å†µå…¨éƒ¨æ‰¾å‡ºæ¥ã€‚

# æ­¤æ—¶ç›¸å½“äºæŠŠæ‰“å¤´çš„å•è¯å¯èƒ½çš„æƒ…å†µå…¨éƒ¨æ‰¾å‡ºæ¥äº†ã€‚

# ç„¶ååŸºäºç¬¬ä¸€ä¸ªå•è¯ä¸€ä¸ªå•è¯ä¸€ä¸ªå•è¯åœ°æ¥ä¸Šå»ã€‚

class Solution:
    def wordBreak(self, s, wordDict):
        n = len(s) 
        dp = [True] + [False]*n

        for end in range(1, n + 1):
            for start in range(end):
                if dp[start] and s[start: end] in wordDict:
                    dp[end] = True # è¯´æ˜s[: i] åœ¨wordDictä¸­
                    break # ä¼˜åŒ–éƒ¨åˆ†ï¼šå‰©ä¸‹çš„åˆ‡åˆ†ç‚¹jä¸ç”¨å†å¯»æ‰¾äº†ï¼Œä¹Ÿå¯ä»¥ä¸å†™ï¼Œåƒä¸‹æ–¹ä¸€æ ·
        return dp[-1]

```

###  1.40. <a name='WordBreakII'></a>140 Word Break II

[å°æ˜](https://www.bilibili.com/video/BV1ht4y1X7DJ?spm_id_from=333.999.0.0)

```py
# ç›´æ¥å›æº¯è¿‡äº†ï¼Œè¿™æ˜¯æ ·ä¾‹å‡ºé—®é¢˜äº†è¿˜æ˜¯æ ‡é”™éš¾åº¦äº†ã€‚ã€‚ã€‚
class Solution(object):
    def wordBreak(self, s, wordDict):
        res = []
        
        # ä¹Ÿæ˜¯å·¦å³ğŸ§åˆ‡
        def backtrack(s, path):
            # nonlocal res
            if len(s) == 0:
                res.append(path[1:])
                return

            n = len(s)
            for i in range(n):
                if s[:i+1] in cash:
                    backtrack(s[i+1:], path+" "+s[:i+1])
                    
        backtrack(s, "")
        return res

class Solution:
    def wordBreak(self, s, wordDict):
        # @lru_cache(None)
        def backtrack(index: int):
            if index == len(s):
                return [[]]
            res = []
            for i in range(index + 1, len(s) + 1):
                left = s[index:i]
                if left in wordSet:
                    rightBreaks = backtrack(i)
                    for right in rightBreaks:
                        res.append(right[:] + [left])
            return res
        
        wordSet = set(wordDict)
        breakList = backtrack(0)
        return [" ".join(words[::-1]) for words in breakList]

class Solution(object):
    def wordBreak(self, s, wordDict):
        memo = {len(s): ['']}
        def sentences(i):
            if i not in memo:
                memo[i] = [s[i:j] + (tail and ' ' + tail)
                           for j in range(i+1, len(s)+1)
                           if s[i:j] in wordDict
                           for tail in sentences(j)]
            return memo[i]
        return sentences(0)
```

###  1.41. <a name='LinkedListCycle'></a>141-Linked List Cycle

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1g7411a7ta?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411H7XP?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1KX4y157vh?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1PA411b7gq?spm_id_from=333.999.0.0)

```py
æ–¹æ³•ä¸€ï¼šé›†åˆ å¦‚æœå‘ç°èŠ‚ç‚¹å·²åœ¨é›†åˆå†…åˆ™è¯´æ˜å­˜åœ¨ç¯

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            visited.add(head)
            head = head.next
            if head in visited:
                return True
        return False

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            if head in visited:
                return True
            visited.add(head)
            head = head.next
        return False

æ„Ÿè§‰åˆå§‹æ—¶æŠŠå¿«æ…¢æŒ‡é’ˆéƒ½æŒ‡å‘ head åè€Œæ›´ç®€æ´ï¼š

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
        
```


```scala
object Solution1 {
    def hasCycle(head: ListNode): Boolean = {
        
        var cur = head
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        
        var res: Boolean = false
        while (cur != null && res != true) {

            if(visited.contains(cur))  
                res = true
            else {
                visited += cur
                cur = cur.next
            }
        }
        res
    }
}


object Solution3 {
    def hasCycle(head: ListNode): Boolean = {
        var fast = head
        var slow = head
        
        
        var result = false
        while (fast != null && fast.next != null && result != true) {
            fast = fast.next.next
            slow = slow.next
        
            if(fast == slow) result = true
        }
        result
    }
}

object Solution {
    def hasCycle(head: ListNode): Boolean = {
        
        if(head == null){
            false
        }else{
        
        var slow = head
        var fast = head.next
        var output = true
        
        import scala.util.control.Breaks._
        breakable{
            while(slow != fast){
                if(fast == null || fast.next == null){
                    output=false
                    break
                }
                slow = slow.next
                fast = fast.next.next
            }
        }
        output
    }
    }
}

/**
* two pointer - tail recursive
*/
object Solution {
    def hasCycle(head: ListNode): Boolean = {
        if(head != null && head.next != null) 
            _hasCycle(head.next.next, head.next)
        else false
    }
    
    @annotation.tailrec
    def _hasCycle(fast: ListNode, slow: ListNode): Boolean = {
        if(fast == null || fast.next == null || slow == null) return false
        else if(fast == slow) return true
        else _hasCycle(fast.next.next, slow.next)
    }
}
//Alternate solution: Slow & Fast pointer
```

###  1.42. <a name='LinkedListCycleII'></a>142 Linked List Cycle II

[å°æ˜](https://www.bilibili.com/video/BV1W5411L7AF?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV15e41147EY?spm_id_from=333.999.0.0)

```py
æˆ‘è¿™ä¸ªéƒ½åœ¨ä¸€ä¸ªå¾ªç¯ä¸­ï¼Œç®€æ´ç‚¹

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow, res = head, head, head
        flag = False

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if flag: res = res.next

            if slow == fast: flag = True
            if flag and slow == res: return res
        return None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            # å¦‚æœç›¸é‡
            if slow == fast:
                p = head
                q = slow
                while p!=q:
                    p = p.next
                    q = q.next
                #ä½ ä¹Ÿå¯ä»¥return q
                return p

        return None
```

```py
åœ¨forå¾ªç¯ä¸whileå¾ªç¯ä¸­çš„elseè¯­å¥å—

æ—¨åœ¨å¾ªç¯æ­£å¸¸éå†äº†æ‰€æœ‰å†…å®¹æˆ–ç”±äºå¾ªç¯æ¡ä»¶ä¸æˆç«‹è€Œç»“æŸå¾ªç¯æ—¶æ‰§è¡Œï¼Œ

å¦‚æœforå¾ªç¯ä¸whileå¾ªç¯å› ä¸ºbreaké€€å‡ºï¼Œåˆ™ä¸æ‰§è¡Œelseè¯­å¥å—ä¸­çš„å†…å®¹ã€‚

continueå¯¹elseæ²¡å½±å“ã€‚ 

è¿™æ ·åœ¨whileå¾ªç¯ä¹‹åä½¿ç”¨elseä»£ç å—ï¼Œå°±å¯ä»¥è¾¾åˆ°ä»£ç ä¸­ä½¿ç”¨flagçš„æ•ˆæœ

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head:
            return None
        fast, slow = head,  head
        while slow.next and fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        else:
            return None
        
        slow = head
        while slow != fast:
             slow = slow.next
             fast = fast.next
        return slow

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        # é¦–å…ˆåˆå§‹åŒ–å¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆï¼Œç¡®ä¿å¿«æŒ‡é’ˆèµ°çš„è·¯çš„é•¿åº¦æ˜¯æ…¢æŒ‡é’ˆé•¿åº¦çš„2å€
        if head and head.next:
            fast = head.next.next
            slow = head.next
        else:
            return None  # è¯´æ˜æ— ç¯

        # è¿›è¡Œå¾ªç¯ï¼Œé¦–å…ˆè®©å¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡
        while fast:
            if fast != slow:

                # å¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
                if fast.next:
                    fast = fast.next.next
                else:
                    return None  # è¯´æ˜æ— ç¯

                # æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥
                slow = slow.next
            else:
                detection = head
                while detection != slow:  # æ­¤æ—¶ç”±äºslowå’Œfastæ˜¯ä¸€æ ·çš„ï¼Œç”¨å“ªä¸ªéƒ½è¡Œ
                    slow = slow.next
                    detection = detection.next

                return detection

```

```scala
object Solution {
    def detectCycle(head: ListNode): ListNode = {
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        var cur = head
        
        var result: ListNode = null

        while (cur != null && result == null) {
            // println(result)
            if(visited.contains(cur))  
                result = cur
            else {
                visited += cur
                cur = cur.next
            }
        }
        result
        
    }
}

```

###  1.43. <a name='ReorderList'></a>143 Reorder List

[å°æ˜](https://www.bilibili.com/video/BV1Jf4y1Q7y7?spm_id_from=333.999.0.0)

###  1.44. <a name='Preorderwithstack'></a>144-Preorder with stack

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1HT4y1G74i?spm_id_from=333.999.0.0)

###  1.45. <a name='BinaryTreePreorderTraversal'></a>144-Binary Tree Preorder Traversal

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1n7411D7NZ?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1Ch411Q74P?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1RD4y1D7C7?spm_id_from=333.999.0.0)


```py
Pythoné€’å½’

class Solution(object):
    def preorderTraversal(self, root):
        if not root:
            return []
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)
```

```py
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def dfs(node):
            if not node:
                return
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        res = []
        dfs(root)
        return res
```

stack

```py
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        ans = []
        if not root:
            return ans
        stack = [root]
        while stack:
            node = stack.pop()
            ans.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return ans
```


###  1.46. <a name='Postorderwithstack'></a>145-Postorder with stack

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Ti4y187jL?spm_id_from=333.999.0.0)

###  1.47. <a name='BinaryTreePostorderTraversal'></a>145-Binary Tree Postorder Traversal

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1n7411D7ub?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1uv411h7Gc?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1xZ4y1H7uS?spm_id_from=333.999.0.0)

```py
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def postorder(root: TreeNode):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        
        res = []
        postorder(root)
        return res

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        from collections import deque
        res, que = [], deque()
        que.append(root) if root else None
        while que:
            tmp = que.pop()
            res.append(tmp.val)
            que.append(tmp.left) if tmp.left else None
            que.append(tmp.right) if tmp.right else None
        return res[::-1]

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return list()
        
        res = list()
        stack = list()
        prev = None

        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if not root.right or root.right == prev:
                res.append(root.val)
                prev = root
                root = None
            else:
                stack.append(root)
                root = root.right
        
        return res

```

###  1.48. <a name='LRUCache'></a>146 ã€æ„é€ ğŸ°ã€‘LRU Cache 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV19b411c7ue?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gt411Y7c6?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1vi4y1t7zj?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ZQ4y1A74H?spm_id_from=333.999.0.0)

è¿™ä¸ªfunctools.lru_cache(None)çš„åº•å±‚æ˜¯æ€ä¹ˆåšçš„å‘€ï¼Ÿ 

```py
def lru(f):
    d={}
    def wrapper(*args):
        if args not in d:
            d[args]=f(*args)
        return d[args]
    return wrapper
```

åŠ ä¸ªå‰ç¼€å’Œé¢„å¤„ç†ï¼Œæ—¶é—´å‡å°‘ä¸€åŠï¼š

```py 
# åˆ©ç”¨ super().__init__()
class LRUCache(collections.OrderedDict):

    def __init__(self, capacity: int):
        # super() ç»§æ‰¿ collections.OrderedDict
        super().__init__()
        self.capacity = capacity


    def get(self, key: int) -> int:
        # å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› -1 
        if key not in self:
            return -1
        self.move_to_end(key)
        return self[key]

    def put(self, key: int, value: int) -> None:
        # å¦‚æœå…³é”®å­— key å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ value
        if key in self:
            self.move_to_end(key)
        # å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ key-value
        self[key] = value
        # å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ capacity ï¼Œåˆ™åº”è¯¥ é€å‡º æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚
        if len(self) > self.capacity:
            self.popitem(last=False)
```


```py
# åˆ©ç”¨ self.cache = collections.OrderedDict()
class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = collections.OrderedDict()

    å†™æ³• 1ï¼šæ—  move_to_end
    def get(self, key):
        # å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› -1 
        if key in self.cache:
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
        return -1

    å†™æ³• 2ï¼šæœ‰ move_to_end
    def get(self, key):
        if key in self.cache:
            self.cache.move_to_end(key)
            return self.cache[key]
        return -1

    å†™æ³• 1ï¼šæ—  move_to_end
    def put(self, key, value):
        # å¦‚æœå…³é”®å­— key å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ value
        if key in self.cache:
            self.cache.pop(key)
        # å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ capacity ï¼Œåˆ™åº”è¯¥ é€å‡º æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚
        if len(self.cache) == self.capacity:
            self.cache.popitem(last=False)
                
        # å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ key-value
        self.cache[key] = value

    å†™æ³• 2ï¼šæœ‰ move_to_end
    def put(self, key, value):
        # å¦‚æœå…³é”®å­— key å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ value
        if key in self.cache:
            self.cache.move_to_end(key)
        # å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ key-value
        self.cache[key] = value
        # å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ capacity ï¼Œåˆ™åº”è¯¥ é€å‡º æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)

```

```scala

/**
* chosen solution
* build-in linkedHashMap
* time complexity: O(1)
*/
class LRUCache0(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
    cache.get(key) match {
        case Some(v) => 
            cache.remove(key)
            cache.put(key, v)
            v
        case None => -1
    }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}



/**
* build-in linkedHashMap
*/
class LRUCache3(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
  /**
   *cache.get(key).map{
   *   value =>
   *     cache.remove(key)
   *     cache.update(key, value)
   *     value
   * }.getOrElse(-1)
   */
   cache.get(key) match {
            case Some(v) => 
                cache.remove(key)
                cache.put(key, v)
                v
            case None => -1
        }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}

```

```scala
import scala.collection.mutable._

  class LRUCache(_capacity: Int) {

    val hm = HashMap[Int, Int]()
    val lb = ListBuffer.empty[Int]
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key)
      } else {
        -1
      }

    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key) = value
      } else {
        if (hm.size == c) {
          val lk = lb.head
          hm.remove(lk)
          lb.remove(0)
        }
        hm(key) = value
        lb += key
      }
    }
  }


// test case
//  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
//  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]

//  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]
  class LRUCache3(_capacity: Int) {
    val hm = HashMap[Int, Node]()
    val dl = new DoublyLinkedList()
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v
      } else { // not found
        -1
      }
    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v = value
      } else {
        if (hm.size == c) {
          val old = dl.tail
          if (old!=null) {
            dl.erase(old)
            hm.remove(old.v.k)
          }
        }
        val node = Node(KV(key,value),null,null)
        hm(key) = node
        dl.push_front(node)
      }
    }
  }
```

```scala
  class Test extends BaseExtension {
    def init {
      val lru = new LRUCache(2)
      lru.put(1,1)
      lru.put(2,2)
      println(lru.get(1) == 1)
    }

    val name = "146 LRU chache"
  }

//  ["LRUCache","put","put","get","put","get","put","get","get","get"]
//  [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
  class Test2 extends BaseExtension {
    def init {
      val lru = new LRUCache2(2)
      lru.put(2,1)
      lru.put(1,1)
      lru.put(2,3)
      lru.put(4,1)
      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }

  //  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
  //  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]
  //  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]

  class Test3 extends BaseExtension {
    def init {
      val lru = new LRUCache3(10)
      lru.put(10,13)
      lru.put(3,17)
      lru.put(6,11)
      lru.put(10,5)
      lru.put(9,10)

      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }
```

###  1.49. <a name='InsertionSortList'></a>147 Insertion Sort List

[å°æ˜](https://www.bilibili.com/video/BV1F54y1k7oU?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1Ti4y187pN?spm_id_from=333.999.0.0)

```py
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        dummy = ListNode(0)
        dummy.next = head
        tmp = head
        cur = head.next

        while cur:
            if tmp.val <= cur.val:
                tmp = tmp.next
            else:
                pre = dummy
                while pre.next.val <= cur.val:
                    pre = pre.next
                tmp.next = cur.next
                cur.next = pre.next
                pre.next = cur
            cur = tmp.next
        
        return dummy.next

class Solution(object):
    def insertionSortList(self, head):
        if head == None or head.next == None:
            return head

        dummy = ListNode(0)
        dummy.next = head

        tmp = head 
        cur = head.next

        while cur:
            pre = dummy
            while pre.next.val <= cur.val and pre != tmp:
                pre = pre.next
            if pre != tmp:
                tmp.next = cur.next
                cur.next = pre.next
                pre.next = cur
            tmp = cur
            cur = cur.next

        return dummy.next


# èœé¸¡ç‰ˆ python
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        cur = head.next
        dummy.next.next = None
        while cur:
            pre = dummy
            while pre.next and cur.val > pre.next.val:
                pre = pre.next
            tmp = cur.next
            cur.next = pre.next
            pre.next = cur
            cur = tmp
        return dummy.next
```

###  1.50. <a name='SortList'></a>148. Sort List

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1jW411d7z7?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1VK411A7Gm?spm_id_from=333.999.0.0)

```py
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        sortlist = []
        while(head is not None):
            aft = head.next
            head.next = None
            sortlist.append(head)
            head = aft
        sortlist = sorted(sortlist, key=lambda x: x.val)
        n = len(sortlist)
        if n == 0:
            return None
        dummy.next = sortlist[0]
        for i in range(n-1):
            sortlist[i].next = sortlist[i+1]
        
        return dummy.next
```

```py
# py3 å½’å¹¶æ’åºï¼Œé€’å½’å®ç°ã€‚ç©ºé—´å¤æ‚åº¦ä¸»è¦åœ¨é€’å½’æ ˆæ·±åº¦ï¼šO( log(n) )ï¼Œæ•´ä¸ªé€’å½’è¿‡ç¨‹æœ‰ç‚¹åƒååºéå†

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        mid=self.findmid(head)
        left=head # æŒ‡å®šå·¦å³
        right=mid.next # æŒ‡å®šå·¦å³
        mid.next=None # æ–­å¼€é“¾æ¥
        l=self.sortList(left)
        r=self.sortList(right)
        return self.merge(l,r)

    def findmid(self,head):
        slow=head
        fast=head
        while fast.next and fast.next.next:
            slow=slow.next
            fast=fast.next.next
        return slow

    def merge(self,l,r):
        dummy=ListNode(None)
        cur=dummy
        while l and r:
            if l.val<=r.val:
                cur.next=l
                l=l.next # ä¸‹ä¸€ä¸ª
            else:
                cur.next=r
                r=r.next # ä¸‹ä¸€ä¸ª
            cur=cur.next # ä¸‹ä¸€ä¸ª
        cur.next=l or r
        return dummy.next

        # åŸºæœ¬ç”¨æ³•ï¼š
        # v = p1 or p2

        # å®ƒå®Œæˆçš„æ•ˆæœç­‰åŒäºï¼š
        # if p1:
        #     v = p1
        # else:
        #     v = p2
```

###  1.51. <a name='MaxPointsonaLine'></a>149. Max Points on a Line

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1zb411u7WW?spm_id_from=333.999.0.0)

###  1.52. <a name='EvaluateReversePolishNotation'></a>150. Evaluate Reverse Polish Notation

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14f4y127K8?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV16B4y1P7Nx?spm_id_from=333.999.0.0)

```py
class Solution:
    def evalRPN(self, tokens):
        f1 = lambda a,b:a+b
        f2 = lambda a,b:a-b
        f3 = lambda a,b:a*b
        f4 = lambda a,b:int(a/b)
        maps = {'+':f1,'-':f2,'*':f3,'/':f4}
        stack = []
        for i in tokens:
            if i in maps:
                a = stack.pop()
                b = stack.pop()
                stack.append(maps[i](b,a))
            else:
                i = int(i)
                stack.append(i)
        return stack[-1]

class Solution:
    def evalRPN(self, tokens):
        stack = []
        for item in tokens:
            if item not in {"+", "-", "*", "/"}:
                stack.append(item)
            else:
                first_num, second_num = stack.pop(), stack.pop()
                stack.append(
                    int(eval(f'{second_num} {item} {first_num}'))   # ç¬¬ä¸€ä¸ªå‡ºæ¥çš„åœ¨è¿ç®—ç¬¦åé¢
                )
        return int(stack.pop()) # å¦‚æœä¸€å¼€å§‹åªæœ‰ä¸€ä¸ªæ•°ï¼Œé‚£ä¹ˆä¼šæ˜¯å­—ç¬¦ä¸²å½¢å¼çš„

class Solution:
    def evalRPN(self, tokens):
        """
        è§£é¢˜æ€è·¯:æ•°å­—å…¥æ ˆï¼Œç®—æ•°ç¬¦å·å‡ºæ ˆä¸¤ä¸ªæ•°å­—æ ˆå¹¶è®¡ç®—ï¼Œè®¡ç®—ç»“æœå…¥æ ˆ
        """
        stack = []
        
        for item in tokens:

            if item not in ['+', '-', '*', '/']:
                stack.append(int(item))
            else:
                a = stack.pop()
                b = stack.pop()
                if item == '+': stack.append(a + b)
                elif item == '-': stack.append(b - a)
                elif item == '*': stack.append(a * b)
                elif item == '/': stack.append(int(b / float(a)))   # æ³¨æ„å¦‚ä½•å–æ•´
        return stack[0]
```

###  1.53. <a name='ReverseWordsinaString'></a>151. Reverse Words in a String

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i7g4?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1rT4y1g7AJ?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ei4y1V7yA?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))
```

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        left, right = 0, len(s) - 1
        # å»æ‰å­—ç¬¦ä¸²å¼€å¤´çš„ç©ºç™½å­—ç¬¦
        while left <= right and s[left] == ' ':
            left += 1
        
        # å»æ‰å­—ç¬¦ä¸²æœ«å°¾çš„ç©ºç™½å­—ç¬¦
        while left <= right and s[right] == ' ':
            right -= 1
            
        que, word = collections.deque(), []
        # å°†å•è¯ push åˆ°é˜Ÿåˆ—çš„å¤´éƒ¨
        while left <= right:
            if s[left] == ' ' and word:
                que.appendleft(''.join(word))
                word = []
            elif s[left] != ' ':
                word.append(s[left])
            left += 1
        que.appendleft(''.join(word))
        
        return ' '.join(que)
```

```py
ä¸€ç§æ²¡æœ‰ç”¨split å’Œreverseçš„æ–¹æ³•[^1]

åˆ†ä¸‰æ­¥:

å…ˆç¿»è½¬æ•´ä¸ªæ•°ç»„
å†ç¿»è½¬å•ä¸ªå•è¯
æ¸…é™¤å¤šä½™ç©ºæ ¼
class Solution:
    def reverseWords(self, s: str) -> str:
        s = list(s)
        n = len(s)
        #print(s)
        
        # ç¿»è½¬æ•°ç»„
        def reverse(s, i, j):
            while i < j:
                s[i], s[j] = s[j], s[i]
                i += 1
                j -= 1

        # ç¿»è½¬å•ä¸ªå•è¯
        def word_reverse(s):
            # ç”¨åŒæŒ‡é’ˆæ‰¾åˆ°ä¸€ä¸ªå•è¯
            i = 0
            j = 0
            while i < n:
                # æ‰¾åˆ°ä¸€ä¸ªå•è¯é¦–å­—æ¯
                while i < n and s[i] == " ":
                    i += 1
                j = i
                # æ‰¾åˆ°ä¸€ä¸ªå•è¯æœ«ä½ç½®
                while j < n and s[j] != " ":
                    j += 1
                reverse(s, i, j - 1)
                i = j

        # æ¸…é™¤å¤šä½™ç©ºæ ¼
        def clean_space(s):
            i = 0
            j = 0
            while j < n:
                # æ‰¾åˆ°ä¸€ä¸ªå•è¯
                while j < n and s[j] == " ":
                    j += 1
                # å•è¯æœå‰ç§»
                while j < n and s[j] != " ":
                    s[i] = s[j]
                    i += 1
                    j += 1
                # ç§»åŠ¨ä¸‹ä¸€ä¸ªå•è¯
                while j < n and s[j] == " ":
                    j += 1
                if j < n:
                    s[i] = " "
                    i += 1
            return "".join(s[:i])

        reverse(s, 0, n - 1)
        #print(s)
        word_reverse(s)
        #print(s)
        return clean_space(s)
```



###  1.54. <a name='-1'></a>152 ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ä¹˜ç§¯æœ€å¤§å­æ•°ç»„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV12a4y1i76G?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1iK411K7yG?spm_id_from=333.999.0.0)

maxdp * num, mindp * num, num

```py
# åŠ¨æ€ğŸš€è§„åˆ’ï¼šéå†æ—¶ï¼Œæ¯æ¬¡åˆ†åˆ«å­˜å‚¨ å‰iä¸ªä¸­è¿ç»­æ•°ç»„ [æœ€å¤§çš„ä¹˜ç§¯å’Œ] å’Œ [æœ€å°ä¹˜ç§¯å’Œ]

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums: return 
        res = nums[0]
        maxdp = nums[0]
        mindp = nums[0]
        for num in nums[1:]:
            maxdp, mindp = max(maxdp * num, mindp * num, num), min(maxdp * num, mindp * num, num)
            res = max(res, maxdp)
        return res

# ä¹‹æ‰€æœ‰å­˜ [æœ€å°ä¹˜ç§¯å’Œ]ï¼Œæ˜¯å› ä¸º [æœ€å°ä¹˜ç§¯å’Œ] å¦‚æœæ˜¯è´Ÿæ•°æœ‰å¯èƒ½é‡åˆ°è´Ÿæ•°ï¼Œ

# ç›¸ä¹˜åç»“æœæ›´å¤§ Python
```

```scala

object Solution2-1 {
    def maxProduct(nums: Array[Int]): Int = {
        
        val (_, _, ans) = (1 until nums.length).foldLeft((nums.head, nums.head, nums.head)){
            case ((min, max, ans), idx) => 
                val a = nums(idx) * min 
                val b = nums(idx) * max
                val newMin = a min b min nums(idx)
                val newMax = a max b max nums(idx)
                (newMin, newMax, ans max newMax)
        }
        ans
    }
}


object Solution0 {
  def maxProduct(nums: Array[Int]): Int = {
    val dp = Array.ofDim[Int](nums.length, 2) // record each position n's max product( from 0 to n)
    var result = nums(0)
    dp(0)(0) = nums(0)
    dp(0)(1) = nums(0)

    /* 0 for min, 1 for max */
    for (i <- 1 until nums.length) {
      val a = dp(i - 1)(0) * nums(i)
      val b = dp(i - 1)(1) * nums(i)
      dp(i)(0) = nums(i) min a min b // record min
      dp(i)(1) = nums(i) max a max b // record max
      result = result max dp(i)(1)
    }
    result
  }
}


/**
* optimize above one
* don't copy subArray during transmit parameters
* time complexityï¼š O(N^2)
*/
object Solution {
  def maxProduct(nums: Array[Int]): Int = {
    (1 to nums.length).map(n =>  _maxProduct(nums(n - 1), n, nums)).max
  }
  def _maxProduct(curr: Int, idx: Int, nums: Array[Int]): Int = {
      if(idx >= nums.length) return curr   
      curr max  _maxProduct( curr * nums(idx), idx + 1, nums)
  }

}




object Solution {
    def maxProduct(nums: Array[Int]): Int = {
        if (nums == null || nums.size == 0) {
            return 0;
        }
        val list: List[Int] = nums.toList
        val head: Int = list.head
        val tail: List[Int] = list.tail
        _MaxProduct(tail, head, head, head)
    }
    
    def _MaxProduct(nums: List[Int], min: Int, max: Int, result: Int): Int = nums match {
        case Nil => result
        case x :: xs => {
            val cur_min = math.min(x, math.min(x * max, x * min))
            val cur_max = math.max(x, math.max(x * max, x * min))
            _MaxProduct(xs, cur_min, cur_max, math.max(cur_max, result))
        }
    }
}
```

###  1.55. <a name='-1'></a>153-å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1bT4y1w7yK?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1yK411L7rp?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMin(self, nums):
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == nums[right]:    # æ­¤æ—¶ left å’Œ right ç›¸ç­‰ï¼Œç›´æ¥è¿”å›
                return nums[right]
            elif nums[mid] < nums[right]:   # æ¯”å³ç•Œå°ï¼Œnums[mid] å¯èƒ½æ˜¯æœ€å°å€¼ï¼Œä¸èƒ½å»æ‰
                right = mid
            else:                           # æ¯”å³ç•Œå¤§ï¼Œnums[mid] è‚¯å®šä¸ä¼šæ˜¯æœ€å°å€¼     
                left = mid + 1

        return 1000000    # è¿™é‡Œå†™ä»€ä¹ˆéƒ½æ— æ‰€è°“ï¼Œæ­£å¸¸æƒ…å†µä¸‹ä¸ä¼šèµ°åˆ°è¿™é‡Œçš„

# äºŒåˆ†æ³•

class Solution:
    def findMin(self, nums):
        l,r= 0,len(nums) -1
        while l < r:
            if nums[l] < nums[r]:
                return nums[l]
            mid = (l + r) // 2
            if nums[mid] >= nums[r]:
                l = mid +1
            else:  
                r = mid
        return nums[l]
```

```scala

/**
* my first commitment binary search
*/
object Solution1 {
    def findMin(nums: Array[Int]): Int = {
        search(nums, 0, nums.length - 1)
    }
  
    def search(nums: Array[Int], left: Int, right: Int): Int = {
      if (left > right) return nums(left)
      val mid = left + (right - left) / 2
      val leftAns = if (nums(mid) >= nums(left)){ // left part in order
        nums(left)
      } else {
        search(nums, left, mid - 1)
      }
      
      val rightAns = if (nums(mid) <= nums(right)) { // right part in order
        nums(mid)
      } else {
        search(nums, mid + 1, right)
      }
      
      leftAns min rightAns
    }
}
``` 

###  1.56. <a name='FindMinimuminRotatedSortedArr'></a>154 Find Minimum in Rotated Sorted Arr

[å°æ˜](https://www.bilibili.com/video/BV1ik4y1B7de?spm_id_from=333.999.0.0)

###  1.57. <a name='MinStack'></a>155-ã€æ„é€ ğŸ°ã€‘Min Stack

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1H74118748?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1YK4y1r77W?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ja4y1Y7vY?spm_id_from=333.999.0.0)

   
å…³é”®åœ¨äº  def getMi

```py
æˆ‘è®¤ä¸ºè¿™ä¸ªè§£æ³•æ˜¯é”™è¯¯çš„ï¼š
class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = [math.inf]

    def push(self, x: int) -> None:
        self.stack.append(x)
        self.minStack.append(min(x, self.minStack[-1]))
        # å¯¼è‡´ min è¢« append å¤šæ¬¡

    def pop(self) -> None:
        self.stack.pop()
        self.minStack.pop()
        # è¿™æ ·ï¼Œå½“ min è¢« pop æ‰äº†ï¼ŒminStack ä»ç„¶å­˜æœ‰ min

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]




class MinStack:

    def __init__(self):
        # å¦å¤–ç”¨ä¸€ä¸ªstackï¼Œæ ˆé¡¶è¡¨ç¤ºåŸæ ˆé‡Œæ‰€æœ‰å€¼çš„æœ€å°å€¼
        self.minStack = []
        self.stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if self.minStack == [] or self.minStack[-1] >= val:
            self.minStack.append(val)
            
    è¿™æ ·é€Ÿåº¦æ›´å¿«ä¸€ç‚¹ç‚¹ï¼š
    def push(self, val: int) -> None:
        self.stack.append(val)
        if self.minStack == []:
            self.minStack.append(val)
            return
        if self.minStack[-1] >= val:
            self.minStack.append(val)

    def pop(self) -> None:
        if self.stack[-1] == self.minStack[-1]:
            self.minStack.pop()
        return self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]


    def getMin(self) -> int:
        return self.minStack[-1]        
```

```py
é¢è¯•çš„æ—¶å€™è¢«é—®åˆ°ä¸èƒ½ç”¨é¢å¤–ç©ºé—´ï¼Œå°±å»ç½‘ä¸Šæœäº†ä¸‹ä¸ç”¨é¢å¤–ç©ºé—´çš„åšæ³•ã€‚æ€è·¯æ˜¯æ ˆé‡Œä¿å­˜å·®å€¼ã€‚

class MinStack:
    def __init__(self):

        self.diffstack = []
        self.mins = -1

    def push(self, x: int) -> None:
        if not self.diffstack:
            self.diffstack.append(0)
            self.mins = x
        else:
            diff = x-self.mins
            self.diffstack.append(diff)
            self.mins = self.mins if diff > 0 else x
            # mins æ˜¯ä¼šå˜åŒ–çš„

    def pop(self) -> None:
        if self.diffstack:
            diff = self.diffstack.pop()
            if diff < 0: 
                # [3,2,1,4] [0,-1,-1, 3]
                # mins = 3, 2, 1, 1
                top = self.mins # ç¬¬ä¸€æ­¥ï¼šé¡ºåºä¸èƒ½é”™
                self.mins = self.mins - diff # ç¬¬äºŒæ­¥ï¼šå¦‚æœ diff < 0, é‚£å°±éœ€è¦è¿˜åŸ self.mins
            else:     # å¦‚æœ diff ä¸€ç›´éƒ½ > 0, é‚£å°±éå¸¸å¥½
                top = self.mins + diff
            return top

    def top(self) -> int:
        return self.mins if self.diffstack[-1] < 0 else self.diffstack[-1] + self.mins

    def getMin(self) -> int:
        return self.mins if self.diffstack else -1
```


```scala
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var min = Int.MaxValue

    def push(x: Int) {
        stack = stack :+ x
        if(x < min){
            min = x
        }
    }

    def pop() {
        stack = stack.init
        min = Int.MaxValue
        stack.map(x => {
            if(x < min) min = x
        })
    }

    def top(): Int = {
        stack.last
    }

    def getMin(): Int = {
        min
    }

}

//æ›¿ä»£è§£å†³æ–¹æ¡ˆï¼šæ›´å¿«
//è¿™é‡Œæˆ‘ä»¬å°†å…ƒç´ æ·»åŠ åˆ°åˆ—è¡¨ä¸­è€Œä¸æ˜¯é™„åŠ 
//è¯·æ³¨æ„ï¼Œç”±äºListå®é™…ä¸Šæ˜¯ä¸€ä¸ªLinkedListï¼Œå› æ­¤å¤„ç†åˆ—è¡¨çš„â€œå¤´éƒ¨â€è¦å®¹æ˜“å¾—å¤š
//è¿˜æœ‰å¦ä¸€ä¸ªåˆ—è¡¨æ¥ç»´æŠ¤åˆ—è¡¨çš„æœ€å°å…ƒç´ 
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var mins = List.empty[Int]

    def push(x: Int) {
        //å¦‚æœæˆ‘ä»¬å°†ç¬¬äºŒä¸ªæ¡ä»¶è®¾ä¸º x < mins.headï¼Œåˆ™æ­¤è¡Œå¤±è´¥
        //with NoSuchElementException: ç©ºåˆ—è¡¨çš„å¤´éƒ¨
        //ä¸ºä»€ä¹ˆï¼Ÿï¼Ÿï¼Ÿ
        if(mins.isEmpty || mins.head >= x) mins = x +: mins
        stack = x +: stack
    }

    def pop() {
        if(mins.head == stack.head) mins = mins.tail
        stack = stack.tail
    }

    def top(): Int = {
        stack.head
    }

    def getMin(): Int = {
        mins.head
    }

}

```

###  1.58. <a name='IntersectionofTwoLinkedLists'></a>160-Intersection of Two Linked Lists

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1n741187X6?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1eb411H7uq?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV18K4y1J7wx?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1np4y1y789?spm_id_from=333.999.0.0)

```py
## 1. å“ˆå¸Œè¡¨

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        listA = set()
        while headA:
            listA.add(headA)
            headA = headA.next
        while headB:
            if headB in listA:
                return headB
            headB = headB.next
        return None

# > æ—¶é—´å¤æ‚åº¦ $O(M+N)$, ç©ºé—´å¤æ‚åº¦ $O(M)$

## 2. åŒæŒ‡é’ˆ

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        pa,pb = headA, headB
        while pa != pb:
            pa = pa.next if pa else headB
            pb = pb.next if pb else headA
        return pa

# > æ—¶é—´å¤æ‚åº¦ $O(M+N)$, ç©ºé—´å¤æ‚åº¦ $O(1)$
```

```py

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        lengthA,lengthB = 0,0
        curA,curB = headA,headB
        while(curA!=None): #æ±‚é“¾è¡¨Açš„é•¿åº¦
            curA = curA.next
            lengthA +=1
        
        while(curB!=None): #æ±‚é“¾è¡¨Bçš„é•¿åº¦
            curB = curB.next
            lengthB +=1
        
        curA, curB = headA, headB

        if lengthB>lengthA: #è®©curAä¸ºæœ€é•¿é“¾è¡¨çš„å¤´ï¼ŒlenAä¸ºå…¶é•¿åº¦
            lengthA, lengthB = lengthB, lengthA
            curA, curB = curB, curA

        gap = lengthA - lengthB #æ±‚é•¿åº¦å·®
        while(gap!=0): 
            curA = curA.next #è®©curAå’ŒcurBåœ¨åŒä¸€èµ·ç‚¹ä¸Š
            gap -= 1
        
        while(curA!=None):
            if curA == curB:
                return curA
            else:
                curA = curA.next
                curB = curB.next
        return None
```



```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getIntersectionNode(headA: ListNode, headB: ListNode): ListNode = {
        var ha = headA
        var hb = headB
        
        while(ha != hb){
            if(ha == null){
                ha = headB
            }else{
                ha = ha.next
            }
            
            if(hb == null){
                hb = headA
            }else{
                hb = hb.next
            }
        }
        
        ha
    }
}

```

###  1.59. <a name='FindPeakElement'></a>162. Find Peak Element

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Rb411n7dT?spm_id_from=333.999.0.0)

```py
# åŠªåŠ›æ¥å—äº†ä¸€ä¸‹ã€‚å°±æ˜¯æƒ³è±¡ä¸€ä¸‹å³°é¡¶åœ¨ä¸­é—´ï¼Œé‚£ä¹ˆå·¦å³ä¸¤ä¾§éƒ½æ˜¯æœ‰åºçš„ï¼Œå¯æ ¹æ®midå’Œmid+1çš„å€¼åˆ¤æ–­å½“å‰æ˜¯åœ¨å“ªä¸€ä¾§ï¼Œç„¶åæœ€åå®šä½åˆ°å³°å€¼
class Solution(object):
    def findPeakElement(self, nums):
        l = 0 
        r = len(nums) - 1 

        while l <= r:
        	mid = (l + r) >> 1

        	if l == r : return l # å…³é”®åœ¨äºè¿™é‡Œ

        	if nums[mid] < nums[mid+1]: # å…³é”®åœ¨äºè¿™é‡Œï¼ŒèƒŒä¸€èƒŒå§
        		l = mid + 1
        	else:
        		r = mid
```

###  1.60. <a name='CompareVersionNumbers'></a>165. Compare Version Numbers

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV19K4y1C7L3?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Pk4y117dF?spm_id_from=333.999.0.0)

```py
ç®€æ´ç‰ˆ

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        for x, y in zip_longest(version1.split('.'), version2.split('.'), fillvalue='0'):
            a, b = int(x), int(y)
            if a != b: return 1 if a > b else -1
        return 0 

```

```py
python ç²¾ç®€ç‰ˆ

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = version1.split(".")
        v2 = version2.split(".")

        while v1 or v2:
            x = int(v1.pop(0)) if v1 else 0
            y = int(v2.pop(0)) if v2 else 0

            if x>y:
                return 1
            elif x<y:
                return -1
        return 0
```

###  1.61. <a name='FractiontoRecurringDecimal'></a>166. Fraction to Recurring Decimal

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7PE?spm_id_from=333.999.0.0)

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # ----------æƒ…å†µä¸€ï¼šæ²¡æœ‰ä½™æ•°----------
        if numerator % denominator == 0:
            return str(numerator // denominator)
        # ----------æƒ…å†µä¸€ï¼šæ²¡æœ‰ä½™æ•°----------


        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        s = []

        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        if (numerator < 0) != (denominator < 0):
            s.append('-')
        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        # ----------------å¾—åˆ°è´Ÿæ•°----------------


        # æ•´æ•°éƒ¨åˆ†
        numerator = abs(numerator)
        denominator = abs(denominator)
        integerPart = numerator // denominator
        s.append(str(integerPart))
        s.append('.')

        # å°æ•°éƒ¨åˆ†
        indexMap = {}
        remainder = numerator % denominator
        while remainder and remainder not in indexMap:
            indexMap[remainder] = len(s) 

            # è¿™é‡Œéœ€è¦ä¸€ä¸ªè®¡æ•°å™¨ï¼Œsçš„é•¿åº¦é€’å¢ï¼Œæ‰€ä»¥ç”¨len(s)
            # è§£æ³•äºŒä¸­ï¼š
            # i = 0
            # i += 1
            # ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚
            # len(s) å¯ä»¥ç›´æ¥æŒ‡å‘ insertIndex-æ’å…¥ä½ç½®

            print("ä½™æ•°remainder: ",indexMap.keys())
            remainder *= 10
            s.append(str(remainder // denominator))
            remainder %= denominator
        if remainder:  # æœ‰å¾ªç¯èŠ‚
            insertIndex = indexMap[remainder]
            s.insert(insertIndex, '(') #å·¦ä¾§æ’å…¥
            s.append(')')

        return ''.join(s)
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
```

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        dic = {}
        res = []

        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        if numerator*denominator<0:
            sign = "-"
        else:
            sign = ""
        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        # ----------------å¾—åˆ°è´Ÿæ•°----------------

        numerator = abs(numerator)
        denominator = abs(denominator)
        intPart,res = divmod(numerator, denominator)


        # ----------æƒ…å†µä¸€ï¼šæ²¡æœ‰ä½™æ•°----------
        if res==0:
            return sign + str(intPart)
        # ----------æƒ…å†µä¸€ï¼šæ²¡æœ‰ä½™æ•°----------
        
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        res.append(str(intPart))
        res.append(".")

        dic[res]= len(res) # æ˜¯ 2
        while res!=0:
            intPart,res = divmod(10*res,denominator)
            res.append(str(intPart))
            # å¦‚æœä½™æ•°å‡ºç°åœ¨å­—å…¸ä¸­ï¼ŒåŠ ä¸Šï¼ˆï¼‰å¹¶è¿”å›
            if res in dic:
                res.insert(dic[res],"(") #å·¦ä¾§æ’å…¥
                res.append(")")     #å³ä¾§æ’å…¥
                return sign + "".join(res)
            # ç»§ç»­è®°å½•ä½™æ•°å’Œ(ç´¢å¼•ä½ç½®
            
            dic[res] = len(res) # i+=1
        # å¦‚æœä½™æ•°ä¸º0
        return sign + "".join(res) 
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # å¤„ç†æ•´æ•°éƒ¨åˆ†
        ans = ""

        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        if numerator * denominator < 0:
            ans += "-"
        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        # ----------------å¾—åˆ°è´Ÿæ•°----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart, res = divmod(numerator, denominator)
        # ans += f"{q}"
        ans += str(intPart)


        # ----------æƒ…å†µä¸€ï¼šæ²¡æœ‰ä½™æ•°----------
        if 0 == res:
            return ans
        # ----------æƒ…å†µä¸€ï¼šæ²¡æœ‰ä½™æ•°----------

        
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        ans += '.'
        # å°æ•°éƒ¨åˆ†ï¼šé™¤æ³•å‘ç°å¾ªç¯èŠ‚
        index = len(ans)  # å°æ•°ç‚¹åä¸€ä¸ªä½ç½®
        numerator = res * 10  # è¢«é™¤æ•°å¢åŠ åå€
        dic = {numerator: index}
        while True:
            intPart, res = divmod(numerator, denominator)
            ans += str(intPart)
            if res == 0:
                break
            numerator = res * 10
            if numerator in dic:  # å‘ç°å¾ªç¯èŠ‚
                return ans[:dic[numerator]] + f"({ans[dic[numerator]:]})" # ç›´æ¥åŠ æ‹¬å·ï¼ˆï¼‰
            dic[numerator] = index + 1  # æ–°è¢«é™¤æ•°ä½ç½®
            index += 1
        return ans
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """

        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        sign = "" if numerator * denominator >= 0 else "-"
        # ----------------å¾—åˆ°è´Ÿæ•°----------------
        # ----------------å¾—åˆ°è´Ÿæ•°----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart = numerator // denominator

        # ----------æƒ…å†µä¸€ï¼šæ²¡æœ‰ä½™æ•°----------
        if numerator % denominator == 0: return sign + str(intPart)
        # ----------æƒ…å†µä¸€ï¼šæ²¡æœ‰ä½™æ•°----------

        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        res, dic, index = numerator % denominator, {}, 3
        ans = [sign, str(intPart), "."]
        while res:
            if res not in dic:
                dic[res] = index
            else:
                ans.insert(dic[res], "(")
                ans.append(")")
                break
            res *= 10
            ans.append(str(res // denominator))
            res %= denominator
            index += 1
        return "".join(ans)
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
        # -----------æƒ…å†µäºŒï¼šæœ‰ä½™æ•°-----------
```

###  1.62. <a name='TwoSumII-Inputarrayissorted'></a>167-Two Sum II - Input array is sorted

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV167411h7ou?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7id?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1VZ4y1M7eu?spm_id_from=333.999.0.0)

```py
python 3 æœ‰ç‚¹äºŒåˆ†æ³•çš„å‘³é“

    # åŒæŒ‡é’ˆ
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r =0, n-1 
        while l <= r:
            if numbers[l] + numbers[r] == target:
                return [l+1, r+1]
            elif numbers[l] + numbers[r] < target:
                l +=1
            else:
                r -=1
        return [-1, -1]

    # hasnè¡¨ï¼Œåˆ©ç”¨hashè¡¨è®°å½•æ‰€æœ‰çš„å·®å€¼
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        visited = dict()
        for index, num in enumerate(numbers):
            if num in visited:
                return [visited[num]+1, index+1]
            visited[target - num] = index
```

###  1.63. <a name='ExcelSheetColumnTitle'></a>168-Excel Sheet Column Title

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Qj411f7FY?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H777?spm_id_from=333.999.0.0)

```py
## Açš„asciiç ä¸º65
# åˆæƒ³äº†å¥½ä¹…æ‰çŸ¥é“åœ¨å“ªé‡Œå‡ä¸€ã€‚ã€‚
class Solution:
    def convertToTitle(self, n: int) -> str:
        res = ''
        while(n):
            n -= 1
            res = chr(n%26+65) + res
            n = n//26
        return res



class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        res = ""

        while columnNumber-1 >= 0:
            columnNumber -= 1
            res += chr(columnNumber % 26 + ord('A'))
            columnNumber //= 26
        return res[::-1]

class Solution(object):
    def convertToTitle(self, columnNumber):
        res = ''
        while columnNumber:
            columnNumber -= 1
            res = chr(columnNumber % 26 + 65) + res
            columnNumber = columnNumber // 26 
        return res
```

###  1.64. <a name='MajorityElement'></a>169. ã€ä½è¿ç®—ğŸ˜œã€‘Majority Element

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1hb411c7bF?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7pW?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ff4y1U7Vn?spm_id_from=333.999.0.0)


![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.45eeyfyac6g0.webp)

```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        res = 0
        k = len(nums)//2
        for i in range(32):
            ones = 0
            for n in nums:
                ones += (n >> i) & 1
                if ones > k:
                    if i == 31:
                        res -= 1 << i
                    else:
                        res |= 1 << i
                    break
        return res
```

```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        return sorted(nums)[len(nums) // 2]

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        return nums[len(nums) // 2]


class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)

# æŠ•ç¥¨ç­–ç•¥ï¼ŒåŠæ•°ä»¥ä¸Šè·èƒœ

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = None

        for vot in nums:
            if count == 0:
                candidate = vot
            count += (1 if vot == candidate else -1)

        return candidate
```

```scala
/**
* HashMap
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution2 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.groupBy(identity).mapValues(_.length).maxBy(_._2)._1  
    }
}


/**
* sorting array and pick middle element
* time complexity O(NlogN)
*/

object Solution3 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.sorted(Ordering.Int)(nums.length / 2)
    }
}
```


```scala

/**
* chosen solution
* æŠ•ç¥¨æµ‹é‡
* Boyer-Moore Voting Algorithm
* time complexity N(N)
* space complexity O(1)
*/
object Solution
    def majorityElement(nums: Array[Int]): Int = {
      var counter = 0
      var candidate = nums(0)
      for (idx <- 1 until nums.length) {
        val vot = nums(idx)
        if(candidate == vot)
          counter += 1
        else {
          if(counter == 0)
            candidate = vot
          else
            counter -= 1
        }
      }
      candidate
    }
}


object Solution1 {
  def majorityElement(nums: Array[Int]): Int = {
    var candidate = nums(0)
    var counter = 0
    candidate.foreach { vot =>
      if (candidate == vot) {
        counter += 1
      } else {
        counter -= 1
        if (counter == 0) {
          candidate = vot
          counter += 1
        }
      }
    }
    candidate
  }
}


//Alternate solution O(n) but NO EXTRA SPACE
object Solution {
    def majorityElement(nums: Array[Int]): Int = {     
        var candidate = nums.head
        var count = 0
        nums.foreach(vot => {
            if(count == 0) { 
                candidate = vot
                count = 0
            }
            if(vot == candidate) count+=1;
            else count-=1;
        })
        
        candidate
    }
}

```

###  1.65. <a name='ExcelSheetColumnNumber'></a>171. Excel Sheet Column Number

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7nT?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1h541187Sv?spm_id_from=333.999.0.0)

```py
# python ä»å·¦åˆ°å³éå†
        #26è¿›åˆ¶è½¬10è¿›åˆ¶
class Solution:
def titleToNumber(self, columnTitle: str) -> int:
        res = 0
        for char in columnTitle:
            res *= 26
            res += ord(char) - ord('A') + 1 
        return res
```


```scala
//Alternate solution
object Solution {
    def titleToNumber(s: String): Int = 
        s.foldLeft(0)((acc, ch) => acc * 26 + (ch - 'A' + 1))
}

```

###  1.66. <a name='FactorialTrailingZeroes'></a>172-Factorial Trailing Zeroes

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1hE411n7TM?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7tS?spm_id_from=333.999.0.0)

```py
class Solution:
    def trailingZeroes(self, n: int) -> int:
        # Calculate n!
        factorial = 1
        for i in range(2, n + 1):
            factorial *= i
        # Count how many 0's are on the end.
        res = 0
        while factorial % 10 == 0:
            res += 1
            factorial //= 10
            
        return res



class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n > 0:
            n //= 5
            ans += n
        return ans


class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n >= 5:
            ans += n//5
            n = n//5
        return ans
```

```scala
object Solution {
    def trailingZeroes(n: Int): Int = {
        var count5 = 0
        var count2 = 0
        
        var temp = n
        while(temp>=5){
            count5 += temp/5
            temp = temp/5
        }
        
        temp = n
        while(temp>=2){
            count2 += temp/2
            temp = temp/2
        }
        
        if(count5 < count2) count5 else count2
    }
}

```

###  1.67. <a name='BinarySearchTreeIterator'></a>173 ã€æ„é€ ğŸ°ã€‘Binary Search Tree Iterator

[å°æ˜](https://www.bilibili.com/video/BV1qK41137h1?spm_id_from=333.999.0.0)

```py
# next() å’Œ hasNext() æ“ä½œå‡æ‘Šæ—¶é—´å¤æ‚åº¦ä¸º O(1) ï¼Œå¹¶ä½¿ç”¨ O(h) å†…å­˜ã€‚å…¶ä¸­ h æ˜¯æ ‘çš„é«˜åº¦ã€‚

class BSTIterator(object):

    def __init__(self, root):
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def next(self):
        tmp = self.stack.pop()
        res = tmp.val

        tmp = tmp.right
        while tmp:
            self.stack.append(tmp)
            tmp = tmp.left
        return res

    def hasNext(self):
        # ç›´æ¥å†™ä¹Ÿå¯ä»¥ï¼šreturn self.stack 
        return self.stack != []



class BSTIterator(object):
    def __init__(self, root):
        self.stack = []
        self.pushAllLeft(root)
        

    def hasNext(self):
        return self.stack != []
        

    def next(self):
        tmp = self.stack.pop()
        self.pushAllLeft(tmp.right)
        return tmp.val
            
    def pushAllLeft(self, node):
        while node:
            self.stack.append(node)
            node = node.left
```

é€’å½’è§£æ³•ä¸ç¬¦åˆé¢˜ç›®ï¼šä¸èƒ½ç”¨é€’å½’ åº”è¯¥ç”¨è¿­ä»£

###  1.68. <a name='DungeonGame'></a>174 Dungeon Game

[å°æ˜](https://www.bilibili.com/video/BV1TK411W7T1?spm_id_from=333.999.0.0)

###  1.69. <a name='LargestNumber'></a>179 Largest Number

[å°æ˜](https://www.bilibili.com/video/BV1mV411m7aN?spm_id_from=333.999.0.0)

```py
from functools import cmp_to_key
class Solution(object):
    def largestNumber(self, nums):
        # æ¯”è¾ƒå‡½æ•°
        def compare(a, b):
            return int(b + a) - int(a + b)
        nums = sorted([str(x) for x in nums], key=cmp_to_key(compare))
        return str(int(''.join(nums)))
```

```py
class Solution:
    def largestNumber(self, nums):
        # ç¬¬ä¸€æ­¥ï¼šå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼ŒæŠŠæœ€å¤§çš„æ”¾å·¦è¾¹
        # ç¬¬äºŒæ­¥ï¼šæ’åº
        # ç¬¬ä¸‰æ­¥ï¼šè¿”å›ç»“æœ
        def compare(x, y): return int(y+x) - int(x+y)
        nums = sorted(map(str, nums), key=cmp_to_key(compare))
        return "0" if nums[0]=="0" else "".join(nums)
```

```py
# å¤§å°çš„æ¯”è¾ƒä¸æ˜¯å¸¸è§„çš„å­—ç¬¦ä¸²æ¯”è¾ƒ
# æ­£å¸¸æ¥è¯´'30' > '3' ä½†æ˜¯'303' < '330'
# éœ€è¦è‡ªå·±å®šä¹‰æ’åºè§„åˆ™
import functools
class Solution:
    def largestNumber(self, nums):

        res = []
        for i in nums:
            res.append(str(i))

        def cmp(a,b):
            return 1 if (a+b) < (b+a) else -1
        res.sort(key=functools.cmp_to_key(cmp))
        return str(int(''.join(res)))
```

```py
class Solution:
    def largestNumber(self, nums):
        nums = sorted([str(x) for x in nums],reverse=True)
        for i in range(len(nums)-1):
            for j in range(i,len(nums)):
                if str(nums[i]) + str(nums[j]) < str(nums[j]) + str(nums[i]):
                    nums[i],nums[j] = nums[j],nums[i]
        return str(int(''.join(nums)))
```

###  1.70. <a name='ReverseWordsinaStringII'></a>186. Reverse Words in a String II 

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1GV411Z7fo?spm_id_from=333.999.0.0)

###  1.71. <a name='RepeatedDNASequences'></a>187. â˜…ã€ä½è¿ç®—ğŸ˜œã€‘ã€æ»‘åŠ¨çª—å£ï¼Œdicã€‘Repeated DNA Sequences

#### ç±»ä¼¼567ï¼Œä½†è¿™é‡Œç”¨äº†dicè¿›è¡Œæ¯”è¾ƒ

[å°æ˜](https://www.bilibili.com/video/BV1mp4y1r7v5?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7cqchvpxojw0.webp)

æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N æ˜¯å­—ç¬¦ä¸² s çš„é•¿åº¦ã€‚

ç©ºé—´å¤æ‚åº¦ï¼šO(N)ã€‚

```py


class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        if len(s) < 11: return []

        bins = { "A":  0,
              "C" : 1,
              "G":  2,
              "T":  3 }

        ans = []
        cntDIC = defaultdict(int) # record the appearance time

        x = 0
        for i in range(10): # è½¬æ¢æˆäºŒè¿›åˆ¶å­˜å‚¨èµ·æ¥å¯ä»¥å‡å°ç©ºé—´å¤æ‚åº¦
            x += bins[s[i]] << (i * 2)
        cntDIC[x] = 1
        
        for i in range(10, len(s)):
            x >>= 2  # æ»‘åŠ¨çª—å£
            x += bins[s[i]] << 18 # æ»‘åŠ¨çª—å£

            cntDIC[x] = cntDIC[x] + 1
            if cntDIC[x] == 2:
                ans.append(s[i - 9:i + 1]) # find the result

        return ans

```

###  1.72. <a name='BestTimetoBuyandSellStockIV'></a>188 ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Best Time to Buy and Sell Stock IV

[å°æ˜](https://www.bilibili.com/video/BV1f54y1k7cX?spm_id_from=333.999.0.0)

```py
# èƒŒä¸€èƒŒ
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0

        buy = [prices[0]] * (k+1)
        sell = [0] * (k+1)
        for price in prices:
            for time in range(1,k+1): 
                # å¯¹äºæ¯ä¸€ä¸ªæ–°æ¥çš„ä»·æ ¼ï¼Œä¾ time æ¯”è¾ƒ and æ›´æ–°
                buy[time-1] = min(buy[time-1],  price - sell[time-1])
                sell[time]  = max(sell[time], price - buy[time-1])
                # print('ä»·æ ¼:',price,'æ¬¡æ•°:',time,'buy:',buy)
                # print('ä»·æ ¼:',price,'æ¬¡æ•°:',time,'sell:',sell)
                
        return sell[k]


if __name__ == "__main__":   
	s = Solution()
	print(s.maxProfit(k = 2, prices = [3,2,6,5,0,3,-1,3]))

ä»·æ ¼: 3 æ¬¡æ•°: 1 buy: [3, 3, '*']
ä»·æ ¼: 3 æ¬¡æ•°: 1 sell: [0, 0, 0]
ä»·æ ¼: 3 æ¬¡æ•°: 2 buy: [3, 3, '*']
ä»·æ ¼: 3 æ¬¡æ•°: 2 sell: [0, 0, 0]
--------------------
ä»·æ ¼: 2 æ¬¡æ•°: 1 buy: [2, 3, '*']
ä»·æ ¼: 2 æ¬¡æ•°: 1 sell: [0, 0, 0]
ä»·æ ¼: 2 æ¬¡æ•°: 2 buy: [2, 2, '*']
ä»·æ ¼: 2 æ¬¡æ•°: 2 sell: [0, 0, 0]
--------------------
ä»·æ ¼: 6 æ¬¡æ•°: 1 buy: [2, 2, '*']
ä»·æ ¼: 6 æ¬¡æ•°: 1 sell: [0, 4, 0]
ä»·æ ¼: 6 æ¬¡æ•°: 2 buy: [2, 2, '*']
ä»·æ ¼: 6 æ¬¡æ•°: 2 sell: [0, 4, 4]
--------------------
ä»·æ ¼: 5 æ¬¡æ•°: 1 buy: [2, 2, '*']
ä»·æ ¼: 5 æ¬¡æ•°: 1 sell: [0, 4, 4]
ä»·æ ¼: 5 æ¬¡æ•°: 2 buy: [2, 1, '*']
ä»·æ ¼: 5 æ¬¡æ•°: 2 sell: [0, 4, 4]
--------------------
ä»·æ ¼: 0 æ¬¡æ•°: 1 buy: [0, 1, '*']
ä»·æ ¼: 0 æ¬¡æ•°: 1 sell: [0, 4, 4]
ä»·æ ¼: 0 æ¬¡æ•°: 2 buy: [0, -4, '*']
ä»·æ ¼: 0 æ¬¡æ•°: 2 sell: [0, 4, 4]
--------------------
ä»·æ ¼: 3 æ¬¡æ•°: 1 buy: [0, -4, '*']
ä»·æ ¼: 3 æ¬¡æ•°: 1 sell: [0, 4, 4]
ä»·æ ¼: 3 æ¬¡æ•°: 2 buy: [0, -4, '*']
ä»·æ ¼: 3 æ¬¡æ•°: 2 sell: [0, 4, 7]
--------------------
ä»·æ ¼: -1 æ¬¡æ•°: 1 buy: [-1, -4, '*']
ä»·æ ¼: -1 æ¬¡æ•°: 1 sell: [0, 4, 7]
ä»·æ ¼: -1 æ¬¡æ•°: 2 buy: [-1, -5, '*']
ä»·æ ¼: -1 æ¬¡æ•°: 2 sell: [0, 4, 7]
--------------------
ä»·æ ¼: 3 æ¬¡æ•°: 1 buy: [-1, -5, '*']
ä»·æ ¼: 3 æ¬¡æ•°: 1 sell: [0, 4, 7]
ä»·æ ¼: 3 æ¬¡æ•°: 2 buy: [-1, -5, '*']
ä»·æ ¼: 3 æ¬¡æ•°: 2 sell: [0, 4, 8]
--------------------
8


```




```scala
/**
* chosen solution
* dynamic programming
* memo 
*    1: using an 3-dim array to record previous state
*     dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's restrictions
*  space complexity: O(K),  worst case: O(N)N
*/ 
object Solution0 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
/**
* my first commitment
* dynamic programming
* memo 
*    1: using an 3-dim array to record all previous state
*         dp[state index][k times transaction][buy or sell]
*     dp definition: dp[i][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's constraint
*/
object Solution1 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum
    val profits = Array.ofDim[Int](prices.length, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val ii = (i + prices.length - 1) % prices.length
      profits(i)(j)(1) = profits(ii)(j)(1)  max ( profits(ii)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(i)(j)(0) = profits(ii)(j)(0)  max ( profits(ii)(j - 1)(1) - prices(i)) // buy
      else
        profits(i)(j)(0) = profits(ii)(j)(0)  max  - prices(i) // buy
    }

    profits(prices.length - 1).map(_.max).max
  }
}

/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/

object Solution1-2 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum


    val profits = Array.ofDim[Int](2, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val currentI = (i + 1) % 2
      val preciousI = i % 2
      profits(currentI)(j)(1) = profits(preciousI)(j)(1)  max ( profits(preciousI)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max ( profits(preciousI)(j - 1)(1) - prices(i)) // buy
      else
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max  - prices(i) // buy
    }
    profits(prices.length % 2).map(_.max).max // prices.length % 2: decide the newest status index
  }

  private def debugProfits(profits: Array[Array[Array[Int]]]): Unit = {
        profits.zipWithIndex.foreach{
          case (p, i) =>
            println(s"status: $i")
            p.zipWithIndex.foreach{
            case (pp, j) =>
                println(s"transaction $j: hold: ${pp(0)}, sell: ${pp(1)}")
          }
            println(" ")
        }
  }
}
/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/
object Solution1-3 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
```

###  1.73. <a name='RotateArray'></a>189. Rotate Array 

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7Yy?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1N541177Bk?spm_id_from=333.999.0.0)

```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        r = k % len(nums)
        if r:
            nums[:] = nums[::-1]
            nums[:r] = nums[:r][::-1]
            nums[r:] = nums[r:][::-1]

class Solution:
    def rotate( nums, k):
        n = len(nums)
        k = k % n
        for _ in range(k):
            nums.insert(0,nums.pop())

class Solution:
    def rotate(self, A: List[int], k: int) -> None:
        def reverse(i, j):
            while i < j:
                A[i], A[j] = A[j], A[i]
                i += 1
                j -= 1
        n = len(A)
        k %= n
        reverse(0, n - 1)
        reverse(0, k - 1)
        reverse(k, n - 1)
```


```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        nums[: ] = nums[-k % len(nums): ] + nums[: -k % len(nums)]

class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        nums[: ] = (nums[i] for i in range(-(k % len(nums)), len(nums) - k % len(nums)))
```

###  1.74. <a name='ReverseBits'></a>190. ã€ä½è¿ç®—ğŸ˜œã€‘Reverse Bits

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1NJ411k7VP?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1qv411i7Wg?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseBits(self, n: int) -> int:
        ret = 0
        for i in range(32):
            ret = (ret << 1) + (n & 1)
            n >>= 1
        return ret

# æ¯æ¬¡åªå¯¹æœ€ä½ä½è¿›è¡Œæ“ä½œï¼Œç†è®ºä¸Šæ•ˆç‡é«˜äºå¯¹ 31 çš„å¾ªç¯


 10001111011110101
 b & (-b) = 1
 b & (-b) = 100
 b & (-b) = 10000

è¿™ä¸ªè§£æ³•å¾ˆå¦™ï¼Œå¥½å¥½ä½“ä¼š

class Solution:
    def reverseBits(self, n: int) -> int:
        b = n & ((1 << 32) - 1)
        base = 1 << 31
        ans = 0
        while b:
            ans |=  base // (b & (-b)) # b & (-b)æ‰¾åˆ°æœ€åä¸€ä¸ª 1
            # ans |=  base è¡¨ç¤ºç§»åŠ¨é¡¹
            b &= b-1 # æ¶ˆæ‰æœ€åä¸€ä¸ª1
        return ans    
```

å­—ç¬¦ä¸²è½¬æ•´æ•°

```py
class Solution:
    def reverseBits(self, n):
        return int(bin(n)[2:].zfill(32)[::-1],2)
        # print(bin(n)[2:])
        # print(bin(n))
        # 10100101000001111010011100
        # 0b 10100101000001111010011100
```


```scala
object Solution {
    // you need treat n as an unsigned value
    def reverseBits(x: Int): Int = {
        var binaryString = x.toBinaryString.toList
        
        var additional = (1 to (32 - binaryString.length)).map(_ => '0').toList
        
        binaryString = additional ++ binaryString
        
        val reversed = reverseBinary(binaryString, "")
        
        Integer.parseUnsignedInt(reversed.mkString, 2)
    }
    
    def reverseBinary(x: List[Char], str: String): String = x match{
        case Nil => str
        case x::xs => reverseBinary(xs, x + str)
    }
}

```

###  1.75. <a name='Numberof1Bits'></a>191 Number of 1 Bits

[å°æ˜](https://www.bilibili.com/video/BV1i5411J7SA?spm_id_from=333.999.0.0)

```py
class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = sum(1 for i in range(32) if n & (1 << i)) 
        return ret

class Solution:
    def hammingWeight(self, n: int) -> int:
        return ('{:0b}'.format(n).count('1'))

class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')
#  python è¾“å…¥çš„æ˜¯10è¿›åˆ¶çš„ ç›´æ¥è½¬strä¸è¡Œ å¯ä»¥è¯•è¯• bin(n) å°†10è¿›åˆ¶ è½¬æˆ äºŒè¿›åˆ¶ç„¶å count
```

```py
# ä»1å¼€å§‹ï¼Œæ¯æ¬¡<<ä¸€ä½ï¼Œä¸nåšä¸è¿ç®—ï¼Œå¦‚æœä¸ä¸º0ï¼Œåˆ™è¯¥ä½ä¸º1
class Solution:
    def hammingWeight(self, n: int) -> int:

        res = 0
        while n:
            n &= n - 1
            res += 1
        return res

class Solution:
    def hammingWeight(self, n: int) -> int:
        a, res = 0, 0
        while a <= 32:
            if (1<<a)&n != 0:
                res += 1
            a += 1
        return res
```

```scala

// ä½¿ç”¨ä½æ“ä½œ:x = x & (x -1)å°†æœ€åä¸€ä¸ªéé›¶posè®¾ç½®ä¸ºé›¶  

//Alternate(éœ€è¦ç†è§£è¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆ)å’Œnum, num-1  
// num & num-1è¿”å›æœ€åä¸€ä¸ªSETä½  
//äº¤æ›¿ä½ç§»ä½å’Œè®¡æ•°1  

object Solution{
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        _hammingWeight(n, 0)
    }
    
    @annotation.tailrec
    def _hammingWeight(n: Int, counter: Int): Int = {
        if(n  == 0) counter
        else _hammingWeight(n & (n - 1), counter + 1 )
    }
}


object Solution0 {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {

        var mask = 1
        var counter = 0
        for (_ <- 0 to 32) {

            if ((n & mask) != 0) {
                counter += 1
            }
            mask  = mask << 1
        }
        counter
    }
}


def hammingWeight(n: Int): Int = {
        var count = 0
        var num   = n

        while (num != 0) {
            if ((num & 1) > 0) { count = count + 1 }
            num = num >>> 1
        }
    count
}

def hammingWeight(n: Int): Int = {
        var counter = 0
        var num = n         
        while (num != 0) {
            counter += 1
            num &= (num-1)                
        }
        counter
    }

```

```scala
object Solution {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        n.toBinaryString.toCharArray.filter(_ == '1').length
    }
}
```

###  1.76. <a name='HouseRobber198-'></a>198. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘House Robber 198-æ‰“å®¶åŠ«èˆ

[12:45 èŠ±èŠ±é…± DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1tW411676f?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1u64y1M7PA?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7hu?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1gZ4y1N75c?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV18g4y1i7f9?spm_id_from=333.999.0.0)

```py
åŠ¨æ€ğŸš€è§„åˆ’ï¼Œå…¸å‹ä¾‹é¢˜ï¼š
class Solution:
    def rob(self, nums: List[int]) -> int:
        dp0 = 0
        dp1 = 0
        for num in nums:
            dp0, dp1 = dp1, max(dp0 + num, dp1)
        return dp1
```


```scala
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else if(nums.length == 1){
            nums(0)
        }else if(nums.length == 2){
            Math.max(nums(0), nums(1))
        }else{
            Math.max(
                nums(0) + rob(nums.drop(2)),
                nums(1) + rob(nums.drop(3))
            )
        }
    }
}

//The above solution worked for small input arrays
//but had MEMORY LIMIT EXCEEDED for large input

//While using DP: we try to store values of repetitive calculations
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var dp = Array.fill(nums.length+1)(0)
            
            dp(0) = 0
            dp(1) = nums(0)
            (1 to nums.length-1).map(i => {
                dp(i+1) = Math.max(dp(i), dp(i-1) + nums(i))
            })
            
            dp(nums.length)
        }
    }
}

//Another way to do the same
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.isEmpty){
            0
        }else{
            var rob = nums(0)
            var no_rob = 0
            var prev = rob
            for(i <- 1 until nums.length){
                prev = rob
                rob = no_rob + nums(i)
                no_rob = Math.max(prev, no_rob)
                
            }
            Math.max(no_rob, rob)
        }
    }
}

```

###  1.77. <a name='BinaryTreeRightSideView'></a>199 Binary Tree Right Side View

[å°æ˜](https://www.bilibili.com/video/BV1854y1W7CB?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1xK4y1b7Wh?spm_id_from=333.999.0.0)

```py

class Solution:
    def rightSideView(self, root: TreeNode):
        dic, dfs = {}, lambda node, startI: node and (dic.__setitem__(startI, node.val) or dfs(node.left, startI + 1) or dfs(node.right, startI + 1))
        return dfs(root, 0) or [*dic.values()]
# __setitem__:æ¯å½“å±æ€§è¢«èµ‹å€¼çš„æ—¶å€™éƒ½ä¼šè°ƒç”¨è¯¥æ–¹æ³•ï¼Œå› æ­¤ä¸èƒ½å†è¯¥æ–¹æ³•å†…èµ‹å€¼ self.name = value ä¼šæ­»å¾ªç¯
#  bfs å±‚åºéå†ï¼Œæ¯æ¬¡ä¿ç•™æœ€åä¸€ä¸ªå€¼stack

class Solution:
    def rightSideView(self, root: TreeNode):
        if not root: return []
        ans = []
        stack = deque([root])
        while stack:
            for _ in range(len(stack)):
                node = stack.popleft()
                if node.left: stack.append(node.left)
                if node.right: stack.append(node.right)
            ans.append(node.val)
        return ans

# åŸºç¡€æ–¹æ³•ï¼Œå±‚æ¬¡éå†ï¼š

class Solution:
    def rightSideView(self, root: TreeNode):
        res, level = [], root and [root]
        while level:
            res.append(level[-1].val)
            level = [right for tree in level for right in (tree.left, tree.right) if right]
        return res

# è€å±‚åºéå†äº†

class Solution:
    def rightSideView(self, root: TreeNode):
        if not root:
            return []
        res = []
        node = [root]
        while node:
            tmpNode = []
            for n in node:
                if n.left:
                    tmpNode.append(n.left)
                if n.right:
                    tmpNode.append(n.right)
            res.append(node[-1].val)
            node = tmpNode
        return res

# é€’å½’

class Solution:
    def rightSideView(self, root: TreeNode):
        res = []
        def dfs(node, startIndex):
            if node:
                startIndex == len(res) and res.append(node.val)
                dfs(node.right, startIndex + 1)
                dfs(node.left, startIndex + 1)
        dfs(root, 0)
        return res
```

###  1.78. <a name='-1'></a>200 ã€ğŸ’å¹¶æŸ¥é›†ã€‘å²›å±¿æ•°é‡

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV15K411p72j?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Cg4y1i7dZ?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1KK4y1U7Ds?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1E64y1T7Nk?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Np4y1977S?spm_id_from=333.999.0.0)

[ä¸€ä¿©ä¸‰å››äº”](https://www.bilibili.com/video/BV114411q7sP?from=search&seid=1135814820928819139&spm_id_from=333.337.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3v3ayrrcjf60.png" width="50%">

```py
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        f = {}
        def find(x):
            f.setdefault(x,x)
            if f[x]!=x:
                f[x] = find(f[x])
            return f[x]
        def union(x,y):
            f[find(y)] = find(x)
            
        if not grid:
            return 0
        row,col =len(grid),len(grid[0])
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    for x, y in [[-1, 0], [0, -1]]:
                        tmp_i = i + x
                        tmp_j = j + y
                        if 0 <= tmp_i < row and 0 <= tmp_j < col and grid[tmp_i][tmp_j] == "1":
                            union(tmp_i * col + tmp_j, i * col + j)
        res = set()
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    res.add(find(col*i+j))
        return len(res)
```

```py
# dfs
from pprint import pprint
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0]) # è¡Œåˆ—
        ans = 0
        # å°±åƒæ˜¯æŠŠå²›å±¿ä¸€ä¸ªä¸ªèš•é£Ÿ
        def dfs(i, j): 
            if 0 <= i < m and 0 <= j < n and grid[i][j] == '1':   # è¡¥å……è¾¹ç•Œæ¡ä»¶ï¼Œé˜²æ­¢æº¢å‡º
                grid[i][j] = '0' # dfsç½®ä¸º0
                dfs(i + 1, j)  # éå†4ä¸ªé¢†åŸŸ
                dfs(i - 1, j)  # éå†4ä¸ªé¢†åŸŸ
                dfs(i, j - 1)  # éå†4ä¸ªé¢†åŸŸ
                dfs(i, j + 1)  # éå†4ä¸ªé¢†åŸŸ

        for i in range(m): # è¡Œåˆ—
            for j in range(n): # è¡Œåˆ—
                if grid[i][j] == '1': # å¦‚æœgrid[i][j]ä¸º1ï¼Œåˆ™dfs
                    pprint(grid)
                    ans += 1
                    dfs(i, j)
        return ans

# çœ‹äº†åˆ«äººçš„ä»£ç ï¼Œå†™çš„çœŸç¾ â•®(â•¯_â•°)â•­ å•Š

class Solution(object):
    def numIslands(self, grid):
        def dfs(gird, used, row, col, x, y):
            if gird[x][y] == '0' or used[x][y]:
                return 
            used[x][y] = True

            if x!= 0:
                dfs(grid, used, row,col, x-1,y)
            if x!= row -1 :
                dfs(grid, used, row,col, x+1, y)
            if y!= 0:
                dfs(grid, used, row,col, x, y-1)
            if y!= col - 1:
                dfs(grid, used, row,col, x, y+1)


        row = len(grid) # è¡Œåˆ—
        col = len(grid[0]) if row else 0 # è¡Œåˆ—

        used = [[0 for i in range(col)] for i in range(row)]

        count = 0
        for i in range(row): # è¡Œåˆ—
            for j in range(col): # è¡Œåˆ—
                if grid[i][j] == '1' and not used[i][j]: # å¦‚æœgrid[i][j]ä¸º1ï¼Œåˆ™dfs
                    dfs(grid,used,row,col,i,j)
                    count += 1
        return count

class Solution:
    def dfs(self, grid, r, c):
        grid[r][c] = 0
        nr, nc = len(grid), len(grid[0]) # è¡Œåˆ—
        for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                self.dfs(grid, x, y)

    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid) # è¡Œåˆ—
        if nr == 0:
            return 0
        nc = len(grid[0]) # è¡Œåˆ—

        num_islands = 0
        for r in range(nr): # è¡Œåˆ—
            for c in range(nc): # è¡Œåˆ—
                if grid[r][c] == "1": # å¦‚æœgrid[i][j]ä¸º1ï¼Œåˆ™dfs
                    num_islands += 1
                    self.dfs(grid, r, c)
        
        return num_islands
```

```py
# å‰å®³çš„è§£æ³•ï¼šSink and count the islands.
class Solution(object):
    def numIslands(self, grid):
        def sink(i, j):
            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '1':
                grid[i][j] = '0'
                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))
                return 1
            return 0
        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[0])))

```

```scala
/**
* chosen solution
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/

object Solution0 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}


/**
* my first commit
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/
object Solution1 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}

/**
* Union & Find 
* memo
*    1. without modify original grid's elements
* time complexity: O(N * M) both N M is the dimension of grid 
*     both union and find operation's amortized time complexity in UnionFind class are very very close to 1 but not 1
*/


object Solution {
  private val endLabel = '0'
  def numIslands(grid: Array[Array[Char]]): Int = {
    val unionFind = new UnionFind(grid)
    for(i <- grid.indices; j <- grid(0).indices)
      union((i, j), unionFind, grid)
    unionFind.counter

  }

  def union(coord: (Int, Int), unionFind: UnionFind, grid: Array[Array[Char]]): Unit = {
    val (row, col) = coord
    if(grid(row)(col) == endLabel) return

    neighbors(coord, (grid.length, grid(0).length)).foreach {
      case (nr, nc) if grid(nr)(nc) != endLabel  =>
        unionFind.union(coord, (nr, nc))
      case _ =>
    }
  }

  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{ case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

###  1.79. <a name='BitwiseANDofNumbersRange'></a>201 ã€ä½è¿ç®—ğŸ˜œã€‘Bitwise AND of Numbers Range

[å°æ˜](https://www.bilibili.com/video/BV1dT4y1g75m?spm_id_from=333.999.0.0)


```py
æ—¶é—´å¤æ‚åº¦ï¼š
log(n)

ç©ºé—´å¤æ‚åº¦ï¼š
1

æˆ‘ä»¬çŸ¥é“ï¼Œæ•°ç»„çš„æ•°å­—æ˜¯è¿ç»­çš„ï¼Œ
æˆ‘ä»¬åªè¦æ‰¾å‡ºm,nçš„åšå·¦è¾¹èµ·çš„æœ€é•¿ç›¸åŒçš„äºŒè¿›åˆ¶å¤´éƒ¨å³å¯å‘€ã€‚
```

```py
å…³é”®åœ¨äºæ‰¾è§„å¾‹ï¼š

å½“äºŒè¿›åˆ¶ä½æ•°ä¸åŒæ—¶ï¼Œä¸€å®šä¸º0     
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        while m < n:
            # æŠ¹å»æœ€å³è¾¹çš„ 1
            n = n & (n - 1)
        return n


åªè¦æ‰¾åˆ°è§„å¾‹ï¼Œé‚£ä¹ˆæš´åŠ›æ³•ä¾ç„¶ç»™åŠ›ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯ï¼š
å¦‚æœmä¸nåœ¨äºŒè¿›åˆ¶ä¸‹çš„ä½æ•°ä¸ä¸€æ ·ï¼Œé‚£ä¹ˆå¿…é¡»å¾—0ï¼Œ
ç„¶ååªç®—m,nåœ¨äºŒè¿›åˆ¶ä½æ•°ä¸€æ ·çš„æƒ…å†µä¸‹ï¼Œæ¥ä¸ªæš´åŠ›è§£æ³•ï¼Œå°±å¯ä»¥é€šè¿‡ï¼Œè€Œä¸”é€Ÿåº¦ä¸æ…¢é¢ï¼Œä»£ç å¦‚ä¸‹ï¼š

class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        if len(bin(m))<len(bin(n)):
            return 0
        else:
            temp=m
            for each in range(m+1,n+1,1):
                temp&=each
            return temp
```


```scala
  object Solution {
    def rangeBitwiseAnd(m: Int, n: Int): Int = {
      var count = 0
      var m1 = m
      var n1 = n
      while (m1!=n1) {
        m1 >>= 1
        n1 >>=1
        count+=1
      }
      m1<<count
    }
  }
```

###  1.80. <a name='HappyNumber'></a>202. å¿«ä¹æ•° Happy Number

[å®˜æ–¹](https://www.bilibili.com/video/BV1Ca4y1v7Qr?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1CA41187LQ?spm_id_from=333.999.0.0)

åˆ¤æ–­æ˜¯å¦æˆç¯ï¼Œå’Œä¹‹å‰çš„é“¾è¡¨çš„é¢˜ç›®ç±»ä¼¼

```py
å¦‚æœä»–ä¸æ˜¯å¿«ä¹æ•°ï¼Œ
é‚£ä¹ˆä»–è‚¯å®šåœ¨æŸäº›æ•°å­˜åœ¨ä¸åœå¾ªç¯çš„è¿‡ç¨‹ï¼Œ

class Solution:
    def isHappy(self, n: int) -> bool:
        res = []
        while 1:
            n = sum([ int(i)**2 for i in str(n)])
            if n == 1:
                return True
            else:
                if n not in res:
                    res.append(n)
                else:
                    return False

class Solution:
    def isHappy(self, n: int) -> bool:  
        def getNext(number):
            sqSum = 0
            while number > 0:
                number, digit = divmod(number, 10)
                sqSum += digit ** 2
            return sqSum

        slow = n
        fast = getNext(n)
        while fast != 1 and slow != fast:
            slow = getNext(slow)
            fast = getNext(getNext(fast))
        return fast == 1
```

```py
class Solution:
    def isHappy(self, n: int) -> bool:
        def getNext(n):
            sqSum = 0
            while n > 0:
                n, digit = divmod(n, 10)
                sqSum += digit ** 2
            return sqSum

        visited = set()
        while n != 1 and n not in visited:
            visited.add(n)
            n = getNext(n)

        return n == 1

class Solution:
    def isHappy(self, n: int) -> bool:
        def getNext(number):
            sqSum = 0
            
            # ä»ä¸ªä½å¼€å§‹ä¾æ¬¡å–ï¼Œå¹³æ–¹æ±‚å’Œ
            while number:
                sqSum += (number % 10) ** 2
                number = number // 10
            return sqSum
        # è®°å½•ä¸­é—´ç»“æœ
        visited = set()

        while True:
            n = getNext(n)
            if n == 1:
                return True
            # å¦‚æœä¸­é—´ç»“æœé‡å¤å‡ºç°ï¼Œè¯´æ˜é™·å…¥æ­»å¾ªç¯äº†ï¼Œè¯¥æ•°ä¸æ˜¯å¿«ä¹æ•°
            if n in visited:
                return False
            else:
                visited.add(n)


```

```scala
object Solution {
    
    def getDigitSquaresSum(num: Int) = {
        num.toString.map(_.asDigit).map(x => x*x).foldLeft(0)(_ + _)
    }
    
    def isHappy(n: Int): Boolean = {
        var num = n
        var set = scala.collection.mutable.HashSet.empty[Int]
        var flag = true
        while(flag){
            if(num == 1){
                flag = false
            }else if(set.contains(num)){
                flag = false
            }else{
                set.add(num)
                num = getDigitSquaresSum(num)
            }
        }
        
        num == 1
    }
}

```

```scala

  object Solution {
    def isHappy(n: Int): Boolean = {
      def next(x:Int): Int ={
        x.toString().map(e=> (e-'0')*(e-'0')).sum
      }

      def solve(x:Int, m:Set[Int]): Boolean = x match {
        case 1 => return true
        case x if m.contains(x) =>return false
        case x =>solve(next(x), m+x)
      }
      solve(n, Set[Int]())
    }
  }

```

###  1.81. <a name='RemoveLinkedListElements'></a>203. Remove Linked List Elements

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7bf?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Yi4y137WA?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1Sz411b7zw?spm_id_from=333.999.0.0)

```py
é¦–å…ˆå¤„ç†ç‰¹æ®Šæƒ…å†µ

ç„¶åå¼€å§‹åŒæŒ‡é’ˆï¼Œä¸€å‰ä¸€åï¼Œä¸€èµ·èµ°

å½“åé¢çš„èŠ‚ç‚¹å€¼ç­‰äºvalæ—¶ï¼Œå‰é¢æŒ‡é’ˆä¸åŠ¨ï¼Œåé¢æŒ‡é’ˆç»§ç»­èµ°ï¼Œç›´åˆ°èŠ‚ç‚¹çš„å€¼!=val

æ­¤æ—¶æŠŠå‰é¢æŒ‡é’ˆçš„nextæŒ‡å‘åé¢èŠ‚ç‚¹ï¼Œå³æŠŠä¸­é—´è¿™äº›å€¼ä¸ºvalçš„èŠ‚ç‚¹åˆ é™¤äº†

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        if head == None:  #å¤„ç†[]
            return head
        while head != None and head.val == val:  #å¤„ç†[7,7,7,7,1]
            head = head.next
        if head == None:  #å¤„ç†[7,7,7,7]
            return head

        slow, fast = head, head.next
        while fast != None:
            if fast.val == val:
                while fast != None and fast.val == val:
                    fast = fast.next
                slow.next = fast
            else:
                slow = slow.next
                fast = fast.next
        return head
```

```py
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        cur = head #æ“ä½œå¯¹è±¡æ˜¯åŒä¸€å—å†…å­˜ id(temp)=id(head)
        while cur:
            if cur.next and cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        if head and head.val == val: #å¤´èŠ‚ç‚¹ç­‰äºvalçš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥
            return head.next
        else:
            return head

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy = ListNode(next=head) #æ·»åŠ ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹
        cur = dummy
        while(cur.next!=None):
            if(cur.next.val == val):
                cur.next = cur.next.next #åˆ é™¤cur.nextèŠ‚ç‚¹
            else:
                cur = cur.next
        return dummy.next


class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy = ListNode(1)
        dummy.next = head
        cur = dummy
        while head:
            if head.val == val:
                cur.next = head.next
            else:
                cur = head
            head = head.next   
        return dummy.next
```

```scala
  object Solution {
    def removeElements(head: ListNode, `val`: Int): ListNode = {
      val dummy = ListNode(0)
      dummy.next = head
      var prev = dummy
      var cur = head
      while (cur!=null) {
        if (cur.x != `val`) {
          prev.next = cur
          prev = cur
        } else {
          prev.next = null
        }
        cur = cur.next
      }
      dummy.next
    }
  }
}

```

###  1.82. <a name='CountPrimes'></a>204-Count Primes

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV167411w7Sf?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7cV?spm_id_from=333.999.0.0)

```py
# åŸƒæ°ç­›ä»£ç é‡ç‚¹ç†è§£ä¸€ä¸‹jä»i*iå¼€å§‹å§ï¼Œ

# å› ä¸ºè®¡ç®—i*iä¹‹å‰å°±è®¡ç®—äº†i*2ï¼Œi*3...,i*(i-1)ã€‚ 

# è¿™é¢˜æœåˆ°ä¸€ä¸ªéå¸¸ç‰›é€¼çš„ç®—æ³•,å«åšå„æ‹‰å¤šå¡ç­›æ³•. 

# æ¯”å¦‚è¯´æ±‚20ä»¥å†…è´¨æ•°çš„ä¸ªæ•°,é¦–å…ˆ0,1ä¸æ˜¯è´¨æ•°.2æ˜¯ç¬¬ä¸€ä¸ªè´¨æ•°,

# ç„¶åæŠŠ20ä»¥å†…æ‰€æœ‰2çš„å€æ•°åˆ’å».2åé¢ç´§è·Ÿçš„æ•°å³ä¸ºä¸‹ä¸€ä¸ªè´¨æ•°3,

# ç„¶åæŠŠ3æ‰€æœ‰çš„å€æ•°åˆ’å».3åé¢ç´§è·Ÿçš„æ•°å³ä¸ºä¸‹ä¸€ä¸ªè´¨æ•°5,

# å†æŠŠ5æ‰€æœ‰çš„å€æ•°åˆ’å».ä»¥æ­¤ç±»æ¨.

# ä»£ç çš„å®ç°ä¸Šç”¨äº†éå¸¸å¥½çš„æŠ€å·§:

# å³iæ˜¯ä»(2,int(n**0.5)+1)è€Œé(2,n).è¿™ä¸ªæŠ€å·§æ˜¯å¯ä»¥éªŒè¯çš„,

# æ¯”å¦‚è¯´æ±‚9ä»¥å†…çš„è´¨æ•°ä¸ªæ•°,é‚£ä¹ˆåªè¦åˆ’æ‰sqrt(9)ä»¥å†…çš„è´¨æ•°å€æ•°,

# å‰©ä¸‹çš„å³å…¨ä¸ºè´¨æ•°. æ‰€ä»¥åœ¨åˆ’å»å€æ•°çš„æ—¶å€™ä¹Ÿæ˜¯ä»i*iå¼€å§‹åˆ’æ‰,è€Œä¸æ˜¯i+i.

class Solution:
    def countPrimes(self, n) -> int:
        if n < 3:
            return 0     
        else:
            # é¦–å…ˆç”Ÿæˆäº†ä¸€ä¸ªå…¨éƒ¨ä¸º1çš„åˆ—è¡¨
            isPrime = [1] * n
            # å› ä¸º0å’Œ1ä¸æ˜¯è´¨æ•°,æ‰€ä»¥åˆ—è¡¨çš„å‰ä¸¤ä¸ªä½ç½®èµ‹å€¼ä¸º0
            isPrime[0],isPrime[1] = 0,0
             # æ­¤æ—¶ä»index = 2å¼€å§‹éå†,output[2]==1,å³è¡¨æ˜ç¬¬ä¸€ä¸ªè´¨æ•°ä¸º2,ç„¶åå°†2çš„å€æ•°å¯¹åº”çš„ç´¢å¼•
             # å…¨éƒ¨èµ‹å€¼ä¸º0. æ­¤æ—¶output[3] == 1,å³è¡¨æ˜ä¸‹ä¸€ä¸ªè´¨æ•°ä¸º3,åŒæ ·åˆ’å»3çš„å€æ•°.ä»¥æ­¤ç±»æ¨.
            for i in range(2,int(n**0.5)+1): 
                if isPrime[i] == 1:
                    isPrime[i*i:n:i] = [0] * len(isPrime[i*i:n:i])
         # æœ€åoutputä¸­çš„æ•°å­—1è¡¨æ˜è¯¥ä½ç½®ä¸Šçš„ç´¢å¼•æ•°ä¸ºè´¨æ•°,ç„¶åæ±‚å’Œå³å¯.
        return sum(isPrime)

import math
from math import sqrt
class Solution(object):
    def countPrimes(self, n):
        isprime = [1]*n
        for i in range(2,int(sqrt(n))+1):
            if isprime[i]:
                for j in range(i*i,n,i):
                    isprime[j] = 0
        count = 0
        for i in range(2,n):
            if isprime[i]:count += 1
        return count

# è¿™ä¸ªè§£æ³•çœŸæ˜¯å¤ªèµäº†!åˆå­¦åˆ°äº†å¾ˆå¤š~~~ å’Œå¤§å®¶åˆ†äº«ä¸€ä¸‹
class Solution(object):
    def countPrimes(self, n):

        isPrime = [1 for i in range(n)]

        i = 2
        while i * i < n:
        	if isPrime[i]:
        		j = i * i 
        		while j < n :
        			isPrime[j] = 0
        			j += i
        	i += 1

        return sum(isPrime[2:])
```

```scala
object Solution {
    def countPrimes(n: Int): Int = {
        
        //Sieve of Eratosthenes
        
        var primeArray = Array.fill(n)(false)
        (2 until n).map(i => primeArray(i) = true)
        
        //We need to check for all numbers i, where i < sqrt(n)
        //To avoid doing sqrt operation again & again (since its expensive)
        //We can do i*i < n
        
        var i =2
        while(i*i < n){
            if(primeArray(i)){
                var j = i*i
                while(j < n){
                    primeArray(j) = false
                    j += i //because we are only checking multiple of i for each i in iteration
                }
            }
            i+=1
        }
        
        primeArray.filter(x => x).length
    }
}

```


###  1.83. <a name='isomorphicstrings'></a>205. isomorphic strings

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1ab411H7ZS?spm_id_from=333.999.0.0)

```py
æ»¡è¶³é¢˜ç›®è¦æ±‚çš„åŒæ„å­—ç¬¦ä¸²å³ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å­—ç¬¦ä¹‹é—´æ˜¯åŒå°„æˆ–è€…è¯´ä¸€ä¸€å¯¹åº”çš„å…³ç³»ï¼Œå‡è®¾så­—ç¬¦ä¸²å¯¹åº”çš„é›†åˆæ˜¯Sï¼Œtå­—ç¬¦ä¸²å¯¹åº”çš„é›†åˆæ˜¯Tï¼Œåˆ™åŒå°„å…³ç³»è¦æ±‚ï¼š

Sçš„å…ƒç´ ä¸ªæ•°ã€Tçš„å…ƒç´ ä¸ªæ•°ã€Sä¸Tä¹‹é—´çš„æ˜ å°„ä¸ªæ•°ä¸‰è€…éƒ½ç›¸ç­‰ï¼Œåˆ™åªéœ€è¦ä¸€è¡Œä»£ç å³å¯ï¼š

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s)) == len(set(t)) == len(set(zip(s,t)))

ä»è¯„è®ºåŒº@StrayCamel æ¬è¿æ›´ Pythonic çš„å†™æ³•ï¼š

åŸå›ç­”ï¼š

è¡¥å……ä¸€ä¸ªpython3

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s)) == len(set(t)) and len(set(s)) == len(set(zip(s, t)))
```

```py
ä¾‹å¦‚å­—ç¬¦ä¸² adsds å’Œ opfpf

a å’Œ o æ˜¯æ˜ å°„å…³ç³» d å’Œ p æ˜¯æ˜ å°„å…³ç³» s å’Œ f æ˜¯æ˜ å°„å…³ç³» é‚£ä¹ˆ

adsds.index('a') ==  opfpf.index('o')
 adsds.index('d') ==  opfpf.index('p')
 adsds.index('s') ==  opfpf.index('f')

è¿™ä¸‰ä¸ªæ˜¯ä¸æ˜¯æ’æˆç«‹

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        n = len(s)
        for i in range(n):
            if s.index(s[i]) != t.index(t[i]):  # ä¸¤ä¸ªå­—ç¬¦åœ¨å„è‡ªå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ç›¸åŒï¼Œè¡¨ç¤ºå¯ä»¥é‡æ„
                return False
        else:
            return True
```

```py          
é‡‡ç”¨ä¸¤ä¸ªdictï¼Œäº’ç›¸æŒ‡å‘ï¼Œæ„æˆåŒå°„ã€‚å‘ç°äº†å†²çªï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªå­—æ¯å¯èƒ½å¯¹åº”äº†ä¸¤ä¸ªä¸åŒçš„å­—æ¯ï¼Œå°±è¯´æ˜ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸æ˜¯åŒæ„äº†ã€‚

class Solution(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False
        
        lookup1 = dict()
        lookup2 = dict()
        for c1,c2 in zip(s,t):
            if (c1 in lookup1 and lookup1[c1] != c2) or (c2 in lookup2 and lookup2[c2] != c1) :
                return False
            lookup1[c1] = c2
            lookup2[c2] = c1        
        return True


class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(t) != len(s):
            return False
        lookup1 = {}
        lookup2 = {}
        for i in range(len(s)):
            c1, c2 = s[i], t[i]
            if c1 not in lookup1:
                lookup1[c1] = c2
            if c2 not in lookup2:
                lookup2[c2] = c1
            if lookup1[c1] != c2 or lookup2[c2] != c1:
                return False
        return True 

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        lookup1 = {}
        lookup2 = {}
        for c1, c2 in zip(s, t):
            # è¿™ä¸ªgeté»˜è®¤å€¼ç”¨çš„å¥½ï¼Œæ»¡è¶³äº†è¿˜æ²¡æœ‰å®Œæˆé…å¯¹å­—ç¬¦å‡ºç°çš„Noneå€¼çš„æƒ…å†µ
            if lookup1.get(c1, c2) != c2 or lookup2.get(c2, c1) != c1:
                return False
            lookup1[c1] = c2
            lookup2[c2] = c1
        return True


class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t): return False

        dic = dict()
        for i in range(len(s)):
            if s[i] not in dic and t[i] not in dic.values():
                dic[s[i]]=t[i]
            elif s[i] in dic and dic[s[i]] == t[i]:
                pass
            else:return False
        return True
```

```scala
  object Solution {
    def isIsomorphic(s: String, t: String): Boolean = {
      val m:HashMap[Char,Char] = HashMap[Char,Char]()
      val n:HashMap[Char,Char] = HashMap[Char,Char]()

      s.indices.foreach(
        idx=>idx match {
          case idx if m.contains(s(idx)) && m(s(idx))!=t(idx) => return false
          case idx if n.contains(t(idx)) && n(t(idx))!=s(idx) => return false
          case idx =>{
            m(s(idx))=t(idx)
            n(t(idx))=s(idx)
          }
        }
      )
      true
    }
  }
```

###  1.84. <a name='ReverseLinkedList'></a>206-Reverse Linked List

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Q7411V7zr?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV16Q4y1M767?spm_id_from=333.999.0.0)

```py
å‰ç½®æ¡ä»¶ï¼šè¿­ä»£æŒ‡é’ˆï¼šp = headã€ç»“æœæŒ‡é’ˆï¼šres = none

ä»¥1->2->3->4->5ä¸ºä¾‹ï¼š

è¿‡ç¨‹ï¼š

res:None

ç¬¬ä¸€å±‚å¾ªç¯

res:1->2->3->4->5 res = p

res:1->None res.next = res

p:2->3->4->5 p = p.next

ç¬¬äºŒå±‚å¾ªç¯

res:2->3->4->5 res = p

res:2->1->None res.next = res

p:3->4->5 p = p.next

ç¬¬ä¸‰å±‚å¾ªç¯

res:3->4->5 res = p

res:3->2->1->None res.next = res

p:4->5 p = p.next

ç¬¬å››å±‚å¾ªç¯

res:4->5 res = p

res:4->3->2->1->None res.next = res

p:5 p = p.next

ç¬¬äº”å±‚å¾ªç¯

res:5 res = p

res:5->4->3->2->1->None res.next = res

p:None p = p.next

end...

class Solution:
    def reverseList(self, head):
        pre, res = head, None
        while pre:
            res = pre
            res.next = res
            pre = pre.next
        return res
```

```py
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        """ è¿˜æœ‰ä¸€ç§æ–¹æ³•ï¼Œä¸éœ€è¦ä½¿ç”¨é¦–å…ƒç»“ç‚¹ 
            1 -> 2 -> 3 -> 4    å¯ä»¥ä¾æ¬¡é€†åºæ¯ä¸ªæŒ‡é’ˆ
            1 <- 2 <- 3 <- 4    4å˜ä¸ºäº†æ–°çš„è¡¨å¤´
            å’Œå¤´æ’æ³•ä¸€æ ·ï¼Œ éœ€è¦æ³¨æ„æ”¹å˜èŠ‚ç‚¹æŒ‡é’ˆçš„æ—¶å€™ï¼Œä¸èƒ½å½±å“åˆ° éå†ä¸‹ä¸€ä¸ªå…ƒç´ 
        """
        # 1. é¦–å…ˆéœ€è¦ä¸€ä¸ªæŒ‡é’ˆpé¡ºåºéå†èŠ‚ç‚¹ï¼Œ è¿˜éœ€è¦pre å’Œ cur æŒ‡é’ˆç”¨äºåè½¬
        pre = None
        tmp = cur = head
        while tmp:
            # 1. æ›´æ–°curä¸ºå½“å‰èŠ‚ç‚¹
            cur = tmp
            # 2. pæŒ‡é’ˆåç§»
            tmp = tmp.next
            # 3. åšåè½¬
            cur.next = pre
            # 4. æ›´æ–°preä¸ºå½“å‰èŠ‚ç‚¹
            pre = cur

        # 5. é‡æ–°å®šä¹‰ headæŒ‡å‘é“¾è¡¨æœ«å°¾
        head = cur
        return head
```


```py

é€’å½’è§£æ³•ï¼Œ å…ˆå†™å‡º whileå¾ªç¯çš„è¿­ä»£è§£æ³•ï¼Œå†æ¨å¯¼åˆ° è¿­ä»£å†™æ³•ã€‚å¥½åƒå®¹æ˜“ç†è§£ä¸€äº›
# è¿˜å¯ä»¥ ä»¥é€’å½’çš„å½¢å¼è§£å†³é—®é¢˜
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        """ 
            è¿­ä»£è§£æ³•ä¸­ï¼Œæ¯ä¸€æ­¥éƒ½æ˜¯ é‡æ–°æŒ‡å‘nextæŒ‡é’ˆï¼Œ å¯ä»¥åˆ†æ²»æ³•ï¼Œä½¿ç”¨é€’å½’æ±‚è§£ã€‚æ‰¾åˆ°æœ€å°å­é—®é¢˜åŠç»ˆæ­¢æ¡ä»¶
            éœ€è¦è°ƒç”¨é€’å½’æ ˆï¼Œ ç©ºé—´æ•ˆç‡è¦ä½å¾ˆå¤šã€‚
        """
        # 1. é¦–å…ˆéœ€è¦ä¸€ä¸ªæŒ‡é’ˆpé¡ºåºéå†èŠ‚ç‚¹ï¼Œ è¿˜éœ€è¦pre å’Œ cur æŒ‡é’ˆç”¨äºåè½¬
        def reverse(pre, cur):
            # å½“curä¸ºNoneäº†ï¼Œ è¯´æ˜preæŒ‡å‘æœ€åçš„èŠ‚ç‚¹ï¼Œè¿”å›ä½œä¸ºæ–°çš„å¤´ç»“ç‚¹
            if not cur: 
                return pre
            next = cur.next
            cur.next = pre
            return reverse(cur, next)
        

        head = reverse(None, head)
        return head


class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        
        def reverse(pre,cur):
            if not cur:
                return pre
                
            tmp = cur.next
            cur.next = pre

            return reverse(cur,tmp)
        
        return reverse(None,head)
```




```scala
object Solution {
    def reverseList(head: ListNode): ListNode = {
        if(head == null || head.next == null){
            head
        } else{
            var p = reverseList(head.next)
            head.next.next = head
            head.next = null
            p
        }
    }
}

```
```scala
/**
* time complexity: O(n)
* space complexity: O(1) 
*/
object Solution0 {
    def reverseList(head: ListNode): ListNode = {        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        prev
    }
}

 /**
 * time complexity: O(n)
 * space complexity: O(1)
 */
object Solution1 {
    def reverseList(head: ListNode): ListNode = {
        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        prev
    }
    
    def printNode(node: ListNode) {
        var n = node
        while(n != null) {
            print(s"${n.x} ")
            n = n.next
        }
    }
}


/** recursive version */

object Solution2 {
    def reverseList(head: ListNode): ListNode = {
        
        val curr:ListNode = null
        
        _reverseList(curr, head)
        
    }
    
    @annotation.tailrec
    def _reverseList(curr: ListNode, next: ListNode): ListNode = {
        if(next == null) {
            curr
        }else{
            val tmpNode = next.next
            next.next = curr
            _reverseList(next, tmpNode)
        }
    }
}

object Solution2-1 {
    def reverseList(head: ListNode): ListNode = {
        if(head == null) head
        else _reverseList(head)
        
    }
    
    def _reverseList(node: ListNode): ListNode = {
        if (node == null || node.next == null) {
            node
        }else {
            val newHead = _reverseList(node.next)
              // reversedHead æ˜¯è¿”å›åŸæœ¬çš„å°¾å·´ï¼Œè‹¥ä¸€é–‹å§‹è¼¸å…¥æ˜¯ 1 -> 2 -> 3 -> 4 -> 5  -> null , é‚£ reversedHead å°±æ˜¯ 5
            // æ¯æ¬¡ iteration è¿”å›éƒ½æ˜¯åŒä¸€å€‹ reversedHead ä¹Ÿå°±æ˜¯ 5
            node.next.next = node
            node.next = null
             // æ¯æ¬¡è¿­ä»£ æ”¹è®Šçš„å°±æ˜¯é€é€²æ¯å€‹ function çš„ listnode çš„ next èˆ‡ next.next æŒ‡å‘
            newHead
        }
        
        
    }
}

```

###  1.85. <a name='-1'></a>207-è¯¾ç¨‹è¡¨

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Ut411a74a?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV19k4y1r76s?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1jz411B7UJ?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Xp4y1Y7FJ?spm_id_from=333.999.0.0)

```py
class Solution(object):

    # è¿™é‡Œä½¿ç”¨é€†é‚»æ¥è¡¨

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int è¯¾ç¨‹é—¨æ•°
        :type prerequisites: List[List[int]] è¯¾ç¨‹ä¸è¯¾ç¨‹ä¹‹é—´çš„å…³ç³»
        :rtype: bool
        """
        # è¯¾ç¨‹çš„é•¿åº¦
        clen = len(prerequisites)
        if clen == 0:
            # æ²¡æœ‰è¯¾ç¨‹ï¼Œå½“ç„¶å¯ä»¥å®Œæˆè¯¾ç¨‹çš„å­¦ä¹ 
            return True
        # æ·±åº¦ä¼˜å…ˆéå†ï¼Œåˆ¤æ–­ç»“ç‚¹æ˜¯å¦è®¿é—®è¿‡
        # è¿™é‡Œè¦è®¾ç½® 3 ä¸ªçŠ¶æ€
        # 0 å°±å¯¹åº” False ï¼Œè¡¨ç¤ºç»“ç‚¹æ²¡æœ‰è®¿é—®è¿‡
        # 1 å°±å¯¹åº” True ï¼Œè¡¨ç¤ºç»“ç‚¹å·²ç»è®¿é—®è¿‡ï¼Œåœ¨æ·±åº¦ä¼˜å…ˆéå†ç»“æŸä»¥åæ‰ç½®ä¸º 1
        # 2 è¡¨ç¤ºå½“å‰æ­£åœ¨éå†çš„ç»“ç‚¹ï¼Œå¦‚æœåœ¨æ·±åº¦ä¼˜å…ˆéå†çš„è¿‡ç¨‹ä¸­ï¼Œ
        # æœ‰é‡åˆ°çŠ¶æ€ä¸º 2 çš„ç»“ç‚¹ï¼Œå°±è¡¨ç¤ºè¿™ä¸ªå›¾ä¸­å­˜åœ¨ç¯
        visited = [0 for _ in range(numCourses)]
        print("visited:", visited)

        # é€†é‚»æ¥è¡¨ï¼Œå­˜çš„æ˜¯æ¯ä¸ªç»“ç‚¹çš„å‰é©±ç»“ç‚¹çš„é›†åˆ
        # æƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºä»–ä»¬: [0,1]
        # 1 åœ¨å‰ï¼Œ0 åœ¨å
        inverse_adj = [set() for _ in range(numCourses)]
        print("inverse_adj:",inverse_adj)
        for second, first in prerequisites:
            print("[first]:",first)
            print("[second]:",second)
            inverse_adj[second].add(first)
            print("inverse_adjè¡¨ç¤ºåœ¨å­¦ä¹ ç¬¬[",second,"]èŠ‚è¯¾å‰ï¼Œè¦å…ˆå­¦ä¹ :",inverse_adj[second])

        for i in range(numCourses):
            # åœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‘ç°æœ‰ç¯ï¼Œåˆ™dfsè¿”å›trueï¼Œå°±é€€å‡º
            if self.__dfs(i, inverse_adj, visited,1): # visited åˆå§‹åŒ–ä¸º 0
                return False
        return True

    def __dfs(self, vertex, inverse_adj, visited,depth):
        """
        æ³¨æ„ï¼šè¿™ä¸ªé€’å½’æ–¹æ³•çš„è¿”å›å€¼æ˜¯è¿”å›æ˜¯å¦æœ‰ç¯
        :param vertex: ç»“ç‚¹çš„ç´¢å¼•
        :param inverse_adj: é€†é‚»æ¥è¡¨ï¼Œè®°å½•çš„æ˜¯å½“å‰ç»“ç‚¹çš„å‰é©±ç»“ç‚¹çš„é›†åˆ
        :param visited: è®°å½•äº†ç»“ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡ï¼Œ2 è¡¨ç¤ºå½“å‰æ­£åœ¨ DFS è¿™ä¸ªç»“ç‚¹
        :return: æ˜¯å¦æœ‰ç¯
        """
        # ç»“æŸæ¡ä»¶ï¼š
        # 2 è¡¨ç¤ºè¿™ä¸ªç»“ç‚¹æ­£åœ¨è®¿é—®
        # 2 è¡¨ç¤ºå½“å‰æ­£åœ¨éå†çš„ç»“ç‚¹ï¼Œå¦‚æœåœ¨æ·±åº¦ä¼˜å…ˆéå†çš„è¿‡ç¨‹ä¸­ï¼Œ
            # -------------ğŸ¨å¾ˆé‡è¦ğŸ¨-------------
        if visited[vertex] == 2:
            # è¡¨ç¤ºé‡åˆ°ç¯
            # æœ‰é‡åˆ°çŠ¶æ€ä¸º 2 çš„ç»“ç‚¹ï¼Œå°±è¡¨ç¤ºè¿™ä¸ªå›¾ä¸­å­˜åœ¨ç¯
            return True
            # -------------ğŸ¨å¾ˆé‡è¦ğŸ¨-------------
        if visited[vertex] == 1: # 1 è¡¨ç¤ºç»“ç‚¹å·²ç»è®¿é—®è¿‡ï¼Œåœ¨æ·±åº¦ä¼˜å…ˆéå†ç»“æŸä»¥åæ‰ç½®ä¸º 1
            return False

        print("ç¬¬1æ­¥vertex:",vertex,"visited:", visited," depth:",depth)
        visited[vertex] = 2
        print("ç¬¬2æ­¥vertex:",vertex,"visited:", visited," depth:",depth)
        for precursor in inverse_adj[vertex]: # æ˜¯ä¸ªset()
            # å¦‚æœæœ‰ç¯ï¼Œå°±è¿”å› True è¡¨ç¤ºæœ‰ç¯
            # -------------ğŸ¨å¾ˆé‡è¦ğŸ¨-------------
            if self.__dfs(precursor, inverse_adj, visited,depth+1):
                return True 
            # -------------ğŸ¨å¾ˆé‡è¦ğŸ¨-------------
        print("ç¬¬3æ­¥vertex:",vertex,"visited:", visited," depth:",depth)

        # 1 è¡¨ç¤ºè®¿é—®ç»“æŸ
        visited[vertex] = 1
        print("ç¬¬4æ­¥vertex:",vertex,"visited:", visited," depth:",depth)
        return False

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        visited = [0] * numCourses
        result = list()
        valid = True

        for info in prerequisites:
            edges[info[1]].append(info[0])
        
        def dfs(u: int):
            nonlocal valid
            visited[u] = 1
            for v in edges[u]:
                if visited[v] == 0:
                    dfs(v)
                    if not valid:
                        return
                elif visited[v] == 1:
                    valid = False
                    return
            visited[u] = 2
            result.append(u)
        
        for i in range(numCourses):
            if valid and not visited[i]:
                dfs(i)
        
        return valid

class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        def dfs(i, colors, prerequisites):
        	colors[i] = 'G'
        	#print i, colors
        	for front, tail in prerequisites:
        		if tail == i:
        			if colors[front] == 'G':
        				return False
        			elif colors[front] == 'B':
        				continue
        			elif dfs(front, colors, prerequisites) == False:
        				return False
        	colors[i] = 'B'
        	return True

        colors = ['W' for i in range(numCourses)]
        for i in range(numCourses):
        	if colors[i] == 'W':
        		if dfs(i, colors, prerequisites) == False:
        			return False
        return True
```

```py
# python
from collections import defaultdict 
class Solution:
    def canFinish(self, numCourses, prerequisites):
        inde = defaultdict(lambda:0)  # keep track of indegree of a course
        g = defaultdict(list)          # digraph of courses 
        for t,f in prerequisites:
            g[f].append(t)
            inde[t]+=1
        inde0 = []                   # inde0 holds courses whose indegree is 0
        for i in range(numCourses):
            if inde[i]==0:
                inde0.append(i)      # initialize inde0
        for i in inde0:
            for j in g[i]:
                inde[j]-=1
                if inde[j]==0:
                    inde0.append(j)
        return len(inde0)==numCourses

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        indeg = [0] * numCourses

        for info in prerequisites:
            edges[info[1]].append(info[0])
            indeg[info[0]] += 1
        
        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])
        visited = 0

        while q:
            visited += 1
            u = q.popleft()
            for v in edges[u]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)

        return visited == numCourses

class Solution(object):

    # æ€æƒ³ï¼šè¯¥æ–¹æ³•çš„æ¯ä¸€æ­¥æ€»æ˜¯è¾“å‡ºå½“å‰æ— å‰è¶‹ï¼ˆå³å…¥åº¦ä¸ºé›¶ï¼‰çš„é¡¶ç‚¹

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int è¯¾ç¨‹é—¨æ•°
        :type prerequisites: List[List[int]] è¯¾ç¨‹ä¸è¯¾ç¨‹ä¹‹é—´çš„å…³ç³»
        :rtype: bool
        """
        # è¯¾ç¨‹çš„é•¿åº¦
        clen = len(prerequisites)
        if clen == 0:
            # æ²¡æœ‰è¯¾ç¨‹ï¼Œå½“ç„¶å¯ä»¥å®Œæˆè¯¾ç¨‹çš„å­¦ä¹ 
            return True
        # å…¥åº¦æ•°ç»„ï¼Œä¸€å¼€å§‹å…¨éƒ¨ä¸º 0
        in_degrees = [0 for _ in range(numCourses)]
        # é‚»æ¥è¡¨
        adj = [set() for _ in range(numCourses)]

        # æƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºä»–ä»¬: [0,1]
        # [0,1] è¡¨ç¤º 1 åœ¨å…ˆï¼Œ0 åœ¨å
        # æ³¨æ„ï¼šé‚»æ¥è¡¨å­˜æ”¾çš„æ˜¯åç»§ successor ç»“ç‚¹çš„é›†åˆ
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)

        # print("in_degrees", in_degrees)
        # é¦–å…ˆéå†ä¸€éï¼ŒæŠŠæ‰€æœ‰å…¥åº¦ä¸º 0 çš„ç»“ç‚¹åŠ å…¥é˜Ÿåˆ—
        res = []
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)
        counter = 0
        while queue:
            top = queue.pop(0)
            counter += 1

            for successor in adj[top]:
                in_degrees[successor] -= 1
                if in_degrees[successor] == 0:
                    queue.append(successor)

        return counter == numCourses
```

```scala

// new and apply
// Use the new keyword when you want to refer to a class's own constructor:
// è§£æ³•æ˜¯ æ¯ä¸ªnode(node)ï¼Œ1.å®ƒä¾èµ–çš„nodeä¸ªæ•°(parent) 2.ç»Ÿè®¡ä¾èµ–å®ƒçš„nodeä¸ªæ•°(son)ï¼Œ
// ä¸€ä¸ªnodeæ²¡æœ‰ä¾èµ–å…¶å®ƒèŠ‚ç‚¹ï¼Œæ”¾å…¥zeroInDegree
// å¯¹zeroIndegreeçš„nodeéå†ï¼Œå¯¹æ¯ä¸ªä¾èµ–å®ƒçš„nodeéƒ½å¯ä»¥ç›´æ¥é™¤å»ä¾èµ–


  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def canFinish(numCourses: Int, prerequisites: Array[Array[Int]]): Boolean = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //å¿…é¡»åˆå§‹åŒ–

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum == numCourses
    }
  }

  class Test extends BaseExtension {
    def init {
      val input = Array(Array(0,1),Array(1,2))
      println(Solution.canFinish(3,input) == true)
      //println(lru.get(1) == 1)
    }

    val name = "207 course schedule"
  }

```

###  1.86. <a name='ImplementTriePrefixTree'></a>208. ã€æ„é€ ğŸ°ã€‘Implement Trie (Prefix Tree)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Ut411a74P?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Zz4y1R7j8?spm_id_from=333.999.0.0)

```py
# ç®€å•ç‰ˆï¼šç›´æ¥ç”¨å­—å…¸

# å†™æ³•ä¸€ï¼š

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            r = r.setdefault(c, {})
        r['#'] = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r: return False
            r = r[c]
        return r.get("#", False)

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r: return False
            r = r[c]
        return True

# å†™æ³•äºŒï¼š

class Trie:

    def __init__(self):
        self.root = {}


    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            if not r.get(c):
                r[c] = {}
            r = r[c]
        r['end'] = True


    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            try:
                r = r[c]
            except:
                return False
        return 'end' in r


    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            try:
                r = r[c]
            except:
                return False
        return True

# å†™æ³•ä¸‰ï¼š

class Trie:

    def __init__(self):
        self.root = {}


    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            if c not in r:
                r[c] = {}
            r = r[c]
        r['end'] = True


    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r:
                return False
            r = r[c]
        return 'end' in r


    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r:
                return False
            r = r[c]
        return True
```

```scala
/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

/**
* chosen solution
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie0() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}



/**
* my first commitment
*/
case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
}

class Trie1() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach { c =>

      val cIdx = c.asDigit - 'a'.asDigit
      if (node.childNode(cIdx) == null) {
        node.childNode(cIdx) = Node()
      }
      node = node(cIdx)
    }
    node.isWord = true

  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    val node = searchUtil(word)

    node != null && node.isWord

  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix) != null
  }


   private def searchUtil(s: String): Node = {
    var node = root
    var continue = true
    for {
      c <- s
      if continue
    } {
      val cIdx = c.asDigit - 'a'.asDigit
      if (node(cIdx) == null) {
        continue = false
      } 
      node = node(cIdx)
    }
    node
  }
}


/**
*  more elegant
*  Node with apply and update
*/

case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
  
  def update(idx: Int, node: Node): Unit = {
    childNode(idx) = node
  }

  def update(c: Char, node: Node): Unit = {
    this.update(c.asDigit - 'a'.asDigit, node)
  }
}
class Trie1-2() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach {
      case c if node(c) == null => 
        node(c) = Node()
        node = node(c)

      case c => node = node(c)
    }
    node.isWord = true
      
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }


  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach {
      case c if node(c) != null => node = node(c)
      case _ => return None
    }
    Some(node)
  }
  def traversal(): Unit = {
    val result = scala.collection.mutable.ListBuffer[String]()

    def _traversal(prefix: String, node: Node): Unit = {
      if (node.isWord) {
        result += prefix
      }
      node.childNode.zipWithIndex.foreach {
        case (n, idx) if n != null => _traversal(prefix + ('a' + idx).toChar, n)
        case _ =>
      }

    }

    _traversal("", root)
    result.foreach(s => println(s.mkString("")))

  }

}

/**
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie2() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}
```

###  1.87. <a name='-1'></a>209-é•¿åº¦æœ€å°çš„å­æ•°ç»„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1JZ4y1N7Rt?spm_id_from=333.999.0.0)

###  1.88. <a name='CourseScheduleII210-II'></a>210. Course Schedule II 210-è¯¾ç¨‹è¡¨II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gW411y7Kb?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Ja4y147on?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1qt4y1X7oC?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1kK411W7rL?spm_id_from=333.999.0.0)

```py
# æ€è·¯2ï¼šæ„å»ºé€†é‚»æ¥è¡¨ï¼Œå®ç°æ·±åº¦ä¼˜å…ˆéå†ã€‚æ€è·¯å…¶å®ä¹Ÿå¾ˆç®€å•ï¼Œå…¶å®å°±æ˜¯æ£€æµ‹è¿™ä¸ªæœ‰å‘å›¾ä¸­æœ‰æ²¡æœ‰ç¯ï¼Œåªè¦å­˜åœ¨ç¯ï¼Œè¯¾ç¨‹å°±ä¸èƒ½å®Œæˆã€‚

# æ³¨æ„ï¼šè¿™ä¸ªæ·±åº¦ä¼˜å…ˆéå†å¾—é€šè¿‡é€†é‚»æ¥è¡¨å®ç°ï¼Œå½“è®¿é—®ä¸€ä¸ªç»“ç‚¹çš„æ—¶å€™ï¼Œåº”è¯¥é€’å½’è®¿é—®å®ƒçš„å‰é©±ç»“ç‚¹ï¼Œç›´è‡³å‰é©±ç»“ç‚¹æ²¡æœ‰å‰é©±ç»“ç‚¹ä¸ºæ­¢ã€‚

# Python ä»£ç ï¼š

class Solution(object):

    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int è¯¾ç¨‹é—¨æ•°
        :type prerequisites: List[List[int]] è¯¾ç¨‹ä¸è¯¾ç¨‹ä¹‹é—´çš„å…³ç³»
        :rtype: bool
        """
        # è¯¾ç¨‹çš„é•¿åº¦
        clen = len(prerequisites)
        if clen == 0:
            # æ²¡æœ‰è¯¾ç¨‹ï¼Œå½“ç„¶å¯ä»¥å®Œæˆè¯¾ç¨‹çš„å­¦ä¹ 
            return [i for i in range(numCourses)]

        # é€†é‚»æ¥è¡¨
        inverse_adj = [set() for _ in range(numCourses)]
        # æƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºä»–ä»¬: [0,1]
        # 1 -> 0ï¼Œè¿™é‡Œè¦æ³¨æ„ï¼šä¸è¦å¼„åäº†
        for second, first in prerequisites:
            inverse_adj[second].add(first)

        visited = [0 for _ in range(numCourses)]
        # print("in_degrees", in_degrees)
        # é¦–å…ˆéå†ä¸€éï¼ŒæŠŠæ‰€æœ‰å…¥åº¦ä¸º 0 çš„ç»“ç‚¹åŠ å…¥é˜Ÿåˆ—

        res = []
        for i in range(numCourses):
            if self.__dfs(i,inverse_adj, visited, res,1):
                return []
        return res

    def __dfs(self, vertex, inverse_adj, visited, res,depth):
        """
        æ³¨æ„ï¼šè¿™ä¸ªé€’å½’æ–¹æ³•çš„è¿”å›å€¼æ˜¯è¿”å›æ˜¯å¦æœ‰ç¯
        :param vertex: ç»“ç‚¹çš„ç´¢å¼•
        :param inverse_adj: é€†é‚»æ¥è¡¨ï¼Œè®°å½•çš„æ˜¯å½“å‰ç»“ç‚¹çš„å‰é©±ç»“ç‚¹çš„é›†åˆ
        :param visited: è®°å½•äº†ç»“ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡ï¼Œ2 è¡¨ç¤ºå½“å‰æ­£åœ¨ DFS è¿™ä¸ªç»“ç‚¹
        :return: æ˜¯å¦æœ‰ç¯
        """
        # 2 è¡¨ç¤ºè¿™ä¸ªç»“ç‚¹æ­£åœ¨è®¿é—®
        if visited[vertex] == 2:
            # DFS çš„æ—¶å€™å¦‚æœé‡åˆ°ä¸€æ ·çš„ç»“ç‚¹ï¼Œå°±è¡¨ç¤ºå›¾ä¸­æœ‰ç¯ï¼Œè¯¾ç¨‹ä»»åŠ¡ä¾¿ä¸èƒ½å®Œæˆ
            return True
        if visited[vertex] == 1:
            return False
        # è¡¨ç¤ºæ­£åœ¨è®¿é—®è¿™ä¸ªç»“ç‚¹
        visited[vertex] = 2
        # é€’å½’è®¿é—®å‰é©±ç»“ç‚¹
        for precursor in inverse_adj[vertex]:
            # å¦‚æœæ²¡æœ‰ç¯ï¼Œå°±è¿”å› Falseï¼Œ
            # æ‰§è¡Œä»¥åï¼Œé€†æ‹“æ‰‘åºåˆ—å°±å­˜åœ¨ res ä¸­
            print(vertex,"çš„precursor:",precursor,"depth:",depth)
            if self.__dfs(precursor, inverse_adj, visited, res,depth+1):
                
                return True

        # èƒ½èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜æ‰€æœ‰çš„å‰é©±ç»“ç‚¹éƒ½è®¿é—®å®Œäº†ï¼Œæ‰€ä»¥å¯ä»¥è¾“å‡ºäº†
        # å¹¶ä¸”å°†è¿™ä¸ªç»“ç‚¹çŠ¶æ€ç½®ä¸º 1
        visited[vertex] = 1
        print("ç¬¬4æ­¥vertex:",vertex,"visited:", visited," depth:",depth)
        # å…ˆæŠŠ vertex è¿™ä¸ªç»“ç‚¹çš„æ‰€æœ‰å‰é©±ç»“ç‚¹éƒ½è¾“å‡ºä¹‹åï¼Œå†è¾“å‡ºè‡ªå·±
        res.append(vertex)
        print("visitedç½®ä¸º1å,resæ‰èƒ½append:",res,"depth:",depth)
        # æœ€åä¸è¦å¿˜è®°è¿”å› False è¡¨ç¤ºæ— ç¯
        return False
```

```py
# æ€è·¯1ï¼šæ‹“æ‰‘æ’åºã€‚æ„å»ºçš„é‚»æ¥è¡¨å°±æ˜¯æˆ‘ä»¬é€šå¸¸è®¤è¯†çš„é‚»æ¥è¡¨ï¼Œæ¯ä¸€ä¸ªç»“ç‚¹å­˜æ”¾çš„æ˜¯åç»§ç»“ç‚¹çš„é›†åˆã€‚

# è¯¥æ–¹æ³•çš„æ¯ä¸€æ­¥æ€»æ˜¯è¾“å‡ºå½“å‰æ— å‰è¶‹ï¼ˆå³å…¥åº¦ä¸ºé›¶ï¼‰çš„é¡¶ç‚¹ã€‚

# ä¸ºé¿å…æ¯æ¬¡é€‰å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹æ—¶æ‰«ææ•´ä¸ªå­˜å‚¨ç©ºé—´ï¼Œå¯è®¾ç½®ä¸€ä¸ªé˜Ÿåˆ—æš‚å­˜æ‰€æœ‰å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹ã€‚

# å…·ä½“åšæ³•å¦‚ä¸‹ï¼š

# 1ã€åœ¨å¼€å§‹æ’åºå‰ï¼Œæ‰«æå¯¹åº”çš„å­˜å‚¨ç©ºé—´ï¼Œå°†å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹å‡å…¥é˜Ÿåˆ—ã€‚

# 2ã€åªè¦é˜Ÿåˆ—éç©ºï¼Œå°±ä»é˜Ÿé¦–å–å‡ºå…¥åº¦ä¸º 0 çš„é¡¶ç‚¹ï¼Œå°†è¿™ä¸ªé¡¶ç‚¹è¾“å‡ºåˆ°ç»“æœé›†ä¸­ï¼Œå¹¶ä¸”å°†è¿™ä¸ªé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥ç‚¹çš„å…¥åº¦å‡ 1ï¼Œ

# åœ¨å‡ 1 ä»¥åï¼Œå‘ç°è¿™ä¸ªé‚»æ¥ç‚¹çš„å…¥åº¦ä¸º 0 ï¼Œå°±ç»§ç»­å…¥é˜Ÿã€‚

# æœ€åæ£€æŸ¥ç»“æœé›†ä¸­çš„é¡¶ç‚¹ä¸ªæ•°æ˜¯å¦å’Œè¯¾ç¨‹æ•°ç›¸åŒå³å¯ã€‚

# Python ä»£ç ï¼š

class Solution(object):
    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int è¯¾ç¨‹é—¨æ•°
        :type prerequisites: List[List[int]] è¯¾ç¨‹ä¸è¯¾ç¨‹ä¹‹é—´çš„å…³ç³»
        :rtype: bool
        """
        # è¯¾ç¨‹çš„é•¿åº¦
        clen = len(prerequisites)
        if clen == 0:
            # æ²¡æœ‰è¯¾ç¨‹ï¼Œå½“ç„¶å¯ä»¥å®Œæˆè¯¾ç¨‹çš„å­¦ä¹ 
            return [i for i in range(numCourses)]
        # å…¥åº¦æ•°ç»„ï¼Œä¸€å¼€å§‹å…¨éƒ¨ä¸º 0
        in_degrees = [0 for _ in range(numCourses)]
        # é‚»æ¥è¡¨
        adj = [set() for _ in range(numCourses)]
        # æƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºä»–ä»¬: [0,1]
        # 1 -> 0ï¼Œè¿™é‡Œè¦æ³¨æ„ï¼šä¸è¦å¼„åäº†
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)

        # print("in_degrees", in_degrees)
        # é¦–å…ˆéå†ä¸€éï¼ŒæŠŠæ‰€æœ‰å…¥åº¦ä¸º 0 çš„ç»“ç‚¹åŠ å…¥é˜Ÿåˆ—
        res = []
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)

        while queue:
            top = queue.pop(0)
            res.append(top)

            for successor in adj[top]:
                in_degrees[successor] -= 1
                if in_degrees[successor] == 0:
                    queue.append(successor)
        if len(res) != numCourses:
            return []
        return res

# bfs å€ŸåŠ©é˜Ÿåˆ—å®ç°æ‹“æ‰‘æ’åº
from collections import deque
class Solution:
    def findOrder(self, numCourses, prerequisites):
        # å»ºå›¾ï¼Œä»¥é‚»æ¥è¡¨å­˜å‚¨
        def buildGraph(numCourses, prerequisites):
            graph = []  # é‚»æ¥è¡¨
            indeg = [0] * numCourses  # å…¥åº¦è¡¨

            for i in range(numCourses):  # ç›´æ¥[[]]*numCourseså»ºè¡¨æœ‰é—®é¢˜
                graph.append([])
            for side in prerequisites:
                a, b = side[1], side[0]  # ä¾èµ–å…³ç³»bä¾èµ–aï¼Œå°±æ˜¯a->b
                graph[a].append(b)
                indeg[b] += 1

            return graph, indeg

        graph, indeg = buildGraph(numCourses, prerequisites)
        res = []
        # print(graph)
        # print(indeg)
        
        # å°†æ‰€æœ‰å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­
        queue = deque()
        for i in range(numCourses):
            if indeg[i] == 0:
                queue.append(i)

        while queue:
            # é˜Ÿé¦–èŠ‚ç‚¹å‡ºé˜Ÿï¼Œæ”¾å…¥ç­”æ¡ˆä¸­
            node = queue.popleft()
            res.append(node)
            # å°†è¯¥èŠ‚ç‚¹ç›¸é‚»èŠ‚ç‚¹å…¥åº¦-1
            for neighbor in graph[node]:
                indeg[neighbor] -= 1
                # ç›¸é‚»èŠ‚ç‚¹å…¥åº¦ä¸º 0 åˆ™å…¥é˜Ÿ
                if indeg[neighbor] == 0:
                    queue.append(neighbor)

        if len(res) != numCourses:  # å¦‚æœæ‹“æ‰‘æ’åºæ²¡æ’å®Œï¼Œåˆ™è¯´æ˜æœ‰ç¯ï¼Œè¿”å›ç©º
            return []
        return res

class Solution:
    def findOrder(self, numCourses, prerequisites):
        # å­˜å‚¨æœ‰å‘å›¾
        edges = collections.defaultdict(list)
        # å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦
        indeg = [0] * numCourses
        # å­˜å‚¨ç­”æ¡ˆ
        result = list()

        for info in prerequisites:
            edges[info[1]].append(info[0])
            indeg[info[0]] += 1
        
        # å°†æ‰€æœ‰å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­
        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])

        while q:
            # ä»é˜Ÿé¦–å–å‡ºä¸€ä¸ªèŠ‚ç‚¹
            u = q.popleft()
            # æ”¾å…¥ç­”æ¡ˆä¸­
            result.append(u)
            for v in edges[u]:
                indeg[v] -= 1
                # å¦‚æœç›¸é‚»èŠ‚ç‚¹ v çš„å…¥åº¦ä¸º 0ï¼Œå°±å¯ä»¥é€‰ v å¯¹åº”çš„è¯¾ç¨‹äº†
                if indeg[v] == 0:
                    q.append(v)

        if len(result) != numCourses:
            result = list()
        return result

# å†™äº†ä¸ªpython 3 ï¼Œå¹¿åº¦ä¼˜å…ˆçš„ï¼ŒåŠ äº†æ¯ä¸€å¥çš„æ³¨é‡Šï¼Œä»…ä¾›å‚è€ƒ

class Solution:
    def findOrder(self, numCourses, prerequisites):
        p = prerequisites
        # æ‰€æœ‰è¯¾ç¨‹æ²¡æœ‰å…ˆåé¡ºåºï¼Œè¿™é‡Œæˆ‘è¯»é¢˜ä¸€å¼€å§‹æ²¡ç†è§£
        if p == []:
            return [i for i in range(numCourses)]

        from collections import defaultdict, deque
        go = defaultdict(list)
        # come=defaultdict(list) é€†å‘é‚»æ¥è¡¨ï¼Œæœ¬ä¾‹ä¸éœ€è¦
        # è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦
        rudu = defaultdict(int)
        # è®°å½•æ‰€æœ‰prerequisites å‡ºç°çš„è¯¾ç¨‹
        total = set()
        # è¿™ä¸ªé›†åˆä¸­å­˜ç€æ‰€æœ‰éœ€è¦å‰å¯¼è¯¾çš„è¯¾ç¨‹å·
        you = set()

        for i in p:

            a, base = i
            # ç”±åŸºç¡€è¯¾base èƒ½å¤Ÿåˆ°è¾¾çš„a
            go[base].append(a)
            # come[a].append(base)  æœ¬ä¾‹ä¸éœ€è¦
            # è¿›å…¥å¹¶å»é‡
            total.add(a)
            total.add(base)

            rudu[a] += 1
            # åªè¦æœ‰å…¥åº¦å°±æ˜¯æœ‰å‰å¯¼è¯¾
            you.add(a)

        # æ‰€æœ‰å¿…é¡»å­¦ä¹ çš„è¯¾
        first = set([j for j in range(numCourses)])
        # æ‰¾åˆ°é‚£äº›ä¸å…¶ä»–è¯¾ç¨‹æ— å…³çš„è¯¾ï¼Œå…ˆå­¦ä¹ äº†ã€‚ff æ˜¯é›†åˆ
        ff = first - total
        ans = [g for g in ff]

        # æ„å»ºäº†é‚»æ¥è¡¨ï¼Œå…¥åº¦å­—å…¸ï¼Œä¸‹é¢å¼€å§‹æ‹“æ‰‘æ’åº
        #====================================
        # æ‰¾åˆ°å…¥åº¦ä¸º0 çš„è¯¾ç¨‹ï¼Œä»–ä»¬æ˜¯å…¶ä»–è¯¾ç¨‹çš„å‰å¯¼è¯¾ï¼Œc æ˜¯ä¸€ä¸ªé›†åˆ
        c = total - you
        # å‰å¯¼è¯¾åŠ å…¥deque
        q = deque(c)
        while q:

            # å…¥åº¦ä¸º0ï¼Œæ‹¿å‡ºæ¥
            x = q.popleft()
            ans.append(x)
            # éå†æ‰€æœ‰ä»¥x ä¸ºå‰å¯¼è¯¾çš„è¯¾
            xlist = go[x]
            for j in xlist:

                # å…¥åº¦å‡å»ä¸€
                rudu[j] -= 1
                # å‘ç°å…¥åº¦==0 ï¼Œè¿›å…¥é˜Ÿåˆ—
                if rudu[j] == 0:
                    q.append(j)

        return ans if len(ans) == numCourses else []
       
class Solution:
    def findOrder(self, numCourses, prerequisites):
        ##åˆ›å»ºå…¥åº¦çš„åˆ—è¡¨ï¼Œç´¢å¼•å¯¹åº”èŠ‚ç‚¹ç¼–å·ï¼Œè‹¥ç´¢å¼•ä¸èƒ½å¯¹åº”èŠ‚ç‚¹ç¼–å·ï¼Œéœ€è¦åˆ›å»ºå­—å…¸
        indegree = [0]*numCourses
        for i in range(len(prerequisites)):
            indegree[prerequisites[i][0]] += 1
        queue = [] ##å­˜æ”¾å…¥åº¦ä¸º0çš„èŠ‚ç‚¹
        for i in range(numCourses):
            if indegree[i] == 0:
                queue.append(i)
        ret = [] ##æŒ‰é¡ºåºå­˜æ”¾èŠ‚ç‚¹
        while len(queue) != 0:
            cur = queue.pop(0) ##å‡ºé˜Ÿå…¥åº¦ä¸º0çš„èŠ‚ç‚¹
            ret.append(cur)
            for edge in prerequisites:
                if edge[1] == cur:
                    indegree[edge[0]] -= 1 ##æ›´æ–°èŠ‚ç‚¹çš„å…¥åº¦
                    if indegree[edge[0]] == 0:
                        queue.append(edge[0]) ##å°†å…¥åº¦ä¸º0çš„èŠ‚ç‚¹å…¥é˜Ÿ
        return ret if len(ret) == numCourses else [] #è‹¥ç»“æœåˆ—è¡¨ä¸ªæ•°ä¸ç­‰äºè¯¾ç¨‹æ•°ï¼Œè¡¨ç¤ºå­˜åœ¨ç¯
```

```py
# æ‹“æ‰‘æ’åºkhanç®—æ³•çš„py/go/rsä¸‰è¯­è¨€å®ç°

class Solution:
    def findOrder(self, numCourses, prerequisites):
        t = [0] * numCourses
        d = [[] for _ in range(numCourses)]
        for i, j in prerequisites:
            t[i] += 1
            d[j].append(i)
        ans = [i for i, j in enumerate(t) if not j]
        for i in ans:
            for j in d[i]:
                t[j] -= 1
                not t[j] and ans.append(j)
        return len(ans) == numCourses and ans or []
```

```scala

import scala.collection.mutable.ArrayBuffer
// ä¸lc207ç±»ä¼¼ï¼Œä¸è¿‡è¦ç»™å‡ºé¡ºåº

  object Solution {
    def findOrder(numCourses: Int, prerequisites: Array[Array[Int]]): Array[Int] = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //å¿…é¡»åˆå§‹åŒ–

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      val ans = ArrayBuffer[Int]()
      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        ans += cur
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum match {
        case canFinshNum if canFinshNum == numCourses => ans.toArray
        case _ => Array()
      }
    }
  }

```

###  1.89. <a name='AddandSearchWord'></a>211 Add and Search Word

[å°æ˜](https://www.bilibili.com/video/BV1x5411a77S?spm_id_from=333.999.0.0)

###  1.90. <a name='WordSearchII'></a>212. ã€æ„é€ ğŸ° + å›°éš¾ã€‘Word Search II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV184411d7i9?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1vi4y1G7NQ?spm_id_from=333.999.0.0)

```py
from collections import  defaultdict
class TrieNode:
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.isWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            r = r.children[c]
        r.isWord = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r.children:
                return False
            r = r.children[c]
        return r.isWord

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r.children:
                return False
            r = r.children[c]
        return True
```

```py
from collections import defaultdict


class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""

    def insert(self, word):
        cur = self
        for c in word:
            cur = cur.children[c]
        cur.is_word = True
        cur.word = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie = Trie()
        for word in words:
            trie.insert(word)
		
        def dfs(tries, x, y):
            # é€’å½’çš„ç»“æŸï¼štries.childrenä¸èƒ½ç«™åœ¨boardä¸Š
            if board[x][y] not in tries.children:
                return
            # é€’å½’çš„å¼€å§‹ï¼šæœ‰ä¸€ä¸ªtries.childrenèƒ½ç«™åœ¨boardä¸Šï¼Œé‚£å°±æ˜¯å°c
            char = board[x][y]
            
            # é€’å½’çš„æ‰¾åˆ°ç›®æ ‡: å°±æ˜¯charSonï¼Œåªæœ‰charSonæ‰èƒ½åˆ¤æ–­æ˜¯å¦æ˜¯ä¸ªå•è¯
            charSon = tries.children[char]
            if charSon.word:
                res.append(charSon.word)
                charSon.word = "" # æŠŠå•è¯åˆ æ‰
                
            # æ‰¾åˆ°/æ²¡æœ‰æ‰¾åˆ°é€’å½’çš„ç›®æ ‡: å°±æ˜¯charSonçš„Son
            if charSon.children:
                board[x][y] = "#" # æŠŠcharSonçš„fatherèµ°è¿‡çš„è·¯å¾„åˆ æ‰,é¿å…é‡å¤
                for newX, newY in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:
                    if 0 <= newX < m and 0 <= newY < n:
                        dfs(charSon, newX, newY)
                board[x][y] = char # æŠŠcharSonçš„fatherèµ°è¿‡çš„è·¯å¾„æ¢å¤

            # æ²¡æœ‰æ‰¾åˆ°é€’å½’çš„ç›®æ ‡: char å°±æ˜¯èµ°ä¸é€šçš„ï¼Œcharæ€æ­»
            if not charSon.children:
                tries.children.pop(char)

        res = []
        m, n = len(board), len(board[0])

        for i in range(m):
            for j in range(n):
                dfs(trie, i, j)

        return res
```


```py
è¿™ä¸ªç­”æ¡ˆä¸ºä»€ä¹ˆä¸å¯¹å‘¢ï¼Ÿï¼Ÿ
# å¦‚æœæŠŠæ–¹å‘æ¢æˆ[[0,1], [1,0], [0,-1], [-1,0]]è¿‡ä¸äº†ï¼š

# [["a","b","e"],["b","c","d"]]
# ["abcdeb"]

# å…ˆæ£€ç´¢abcï¼ˆbç”¨[0,1]ï¼‰ä¼šè®°å½•è¿™ä¸ªç»“æœä¸ç¬¦åˆï¼Œå†æ£€ç´¢abcï¼ˆbç”¨[1,0]ï¼‰ä¼šç›´æ¥åˆ¤æ–­ä¸è¡Œ, lru_cacheæ²¡æ³•å¤„ç†visitedçš„å·®å¼‚


class Solution:

    def __init__(self):
        self.mark = set()

    def findWords(self, board: [[str]], words: [str]) -> [str]:
        m, n = len(board), len(board[0])
        res = set()
        @lru_cache(None)
        def dfs(x, y, ans):
            if ans in words:
                res.add(ans)
                return
            # å¯¹äºè¿™æ ·ä¸€ä¸ªcaseï¼Œè¿˜æ˜¯åº”è¯¥è¦ç»§ç»­çš„
            # [["o","a","b","n"],["o","t","a","e"],["a","h","k","r"],["a","f","l","v"]]
            # ["oa","oaa"]        
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                if 0 <= x + dx < m and 0 <= y + dy < n and (x + dx, y + dy) not in self.mark:
                    self.mark.add((x + dx, y + dy))
                    dfs(x + dx, y + dy, ans + board[x + dx][y + dy])
                    self.mark.remove((x + dx, y + dy))
        for i in range(m):
            for j in range(n):
                self.mark = set(board[i][j])
                dfs(i, j, board[i][j])
        return list(res)

if __name__ == "__main__":     
    s = Solution()
    board = [["a","b","c","e"],["z","z","d","z"],["z","z","c","z"],["z","a","b","z"]]
    words = ["abcdce"]
    print(s.findWords(board, words))
```

```scala

/**
* chosen solution
* tries + dfs + pruning
* memo
*   1. put all words into tries which is implemented by hashmap
*   2. DFS way searching all char in board composing a word and searching whether the word exists in tries
*   3. in dfs, we directly input the node from tries instead of tries itself 
*   4. pruning an edge after matching a word and its children couldn't represent a word
*/
import scala.collection.mutable
case class Node(next: mutable.Map[Char, Node] = mutable.Map.empty, var isWord: Boolean = false){
  def apply(char: Char): Option[Node] = next.get(char)
  def update(char: Char, node: Node): Unit = next(char) = node
}

class Tries(){
  val root = Node()
  def insert(word: String): Unit = {
    var node = root
    word.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined
  def search(word: String): Boolean =  searchUtil(word).exists(_.isWord)

  def searchUtil(s: String): Option[Node] = {
    var node = root
    s.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }
}


object Solution0 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
* tries + dfs + pruning
* memo
*   1. a seenBoard to record which position was visited 
* time complexity: 
* 
*/

object Solution1-1 {
  val result = scala.collection.mutable.Set[String]()

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for{
      row <- board.indices
      col <- board(0).indices
    }{
      _dfs(board, Array.ofDim[Boolean](board.length, board(0).length), tries, "", (row, col))
    }

    result.toList
  }

  private def _dfs(board: Array[Array[Char]], seenBoard:Array[Array[Boolean]], tries: Trie, currentPrefix: String, currentIdx: (Int, Int)) {
    val (row, col) = currentIdx
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    if(tries.startsWith(newPrefix)){
      seenBoard(row)(col) = true
      getNextPosition(currentIdx, seenBoard).foreach{idx =>
        _dfs(board, seenBoard.map(_.clone()), tries, newPrefix, idx)
      }
    }
  }

  private def getNextPosition(currentIdx: (Int, Int), seenBoard: Array[Array[Boolean]]): Array[(Int, Int)] = {

    def check(row: Int, col: Int): Boolean = {
      if(row >= seenBoard.length || row < 0 || col >= seenBoard(0).length || col < 0 || seenBoard(row)(col))  false
      else true
    }
    val (row, col) = currentIdx
    val result = scala.collection.mutable.ArrayBuffer[(Int, Int)]()

    for{
      i <- -1 to 1
      j <- -1 to 1
    }{
      if((math.abs(i) + math.abs(j) == 1) && check(row + i, col + j)) result.append((row + i, col + j))
    }
    result.toArray
  }
}

/**
* simplify : without seen matrix
*/

object Solution1-2 {

  val result = scala.collection.mutable.Set[String]()
  private val inBounds = (shape: (Int, Int)) => (coord: (Int, Int)) => coord._1 < shape._1 && coord._1 >= 0 && coord._2 < shape._2 && coord._2 >= 0
  private val getNeighbors = (coord: (Int, Int), filter: ((Int, Int)) => Boolean) => {
    List(
      (coord._1 + 1, coord._2),
      (coord._1, coord._2 + 1),
      (coord._1 - 1, coord._2),
      (coord._1, coord._2 - 1)
    ).filter(filter)
  }

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for {
      row <- board.indices
      col <- board(0).indices
    } {
      _dfs(board, tries, "", (row, col))
    }
    result.toList
  }

  private def _dfs(board: Array[Array[Char]], tries: Trie, currentPrefix: String, coord: (Int, Int)) {

    val (row, col) = coord
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    val c = board(row)(col)
    board(row)(col) = '#'
    if (tries.startsWith(newPrefix)) {

      getNeighbors(coord, inBounds((board.length, board.head.length))(_))
        .foreach {
          case (nr, nc) if board(nr)(nc) != '#' =>
            _dfs(board, tries, newPrefix, (nr, nc))
          case _ =>
        }
    }
    board(row)(col) = c
  }
}


object Solution1-3 {
  private val visitedLabel = '#'
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Trie()
    words.foreach(tries.insert)
    dfs(tries, board)
  }


  def dfs(tries: Trie, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int) ,prePrefix: String, board: Array[Array[Char]], ret: scala.collection.mutable.HashSet[String]): Unit = {
      val currentChar =  board(coord._1)(coord._2)
      val newPrefix = prePrefix + currentChar
      if(tries.search(newPrefix)) ret += newPrefix
      /* pruning */
      if(tries.startsWith(newPrefix)){
        board(coord._1)(coord._2) = visitedLabel
        getAvailableCoords(coord, (board.length, board(0).length)).foreach {
          case (r, c) if board(r)(c) != visitedLabel => _dfs((r, c), newPrefix, board, ret)
          case _ =>
        }
        board(coord._1)(coord._2) = currentChar
      }
    }

    val coords = for(i <- board.indices; j <- board(0).indices) yield (i, j)
    val ret = scala.collection.mutable.HashSet[String]()
    coords.foreach(coord => _dfs(coord, "", board, ret))
    ret.toList

  }

  private val getAvailableCoords = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row, col + 1),
      (row - 1, col),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 &&  0 <= c && c < shape._2}
  }
}




object Solution2 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


```

###  1.91. <a name='HouseRobberII213-II'></a>213.ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ House Robber II 213-æ‰“å®¶åŠ«èˆII

[18:13 èŠ±èŠ±é…± DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Ea4y147oh?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1GD4y1d7DS?spm_id_from=333.999.0.0)

```py
# dp[i] = max(dp[i-2] + nums[i], dp[i-1])
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        # æ˜“é”™ç‚¹ï¼šæ³¨æ„ç‰¹æ®Šæƒ…å†µ
        if n <= 2:
            return max(nums)

        dp1 = [0] * (n - 1)
        dp1[0] = nums[0]
        dp1[1] = max(nums[1],nums[0])
        for i in range(2, n - 1):
            dp1[i] = max(dp1[i-2] + nums[i], dp1[i-1])

        dp2 = [0] * (n - 1)
        dp2[0] = nums[1]
        dp2[1] = max(nums[1],nums[2])
        # æ˜“é”™ç‚¹ï¼šæ³¨æ„ï¼Œæ ¹æ®é€’æ¨å¼ï¼Œè¿™é‡Œä¸æ˜¯ï¼Œdp2[1] = nums[2]
        for i in range(2, n - 1):
            dp2[i] = max(dp2[i-2] + nums[i + 1], dp2[i-1])

        return max(dp1[-1],dp2[-1])

# æ ¸å¿ƒåŸåˆ™å°±æ˜¯ï¼šç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä¸èƒ½åŒæ—¶æŠ¢ã€‚ 
# æ‰€ä»¥ï¼šè¦ä¹ˆä¸æŠ¢ç¬¬ä¸€ä¸ªï¼Œè¦ä¹ˆä¸æŠ¢æœ€åä¸€ä¸ªã€‚ 
# æ³¨æ„ï¼Œä¸æŠ¢ç¬¬ä¸€ä¸ªçš„æ—¶å€™ï¼Œæœ€åä¸€ä¸ªå¯æŠ¢å¯ä¸æŠ¢ï¼›
# å¦ä¸€ç§æƒ…å†µåŒç† å–ä¸¤ç§æƒ…å†µä¸­çš„æœ€å¤§å€¼

é™ç»´ä»¥åï¼š

# dp[i] = max(dp[i-2] + nums[i], dp[i-1])
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        # æ˜“é”™ç‚¹ï¼šæ³¨æ„ç‰¹æ®Šæƒ…å†µ
        if n <= 2:
            return max(nums)

        def robrange(start,end):
            dp0 = 0
            dp1 = nums[start]
            for i in range(start + 1,end):
                dp1, dp0 = max(dp0 + nums[i], dp1), dp1
            return dp1
        # ä¹Ÿå¯ä»¥è¿™ä¹ˆå†™ï¼š
        # def robrange(start,end):
        #     dp0 = 0
        #     dp1 = 0
        #     for num in nums[start:end]:
        #         dp1, dp0 = max(dp0 + num, dp1), dp1
        #     return dp1
        return max(robrange(0,n-1),robrange(1,n))
```

###  1.92. <a name='CombinationSumIII216-III'></a>216. Combination Sum III 216-ç»„åˆæ€»å’Œ III

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14b411u7q8?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1SC4y1a7Vy?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1gz4y1Z7CV?spm_id_from=333.999.0.0)

```py
# æšä¸¾å‰ªæï¼Œdfs()!

class Solution(object):
    def combinationSum3(self, k, n):

        def dfs(startIndex, sum, path):
            if sum==0 and len(path)==k: res.append(path)
            if sum<=0: return
            
            for j in range(startIndex, 10):
                dfs(j, sum-j, path+[j])
        
        res = []
        dfs(1, n, [])
        return res

# ç®€å•å›æº¯

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []

        def dfs(startIndex, sum, path):
            if sum < 0:
                return

            if len(path) == k and sum == 0:
                res.append(path[:])
                return

            for i in range(startIndex, 10):
                path.append(i)
                dfs(i+1, sum - i, path)
                path.pop()
                    
        dfs(1, n, [])

        return res

class Solution(object):
    def combinationSum3(self, k, n):
        """
        :type k
        :type n
        :rtype: List[List[int]]
        """
        if not k or not n:
            return []
        
        res = []         
        def dfs(k, n, tmp, start):
            if n == 0 and k == 0:
                res.append(tmp[:])
                return
            if k <= 0 or n <= 0:
                return
            
            for i in range(start, 10):
                tmp.append(i)
                dfs(k - 1, n - i, tmp, i + 1)
                tmp.pop()
                    
        dfs(k, n, [], 1)       
        return res

from typing import List
class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        self.res = []
        cur = []
        def dfs(startI, k, n, path):
            if k == 0 and n == 0:
                self.res.append(path[:])
                return 
            elif n <= 0 or k == 0:
                return 
            for i in range(startI, 10):
                path.append(i)
                dfs(i+1, k-1, n-i, path)
                path.pop()
        dfs(1, k, n, cur)
        return self.res

# é—­åŒ…ç”¨çš„æŒºå¥½ï¼Œå¦‚æœå†…å±‚å‡½æ•°ä¸æ­¢ä¸€å¤„ç”¨åˆ°çš„è¯ï¼Œä¸å»ºè®®å†™æˆå†…å±‚å‡½æ•°ï¼Œæˆ‘æ˜¯è¿™ä¹ˆè®¤ä¸ºçš„ã€‚
# æ„Ÿè§‰å¤§ä½¬ä»¬å†™çš„ä»£ç éƒ½å¥½é•¿å•Šã€‚

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        def dfs(startI:int,sums:int):
            nonlocal path
            if k == len(path):
                if sums == 0:
                    res.append(path[:])
                return
            
            if startI < 10 and sums > 0:
                #æ·»åŠ å½“å‰å…ƒç´ åˆ°ç»„åˆåºåˆ—
                path.append(startI)
                dfs(startI + 1,sums - startI)
                path.pop()
                dfs(startI + 1,sums)
        path, res = list(), list()
        dfs(1,n)
        return res
# å›æº¯çš„king

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []
        def dfs(path, startI):
            if len(path) == k and sum(path) == n:
                res.append(path)
                return
            for j in range(startI, 10):
                dfs(path+[j], j+1)
        dfs([], 1)
        return res

# è¡¥ä¸€ä¸ªpythonè§£æ³•ï¼Œå‡»è´¥98%ï¼Œä¸»è¦è¡¨ç°ä¸ºå‰ªæ

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        if n < 6: return []
        res = []
        def backtrack(num, path, k, n):
            if k == 0 and n == 0:
                res.append(path[:])
            if n < 0 or k < 0:
                return 
            for i in range(num, 10):
                if i > n:
                    break
                path.append(i)
                backtrack(i+1, path, k-1, n-i)
                path.pop()
            return 

        backtrack(1, [], k, n)
        return res

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []  #å­˜æ”¾ç»“æœé›†
        path = []  #ç¬¦åˆæ¡ä»¶çš„ç»“æœ
        def dfs(n,k,sums,startIndex):
            if sums > n: return  #å‰ªææ“ä½œ
            if sums == n and len(path) == k:  #å¦‚æœpath.size() == k ä½†sum != n ç›´æ¥è¿”å›
                return res.append(path[:])
            for i in range(startIndex,9-(k-len(path))+2):  #å‰ªææ“ä½œ
                path.append(i)
                sums += i 
                dfs(n,k,sums,i+1)  #æ³¨æ„i+1è°ƒæ•´startIndex
                sums -= i  #å›æº¯
                path.pop()  #å›æº¯
        
        dfs(n,k,0,1)
        return res

# æ¥è¿‘åŒç™¾çš„é€†å‘æ€ç»´ï¼Œå…ˆä¸€æ¬¡æ€§æ€»ç»“512ç§æ‰€æœ‰çš„æƒ…å†µï¼Œä¹‹åç­›é€‰kå’Œnç¬¦åˆçš„æƒ…å†µå°±è¡Œäº†ï¼Œå¯¹äºæƒ…å†µæœ‰é™çš„ç›´æ¥æšä¸¾è‚¯å®šæœ€å¿«

class Solution(object):
    def combinationSum3(self, k, n):
        def combine(n):
            if n==1:
                return [[1],[]]
            else:
                temp = combine(n-1)
                return [x+[n] for x in temp]+temp
        lookup = combine(9)
        res = combine(n)[]
        for path in lookup:
            if len(path)==k and sum(path)==n:
                res += [path]
        return res
```

###  1.93. <a name='ContainsDuplicate'></a>217. Contains Duplicate

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1ab411H7Zw?spm_id_from=333.999.0.0)

```py
ç®€å•é¢˜ã€‚ã€‚ã€‚æˆ‘è§‰å¾—æˆ‘åˆè¡Œäº†

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(nums) != len(set(nums))

äººç”Ÿè‹¦çŸ­ï¼Œæˆ‘ç”¨Python

class Solution:
    def containsDuplicate(self, nums):
        return len(nums) - len(set(nums)) > 0

æˆ‘ç«Ÿç„¶è‡ªå·±æƒ³å‡ºæ¥äº†è¿™ç§åäººç±»çš„ç©æ„å„¿ pythonï¼š

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) < len(nums)
è°è¿˜ä¸ä¼šä¸€è¡Œå‘¢

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return not (len(nums)==len(set(nums)))
```


```py
ç”¨å“ˆå¸Œè¡¨å­˜æ”¾å…ƒç´ ï¼Œéå†nums

ï¼ˆ1ï¼‰å¦‚æœæ•°å­—ä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¯´æ˜è¯¥æ•°å­—ç¬¬ä¸€æ¬¡å‡ºç°ï¼Œå“ˆå¸Œè¡¨åŠ å…¥è¯¥æ•°å­—

ï¼ˆ2ï¼‰å¦‚æœæ•°å­—å­˜åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¯´æ˜è¯¥æ•°å­—ç¬¬äºŒæ¬¡å‡ºç°ï¼Œç›´æ¥è¿”å›False

å¦‚æœéå†å®Œäº†ï¼Œè¯´æ˜æ‰€æœ‰æ•°å­—éƒ½åªå‡ºç°ä¸€æ¬¡ï¼Œé‚£ä¹ˆè¿”å›True

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        numSet = set()
        for i in nums:
            if i in numSet:
                return True
            else:
                numSet.add(i)
        return False
```

```scala
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        var hashSet = scala.collection.mutable.HashSet.empty[Int]
        import scala.util.control.Breaks._
        var flag = false
        breakable{
            for(num <- nums){
                if(hashSet.contains(num)){
                        flag = true
                        break
                    }else{
                    hashSet.add(num)
                }
                }
            }
        flag
        }
    }
    
  
//Alternate (SCALA) solution
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        return nums.distinctBy(_.self).length != nums.length
    }
}

```

###  1.94. <a name='TheSkylineProblem'></a>218. The Skyline Problem

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1hb411c7Q4?spm_id_from=333.999.0.0)

###  1.95. <a name='ContainsDuplicateII'></a>219. Contains Duplicate II

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7ga?spm_id_from=333.999.0.0)

###  1.96. <a name='ContainsDuplicateIII'></a>220 Contains Duplicate III

[å°æ˜](https://www.bilibili.com/video/BV19h41197iw?spm_id_from=333.999.0.0)

###  1.97. <a name='-1'></a>221-ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘æœ€å¤§æ­£æ–¹å½¢

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1XT4y137Gq?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV16K411575r?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1mA411q7Sw?spm_id_from=333.999.0.0)

```py
# å³ä¸‹è§’çš„åæ ‡ä¸º(x, y) ï¼Œé‚£ä¹ˆ(x - 1, y - 1)ä¸€å®šéœ€è¦æ˜¯ä¸€ä¸ªsquareï¼Œ
# å¹¶ä¸”è¯¥ç‚¹çš„å·¦è¾¹å…¨ä¸º1ï¼Œä¸Šè¾¹ä¹Ÿä¸º1ï¼ŒæŒ‰ç…§è¿™ä¸ªè¿›è¡Œç†è§£å˜é•¿çš„å¢åŠ ã€‚
æ„å»ºdpï¼š
class Solution:
    def maximalSquare(self, matrix):
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * n for _ in range(m)]
        maxEdge = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                    maxEdge = max(dp[i][j], res)
        return maxEdge * maxEdge

åŸåœ°ä¿®æ”¹ï¼š
class Solution:
    def maximalSquare(self, matrix):
        maxEdge = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                if i and j: # è¿™ä¸ªå†™æ³•å¦™å•Šï¼Œåˆšå¥½å°±è·³è¿‡äº† i-1
                    if matrix[i][j] == "1":
                        matrix[i][j] = min(int(matrix[i-1][j-1]), int(matrix[i][j-1]), int(matrix[i-1][j])) + 1
                    else:
                        matrix[i][j] = 0
                maxEdge = max(maxEdge,int(matrix[i][j]))
        return maxEdge**2       
```

###  1.98. <a name='CountCompleteTreeNodes'></a>222. Count Complete Tree Nodes

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1n44y1E73D?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Qz411i7bh?spm_id_from=333.999.0.0)

ä¸¤ç§é€’å½’

```py
class Solution(object):
    def countNodes(self, root):
        if root == None:
        	return 0
        if root.left == None and root.right == None:
        	return 1
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)

class Solution(object):
    def countNodes(self, root):
        if not root:
            return 0
        lh, rh = self.getHeight(root.left), self.getHeight(root.right)
        if lh == rh:  # å·¦å³å­æ ‘é«˜åº¦ç›¸åŒï¼Œè¯´æ˜å·¦å­æ ‘å¿…æ»¡ åˆ™èŠ‚ç‚¹æ•°=å·¦å­æ ‘èŠ‚ç‚¹ + rootèŠ‚ç‚¹(=1) + é€’å½’æ‰¾å³å­æ ‘
            return (pow(2, lh) - 1) + 1 + self.countNodes(root.right)
        else:  # å·¦å­æ ‘æ¯”å³å­æ ‘é«˜ï¼Œè¯´æ˜å³å­æ ‘å¿…æ»¡ åŒç†
            return (pow(2, rh) - 1) + 1 + self.countNodes(root.left)

    def getHeight(self, root):
        ret = 0
        while root:
            ret += 1
            root = root.left
        return ret
# ç›¸å¯¹æ¥è¯´ï¼Œé€’å½’æ³•åˆ©ç”¨å…¬å¼æ›´å®¹æ˜“ç†è§£ï¼š
# æ—¢ç„¶è¯´äº†æ˜¯ complete binary treeï¼Œé‚£ä¹ˆå¿…ç„¶æœ‰ç‰¹æ€§å¯ç”¨ï¼Œ
# complete binary treeçš„ç‰¹æ€§æ˜¯é™¤äº†æœ€åä¸€å±‚ï¼Œä¹‹å‰çš„å°±æ˜¯perfect tree.
```

```py
# å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨{æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯æ»¡äºŒå‰æ ‘}ï¼Œ 
# é¦–å…ˆä»æ ¹èŠ‚ç‚¹å¼€å§‹è®¡ç®—å·¦å³å­æ ‘çš„é«˜åº¦ï¼Œå¦‚æœç›¸ç­‰åˆ™ä¸ºæ»¡äºŒå‰æ ‘ï¼Œç›´æ¥è¿”å› 
# å¦åˆ™é€’å½’è®¡ç®—å·¦å³å­æ ‘ 
# Noteï¼šä¹ä¸€çœ‹æ—¶é—´å¤æ‚åº¦ä¸ºO(N*logN)ï¼Œ
# ä½†æ˜¯æ ¹æ®å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨,å…¶å­æ ‘ä¸­è‡³å°‘æœ‰ä¸€ä¸ªæ»¡äºŒå‰æ ‘ï¼Œ
# æ‰€ä»¥åªä¼šæœ‰ä¸€ä¸ªé€’å½’ä¼šæ­£çœŸçš„æ‰§è¡Œä¸‹å» 
# æŸ¥æ‰¾æ·±åº¦çš„æ—¶é—´å¤æ‚åº¦ä¸ºlogN,é€’å½’çš„æ·±åº¦ä¸ºO(logN)ï¼Œ
# æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(logN * logN)

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        left = right = 0
        tmp1 = tmp2 =  root

        # æ±‚å‡ºæ ‘çš„æ·±åº¦
        while tmp1:
            left += 1
            tmp1 = tmp1.left
        while tmp2:
            right += 1
            tmp2 = tmp2.right

        # åˆ©ç”¨æ ‘çš„æ·±åº¦
        if left == right:
            return 2 ** left - 1
        else:
            return 1 + self.countNodes(root.left) + self.countNodes(root.right)  #æ ¹æ®å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨ï¼Œè¿™ä¸¤åœ°é€’å½’çœŸæ­£æ‰§è¡Œçš„åªæœ‰ä¸€ä¸ª


# æ‰€ä»¥å¯»æ‰¾å·¦å­æ ‘çš„æœ€å·¦è¾¹çš„é«˜åº¦å’Œå³å­æ ‘çš„æœ€å³è¾¹çš„nodeé«˜åº¦ï¼Œ
# å¦‚æœç›¸åŒå°±æ˜¯perfect treeï¼Œé«˜åº¦2^h - 1ï¼Œ å¦åˆ™é€’å½’çš„æ¥çœ‹å·¦å­æ ‘å’Œå³å­æ ‘

class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root == None:
        	return 0
        
        p, q = root,root

        leftHeight = 0
        rightHeight = 0

        while p:
        	p = p.left
        	leftHeight += 1

        while q:
        	q = q.right
        	rightHeight += 1

        if leftHeight == rightHeight:
        	return (int)(math.pow(2,leftHeight) - 1)
        else:
        	return 1 + self.countNodes(root.left) + self.countNodes(root.right)



# æˆ‘éšä¾¿å†™äº†å†™ï¼Œè¿˜å‡†å¤‡ä¿®æ”¹ï¼Œæ²¡æƒ³åˆ°ä¸€æäº¤å•ªå°±é€šè¿‡äº†ï¼Œå¾ˆå¿«å•Šï¼

class Solution(object):
    def countNodes(self, root):
        if not root: return 0
        depth=0
        
        def getDepth(root):
            nonlocal depth
            depth += 1
            if root.left:
                getDepth(root.left)
            else:
                return
            
        getDepth(root)
        ans=2**(depth-1)-1
        
        def dfs(node,path):
            nonlocal ans
            path.append(node)
            if node.left:
                dfs(node.left,path)
            if node.right:
                dfs(node.right,path)
            if not node.left and not node.right:
                if len(path)==depth:
                    ans+=1
            path.pop()
            
        dfs(root,[])
        return ans
```

###  1.99. <a name='RectangleArea'></a>223. Rectangle Area

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Ck4y1z7Hp?spm_id_from=333.999.0.0)

```py
class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        def overlapLength(a1, a2, b1, b2) -> int:
            return max(min(a2, b2) - max(a1, b1), 0)

        overlap = overlapLength(ax1, ax2, bx1, bx2) * overlapLength(ay1, ay2, by1, by2)

        areaA = (ax2 - ax1) * (ay2 - ay1)

        areaB = (bx2 - bx1) * (by2 - by1)

        return areaA + areaB - overlap
```

```py
class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        
        xx1 = max(ax1,bx1)
        yy1 = min(ay2,by2)
        xx2 = min(ax2,bx2)
        yy2 = max(ay1,by1)
        
        w = max(0,xx2- xx1)
        h = max(0,yy1 - yy2)

        area1 = (ax2- ax1) * (ay2- ay1)
        area2 = (bx2- bx1) * (by2- by1)
        return area1 + area2 -w * h

class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        area1 = (ax2 - ax1) * (ay2 - ay1)
        area2 = (bx2 - bx1) * (by2 - by1)
        overlapWidth = min(ax2, bx2) - max(ax1, bx1)
        overlapHeight = min(ay2, by2) - max(ay1, by1)
        overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0)
        return area1 + area2 - overlapArea
```

###  1.100. <a name='-1'></a>224
 
https://www.bilibili.com/video/BV1Nb4y1z7hG?from=search&seid=1882841343164929357&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.71qtf391s5w0.png" width="40%">

```py
class Solution:
    def calculate(self, s: str) -> int:
        stack = [1]
        sign = 1
        i = 0
        res = 0
        while i < len(s):
            if s[i].isdigit():
                n = 0
                while i<len(s) and s[i].isdigit():
                    n = 10*n + int(s[i])
                    i += 1
                res += sign*n
            else:
                if s[i]=='+':   sign=stack[-1]
                elif s[i]=='-': sign=-stack[-1]
                elif s[i]=='(': stack.append(sign)
                elif s[i]==')': stack.pop()
                i += 1
        return res
```

###  1.101. <a name='ImplementStackusingQueues'></a>225-ã€æ„é€ ğŸ°ã€‘Implement Stack using Queues

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1p741177pK?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ep4y1Y77j?spm_id_from=333.999.0.0)

```py



class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = collections.deque()


    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        n = len(self.queue)
        self.queue.append(x)
        for _ in range(n):
            self.queue.append(self.queue.popleft())


    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue.popleft()


    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue[0]


    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue
```

ä»¥ä¸‹ä¸¤ç§å†™æ³•ï¼Œé€Ÿåº¦æ›´å¿«ä¸€ç‚¹ç‚¹ï¼Œä½†æ˜¯å†™æ³•å¤æ‚

```py
q2å½“ä½œç¼“å­˜é˜Ÿåˆ—

class MyStack:

    def __init__(self):
        # q1å’Œq2æ˜¯ä¸¤ä¸ªé˜Ÿåˆ—
        ## ä¿è¯q1å½“ä¸­æ°¸è¿œæœ‰å…ƒç´ 
        ## ä¿è¯q2å½“ä¸­æ°¸è¿œæ²¡æœ‰å…ƒç´ 
        self.q1 = deque([])
        self.q2 = deque([])

    def push(self, x: int) -> None:
        self.q1.append(x)
        
    def pop(self) -> int:
        while len(self.q1) > 1:
            self.q2.append(self.q1.popleft())
        self.q1,self.q2 = self.q2, self.q1
        return self.q2.popleft()
        
        
    def top(self) -> int:
        return self.q1[-1]

    def empty(self) -> bool:
        return not self.q1

```

```scala
/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */


/**
* chosen solution
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack0() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}




 /**
 * my first commit
 * two queue version
 * time complexity: 
 *   push: O(1)
 *   pop: O(2n - 1)  n is the element in queue1
 *   top: O(2n - 1)
 */
class MyStack1() {

    /** Initialize your data structure here. */
    var queue1 = scala.collection.mutable.Queue[Int]()
    var queue2 = scala.collection.mutable.Queue[Int]()

    /** Push element x onto stack. */
    def push(x: Int) {
        queue1.enqueue(x)
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
       }
    
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        ret
        
    }

    /** Get the top element. */
    def top(): Int = {
        while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
        }
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        queue1.enqueue(ret)
        ret
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty && queue2.isEmpty
    }

}

/**
* two queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack2() {

   import scala.collection.mutable.Queue
    /** Initialize your data structure here. */
    var queue1 = Queue.empty[Int] 


    /** Push element x onto stack. */
    def push(x: Int) {
        val queue2 = Queue(x)
        queue2.enqueueAll(queue1.dequeueAll(_ => true))
        queue1 = queue2
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
        if(queue1.isEmpty) -1 else queue1.dequeue
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }
}

/**
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack3() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}

/**
* memo:
*   1. push entire old queue into a new queue without expanding all elements 
* time complexity:  
*     all operation are O(1) after being amortized
*   
* start  Queue()
* push1  Queue(1, Queue())
* push2  Queue(2, Queue(1, Queue()))
* push3  Queue(3, Queue(2, Queue(1, Queue())))
* push4  Queue(4, Queue(3, Queue(2, Queue(1, Queue()))))
* pop    Queue(3, Queue(2, Queue(1, Queue())))
* pop    Queue(2, Queue(1, Queue()))
*/

class MyStack4() {
  import scala.collection.mutable
  /** Initialize your data structure here. */
  var queue: mutable.Queue[Any] = mutable.Queue.empty[Any]

  /** Push element x onto stack. */
  def push(x: Int) {
    val queue2: mutable.Queue[Any] = mutable.Queue(x)
    queue2.enqueue(queue)
    queue = queue2

  }
  /** Removes the element on top of the stack and returns that element. */
  def pop(): Int = {

    if(queue.isEmpty) -1 else {
      val ret = queue.dequeue.asInstanceOf[Int]
      queue = queue.dequeue.asInstanceOf[mutable.Queue[Any]]
      ret
    }
  }
  /** Get the top element. */
  def top(): Int = {
    if(queue.isEmpty) -1 else queue.head.asInstanceOf[Int]
  }

  /** Returns whether the stack is empty. */
  def empty(): Boolean = {
    queue.size != 2
  }
}
```

###  1.102. <a name='-1'></a>226-ç¿»è½¬äºŒå‰æ ‘

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Sh411R7B2?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H73E?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1FK411p7Co?spm_id_from=333.999.0.0)

```py
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```

```py
ç”¨é˜Ÿåˆ—åšï¼Œæ¯æ¬¡éƒ½å¼¹å‡ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶ååˆ¤æ–­

å¦‚æœèŠ‚ç‚¹ä¸ºå¶å­èŠ‚ç‚¹ï¼Œé‚£å°±ä»€ä¹ˆéƒ½ä¸åš

å¦‚æœä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£å°±æœ‰ä¸‰ç§æƒ…å†µï¼š

1.å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹éƒ½å­˜åœ¨ï¼Œæ­¤æ—¶æŠŠä¸¤ä¸ªèŠ‚ç‚¹äº¤æ¢ï¼Œç„¶åæŠŠå·¦å³èŠ‚ç‚¹éƒ½é‡æ–°åŠ å…¥é˜Ÿåˆ—

2.åªæœ‰å·¦èŠ‚ç‚¹ï¼Œæ­¤æ—¶äº¤æ¢ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œç„¶åæŠŠå³èŠ‚ç‚¹é‡æ–°åŠ å…¥é˜Ÿåˆ—

3.åªæœ‰å³èŠ‚ç‚¹ï¼Œæ­¤æ—¶äº¤æ¢ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œç„¶åæŠŠå·¦èŠ‚ç‚¹é‡æ–°åŠ å…¥é˜Ÿåˆ—

### ä»£ç 

class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if root == None:
            return root
        Q = deque([root])
        while Q:
            r = Q.popleft()
            if r.left or r.right:
                r.left, r.right = r.right, r.left
                if r.left and r.right:
                    Q.append(r.left)
                    Q.append(r.right)
                elif r.right and not r.left:
                    Q.append(r.right)
                else:
                    Q.append(r.left)
        return root
```

###  1.103. <a name='BasicCalculatorII'></a>227 Basic Calculator II

[å°æ˜](https://www.bilibili.com/video/BV1Qy4y167Ax?spm_id_from=333.999.0.0)

https://www.bilibili.com/video/BV1t4411c7m6?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

https://www.bilibili.com/video/BV1v54y1a74b?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

```py
class Solution:
    def calculate(self, s: str) -> int:
        n = len(s)
        stack = []
        op = '+'
        num = 0
        for i in range(n):
            if s[i] != ' ' and s[i].isdigit():
                num = num * 10 + ord(s[i]) - ord('0')
            if i == n - 1 or s[i] in '+-*/':
                if op == '+':
                    stack.append(num)
                elif op == '-':
                    stack.append(-num)
                elif op == '*':
                    stack.append(stack.pop() * num)
                else:
                    stack.append(int(stack.pop() / num))
                op = s[i]
                num = 0
        return sum(stack)

class Solution:
    def calculate(self, s: str) -> int:
        stack = []
        num, op = 0, "+"
        for i, c in enumerate(s):
            if c.isdigit():
                num = 10*num + int(c)
            if c in "+-*/" or i==len(s)-1:
                if op == "+":
                    stack.append(num)
                elif op == "-":
                    stack.append(-num)
                elif op == "*":
                    stack.append(stack.pop()*num)
                elif op == "/":
                    stack.append(int(stack.pop()/float(num)))
                num, op = 0, c
        return sum(stack)

# pythoné‡Œ -3/2==-2
# -3//2=-2ï¼Œå°±æ˜¯ä¸ªå‘
import operator
class Solution(object):
    def calculate(self, s):
        res = []
        opMap = {
            "+": lambda e: res.append(e),
            "-": lambda e: res.append(-e),
            "*": lambda e: res.append(e * res.pop()),
            "/": lambda e: res.append(int((res.pop()/e)))
            # "/": lambda e: a.append(int(operator.truediv(a.pop(), e)))
        }
        op = "+"
        num = 0
        for char in s+"+":
            if char.isdigit():
                num = num * 10 + int(char)
            elif char != " ":
                opMap[op](num)
                op = char
                num = 0
        return sum(res)
```

```py
# æœ¬é¢˜ä¸å«æ‹¬å·å’Œç¬¦å·ä½ï¼Œæ‰€ä»¥å°† '/' æ›¿æ¢ä¸º '//' å°±å¯ä»¥ç›´æ¥è°ƒç”¨ eval äº†ã€‚
class Solution(object):
    def calculate(self, s):
        return eval(s.replace('/', '//'))
```

###  1.104. <a name='SummaryRanges'></a>228 Summary Ranges

[å°æ˜](https://www.bilibili.com/video/BV1Et4y1i7YZ?spm_id_from=333.999.0.0)

###  1.105. <a name='MajorityElementII'></a>229. Majority Element II 

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV12z411B7rS?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1nK411P7qR?spm_id_from=333.999.0.0)

```py
# å“ˆå¸Œç»Ÿè®¡

class Solution:
    def majorityElement(self, nums):
        lookup = defaultdict(int)
        res = []
        for num in nums:
            lookup[num] += 1
            if lookup[num] > len(nums) // 3:
                res.append(num)
        return list(set(res))


class Solution:
    def majorityElement(self, nums):
        lookup = {}
        res = []

        for num in nums:
            if num in lookup:
                lookup[num] += 1
            else:
                lookup[num] = 1
        for item in lookup.keys():
            if lookup[item] > len(nums)//3:
                res.append(item)

        return res
```


###  1.106. <a name='KthSmallestElementinaB'></a>230 Kth Smallest Element in a B

[å°æ˜](https://www.bilibili.com/video/BV1ha4y1i7dZ?spm_id_from=333.999.0.0)

```py
# ç”¨yieldæ¥æ³¢éªšæ“ä½œ

class Solution:
    def kthSmallest(self, root, k):

        def gen(r):
            if r is not None:
                yield from gen(r.left)
                yield r.val
                yield from gen(r.right)
        
        it = gen(root)
        for _ in range(k):
            ans = next(it)
        return ans

# æ”¶è—ä¸€æ³¢ï¼Œåšä¸»å¤§å¤§å¨æ­¦
# yieldçœŸæ˜¯è¿­ä»£ä¼˜åŒ–åˆ©å™¨

# 6å¾—é£èµ·ï¼~ æ¥åŒ–ç®€ä¸‹åŠ©æ¶¨æ¥¼ä¸»éªšæ°”
class Solution:
    def kthSmallest(self, root, k):
        from itertools import chain, islice
        def gen(x): yield from chain(gen(x.left), [x.val], gen(x.right)) if x else ()
        return next(islice(gen(root), k - 1, k))
```

```py
# InOrderæ’åºï¼Œè¾“å‡º
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        stack = []
        while root or stack: # stackä¸€èˆ¬éƒ½æœ‰
            while root: # æ‰¾åˆ°æœ€æ·±çš„èŠ‚ç‚¹ï¼Œrootåœ¨æœ€æ·±å¤„çš„æ—¶å€™å°±ä¸ºnone
                stack.append(root)
                root = root.left
            root = stack.pop() # stackå¼¹å‡ºæœ€æ·±å¤„çš„èŠ‚ç‚¹
            k -= 1
            if k == 0:
                return root.val
            root = root.right #å»å³å­©å­çœ‹çœ‹

class Solution:
    def kthSmallest(self, root, k: int) -> int:
        queue = deque([])

        def inOrder(root):
            
            if not root: return
            helper(root.left)
            queue.append(root.val)
            helper(root.right)
            return

        inOrder(root)
        return queue[k - 1]
```


```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */

object Solution {
    def kthSmallest(root: TreeNode, k: Int): Int = {

      val stack = collection.mutable.Stack[TreeNode]()
      var node = root
      var counter = 0
      var ans = 0
      while ((counter <= k) && (node != null || stack.nonEmpty)) {
        while(node != null) {
          stack push node
          node = node.left
        }
        node = stack.pop
        
        counter += 1
        if (counter == 1 || counter <= k) {
          ans = node.value
        }
        
        node = node.right
        
      }
      ans
    }
}
/**
* my first commit
* inorder iterative template
* time complexity: O(H + K) => H is tree height, H + K = element in stack
*/

object Solution1 {
    def kthSmallest(root: TreeNode, k: Int): Int = {
        
        val stack = collection.mutable.Stack[TreeNode]()
        var node = root
        var counter = 0
        
        
        while(node != null || stack.nonEmpty) {
            while(node != null) {
                stack push node
                node = node.left
            }
            node = stack.pop
            counter += 1
            if(counter == k) return node.value
            else node = node.right
            
        }
        -1
    }
}

/**
* inorder traversal - recursive version
* time complexity: O(H + k)
*/

object Solution2-1 {
    import scala.collection.mutable
    def kthSmallest(root: TreeNode, k: Int): Int = {
        val ret = _kthSmallest(root, k, mutable.ListBuffer.empty)

        ret(k - 1)
    }
    
    def _kthSmallest(node: TreeNode, k:Int, l: mutable.ListBuffer[Int]): mutable.ListBuffer[Int]  = {
       if(node == null) l
       else {
           _kthSmallest(node.left, k, l)
           l += node.value
           if(l.size >= k) l  // shortcut
           else  _kthSmallest(node.right, k, l)  
       }
    }
}


/**
* a brilliant solution - inorder recursive traversal 
* memo:
*   1. using Either, right records numbers of visited node, left record the value when the condition is meet
* time complexity:
*      O(H + K) H is the height of the tree calculated by log(N) approximately
*/
object Solution2-2 {
  def go (node: TreeNode, k: Int) : Either[Int, Int] = {
     val r =for {
      numElementsLeft <- if (node.left == null) Right (0) else go(node.left, k)
      numElementsRight <- if (numElementsLeft + 1 == k) Left(node.value)
      else
        if (node.right == null) Right(0) else go(node.right, k - (numElementsLeft + 1))

    } yield numElementsLeft + numElementsRight + 1
      println(r)
      r

  }

  def kthSmallest(root: TreeNode, k: Int): Int = {
    go(root, k).left.get
  }
}

```



###  1.107. <a name='PowerofTwo'></a>231. ã€ä½è¿ç®—ğŸ˜œã€‘Power of Two

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H73f?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1rV411r7AL?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0


class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return bin(n).count('1') == 1 and n > 0



class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & -n) == n
```

```py
2147483648æ˜¯æ•´æ•°èŒƒå›´å†…æœ€å¤§çš„2æ¬¡å¹‚ï¼Œè‹¥næ˜¯2çš„å¹‚ï¼Œé‚£ä¹ˆ2147483648ä¸€å®šèƒ½æ•´é™¤å®ƒ

class Solution(object):
    def isPowerOfTwo(self, n):
        return n > 0 and 2147483648 % n == 0

        
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        BIG = 1<<30 # æˆ‘è¯•äº†ä¸€ä¸‹ï¼Œ30,31,32éƒ½å¯¹
        return n > 0 and BIG % n == 0
```

```scala
/**
* time complexity  O(1)
*/
object Solution {
    def isPowerOfTwo(n: Int): Boolean = {
        n > 0 && (n & (n - 1) ) == 0
    }
}
```

###  1.108. <a name='ImplementQueueusingStacks'></a>232-ã€æ„é€ ğŸ°ã€‘Implement Queue using Stacks

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1p741177pp?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1Gf4y147Vj?spm_id_from=333.999.0.0)


```py
class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def push(self, x):
        # è¦æŠŠæ–°æ¥çš„å…ƒç´ å‹å…¥
        while self.s1:
            self.s2.append(self.s1.pop())
        self.s2.append(x)
        while self.s2:
            self.s1.append(self.s2.pop())

    def pop(self):
        # å‡è£…æœ€åä¸€ä¸ªå…ƒç´ æ˜¯å¼€å¤´
        return self.s1.pop() if self.s1 else None
        

    def peek(self):
        # å‡è£…æœ€åä¸€ä¸ªå…ƒç´ æ˜¯å¼€å¤´
        return self.s1[-1] if self.s1 else None

    def empty(self):
        return False if self.s1 else True
```

```scala
/**
* using two stack to implement
* one for push, the other for pop
* time complexity amortized O(1) per operation
* space complexity
*/

class MyQueue() {

  /** Initialize your data structure here. */
  private val inputStack = scala.collection.mutable.ArrayStack[Int]()
  private val outputStack = scala.collection.mutable.ArrayStack[Int]()


  /** Push element x to the back of queue. */
  def push(x: Int) {
    inputStack.push(x)

  }

  /** Removes the element from in front of queue and returns that element. */
  def pop(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.pop()

  }

  /** Get the front element. */
  def peek(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.head
  }

  /** Returns whether the queue is empty. */
  def empty(): Boolean = {
    outputStack.isEmpty && inputStack.isEmpty
  }

}

```

###  1.109. <a name='PalindromeLinkedList'></a>234. ã€å›æ–‡ğŸŒˆã€‘Palindrome Linked List

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7ML?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        vals = []
        current_node = head
        while current_node is not None:
            vals.append(current_node.val)
            current_node = current_node.next
        return vals == vals[::-1]

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚


class Solution:
    def isPalindrome(self, head: ListNode) -> bool:

        self.front_pointer = head

        def recursively_check(current_node=head):
            if current_node is not None:
                if not recursively_check(current_node.next):
                    return False
                if self.front_pointer.val != current_node.val:
                    return False
                self.front_pointer = self.front_pointer.next
            return True

        return recursively_check()

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
ç§’å•Šï¼Œå°±æ˜¯æœ‰å¯èƒ½æ•°å­—å¤ªå¤§
å¯ä»¥ç†è§£æˆå­—ç¬¦ä¸²(é“¾è¡¨)è½¬æ•°å­—ï¼Œå¦‚æœæ˜¯å›æ–‡ğŸŒˆä»å‰å¾€åä¸ä»åå¾€å‰å¾—åˆ°çš„æ•°å­—æ˜¯ä¸€æ ·çš„
è™½ç„¶æ²¡æœ‰æ·±å…¥æƒ³ï¼Œä½†æ˜¯è¿™ä¸ªç®—æ³•åœ¨ç»è¿‡è¯æ˜ä¹‹å‰ï¼ŒçœŸå¿ƒä¸æ•¢ç”¨ã€‚æœ‰å¯èƒ½åœ¨ç‰¹å®šæµ‹è¯•ä¾‹ä¸‹å¤±è´¥
åªæœ‰python èƒ½åšï¼Œåªè¦ç”¨å¼ºåˆ¶ç±»å‹è¯­è¨€éƒ½ä¼šè¶Šç•Œã€‚
class Solution(object):

def isPalindrome(self, head):
    s1=0
    s2=0
    t=1

    while head!=None:
        s1=s1*10+head.val
        s2=s2+t*head.val
        t=t*10
        head=head.next
        
    return s1==s2
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
 
 /**
 * my first commitment
 *  using two pointer, one run 2 times faster than the other
 */
object Solution1 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null){
            true
        }else {
            var slowPre: ListNode = null
            var slow = head
            var fast = head

            while (fast != null && fast.next != null) {
                fast = fast.next.next

                val slowNext = slow.next
                slow.next = slowPre
                slowPre = slow
                slow = slowNext

            }

            fast match {
                case null => checkPalindrome(slowPre, slow)
                case _ => checkPalindrome(slowPre, slow.next)  // odd case
            }
            /**
                1 2 2 1 null
                s f
                    s   f  

                1 2 3 2 1 null
                s f   
                    s   f
            */
        }
       
                
    }
    def checkPalindrome(left: ListNode, right: ListNode): Boolean = {
        (left, right) match {
            case (null, null) => true
            case (l, r) if l != null && r != null && l.x == r.x => checkPalindrome(left.next, right.next)
            case _ => false   
        }
        
    }
    

    def printNode(node: ListNode) {
        var n = node
        
        while(n != null) {
            print(s"${n.x}\t")
            n = n.next
        }
    }
}


/**
* very brilliant solution
*/
object Solution2 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null) {
            return true
        }
        var p = head
        var result = true
        def go(node: ListNode): Unit = {
            if (node.next != null) {
                go(node.next)
            }
            if (p.x != node.x) {
                result = false
            }
            p = p.next
        }
        go(head)
        result
    }
}
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def isPalindrome(head: ListNode): Boolean = {
        var flag = true
        var rev = head
        var h = head
        def reverse(n: ListNode): Unit = {
            if(n == null){
                ()
            }else{
                reverse(n.next)
                val cond = n.x == h.x
                flag = flag && cond
                h = h.next
            }
        }
       
        reverse(rev)
        flag
    }
}

```

###  1.110. <a name='LowestCommonAncestorofaBinarySearchTree'></a>235. Lowest Common Ancestor of a Binary Search Tree

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7VY?spm_id_from=333.999.0.0)

```py
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        def getPath(root: TreeNode, target: TreeNode) -> List[TreeNode]:
            path = list()
            node = root
            while node != target:
                path.append(node)
                if target.val < node.val:
                    node = node.left
                else:
                    node = node.right
            path.append(node)
            return path
        
        path_p = getPath(root, p)
        path_q = getPath(root, q)
        ancestor = None
        for u, v in zip(path_p, path_q):
            if u == v:
                ancestor = u
            else:
                break
        
        return ancestor

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        ancestor = root
        while True:
            if p.val < ancestor.val and q.val < ancestor.val:
                ancestor = ancestor.left
            elif p.val > ancestor.val and q.val > ancestor.val:
                ancestor = ancestor.right
            else:
                break
        return ancestor

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
python3 åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹ç‚¹ï¼Œå¦‚æœpã€qçš„å€¼éƒ½å°äºrootï¼Œ

è¯´æ˜p q è‚¯å®šåœ¨rootçš„å·¦å­æ ‘ä¸­ï¼›å¦‚æœp qéƒ½å¤§äºrootï¼Œ

è¯´æ˜è‚¯å®šåœ¨rootçš„å³å­æ ‘ä¸­ï¼Œå¦‚æœä¸€ä¸ªåœ¨å·¦ä¸€ä¸ªåœ¨å³ 

åˆ™è¯´æ˜æ­¤æ—¶çš„rootè®°ä¸ºå¯¹åº”çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ //python3

å¤ªæœ‰é“ç†äº†, æˆ‘ç«Ÿç„¶æ²¡å½“æˆæœç´¢æ ‘æ¥çœ‹å¾…ã€‚

æ ¹æ®æœç´¢æ ‘çš„ç‰¹ç‚¹ï¼Œå¦‚æœ pï¼Œq å€¼ éƒ½ < root çš„å€¼ï¼Œå°±å»å·¦å­æ ‘
æ ¹æ®æœç´¢æ ‘çš„ç‰¹ç‚¹ï¼Œå¦‚æœ pï¼Œq å€¼ éƒ½ > root çš„å€¼ï¼Œå°±å»å³å­æ ‘
å¦åˆ™å°±æ˜¯è¯´åˆ†å¸ƒåœ¨ rootçš„å·¦å³å­æ ‘ä¸­

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if p.val<root.val and q.val<root.val:
            return self.lowestCommonAncestor(root.left,p,q)
        
        if p.val>root.val and q.val>root.val:
            
            return self.lowestCommonAncestor(root.right,p,q)
        
        return root
```

```py
é€’å½’æ³•ï¼š

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root: return root  //ä¸­
        if root.val >p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left,p,q)  //å·¦
        elif root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right,p,q)  //å³
        else: return root

è‹¥pã€qåˆ†åˆ«åœ¨æŸä¸€èŠ‚ç‚¹çš„å·¦å³å­æ ‘å†…ï¼Œåˆ™è¯¥èŠ‚ç‚¹ä¸ºæœ€å°å…¬å…±ç¥–å…ˆã€‚

ï¼ˆå¯¹äºäºŒå‰æœç´¢æ ‘è€Œè¨€ï¼Œå³éœ€æ»¡è¶³è¯¥min(p,q)<=node.val<=max(p,q)ï¼‰

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        r1=max(p.val,q.val)
        r2=min(p.val,q.val)
        while root :
            if root.val>=r2 and root.val<=r1:
                return root
            if root.val>r1:
                root=root.left
            else:
                root=root.right
        return root
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
* DFS 
* 
* exploit binary search three property:  right > parent value > left
* time complexity : O(N)
* space complexity: O(N)
*/
object Solution1 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }
  
  @annotation.tailrec
  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    (p, q) match {
      case (pp, qq) if p.value > node.value && q.value > node.value  && node != null => _lowestCommonAncestor(node.right, pp, qq)
      case (pp, qq) if p.value < node.value && q.value < node.value && node != null => _lowestCommonAncestor(node.left, pp, qq)
      case _ => node
    }
  }
}


/**
* iterative version
*/
object Solution1-2 {
    def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
      if(root == null) return root
      var node = root
      
      var condition = true
      while(condition && node != null){
        if(q.value > node.value && p.value > node.value)
          node = node.right
        else if (node.value > q.value && node.value > p.value)
          node = node.left
        else 
          condition = false
      }
      node
    }
}
```

###  1.111. <a name='-1'></a>236-äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1ov411172r?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV125411p7dr?spm_id_from=333.999.0.0)

```py
# æä¾›ä¸€ä¸ªpython3é¢˜è§£ï¼š

# æ€è·¯ ï¼šè¿™æ˜¯æˆ‘çœ‹è¿‡è§£é‡Šæœ€æ¸…æ¥šçš„youtubeé¢˜è§£ éœ€è¦å¬æ‡‚å°åº¦å£éŸ³è‹±è¯­ï¼Œä½†è®²å¾—éå¸¸å¥½

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return 
        if root == p or root == q:
            return root 
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        if left and right:
            return root 
        elif left and not right:
            return left 
        elif right and not left:
            return right 

# Python è¶…è¶Š99%æ‰§è¡Œé€Ÿåº¦çš„è§£æ³•ï¼šè€Œä¸”ä¹Ÿç®€çŸ­

class Solution:
    def lowestCommonAncestor(self, root, p, q) -> 'TreeNode':

        if root in (None,p,q):
            return root 

        L = self.lowestCommonAncestor(root.left,p,q)
        R = self.lowestCommonAncestor(root.right,p,q)

        return R if None==L else L if None==R else root

# å·¦å­æ ‘æˆ–è‡ªå·±å«p å°±è¿”å›pï¼Œå³å­æ ‘æˆ–è‡ªå·±å«qå°±è¿”å›qï¼Œå·¦å³å­æ ‘è¿”å›ä¸€pä¸€qåˆ™è¿”å›è‡ªå·±ï¼Œ
# å¦‚æœæŸå­æ ‘è¿”å›äº†ç­”æ¡ˆï¼ˆå¦ä¸€å­æ ‘å¿…ç„¶è¿”å›Noneï¼‰ï¼Œ
# åˆ™è¿”å›ç­”æ¡ˆï¼Œå‰©ä¸‹å°±æ˜¯ä¸¤ä¸ªå­æ ‘éƒ½è¿”å›ç©ºï¼Œåˆ™è¿”å›ç©ºã€‚ 
# ç»è¿‡é€»è¾‘åŒ–ç®€ï¼š

# å…ˆåˆ†æè‡ªå·±ï¼Œè‡ªå·±æ˜¯p,q,Noneä¸­çš„ä¸€è€…ï¼Œè‡ªç„¶è¿”å›è‡ªå·±ã€‚
# ç„¶ååˆ†æå·¦å³å­æ ‘çš„è¿”å›å€¼ï¼Œå¦‚æœå…¶ä¸­ä¸€ä¸ªæ˜¯Noneï¼Œåˆ™è¿”å›å¦ä¸€ä¸ªï¼Œ
# ä½œä¸ºä¼ é€’ï¼Œæ— è®ºæ˜¯ä¼ é€’æœ€ç»ˆçš„ç­”æ¡ˆï¼Œè¿˜æ˜¯ä¼ é€’på’Œqã€‚
# å¦‚æœå·¦å³å­æ ‘è¿”å›på’Œqï¼Œå½“ç„¶è¿”å›rootã€‚ Pythonä¸­çš„Noneå³C/C++/Java ä¸­çš„Null/null

# //é€’å½’
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q: return root  
        # //æ‰¾åˆ°äº†èŠ‚ç‚¹pæˆ–è€…qï¼Œæˆ–è€…é‡åˆ°ç©ºèŠ‚ç‚¹
        left = self.lowestCommonAncestor(root.left,p,q)  
        # //å·¦
        right = self.lowestCommonAncestor(root.right,p,q)  
        # //å³
        if left and right: return root  
        # //ä¸­: leftå’Œrightä¸ä¸ºç©ºï¼Œrootå°±æ˜¯æœ€è¿‘å…¬å…±èŠ‚ç‚¹
        elif left and not right: return left  
        # //ç›®æ ‡èŠ‚ç‚¹æ˜¯é€šè¿‡leftè¿”å›çš„
        elif not left and right: return right  
        # //ç›®æ ‡èŠ‚ç‚¹æ˜¯é€šè¿‡rightè¿”å›çš„
        else: return None  
        # //æ²¡æ‰¾åˆ°
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
*  chosen solution
*  DFS with recursive
*  time complexity O(N), N is the number of node in the tree
*  space complexity O(N)
*/
object Solution0 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }

  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    if (node == null || node == p || node == q) return node
    /**
    *  1. if p and q are node 's child, return p q 's LCA 
    *  2.  if p and q are not node's child return null
    *  3. if p and q, only one of then ar node's child return that node (p or q)
    */
    val left = _lowestCommonAncestor(node.left, p, q)
    val right = _lowestCommonAncestor(node.right, p, q)

    (left, right) match {
      case (null, _) => right  // p and q are both not in left
      case (_, null) => left  // p and q are both not in right
      case (l, r) =>  node // only lowest common ancestor could return both non null node
      // p and q, one of then in left and the other one in right
    }
  }
}
```

###  1.112. <a name='DeleteNodeinaLinkedList'></a>237. Delete Node in a Linked List

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1rv411h7Lv?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1ap4y1C7JP?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1vt4y1y7eM?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next

```


```scala
object Solution {
    def deleteNode(node: ListNode): Unit = {
        node.x = node.next.x
        node.next = node.next.next 
    }
}

```

###  1.113. <a name='ProductofArrayExceptSelf'></a>238 ã€å‰ç¼€å’ŒğŸ¨ã€‘Product of Array Except Self

[å°æ˜](https://www.bilibili.com/video/BV1oT4y1G78Y?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV16z4y197oQ?spm_id_from=333.999.0.0)

```py
# æ–¹æ³•ä¸€ï¼šå·¦å³ä¹˜ç§¯åˆ—è¡¨
class Solution:
    def productExceptSelf(self, nums):
        n=len(nums)
        left=[1]*n
        right=[1]*n
        res=[]
        for i in range(1,n):
            left[i]=left[i-1]*nums[i-1]
        for i in range(n-2,-1,-1):
        # ç­‰ä»·äºï¼š for i in reversed(range(n - 1)):
            right[i]=right[i+1]*nums[i+1]
        for i in range(n):
            res.append(left[i]*right[i])
        return res 

# æ–¹æ³•äºŒï¼šç©ºé—´å¤æ‚åº¦ O(1)O(1) çš„æ–¹æ³•

# æ€è·¯
# å°½ç®¡ä¸Šé¢çš„æ–¹æ³•å·²ç»èƒ½å¤Ÿå¾ˆå¥½çš„è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯ç©ºé—´å¤æ‚åº¦å¹¶ä¸ä¸ºå¸¸æ•°ã€‚
# ç”±äºè¾“å‡ºæ•°ç»„ä¸ç®—åœ¨ç©ºé—´å¤æ‚åº¦å†…ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°† L æˆ– R æ•°ç»„ç”¨è¾“å‡ºæ•°ç»„æ¥è®¡ç®—ã€‚
# å…ˆæŠŠè¾“å‡ºæ•°ç»„å½“ä½œ L æ•°ç»„æ¥è®¡ç®—ï¼Œç„¶åå†åŠ¨æ€æ„é€  R æ•°ç»„å¾—åˆ°ç»“æœã€‚
# è®©æˆ‘ä»¬æ¥çœ‹çœ‹åŸºäºè¿™ä¸ªæ€æƒ³çš„ç®—æ³•ã€‚
      
# python æ€æƒ³ï¼šå‰ç¼€ç§¯ï¼Œå‰ç¼€ç§¯å’Œå‰ç¼€å’ŒğŸ¨å·®ä¸å¤š
# ç”¨ä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨æ¯ä¸€ä¸ªæ•°çš„å·¦è¾¹çš„æ•°çš„ä¹˜ç§¯ï¼Œé‚£ä¹ˆ ans[i] = ans[i-1]*nums[i]ï¼Œ 
# ç¬¬ä¸€ä¸ªæ•°å·¦è¾¹æ²¡æœ‰æ•°ï¼Œè®¤ä¸ºans[0] = 1ã€‚
# å†ç”¨ä¸€ä¸ªæ•° R æ¥å­˜å‚¨å³è¾¹çš„æ•°çš„ä¹˜ç§¯ï¼Œ
# ä»åå¾€å‰å¾ªç¯ï¼Œansä¹˜ä»¥Rå°±æ˜¯å·¦å³æ•°ç¼€çš„ä¹˜ç§¯ï¼ŒåŒæ—¶æ›´æ–°Rã€‚
class Solution:
    def productExceptSelf(self, nums):
        n = len(nums)
        res = [1]*n
        right = 1
        for i in range(1, n):
            res[i] = res[i-1] * nums[i-1]
        for i in range(n-1, -1, -1):
        # ç­‰ä»·äºï¼š for i in reversed(range(n)):
            res[i] *= right
            right *= nums[i]
        return res
```

```scala
object Solution {

    //pre-compute prefix & suffix products in O(N) time and then multiply them
    def productExceptSelf(nums: Array[Int]): Array[Int] = {
        var prefix = Array.fill(nums.length)(1)
        var suffix = Array.fill(nums.length)(1)
        
        (1 until prefix.length).map(i => {
            prefix(i) = prefix(i-1)*nums(i-1)
        })
        
        (suffix.length-2 to 0 by -1).map(i => {
            suffix(i) = suffix(i+1)*nums(i+1)
        })
        
        (0 until nums.length).map(i => {
            nums(i) = prefix(i) * suffix(i)
        })
        nums
    }
}

```

###  1.114. <a name='SlidingWindowMaximum'></a>239. â˜…ã€æœ€å°å †ğŸŒµ + æ»‘åŠ¨çª—å£ğŸ”¹å•è°ƒé˜Ÿåˆ—ã€‘Sliding Window Maximum

#### ä¸ç±»ä¼¼567ï¼Œ567ç±»ä¼¼187

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1WW411C763?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Bf4y1v758?spm_id_from=333.999.0.0)

è¿™ä¸ªçª—å£é‡Œé¢ï¼Œæ¯ä¸€ä¸ªå€¼éƒ½å¯èƒ½æœ‰ç”¨çš„

åŒ…å«ï¼š

52343  k=4

- æ–°åŠ å…¥çš„å€¼ 3
- å°†è¦è¢«å¼¹å‡ºçš„å€¼ 5
- è¿‡å»çš„æœ€å¤§å€¼ 5


```py
æ€è·¯ï¼š

ç»´æŠ¤ï¼šæœ€å¤§å€¼çš„posã€æœ€æ¥è¿‘å³è¾¹çš„æœ€å¤§å€¼çš„pos
# winQ []
# winQ [0]
# winQ [0, 1]
# winQ [0, 2]
# winQ [0, 3]

s = Solution()
print(s.maxSlidingWindow([5,2,3,4,3],4))
```

```py
class Solution(object):
    def maxSlidingWindow(self, nums, k):
        winpos, maxnums = [], []

        for i, v in enumerate(nums):
            # å°äºæ–°åŠ å…¥çš„å€¼å…¨éƒ¨å¼¹å‡ºã€‚æœ€å·¦ç«¯å³ä¸ºçª—å£æœ€å¤§å€¼ 
            while winpos and nums[winpos[-1]] <= v: 
                winpos.pop()
            winpos.append(i)

            # å¼¹å‡ºå‡ºç•Œçš„left
            if i >= k and winpos[0] <= i - k: 
                winpos.pop(0)

            # å¼€å§‹å†™å…¥ç­”æ¡ˆ
            if i >= k - 1: 
                maxnums.append(nums[winpos[0]])
                
        return maxnums
        
# print(winpos)
# [1,3,-1,-3,5,3,6,7]
ä¿è¯çª—å£å†…çš„å€¼æ˜¯é€’å‡çš„å³å¯
# []
# [0]
# [1]
# [1, 2]
# [1, 2, 3]
# [4]
# [4, 5]
# [6]

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        winQ = deque()
        res = []
        for i, v in enumerate(nums):

            while winQ and nums[winQ[-1]] < v:
                winQ.pop()
            winQ.append(i)

            if i - k == winQ[0]:
                winQ.popleft()

            if i >= k - 1:
                res.append(nums[winQ[0]])

        return res
```

```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # æ³¨æ„ Python é»˜è®¤çš„ä¼˜å…ˆé˜Ÿåˆ—æ˜¯å°æ ¹å †
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)

        ans = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k:
                heapq.heappop(q)
            ans.append(-q[0][0])
        
        return ans


class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        q = collections.deque()
        for i in range(k):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)

        ans = [nums[q[0]]]
        for i in range(k, n):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)
            while q[0] <= i - k:
                q.popleft()
            ans.append(nums[q[0]])
        
        return ans

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        prefixMax, suffixMax = [0] * n, [0] * n
        for i in range(n):
            if i % k == 0:
                prefixMax[i] = nums[i]
            else:
                prefixMax[i] = max(prefixMax[i - 1], nums[i])
        for i in range(n - 1, -1, -1):
            if i == n - 1 or (i + 1) % k == 0:
                suffixMax[i] = nums[i]
            else:
                suffixMax[i] = max(suffixMax[i + 1], nums[i])

        ans = [max(suffixMax[i], prefixMax[i + k - 1]) for i in range(n - k + 1)]
        return ans

```

```scala

/**
* chosen solution 
* using  array deque (double side queue)  which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution0 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
        //you should always delete elements from right side
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* using max heap, may not AC
* pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)} : keep element's time complexity is O(K)
* time complexity: O(N log K)
*/

object Solution1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        var pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
        val rest = scala.collection.mutable.ArrayBuffer[Int]()
        
        nums.zipWithIndex.foreach{case (v: Int, idx: Int) => {
     
            pq += ((v, idx))
            
            /* keep the elements that is only larger than newest v and the nearest k */
            pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)}       

            if (idx + 1 >= k) {
                rest += pq.head._1
            }
          
        }}        
        rest.toArray
    }
}


/**
* may not AC
* fold left version, it is worst than for loop version
*/
object Solution1-2 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
  val (_, rest, _) = nums.zipWithIndex.foldLeft((pq, Array.empty[Int], k)){
    (B, v_id) =>
      val (_pq, rest: Array[Int], _k) = B
      var newPq = _pq
      newPq += v_id
      if(v_id._2 + 1 >= k) {
        newPq = newPq.filter{case (_v:Int, _idx: Int) => (_v >= v_id._1) && (_idx > v_id._2 - k) }
          
         (newPq, rest :+ newPq.head._1, _k)
      }else {
         (newPq, rest, _k)
      }
     
  }
  rest
        
    }
}


/**
* using scala vector, due to scala vector is immutable, any operation about add update remove is generate a new vector
* so it's not a proper substitute for deque
*/

object Solution2 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    var windows = Vector.empty[Int]
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.head <= index - k)
        windows = windows.drop(1)

      while (windows.nonEmpty && nums(windows.last) <= value){
        windows = windows.dropRight(1)
      }
      windows = windows :+ index
      if (index + 1 >= k) {
        ret += nums(windows.head)
      }
    }
    ret.toArray
  }
}

/**
* using java array deque (double side queue) version which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution3 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    import java.util
    val windows = new util.ArrayDeque[Int]  // record nums index
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.peekFirst() <= index - k) {
        // remove out of date element
        windows.removeFirst()
      }

      while (!windows.isEmpty && nums(windows.peekLast()) <= value) {
        // drop the element if  it is smaller than upcoming element
        windows.removeLast()
      }
      windows.add(index)
      if (index + 1 >= k) {
        ret += nums(windows.peekFirst())
      }
    }
    ret.toArray
  }
}

/**
* use scala build-in arrayDeque
*/
object Solution3-1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* brute force, not AC
*/
object Solution4 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        nums.sliding(k).map(_.max).toArray
    }
}
```

###  1.115. <a name='-1'></a>240. äºŒç»´æ•°ç»„çš„æŸ¥æ‰¾

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1dz411i7jC?spm_id_from=333.999.0.0)

```py
import bisect
class Solution:
    def searchMatrix(self, matrix, target):
        for row in matrix:
            idx = bisect.bisect_left(row, target)
            if idx < len(row) and row[idx] == target:
                return True
        return False
```

```py
class Solution(object):
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if not matrix:
            return False
        row = len(matrix)
        col = len(matrix[0]) if row else 0 
        m, n = 0, col - 1
        while m < row and n >= 0:
            if matrix[m][n] < target:
                m += 1
            elif matrix[m][n] > target:
                n -= 1
            else:
                return True
        return False

class Solution:
    def searchMatrix(self, matrix, target):
        for row in matrix:
            for element in row:
                if element == target:
                    return True
        return False

# ä»å³ä¸Šè§’å¼€å§‹æ‰¾ï¼Œè‹¥ç›®æ ‡å°äº†å°±å·¦ç§»ï¼Œç›®æ ‡å¤§äº†å°±ä¸‹ç§»

class Solution:
    def searchMatrix(self, matrix, target):
        i,j=0,len(matrix[0])-1
        while i<len(matrix) and j>=0:
            if matrix[i][j]==target: return True
            if target<matrix[i][j]: j-=1
            elif target>matrix[i][j]: i+=1
        return False


class Solution:
    def searchMatrix(self, matrix, target):
        m,n=len(matrix),len(matrix[0])
        for i in range(m):
            for j in range(n):
                if matrix[i][j]<target:
                    continue
                elif matrix[i][j]==target:
                    return True 
                else:
                    if j==0:
                        return False 
                    else:
                        break
        return False
# ï¼ˆpythonï¼‰å¯¹æ¯ä¸€è¡ŒäºŒåˆ†æŸ¥æ‰¾
# åˆ†æ²»æ³•ã€‚

# å·¦ä¸‹è§’çš„å…ƒç´ æ˜¯è¿™ä¸€è¡Œä¸­æœ€å°çš„å…ƒç´ ï¼ŒåŒæ—¶åˆæ˜¯è¿™ä¸€åˆ—ä¸­æœ€å¤§çš„å…ƒç´ ã€‚æ¯”è¾ƒå·¦ä¸‹è§’å…ƒç´ å’Œç›®æ ‡ï¼š
# è‹¥å·¦ä¸‹è§’å…ƒç´ ç­‰äºç›®æ ‡ï¼Œåˆ™æ‰¾åˆ°
# è‹¥å·¦ä¸‹è§’å…ƒç´ å¤§äºç›®æ ‡ï¼Œåˆ™ç›®æ ‡ä¸å¯èƒ½å­˜åœ¨äºå½“å‰çŸ©é˜µçš„æœ€åä¸€è¡Œï¼Œé—®é¢˜è§„æ¨¡å¯ä»¥å‡å°ä¸ºåœ¨å»æ‰æœ€åä¸€è¡Œçš„å­çŸ©é˜µä¸­å¯»æ‰¾ç›®æ ‡
# è‹¥å·¦ä¸‹è§’å…ƒç´ å°äºç›®æ ‡ï¼Œåˆ™ç›®æ ‡ä¸å¯èƒ½å­˜åœ¨äºå½“å‰çŸ©é˜µçš„ç¬¬ä¸€åˆ—ï¼Œé—®é¢˜è§„æ¨¡å¯ä»¥å‡å°ä¸ºåœ¨å»æ‰ç¬¬ä¸€åˆ—çš„å­çŸ©é˜µä¸­å¯»æ‰¾ç›®æ ‡
# è‹¥æœ€åçŸ©é˜µå‡å°ä¸ºç©ºï¼Œåˆ™è¯´æ˜ä¸å­˜åœ¨
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        m = len(matrix)
        if m == 0:
            return False
        n = len(matrix[0])
        if n == 0:
            return False

        i = m - 1
        j = 0
        while i >= 0 and j < n:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] < target:
                j = j + 1
            else:
                i = i - 1
        return False
class Solution:
    def searchMatrix(self, matrix, target):
        row,col=len(matrix),len(matrix[0])
        for i in range(row):
            left,right=0,col-1
            while left<=right:
                mid=(left+right)//2
                if matrix[i][mid]==target:
                    return True
                elif matrix[i][mid]>target:
                    right=mid-1
                else:
                    left=mid+1
        return False 
```

###  1.116. <a name='ValidAnagram'></a>242. Valid Anagram 

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Db411s78v?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1hV411i73u?spm_id_from=333.999.0.0)

```py
ç›´æ¥è¿”å›ä¸¤ä¸ªè®¡æ•°å™¨æ˜¯å¦ç›¸ç­‰å³å¯

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)


class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        a = collections.Counter(s)
        b = collections.Counter(t)
        return True if a == b else False
```

```py
Pythonï¼š

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        record = [0] * 26
        for i in range(len(s)):
            #å¹¶ä¸éœ€è¦è®°ä½å­—ç¬¦açš„ASCIIï¼Œåªè¦æ±‚å‡ºä¸€ä¸ªç›¸å¯¹æ•°å€¼å°±å¯ä»¥äº†
            record[ord(s[i]) - ord("a")] += 1
        print(record)
        for i in range(len(t)):
            record[ord(t[i]) - ord("a")] -= 1
        for i in range(26):
            if record[i] != 0:
                #recordæ•°ç»„å¦‚æœæœ‰çš„å…ƒç´ ä¸ä¸ºé›¶0ï¼Œè¯´æ˜å­—ç¬¦ä¸²så’Œt ä¸€å®šæ˜¯è°å¤šäº†å­—ç¬¦æˆ–è€…è°å°‘äº†å­—ç¬¦ã€‚
                return False
        return True
Pythonå†™æ³•äºŒï¼ˆæ²¡æœ‰ä½¿ç”¨æ•°ç»„ä½œä¸ºå“ˆå¸Œè¡¨ï¼Œåªæ˜¯ä»‹ç»defaultdictè¿™æ ·ä¸€ç§è§£é¢˜æ€è·¯ï¼‰ï¼š

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        from collections import defaultdict
        
        s_dict = defaultdict(int)
        t_dict = defaultdict(int)

        for x in s:
            s_dict[x] += 1
        
        for x in t:
            t_dict[x] += 1

        return s_dict == t_dict
```

```scala

/**
* chosen solution
* one line version
* time complexity: O(N)
*/

object Solution0 {
  def isAnagram(s: String, t: String): Boolean = {
   s.groupBy(identity).mapValues(_.length).toMap == t.groupBy(identity).mapValues(_.length).toMap  // toMap: transform MapView to Map

  }
}


/**
* my first commit
* time complexity: O(N)
*/

object Solution1 {
  def isAnagram(s: String, t: String): Boolean = {
    charCounter(s) equals charCounter(t)
  }
  private def charCounter(str: String): Map[Char, Int] = {
    str.foldLeft(collection.mutable.Map.empty[Char, Int]) {
      (map, s) =>
        map.get(s) match {
          case Some(e) =>
            map.update(s, e + 1)
            map
          case None =>
            map.update(s, 1)
            map
        }
    }.toMap
  }
}



```

```scala
//Time complexity( O(NlogN + N))
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        if(arr1.size != arr2.size){
            false
        } else{
            java.util.Arrays.sort(arr1)
            java.util.Arrays.sort(arr2)
            
            var flag = true
            import scala.util.control.Breaks._
            var index = 0
            breakable{
            while(index < arr1.size){
                if(arr1(index) != arr2(index)){
                    flag = false
                    break
                }
                index += 1
            }
            }
            flag
        }
    }
}

//Time complexity O(n)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        
        if(arr1.size != arr2.size){
            false
        } else{
            var map = scala.collection.mutable.Map.empty[Char, Int]
            for(elem <- arr1){
                map.get(elem) match{
                    case Some(count) => map += (elem -> (count+1))
                    case None => map += (elem -> 1)
                }
            }
            
            for(elem <- arr2){
                map.get(elem) match{
                    case Some(count) if count == 1 => map.remove(elem)
                    case Some(count) => map += (elem -> (count-1))
                    case None => ()
                }
            }
            
            if(map.keys.isEmpty) true else false
        }
    }
}

//One more: O(N)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        if(s.size != t.size){
            false
        }else{
        var arr = Array.fill(26)(0)
        for(elem <- s){
            arr(elem - 'a') += 1
        }
        
        import scala.util.control.Breaks._
        var flag = true
        breakable{
        for(elem <- t){
            arr(elem - 'a') -= 1
            if(arr(elem - 'a') < 0){
                flag = false
                break
            }
        }
        }
        flag
    }
    }
}

```

###  1.117. <a name='ShortestWordDistance'></a>243. Shortest Word Distance

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Lb411x7Ae?spm_id_from=333.999.0.0)

###  1.118. <a name='StrobogrammaticNumber'></a>246. Strobogrammatic Number

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV14b411g7zD?spm_id_from=333.999.0.0)

###  1.119. <a name='-1'></a>257-äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1rf4y1X7He?spm_id_from=333.999.0.0)

```py
class Solution:
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        def construct_paths(root, path):
            if root:
                path += str(root.val)
                if not root.left and not root.right:  # å½“å‰èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹
                    paths.append(path)  # æŠŠè·¯å¾„åŠ å…¥åˆ°ç­”æ¡ˆä¸­
                else:
                    path += '->'  # å½“å‰èŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç»§ç»­é€’å½’éå†
                    construct_paths(root.left, path)
                    construct_paths(root.right, path)

        paths = []
        construct_paths(root, '')
        return paths

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        paths = list()
        if not root:
            return paths

        node_queue = collections.deque([root])
        path_queue = collections.deque([str(root.val)])

        while node_queue:
            node = node_queue.popleft()
            path = path_queue.popleft()

            if not node.left and not node.right:
                paths.append(path)
            else:
                if node.left:
                    node_queue.append(node.left)
                    path_queue.append(path + '->' + str(node.left.val))
                
                if node.right:
                    node_queue.append(node.right)
                    path_queue.append(path + '->' + str(node.right.val))
        return paths

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
python3 æœ€å¥½ç†è§£çš„é€’å½’å®ç°

class Solution:
            
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root:
            return []
        if not root.left and not root.right:
            return [str(root.val)]
        paths = []
        if root.left:
            for i in self.binaryTreePaths(root.left):
                paths.append(str(root.val) + '->' + i)
        if root.right:
            for i in self.binaryTreePaths(root.right):
                paths.append(str(root.val) + '->' + i)
        return paths  
paths é€’å½’æ¯è°ƒç”¨ä¸€æ¬¡è¦åˆ›å»ºä¸€ä¸ªä»¥ä¾¿ç»™ä¸Šä¸€å±‚éå†ï¼ˆå åŠ ï¼‰
è°ƒç”¨self.binaryTreePaths(root.left)å¾—åˆ°çš„æ˜¯å·¦å­æ ‘çš„å…¨éƒ¨è·¯å¾„ï¼ŒåŠ å…¥å·¦å­æ ‘ä¸º[1,2,3],é‚£ä¹ˆå¾—åˆ°çš„ç»“æœæ˜¯[1,2],[1,3]ä¸¤ç»„ï¼Œç„¶åè¿˜è¦å’Œæ ¹èŠ‚ç‚¹è¿›è¡Œæ‹¼æ¥ï¼Œæ‰€ä»¥è¦ç”¨å¾ªç¯ã€‚
```

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

//Given a binary tree, return all root-to-leaf paths.
//
//Note: A leaf is a node with no children.
//
//Example:
//
//Input:
//
//1
///   \
//2     3
//\
//5
//
//Output: ["1->2->5", "1->3"]
//
//Explanation: All root-to-leaf paths are: 1->2->5, 1->3

package lc0257 {

  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def binaryTreePaths(root: TreeNode): List[String] = {
      val tmp = ArrayBuffer[Int]()
      val ret =ArrayBuffer[ArrayBuffer[Int]]()
      helper(root, tmp, ret)
      ret.toList.map({
        x=>x.mkString("->")
      })
    }

    def helper(node:TreeNode,tmp:ArrayBuffer[Int],ret:ArrayBuffer[ArrayBuffer[Int]]): Unit = {
      if (node==null) {
        return
      }

      tmp += node.value

      if (node.left == null && node.right==null) {
          ret += tmp.clone()
      } else {
        helper(node.left, tmp, ret)
        helper(node.right, tmp, ret)
      }
      tmp.remove(tmp.length-1)
    }
  }

  class Test extends BaseExtension {
    def init {
      val t1 = Tree.build(IndexedSeq("1","2 3","5 N N N"))
      println(Solution.binaryTreePaths(t1))
    }
    val name = "257 binary tree path"
  }
}

```

###  1.120. <a name='AddDigits'></a>258. Add Digits

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1ub41137cm?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1N54y1B7XU?spm_id_from=333.999.0.0)

```py
é™¤äº†ä¼ ç»Ÿçš„å•çº¯å¾ªç¯ï¼Œè¿˜å¯ä»¥æ‰¾è§„å¾‹ã€‚

å‡å¦‚ä¸€ä¸ªä¸‰ä½æ•°'abc'ï¼Œå…¶å€¼å¤§å°ä¸ºs1 = 100 * a + 10 * b + 1 * cï¼Œ

ç»è¿‡ä¸€æ¬¡å„ä½ç›¸åŠ åï¼Œå˜ä¸ºs2 = a + b + cï¼Œå‡å°çš„å·®å€¼ä¸º(s1 -s2) = 99 * a + 9 * bï¼Œ

å·®å€¼å¯ä»¥è¢«9æ•´é™¤ï¼Œæ¯ä¸€ä¸ªå¾ªç¯éƒ½è¿™æ ·ï¼Œç¼©å°äº†9çš„å€æ•°ã€‚

å½“numå°äº9ï¼Œå³åªæœ‰ä¸€ä½æ—¶ï¼Œç›´æ¥è¿”å›numï¼Œ

å¤§äº9æ—¶ï¼Œå¦‚æœèƒ½è¢«9æ•´é™¤ï¼Œåˆ™è¿”å›9

ï¼ˆå› ä¸ºä¸å¯èƒ½è¿”å›0ä¹Ÿä¸å¯èƒ½è¿”å›ä¸¤ä½æ•°åŠä»¥ä¸Šçš„å€¼ï¼‰ï¼Œ

å¦‚æœä¸èƒ½è¢«æ•´é™¤ï¼Œå°±è¿”å›è¢«9é™¤çš„ä½™æ•°ã€‚

class Solution:
    def addDigits(self, num: int) -> int:
        if num > 9:
            num = num % 9
            if num == 0:
                return 9
        return num

class Solution:
    def addDigits(self, num: int) -> int:
        while num>9:
            num=sum([int(c) for c in str(num)])
        return num
```

```py
ä½†å¯¹äºPythonæ¥è¯´ï¼Œ% å–ä½™è¿ç®—æ˜¯å¯¹æ•´ä½“è¿›è¡Œè¿ç®—ï¼Œç»“æœæ˜¯éè´Ÿæ•°ï¼Œæ•… -10 % 9 = 8ï¼Œæ‰€ä»¥ä¸Šè¿°é€»è¾‘åœ¨Pythonä¸­æœ‰å°ç‘•ç–µï¼Œéœ€æå‰è¿›è¡Œåˆ¤æ–­ï¼Œä»£ç å¦‚ä¸‹ï¼š

class Solution:
    def addDigits(self, num: int) -> int:
        return (num - 1) % 9 + 1 if num >= 10 else num

class Solution:
    def addDigits(self, num: int) -> int:
        return num - int((num - 1) / 9) * 9
```

###  1.121. <a name='III-1'></a>260-ã€ä½è¿ç®—ğŸ˜œã€‘åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— III

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV15Z4y1H7Sw?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1QK411J7dN?spm_id_from=333.999.0.0)

éš¾ç‚¹åœ¨äºåªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ä¸æ­¢ä¸€ä¸ªï¼Œ

ä½†æ˜¯åˆšå¥½æœ‰ä¸”åªæœ‰ä¸¤ä¸ª

```py

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        freq = Counter(nums)
        return [num for num, occ in freq.items() if occ == 1]

```

```py
å¤æ‚åº¦åˆ†æ

æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„ nums çš„é•¿åº¦ã€‚

ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        xorsum = 0
        for num in nums:
            xorsum ^= num # æ‰¾åˆ°è¿™ä¸¤ä¸ªæ•°çš„å·®å¼‚
        
        lsb = xorsum & (-xorsum) # æ‰¾åˆ°è¿™ä¸¤ä¸ªæ•°çš„å·®å¼‚çš„æœ€åä¸€ä½1
        type1 = type2 = 0
        for num in nums:
            if num & lsb: # è¿™é‡Œåªèƒ½ç”¨ &ï¼Œæ¥å†³num & lsb == 100 or 0
                type1 ^= num
            else:
                type2 ^= num
        
        return [type1, type2]


æ€è·¯, å…ˆå…¨éƒ¨å¼‚æˆ–ä¸€æ¬¡, å¾—åˆ°çš„ç»“æœ, è€ƒå¯Ÿå…¶çš„æŸä¸ªé0ä½(æ¯”å¦‚æœ€é«˜é0ä½), é‚£ä¹ˆåªå‡ºç°ä¸€æ¬¡çš„ä¸¤ä¸ªæ•°ä¸­, åœ¨è¿™ä¸ªä½ä¸Šä¸€ä¸ªä¸º0, ä¸€ä¸ªä¸º1, ç”±æ­¤å¯ä»¥å°†æ•°ç»„ä¸­çš„å…ƒç´ åˆ†æˆä¸¤éƒ¨åˆ†,é‡æ–°éå†, æ±‚ä¸¤ä¸ªå¼‚æˆ–å€¼
```

###  1.122. <a name='UglyNumber'></a>263 Ugly Number

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11W411C7zd?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Mb41157Pa?spm_id_from=333.999.0.0)

```py
class Solution:
    def isUgly(self, n: int) -> bool:
        # ç‰¹åˆ¤ï¼Œæ•´æ•°nä¸º1æ—¶ï¼Œå³ä¸ºä¸‘æ•°ï¼Œè¿”å›true
        if n == 1:
            return True
        # å¦‚æœæ•´æ•°nä¸º0æ—¶ï¼Œç›´æ¥è¿”å›false
        elif n == 0:
            return False

        # å¯¹æ•´æ•°nåˆ¤æ–­æ˜¯åªåŒ…å«è´¨å› æ•°2ã€3ã€5
        while n != 1:
            if n % 2 == 0:
                n /= 2
            elif n % 3 == 0:
                n /= 3
            elif n % 5 == 0:
                n /= 5
            else:
                return False
        # å¦åˆ™å°±ä¸ºä¸‘æ•°ï¼Œè¿”å›true
        return True


class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False

        factors = [2, 3, 5]
        for factor in factors:
            while n % factor == 0:
                n //= factor
        
        return n == 1

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/ugly-number/solution/chou-shu-by-leetcode-solution-fazd/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
æ€è·¯ä¸€ï¼šé€’å½’

class Solution:
    def isUgly(self, num: int) -> bool:
        if num == 0: return False
        if num == 1:return True
        if num % 2 == 0: return self.isUgly(num // 2)
        if num % 3 == 0: return self.isUgly(num // 3)
        if num % 5 == 0: return self.isUgly(num // 5)
        return False
æ€è·¯äºŒï¼šè¿­ä»£

class Solution:
    def isUgly(self, num: int) -> bool:
        for p in 2, 3, 5:
            while num % p == 0 < num:
                num //= p
        return num == 1

èœé¸¡æƒ³é—®é—® num % p == 0 < num: è¿™é‡Œä¸ºå•¥è¦åŠ ä¸€ä¸ª<numå‘¢ï¼Ÿ ä¸åŠ ä¼šè¶…æ—¶ï¼Œæ²¡ææ‡‚åŸç†ğŸ˜¥
é˜²æ­¢numä¸º0æ—¶æ— é™å¾ªç¯
```

###  1.123. <a name='UglyNumberII'></a>264. ã€åŠ¨æ€ğŸš€è§„åˆ’ + 3æŒ‡é’ˆã€‘Ugly Number II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yW411C7Sm?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1vT4y1775u?spm_id_from=333.999.0.0)

```py
# python å®ä¹ é¢è¯•è¿™é“é¢˜æŒ‚äº†ï¼Œä½†æˆ‘å°±ä¸æ‡‚äº†ï¼Œç¬¬ä¸€æ¬¡è§è¿™é¢˜ç›®è°èƒ½æƒ³åˆ°3æŒ‡é’ˆçš„æ–¹æ³•ï¼Ÿ
# [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]
class Solution(object):
    def nthUglyNumber(self, n):
        res = [1]
        idx2 = 0
        idx3 = 0
        idx5 = 0
        for i in range(n-1):
            nxt = min(res[idx2]*2, res[idx3]*3, res[idx5]*5)
            res.append(nxt)
            print(res[idx2]*2, res[idx3]*3, res[idx5]*5, res)
            if nxt == res[idx2]*2:
                idx2 += 1
            if nxt == res[idx3]*3:
                idx3 += 1
            if nxt == res[idx5]*5:
                idx5 += 1
        return res[-1]

# 2 3 5 [1, 2]
# 4 3 5 [1, 2, 3]
# 4 6 5 [1, 2, 3, 4]
# 6 6 5 [1, 2, 3, 4, 5]
# 6 6 10 [1, 2, 3, 4, 5, 6]
# 8 9 10 [1, 2, 3, 4, 5, 6, 8]
# 10 9 10 [1, 2, 3, 4, 5, 6, 8, 9]
# 10 12 10 [1, 2, 3, 4, 5, 6, 8, 9, 10]
# 12 12 15 [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]

```

###  1.124. <a name='MissingNumber'></a>268 ã€ä½è¿ç®—ğŸ˜œã€‘Missing Number


[å°æ˜](https://www.bilibili.com/video/BV1LU4y1p7n7?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1caw225arjj4.webp)

```py
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        nums.sort()
        for i, num in enumerate(nums):
            if num != i:
                return i
        return len(nums)


class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        s = set(nums)
        for i in range(len(nums) + 1):
            if i not in s:
                return i




class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        total = n * (n + 1) // 2
        arrSum = sum(nums)
        return total - arrSum


```

```py
æšä¸¾æ³•ï¼š
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        xor = len(nums)
        for i, num in enumerate(nums):
            xor ^= i
            xor ^= num
        return xor

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        xor = 0
        for i, num in enumerate(nums):
            xor ^= i ^ num
        return xor ^ len(nums)

è¿›é˜¶è§£æ³• ç”¨å¯èƒ½å‡ºç°çš„æ‰€æœ‰æ•°çš„å’Œ - å®é™…å‡ºç°çš„æ•°çš„å’Œ = æœªå‡ºç°çš„æ•° res

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = len(nums)
        # ç”¨å¯èƒ½å‡ºç°çš„æ‰€æœ‰æ•°(n + range(n))çš„å’Œ - å®é™…å‡ºç°çš„æ•° nums çš„å’Œ = æœªå‡ºç°çš„æ•° res
        for i, num in enumerate(nums) :
            res += i - num
        return res
```

```py
ï¼ˆpythonï¼‰é›†åˆåšå·® O(n)

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        a=set(nums)
        b=set()
        for i in range(len(nums)+1):
            b.add(i)
        return list(b-a)[-1]

åˆ©ç”¨é›†åˆçš„æ–¹æ³•æ—¶é—´å¤æ‚åº¦æ›´ä½ä¸€äº›ï¼Œæ„Ÿè°¢æé†’

å¼€å§‹ä¸è®¤çœŸçœ‹é¢˜ç›®ä»¥ä¸ºæ±‚å‡ºæ‰€æœ‰ï¼Œæ‰€ä»¥ç”¨ä¸¤ä¸ªé›†åˆæ±‚å·®é›†ï¼Œç„¶åå‘ç°ç»“æœåªæœ‰ä¸€ä¸ªæ•°ï¼Œå°±æ”¹äº†ä¸‹

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        return list({i for i in range(0, len(nums)+1)} - set(nums))[0]
```

```py
ï¼ˆpythonï¼‰æ’åºæ¯”è¾ƒ O(n*logn)

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = 0
        nums.sort()
        n = len(nums)
        for i in range(n):
            if res == nums[i]:
                res += 1
            else:
                return res 
        return n 

å¦‚æœç›´æ¥æ±‚å’Œçš„æœ€å¤§çš„å’Œä¸º 49995000 æœªè¶…å‡º int çš„èŒƒå›´ 


```

```scala
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        val idealSum = (size * (size + 1))/2
        
        val arraySum = nums.foldLeft(0)(_ + _) // can also use nums.sum
        
        idealSum - arraySum
    }
}

//Removing foldLeft improved time
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        var idealSum = (size * (size + 1))/2
        
        for(num <- nums){
            idealSum -= num
        }

        idealSum
    }
}

```

###  1.125. <a name='ClosestBinarySearchTreeValue'></a>270. Closest Binary Search Tree Value

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1zy4y1a7mR?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1fi4y1u7Sb?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.126. <a name='H-Index'></a>274 H-Index

[å°æ˜](https://www.bilibili.com/video/BV1ZV411z7Kx?spm_id_from=333.999.0.0)


###  1.127. <a name='FirstBadVersion'></a>278. First Bad Version

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1rZ4y1P7YF?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1cQ4y1N7dc?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        left = 1
        right = n
        while left < right:
            mid = left + (right - left) // 2
            if isBadVersion(mid) == True:
                right = mid
            else:
                left = mid + 1
        return right
```

```py
class Solution:
    def firstBadVersion(self, n):
        if isBadVersion(1) == True:
            return 1
        else:

            left = 1
            right = n
            while right - left > 1:
                k = int((left + right) / 2)
                if isBadVersion(k) == False:
                    left = k
                else:
                    right = k
            return right
```

```scala
/* The isBadVersion API is defined in the parent class VersionControl.
      def isBadVersion(version: Int): Boolean = {} */



/**
* my first commitment
* binary search recursive version
* time complexity
*   log(n)
*/
class Solution1 extends VersionControl {
    def firstBadVersion(n: Int): Int = {
        search(1, n)
    }
  
    def search(left: Int, right: Int): Int  = {
      if (left > right) return -1
       /**
      * it's bad version from mid to n, we could keep right side a bad version
      * the we return left side index as left index equals to right index
      */
      if (left == right) return left
      
      val mid = left + (right - left) / 2
      if (isBadVersion(mid))
     
        search(left, mid) 
      else
        search(mid + 1, right)
    }
}

```

###  1.128. <a name='PerfectSquares'></a>279 ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ…ã€‘Perfect Squares

[å°æ˜](https://www.bilibili.com/video/BV1r5411Y7MH?spm_id_from=333.999.0.0)

```py
# åŠ¨æ€ğŸš€è§„åˆ’
        '''ç‰ˆæœ¬ä¸€ï¼Œå…ˆéå†èƒŒåŒ…, å†éå†ç‰©å“'''
        '''ç‰ˆæœ¬äºŒï¼Œ å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…'''
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [10e5] * (n + 1)
        dp[0] = 0
        # ä¹Ÿå¯ä»¥ sqrt = floor(n**0.5) 
        sqrt = ceil(n**0.5) 
        for i in range(sqrt + 1): # æ˜“é”™ç‚¹ï¼šå¿…é¡»è¦ sqrt+1 æ¯”å¦‚è¾“å…¥ï¼šn = 1
            num = i**2
            for j in range(num, n + 1):
                if j >= num:
                    dp[j] = min(dp[j], dp[j-num] + 1) 
        return dp[-1]
```

###  1.129. <a name='ExpressionAddOperators'></a>282. Expression Add Operators

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV15W411C727?spm_id_from=333.999.0.0)

###  1.130. <a name='MoveZeros'></a>283. Move Zeros

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1m441187Kt?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ba4y1t7eK?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1Wp4y1y7pT?spm_id_from=333.999.0.0)

```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        n = len(nums)
        left = right = 0
        while right < n:
            if nums[right] != 0:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
            right += 1

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

å¹´è½»äººä¸è®²äº”çš„~

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # way1: Time:19.38 Space:55.79
        n_zero = nums.count(0)  # O(n)
        while n_zero > 0:
            nums.remove(0)  # O(n)
            nums.append(0)  # O(1)
            n_zero -= 1

        # way2: Time:87.76 Space:28.35
        # keyçš„å€¼æ˜¯boolï¼Œä¹Ÿå°±æ˜¯åªå¯¹0æ’åºï¼Œéé›¶çš„1ï¼Œ3ï¼Œ12ä¸æ’åºã€‚
        # ç”¨lambda x:x!=0 ä¹Ÿä¸€æ ·ã€‚
        nums.sort(key=bool, reverse=True)

æƒ³åˆ°çš„ç¬¬ä¸€ä¸ªæ–¹æ³•æ˜¯ç”¨pop

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        j=0
        for i in range(len(nums)):
            if nums[j]==0:
                nums.pop(j)
                nums.append(0)
            else:
                j+=1
```

```py
ç›´æ¥éå†ï¼Œåé¢è¡¥0ï¼Œæ‰¾åˆ°çš„0åˆ é™¤

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        i = 0
        while i < n:
            if nums[i] == 0:
                nums.append(0)
                del nums[i]
                i -=1
                n-=1
            i += 1

python3ï¼Œä¸‰è¡Œæå®š

æ—¶é—´å¤æ‚åº¦åˆ†æ remove() ---> O(N) ï¼Œappend() --> O(1) count()---> O(N)---- æ•´ä½“= O(3N)

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        for i in range(nums.count(0)):
            nums.remove(0)
            nums.append(0)

Python 1è¡Œ

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        nums.sort(key=bool, reverse=True)

è®¾ç½®ä¸€ä¸ªindexï¼Œé‡åˆ°ä¸æ˜¯0çš„æ•°å°±å’Œindexä½ç½®çš„æ•°äº¤æ¢ï¼Œç„¶åindexåŠ ä¸€ï¼Œpythonï¼š

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        index = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[index], nums[i] = nums[i], nums[index]
                index += 1

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0:
                nums[slow] = nums[fast]
                slow += 1
        for i in range(slow, len(nums)):
            nums[i] = 0
```

```scala
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        var p1 = 0
        var p2 = 0
        while(p1 < nums.size && p2 < nums.size){
            if(nums(p1) == 0 && nums(p2) != 0 && p1<p2){
                nums(p1) = nums(p2)
                nums(p2) = 0
                p1 += 1
                p2 += 1
            } else if(nums(p1) != 0 && nums(p2) != 0){
                p1 += 1
            }else{
                p2 += 1
            }
        }
    }
}

//Alternate solution: calculate the number of shifts 
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        
        var zeroCount = 0
        //count of zero is amount character is shifted to left
        //from first zero position traverse array left
        for(a <- 0 to nums.size-1){   
            //count zeroes and shift when not zero
            if(nums(a) == 0){
                zeroCount = zeroCount + 1
            }else if(zeroCount>0){
                //shift left if not 0 by zeroCount
                nums(a-zeroCount) = nums(a)
                nums(a) = 0
            }
        }
    }
}

```

```scala
package com.zhourui.leetcode

package lc0283_movezero {
  object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
//      nums.foldLeft(0) {
//        case (w,b) => {
//          if (b!=0) {
//            nums(w) = b
//
//            w+1
//          } else w
//        }
//      }

      nums.indices.foldLeft(0) {
        case (acc, e) => {
          if (nums(e)!=0) {
            val tmp = nums(e)
            nums(e) = nums(acc)
            nums(acc) = tmp
            acc+1
          } else acc
        }
      }
    }
  }
}

/*
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int w = 0;
        for (int i = 0; i< nums.size(); i++) {
            if (nums[i]!=0) {
                swap(nums[w++], nums[i]);
            }
        }
    }
};
 */

```

###  1.131. <a name='PeekingIterator'></a>284 Peeking Iterator

[å°æ˜](https://www.bilibili.com/video/BV1LN411R7U7?spm_id_from=333.999.0.0)

###  1.132. <a name='FindtheDuplicateNumber'></a>287 Find the Duplicate Number

[å°æ˜](https://www.bilibili.com/video/BV1Ug4y1v7mF?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Pz4y1X7qR?spm_id_from=333.999.0.0)

```py
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        #æ•°ç»„åªèƒ½è¯» æ‰€ä»¥ä¸èƒ½æ’åº,ä¸èƒ½swapæ•°ç»„ä¸‹æ ‡
        #æ—¶é—´å¤æ‚åº¦å°äº O(n^2) ä¸èƒ½æš´åŠ›
        #ç©ºé—´å¤æ‚åº¦ O(1) ä¸èƒ½é¢å¤–å¼€è¾Ÿæ•°ç»„
        
        ''' 1ã€æš´åŠ›ä¸ç¬¦åˆé¢˜æ„
        for i in nums:
            count = 0
            for num in nums:
                if num == i:
                    count += 1
            if count > 1:
                return i
        return -1
        '''
        
        '''2ã€å°äºO(n^2) äºŒåˆ†æŸ¥æ‰¾
        æˆ‘ä»¬ä¸è¦è€ƒè™‘æ•°ç»„,åªéœ€è¦è€ƒè™‘ æ•°å­—éƒ½åœ¨ 1 åˆ° n ä¹‹é—´
        ç¤ºä¾‹ 1:
        arr = [1,3,4,2,2] æ­¤æ—¶æ•°å­—åœ¨ 1 â€” 5 ä¹‹é—´

        mid = (1 + 5) / 2 = 3 arrå°äºç­‰äºçš„3æœ‰4ä¸ª(1,2,2,3)ï¼Œ1åˆ°3ä¸­è‚¯å®šæœ‰é‡å¤çš„å€¼
        mid = (1 + 3) / 2 = 2 arrå°äºç­‰äºçš„2æœ‰3ä¸ª(1,2,2)ï¼Œ1åˆ°2ä¸­è‚¯å®šæœ‰é‡å¤çš„å€¼
        mid = (1 + 2) / 2 = 1 arrå°äºç­‰äºçš„1æœ‰1ä¸ª(1)ï¼Œ2åˆ°2ä¸­è‚¯å®šæœ‰é‡å¤çš„å€¼
        æ‰€ä»¥é‡å¤çš„æ•°æ˜¯ 2 
        '''
        left = 1
        right = len(nums)
        while left < right:
            mid = int(left + (right - left)/2)
            cnt = 0
            for num in nums:
                if num <= mid:
                   cnt += 1
            if cnt <= mid:
                left = mid + 1
            else:
                right = mid
        return right

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        low, high = 1, len(nums) - 1
        while low <= high:
            mid = (low + high) >> 1
            cnt = sum(x <= mid for x in nums)
            if cnt > mid:
                high = mid - 1
            else:
                low = mid + 1

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = {}
        # dic = dict()
        for n in nums:
            dic[n] = dic.get(n, 0) + 1
            print(dic)
            if dic[n] >= 2:
                return n
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        print(set(nums))
        return (sum(nums)-sum(set(nums)))//(len(nums) - len(set(nums)))
```

###  1.133. <a name='GameofLife'></a>289. Game of Life

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14W411d7ji?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1hp4y1B7D5?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1vz4y1R7DJ?spm_id_from=333.999.0.0)

```py
è§£é¢˜æ€è·¯
æ€è·¯ï¼ŒåŸåœ°ä¿®æ”¹çš„å‰ææ˜¯ï¼Œæ•°å­—ç‰¹å¾å€¼è®°å½•è¿­ä»£å‰æ­»æ´»ï¼Œæœ¬äººçš„æ€è·¯æ˜¯æ ¡éªŒå¥‡å¶ï¼Œå³å®šä¹‰ï¼š
æ´»->æ´» 1->1
æ´»->æ­» 1->3
æ­»->æ´» 0->2
æ­»->æ­» 0->0
åªæœ‰æ­»æ´»è½¬æ¢çš„æ—¶å€™éœ€è¦æ”¹å˜boardå€¼ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼š
boardä»¥å‰æ˜¯æ´»çš„æ—¶å€™ï¼Œéœ€è¦åˆ¤æ–­ç°åœ¨æ˜¯å¦è¦æ­»è¿‡å»
boardä»¥å‰æ˜¯æ­»çš„æ—¶å€™ï¼Œéœ€è¦åˆ¤æ–­ç°åœ¨æ˜¯å¦è¦æ´»è¿‡æ¥
æ£€æŸ¥åŸçŠ¶æ€çš„æ—¶å€™ï¼Œåªéœ€è¦%2å³å¯çŸ¥é“åŸçŠ¶æ€ï¼Œ&1å’Œ%2æ•ˆæœä¸€æ ·
è®¡æ•°å‡½æ•°ï¼Œéå†ä¹ä¸ªæ ¼å­ï¼Œä¸èƒ½è¶Šç•Œï¼Œä¸èƒ½åŸåœ°æ¯”è¾ƒï¼šä¸èƒ½ijåŒæ—¶ä¸º0

ä½œè€…ï¼štangchuqi
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/game-of-life/solution/py3yuan-di-xiu-gai-jian-duan-gao-xiao-by-liu-xian-/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        n,m=len(board),len(board[0])
        for i in range(n):
            for j in range(m):
                C=0
                for x in (-1,0,1):
                    for y in (-1,0,1):
                        if(x or y)and 0<=i+x<n and 0<=j+y<m and board[x+i][j+y]&1:C+=1
                if board[i][j]&1 and(C<2 or C>3):board[i][j]=3
                if board[i][j]&1==0 and C==3:board[i][j]=2
        for i in range(n):
            for j in range(m):
                board[i][j]=int(0<board[i][j]<3)

ä½œè€…ï¼štangchuqi
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/game-of-life/solution/py3yuan-di-xiu-gai-jian-duan-gao-xiao-by-liu-xian-/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ã€

boardä¸­åªæœ‰0å’Œ1ä¸¤ç§çŠ¶æ€ï¼Œåªå ç”¨äº†intçš„æœ€ä½ä½ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠintçš„é«˜ä½åˆ©ç”¨èµ·æ¥

ç¬¬ä¸€æ¬¡éå†boardï¼Œå½“æˆ‘ä»¬ç¡®å®š(i, j)ä½ç½®çš„cellæ›´æ–°åçš„çŠ¶æ€æ˜¯å­˜æ´»ï¼Œå°±æŠŠé«˜ä½çš„å€¼ç½®ä¸º1
board[i][j] |= 2

ç¬¬äºŒæ¬¡éå†boardï¼ŒæŠŠé«˜ä½æŒªå›ä½ä½
board[i][j] >>= 1

python

class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        offsets = ((-1, -1), (-1, 0), (-1, 1), (0, -1),
                   (0, 1), (1, -1), (1, 0), (1, 1))
        m, n = len(board), len(board[0])
        for i in range(m):
            for j in range(n):
                alive = 0
                for offset in offsets:
                    x, y = i + offset[0], j + offset[1]
                    if x >= 0 and x < m and y >= 0 and y < n:
                        alive += board[x][y] & 1
                if alive == 3 or alive == 2 and board[i][j]:
                    board[i][j] |= 2
        for i in range(m):
            for j in range(n):
                board[i][j] >>= 1

ä½œè€…ï¼šDarkArmed
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/game-of-life/solution/pythonyuan-di-wei-yun-suan-ti-jie-by-darkarmed/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
# ç”Ÿå‘½åœ¨äºè°ƒåº“

import numpy as np
from scipy import signal
class Solution:
    def gameOfLife(self, board):
        arr = np.array(board)
        mask = np.ones((3,3))
        mask[1, 1] = 0
        around = signal.convolve2d(arr, mask, mode='same')
        arr[around < 2] = 0
        arr[around == 3] = 1
        arr[around > 3] = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                board[i][j] = arr[i, j]

        return board

# å·ç§¯æ³•

from scipy.signal import convolve2d
import numpy as np
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """
        b=np.array(board)
        x=convolve2d(b,[[1,1,1],[1,10,1],[1,1,1]],'same')
        board[:]=b*(x//2==6)+(x==3)
        return board
```

```py
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """

        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        rows = len(board)
        cols = len(board[0])

        # ä»åŸæ•°ç»„å¤åˆ¶ä¸€ä»½åˆ° copy_board ä¸­
        copy_board = [[board[row][col] for col in range(cols)] for row in range(rows)]

        # éå†é¢æ¿æ¯ä¸€ä¸ªæ ¼å­é‡Œçš„ç»†èƒ
        for row in range(rows):
            for col in range(cols):

                # å¯¹äºæ¯ä¸€ä¸ªç»†èƒç»Ÿè®¡å…¶å…«ä¸ªç›¸é‚»ä½ç½®é‡Œçš„æ´»ç»†èƒæ•°é‡
                live_neighbors = 0
                for neighbor in neighbors:

                    r = (row + neighbor[0])
                    c = (col + neighbor[1])

                    # æŸ¥çœ‹ç›¸é‚»çš„ç»†èƒæ˜¯å¦æ˜¯æ´»ç»†èƒ
                    if (r < rows and r >= 0) and (c < cols and c >= 0) and (copy_board[r][c] == 1):
                        live_neighbors += 1

                # è§„åˆ™ 1 æˆ–è§„åˆ™ 3        
                if copy_board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    board[row][col] = 0
                # è§„åˆ™ 4
                if copy_board[row][col] == 0 and live_neighbors == 3:
                    board[row][col] = 1
        return board

class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """

        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        rows = len(board)
        cols = len(board[0])

        # éå†é¢æ¿æ¯ä¸€ä¸ªæ ¼å­é‡Œçš„ç»†èƒ
        for row in range(rows):
            for col in range(cols):

                # å¯¹äºæ¯ä¸€ä¸ªç»†èƒç»Ÿè®¡å…¶å…«ä¸ªç›¸é‚»ä½ç½®é‡Œçš„æ´»ç»†èƒæ•°é‡
                live_neighbors = 0
                for neighbor in neighbors:

                    # ç›¸é‚»ä½ç½®çš„åæ ‡
                    r = (row + neighbor[0])
                    c = (col + neighbor[1])

                    # æŸ¥çœ‹ç›¸é‚»çš„ç»†èƒæ˜¯å¦æ˜¯æ´»ç»†èƒ
                    if (r < rows and r >= 0) and (c < cols and c >= 0) and abs(board[r][c]) == 1:
                        live_neighbors += 1

                # è§„åˆ™ 1 æˆ–è§„åˆ™ 3 
                if board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    # -1 ä»£è¡¨è¿™ä¸ªç»†èƒè¿‡å»æ˜¯æ´»çš„ç°åœ¨æ­»äº†
                    board[row][col] = -1
                # è§„åˆ™ 4
                if board[row][col] == 0 and live_neighbors == 3:
                    # 2 ä»£è¡¨è¿™ä¸ªç»†èƒè¿‡å»æ˜¯æ­»çš„ç°åœ¨æ´»äº†
                    board[row][col] = 2

        # éå† board å¾—åˆ°ä¸€æ¬¡æ›´æ–°åçš„çŠ¶æ€
        for row in range(rows):
            for col in range(cols):
                if board[row][col] > 0:
                    board[row][col] = 1
                else:
                    board[row][col] = 0
        return board

class Solution(object):
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        row = len(board)
        col = len(board[0]) if row else 0

        dx = [-1,-1,-1,0,1,1,1,0]
        dy = [-1,0,1,1,1,0,-1,-1]
    
        for i in range(row):
            for j in range(col):
                cnt = 0
                for k in range(8):
                    x, y = i + dx[k], j + dy[k]
                    if x >=0 and x < row and y >=0 and y < col and (board[x][y] == 1  or board[x][y] == 2):
                        cnt += 1

                if board[i][j] and (cnt < 2 or cnt > 3):
                    board[i][j] = 2
                elif board[i][j] == 0 and cnt == 3:
                    board[i][j] = 3

        for i in range(row):
            for j in range(col):
                board[i][j] %= 2
        return board
```

###  1.134. <a name='WordPattern'></a>290. Word Pattern

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1d4411V7mi?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1HZ4y1N7wD?spm_id_from=333.999.0.0)

```py
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        word2ch = dict()
        ch2word = dict()
        words = s.split()
        if len(pattern) != len(words):
            return False
        
        for ch, word in zip(pattern, words):
            if (word in word2ch and word2ch[word] != ch) or (ch in ch2word and ch2word[ch] != word):
                return False
            word2ch[word] = ch
            ch2word[ch] = word
    
        return True

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/word-pattern/solution/dan-ci-gui-lu-by-leetcode-solution-6vqv/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

1.205é¢˜å‡è®¾sä¸té•¿åº¦ç›¸ç­‰ï¼Œè¿™é“é¢˜éœ€è¦å¤„ç†patternå’Œsé•¿åº¦ä¸ä¸€æ ·çš„æƒ…å†µ

2.æœ¬é¢˜éœ€è¦å°†såˆ†éš”æˆå•ä¸ªå•è¯

å…¶å®ƒéƒ¨åˆ†éƒ½ä¸€æ ·ï¼ŒåŠ ä¸¤è¡Œä»£ç å³å¯ï¼Œæ€»å…±ä¸‰è¡Œä»£ç ï¼š

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split()
        if len(pattern) != len(words): return False
        return len(set(pattern)) == len(set(words)) == len(set(zip(pattern,words)))

ç®€ç­”æ€è·¯-->å­—å…¸ç±»å‹

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        d=dict()
        s=s.split()
        if len(pattern)!=len(s):return False

        for x in range(len(pattern)):
            if pattern[x] not in d and s[x] not in d.values():
                d[pattern[x]]=s[x]
            elif pattern[x] in d and  d[pattern[x]]==s[x]:
                pass
            else : return False
        return True
```


```py
ä¸¤ç§æ€è·¯ï¼š æ€è·¯ä¸€ï¼šå“ˆå¸Œè¡¨åŒå°„ï¼Œè¿™ä¸ªæ›´å¿«ï¼Œå°±æ˜¯ä¸¤è¾¹çš„é”®æŒ‰ç…§é¡ºåºå½•å…¥ï¼Œä½†æ˜¯å€¼è¦è¿›è¡Œäº¤æ¢ï¼Œè¦æ˜¯åœ¨å¯¹æ¯”è¿‡ç¨‹ä¸­è¿™ä¸ªé”®å‡ºç°è¿‡ï¼Œä½†æ˜¯å€¼ä¸åŒå°±ä¸ºfalse

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s = s.split(' ')
        pi = {}; si = {}
        if len(pattern) != len(s): return False
        for i, j in zip(pattern, s):
            if (i in pi and pi[i] != j) or (j in si and si[j] != i): return False
            else: 
                pi[i] = j
                si[j] = i
        return True
æ€è·¯äºŒï¼šè¿™ä¸ªæ€è·¯æ˜¯çœ‹è¯„è®ºåŒºçš„ï¼Œéå¸¸æœ‰æ„æ€ï¼Œå°±æ˜¯åˆ©ç”¨äº†indexå‡½æ•°åªè¿”å›ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„ç´¢å¼•çš„æƒ…å†µï¼Œç„¶åè¿›è¡Œæ¯”è¾ƒ

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s = s.split(' ')
        pi = [pattern.index(i) for i in pattern]
        si = [s.index(i) for i in s]
        return True if pi == si else False

python3ä¸­ä¸€ç§æ¯”è¾ƒè®¨å·§çš„è§£æ³•ï¼š

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        pi = []
        si = []
        for v in pattern:
            pi.append(pattern.index(v))
            
        ss = s.split(' ')
        for v in ss:
            si.append(ss.index(v))

        if si == pi:
            return True
        else:
            return False

åœ¨å¤§ä½¬çš„åŸºç¡€ä¸Šç®€åŒ–ä¸€ä¸‹ä»£ç 

class Solution:
    def wordPattern(pattern, s):
        if len(s.split(' ')) != len(pattern):
            return False
        ss = s.split(' ')
        listP,listS = [pattern.index(i) for i in pattern],[ss.index(j) for j in ss]
        return listP == listS
```


###  1.135. <a name='SerializeandDeserializeBinaryTree'></a>297. Serialize and Deserialize Binary Tree

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Hb411c7cr?spm_id_from=333.999.0.0)

###  1.136. <a name='BullsandCows'></a>299. Bulls and Cows

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1M64y1M7aP?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1bh411R7n4?spm_id_from=333.999.0.0)

```py
from collections import defaultdict
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        n = len(secret)
        s, g = defaultdict(int), defaultdict(int)
        a, b = 0, 0
        for i in range(n) :
            l,r = secret[i], guess[i]
            if l == r :
                a += 1
            else :
                s[l] += 1
                g[r] += 1
        for k,v in s.items() :
            b += min(v, g[k])
        return str(a) + 'A' + str(b) + 'B'

# python
#  ä½ è¿™ç”šè‡³ä¸å¦‚sortä¹‹åå†ä¸€ä¸ªä¸€ä¸ªåŒ¹é…ï¼Œç®—ä¸¤éä¸éº»çƒ¦å˜›
#  sortä¹‹åä¸€ä¸€åŒ¹é…ç›¸ç­‰å…ƒç´ å¯¹ä¹ˆï¼Œé‚£ä½ å¦‚ä½•çŸ¥é“bullä¸ªæ•°ï¼Ÿ
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        secret_list = list(secret)
        guess_list = list(guess)

        # å…ˆéå†ä¸€éç»Ÿè®¡bull
        bull = 0
        for i in range(len(secret_list)):
            if secret_list[i] == guess_list[i]:
                bull += 1
        
        # å†éå†ç»Ÿè®¡ä¸€å…±æœ‰å¤šå°‘ä¸ªç›¸ç­‰çš„å…ƒç´ å¯¹
        cow = 0
        for ch in secret_list:
            if ch in guess_list:
                cow += 1
                guess_list.remove(ch)

        # cow - bull å³ä¸ºçœŸæ­£çš„ cow
        return str(bull) + 'A' + str(cow-bull) + 'B'

# åšäº†ä¸¤æ¬¡æ‰åšå‡ºæ¥ï¼Œéœ€è¦æ³¨æ„ï¼š

# è°ƒæ•´ä½ç½®æ—¶ï¼Œä½ç½®åªèƒ½ç”¨ä¸€æ¬¡ æ¯”å¦‚1123 1011 è¾“å‡ºçš„æ˜¯1A1Bè€Œä¸æ˜¯1A2B

# å…ˆè®¡ç®—å…¬ç‰›ï¼ˆæ•°å­—å’Œä½ç½®éƒ½åŒ¹é…ï¼‰ï¼Œæ¯”å¦‚1122 1222 è¾“å‡ºçš„æ˜¯ 3A0Bè€Œä¸æ˜¯3A1B

class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        a = b = 0
        hashmap = collections.Counter(secret)
        for x, y in zip(secret, guess):
            if x == y:
                a += 1
                hashmap[x] -= 1
        for x, y in zip(secret, guess):
            if x != y:
                if y in hashmap:
                    if hashmap[y] > 0:
                        b += 1
                    hashmap[y] -= 1
        return f'{a}A{b}B'

from collections import Counter
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bull = sum(secret[i] == guess[i] for i in range(len(secret)))
        cow = sum((Counter(secret) & Counter(guess)).values()) - bull
        return f'{bull}A{cow}B'

# éƒ½è¿™ä¹ˆçŸ­ã€‚ã€‚ã€‚ã€‚ã€‚
# æˆ‘Pythonè¿˜æ˜¯ç”¨çš„ä¸è¡Œå•Š
import operator
class Solution(object):
    def getHint(self, secret, guess):
        """
        :type secret: str
        :type guess: str
        :rtype: str
        """
        bull = sum(map(operator.eq, secret, guess))
        sa = collections.Counter(secret)
        sb = collections.Counter(guess)
        cow = sum((sa & sb).values()) - bull
        return str(bull) + 'A' + str(cow) + 'B'
```

###  1.137. <a name='LongestIncreasingSubsequence'></a>300 ã€åŠ¨æ€ğŸš€è§„åˆ’ + äºŒåˆ†ã€‘Longest Increasing Subsequence æœ€é•¿ä¸Šå‡å­åºåˆ—

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Wf4y1y7ou?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1rT4y1ujV?spm_id_from=333.999.0.0)

åŠ¨æ€è§„åˆ’ï¼š æ—¶é—´å¤æ‚åº¦ä¸º O(n2)

```py

class Solution(object):
    def lengthOfLIS(self, nums):
        if not nums:
            return 0
        dp = [1 for i in range(len(nums))]
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[j]+1, dp[i])
        return max(dp)

```

è´ªå¿ƒ + äºŒåˆ†æŸ¥æ‰¾

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6wjfuj0uqvo0.webp)

```py
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        res = []
        for num in nums:
            # bisect_leftä¼šæŠŠæ–°çš„å…ƒç´ æ”¾åœ¨ç›¸ç­‰å…ƒç´ å‰é¢, å³åŸæ¥å€¼5çš„ç´¢å¼•ä½ç½®2
            i = bisect_left(res, num)
            if i == len(res):
                res.append(num)
            else:
                res[i] = num
        return len(res)
```

```scala
/**
* chosen answer
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution0 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}

/**
* brute force : not Ac
* memo:
* 1. each position have two choice :
*    1. take current value if currentIdx value > previousIdx value 
*    2. do not take current value
* time complexity: O(2^n)
*/
object Solution1 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        lengthOfLIS(nums, 0, -1)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int): Int = {
      if (currentIdx >= nums.length) return 0
      
      val taken = if (previousIdx == -1  ||  (nums(currentIdx) > nums(previousIdx))) {
        lengthOfLIS(nums, currentIdx + 1, currentIdx) + 1
      } else {
        0
      } 
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx)
      taken max nonTaken
    }
}

/**
* with memorized: we just fill the nxn dimension memory array
* time complexity: O(n^2)
* space complexity: O(n^2)
*/
object Solution1-2 {
    def lengthOfLIS(nums: Array[Int]): Int = {
      val memory = Array.fill[Int](nums.length, nums.length)(-1)
      lengthOfLIS(nums, 0, -1, memory)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int, memory: Array[Array[Int]]): Int  = {
      // println(currentIdx, previousIdx)
      if (nums.length == currentIdx) return 0
      if (memory(currentIdx)(previousIdx + 1) != -1) return memory(currentIdx)(previousIdx + 1)
      
      val taken = if (previousIdx == -1 || nums(currentIdx) > nums(previousIdx)) {
        1 + lengthOfLIS(nums, currentIdx + 1, currentIdx, memory)
      } else {
        0
      }
      
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx, memory)
      
      memory(currentIdx)(previousIdx + 1) = taken max nonTaken
      
      memory(currentIdx)(previousIdx + 1) 
    }
  
  
}





/**
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution3 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        

        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}
```

###  1.138. <a name='RemoveInvalidParentheses'></a>301. Remove Invalid Parentheses

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1VW411y7Xd?spm_id_from=333.999.0.0)

###  1.139. <a name='-1'></a>303 ã€æ„é€ ğŸ°ã€‘åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„ä¸å¯å˜

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1RV411d76R?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV18441137fs?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ho4y1U7wF?spm_id_from=333.999.0.0)

```py
class NumArray:

    def __init__(self, nums: List[int]):
        self.sums = [0]
        _sums = self.sums

        for num in nums:
            _sums.append(_sums[-1] + num)

    def sumRange(self, i: int, j: int) -> int:
        _sums = self.sums
        return _sums[j + 1] - _sums[i]

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/range-sum-query-immutable/solution/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-l-px41/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

å±…ç„¶æ²¡è¶…æ—¶ 233333333

class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums


    def sumRange(self, i: int, j: int) -> int:
        return sum(self.nums[i:j+1])

```

```py
Python3

èœé¸Ÿå¿ƒå¾—ã€‚

é¢˜ç›®å¼ºè°ƒäº†å¤šæ¬¡è°ƒç”¨ï¼Œæœç„¶å°±æ˜¯ä¸€ä¸ªå¤§å‘ï¼Œç¬¬ä¸€æ¬¡å°è¯•å¾ˆæ·¡å®šçš„å†™äº†å¯¹æ•°ç»„åŒºåŸŸæ±‚å’Œå‡½æ•°ï¼Œå¦¥å¦¥çš„è¶…æ—¶äº†ã€‚å¾ˆä¸çˆ½å‡†å¤‡ç¡è§‰ï¼Œç»“æœæ´—æ¼±æ—¶å€™çµæ„Ÿé—ªç°ï¼ŒæŠŠå‰iä¸ªæ•°æ±‚å’Œæ”¾åœ¨nums[i-1]ä½ç½®ï¼Œè¿™æ ·ç­”æ¡ˆä¸å°±æ˜¯nums[j]-nums[i-1]äº†å—ï¼Ÿç¬é—´åº”å¯¹å¤šæ¬¡è°ƒç”¨ğŸ•¶ï¸

class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums
        for i in range(len(self.nums)):
            if i > 0:
                self.nums[i] = self.nums[i]+self.nums[i-1]

    def sumRange(self, i: int, j: int) -> int:
        if i>0:
            return self.nums[j]-self.nums[i-1]
        else:
            return self.nums[j]
```

###  1.140. <a name='RangeSumQuery2D'></a>304. ã€æ„é€ ğŸ°ã€‘Range Sum Query 2D

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Jb411k7LQ?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1R64y127jL?spm_id_from=333.999.0.0)

```py
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), (len(matrix[0]) if matrix else 0)
        self.sums = [[0] * (n + 1) for _ in range(m)]
        _sums = self.sums

        for i in range(m):
            for j in range(n):
                _sums[i][j + 1] = _sums[i][j] + matrix[i][j]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        _sums = self.sums

        total = sum(_sums[i][col2 + 1] - _sums[i][col1] for i in range(row1, row2 + 1))
        return total

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), (len(matrix[0]) if matrix else 0)
        self.sums = [[0] * (n + 1) for _ in range(m + 1)]
        _sums = self.sums

        for i in range(m):
            for j in range(n):
                _sums[i + 1][j + 1] = _sums[i][j + 1] + _sums[i + 1][j] - _sums[i][j] + matrix[i][j]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        _sums = self.sums

        return _sums[row2 + 1][col2 + 1] - _sums[row1][col2 + 1] - _sums[row2 + 1][col1] + _sums[row1][col1]

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

ç›´æ¥åˆ‡ç‰‡ä¸é¦™å—ï¼Ÿ

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.matrix = matrix
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        res = 0
        for i in range(row1,row2+1):
            res += sum(self.matrix[i][col1:col2+1])
        return res

æ•ˆç‡æ¯”è¾ƒä½ï¼Œç©ºé—´æ²¡æœ‰çœä¸‹æ¥ï¼Œæ¯æ¬¡è°ƒç”¨æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(mn)ï¼Œå…¶ä¸­m = row2 - row1, n = col2 - col1ã€‚
```

```py
åˆä¸­ç”Ÿè·¯è¿‡ï¼Œå‘ç°è¿™ä¸€é¢˜è·Ÿå­¦æ ¡æ•™çš„å› å¼åˆ†è§£ (A-B)^2 = A^2 - 2AB + B^2 å¾ˆåƒï¼Œå½“ä¸­ï¼š

row2 å’Œ col2 å°±æ˜¯ A ,

row2 - row1 å’Œ col2 - col1 å°±æ˜¯ B

å½“ç„¶ (A-B)^2 = A^2 - 2AB + B^2 åªåœ¨ row1 == col1 && row2 == col2 çš„æƒ…å†µä¸‹å¯ç”¨ï¼Œä¸¥æ ¼æ¥è¯´åº”è¯¥æ˜¯ï¼š

(A-B)(C-D) = AC - AD - BC + BD

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        
        self.row = len(matrix)+1
        if self.row == 1: return
        self.col = len(matrix[0])+1
        
        self.matrix = [[0 for i in range(self.col)]] + [[0]+i for i in matrix]
        
        for i in range(1, self.row):
            for j in range(1, self.col):
                self.matrix[i][j] = self.matrix[i][j] + self.matrix[i-1][j] + self.matrix[i][j-1] - self.matrix[i-1][j-1]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        
        if self.row == 0: return 0
        
        # é‡ç‚¹ï¼š(A-B)(C-D) = AC - AD - BC + BD
        return self.matrix[row2+1][col2+1] - self.matrix[row1][col2+1] - self.matrix[row2+1][col1] + self.matrix[row1][col1]
```

###  1.141. <a name='BestTimetoBuyandSellStockwithCooldown309-'></a>309. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Best Time to Buy and Sell Stock with Cooldown 309-æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1qW411C7Xc?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Vy4y1z7pb?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV13D4y1U7iU?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy = prices[0]
        lazy = 0
        profit = 0
        for price in prices:
            # é¡ºåºä¸èƒ½é”™
            buy = min(buy, price - lazy)
            # buy <- lazy
            lazy = max(profit, lazy)
            # lazy <- profit
            profit = max(profit, price - buy)
        return max(lazy,profit)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy = prices[0]
        lazy = 0
        profit = 0
        for price in prices:
            # é¡ºåºä¸èƒ½é”™
            buy = min(buy, price - lazy)
            # buy <- lazy
            lazy = max(profit, lazy)
            # lazy <- profit
            profit = price - buy
        return max(lazy,profit)


é€’æ¨å…¬å¼ï¼š
sell[i] = max(buy[i-1]+prices[i], sell[i-1]) (ç¬¬ä¸€é¡¹è¡¨ç¤ºç¬¬iå¤©å–å‡ºï¼Œç¬¬äºŒé¡¹è¡¨ç¤ºç¬¬iå¤©å†·å†»)
buy[i] = max(cool[i-1]-prices[i], buy[i-1]) ï¼ˆç¬¬ä¸€é¡¹è¡¨ç¤ºç¬¬iå¤©ä¹°è¿›ï¼Œç¬¬äºŒé¡¹è¡¨ç¤ºç¬¬iå¤©å†·å†»ï¼‰
cool[i] = max(sell[i-1], buy[i-1], cool[i-1])

```


```scala

/**
* my first commitment
* dynamic programming
* memo
*   1. dp definition: dp[i][j] means the best profit we can have at i-th day in state j of without holding / holding / cooldown 
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        /*
        * state definition
        * 0: without holding
        * 1: holding one
        * 2: sold than cooldown
        */
        val dp = Array.tabulate(prices.length, 3){
            case (0, 0) => 0
            case (0, 1) => -prices(0)
            case (0, 2) => 0
            case _ => 0
        }
        
        for(i <- 1 until prices.length) {
            dp(i)(0) = dp(i - 1)(0) max dp(i - 1)(2) // 0 -> 0 or 2 -> 0
            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i)) // 1 -> 1 or  0 -> 1
            dp(i)(2) = dp(i - 1)(1) + prices(i) // 1 -> 2
        }
        
        dp.last.max
    }
}

/**
* dynamic programming
* memo
*    ok! lets reduce the dp array size without keep all i-th state
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-2 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        var withoutHold = 0
        var hold = Int.MinValue
        var coolDown = 0
        
        for(price <- prices) {
            val withoutHold_ = withoutHold  // keep value
            val hold_ = hold // keep value
            withoutHold = withoutHold max coolDown
            hold = hold max (withoutHold_ - price)
            coolDown = hold_ + price  
        }
        withoutHold max coolDown
    }
}

/**
* dynamic programming - function programming
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-3 {
    def maxProfit(prices: Array[Int]): Int = {
        val (withoutHold, hold, cooldown) = prices.foldLeft(0, Int.MinValue, 0) {
            case ((withoutHold, hold, cooldown), cost) => 
             (
                 withoutHold max cooldown,
                 hold max (withoutHold - cost),
                 hold + cost      
             )
        }
        withoutHold max cooldown
    }
}
```

###  1.142. <a name='NumberofIsland'></a>305 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Number of Island

[éƒ­éƒ­](https://www.bilibili.com/video/BV1pV41147SZ?from=search&seid=13286624680279107&spm_id_from=333.337.0.0)

###  1.143. <a name='MinimumHeightTrees'></a>310 Minimum Height Trees

[å°æ˜](https://www.bilibili.com/video/BV1eA411j7XQ?spm_id_from=333.999.0.0)

###  1.144. <a name='BurstBalloons'></a>312 Burst Balloons

[å°æ˜](https://www.bilibili.com/video/BV1Q64y1f7Vy?spm_id_from=333.999.0.0)

###  1.145. <a name='CountofSmallerNumbersAfterSelf'></a>315. Count of Smaller Numbers After Self

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1BW411C7TM?spm_id_from=333.999.0.0)

###  1.146. <a name='RemoveDuplicateLetters'></a>316 ã€è´ªå¿ƒğŸ§¡ã€‘Remove Duplicate Letters

[å°æ˜](https://www.bilibili.com/video/BV1x54y1R7y7?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Tz4y167pC?spm_id_from=333.999.0.0)

```py
# æ€è·¯æ˜¯å‚è€ƒåˆ«äººçš„ï¼Œ
# å¦‚æœæ•°æ¯”æ ˆé¡¶å°ï¼Œè€Œä¸”æ ˆé¡¶åœ¨åé¢è¿˜æœ‰çš„è¯ï¼Œ
# å°±å¼¹å‡ºæ ˆé¡¶ã€‚
# pythonè‡ªå¸¦åˆ—è¡¨å¼¹å‡ºå’ŒåŠ å…¥æœ€åä¸€ä¸ªæ•°éƒ½æ˜¯å¾ˆå¿«çš„ã€‚
# ç„¶ååœ¨å‰é¢åŠ ä¸€ä¸ª0ï¼Œå› ä¸º0æ¯”ä¸€åˆ‡å­—æ¯å°ï¼Œå¯ä»¥ä¸ç”¨åˆ¤ç©ºï¼Œæ–¹ä¾¿å¾ˆå¤š

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        result = ["0"] # åˆå€¼ä¸è¦ä¸ºç©ºï¼Œä¸ç„¶indexä¸º-1ä¼šæŠ¥é”™
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            print("s[idx:]",s[idx:],"æ•°é‡: ",s[idx:].count(result[-1]),"éœ€è¦å¤§äº0,è¡¨ç¤ºè¦æŠŠcåˆ æ‰ï¼Œå¿…é¡»åé¢è¿˜æœ‰c")
            if char not in result:
                while char < result[-1] and s[idx:].count(result[-1]) > 0:
                    result.pop(-1) # result åˆ é™¤æœ€åä¸€ä½
                result.append(char)
        return "".join(result[1:])

# é€’å½’è´ªå¿ƒç‰ˆæœ¬
class Solution(object):
    def removeDuplicateLetters(self, str):
        """
        :type s: str
        :rtype: str
        """
        print("-"*50)
        # å…ˆæŒ‰å­—å…¸æ’åº
        for char in sorted(set(str)):
            print("-"*20,char)
            suffix = str[str.index(char):]
            print(suffix)


            # çœ‹ä½™ä¸‹çš„æ˜¯å¦èƒ½ç»„æˆæ‰€éœ€çš„å­—æ¯
            # if len(set(suffix)) == len(set(str)): ä¹Ÿå¯ä»¥
            if set(suffix) == set(str):
                return char + self.removeDuplicateLetters(suffix.replace(char, ''))
                # é€æ­¥æŠŠcharåé¢çš„charæ›¿æ¢æ‰
        return ''

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        result = ''
        while s:
            print(list(map(s.rindex, set(s))))
            i = min(map(s.rindex, set(s)))
            c = min(s[:i+1])
            print(s[:i+1])
            result += c
            s = s[s.index(c):].replace(c, '')
            print(s)
        return result

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        rindex = {char: idx for idx, char in enumerate(s)}
        print("rindex",rindex)
        result = '' 
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            if char not in result:
                while char < result[-1:] and idx < rindex[result[-1:]]:
                    # å¦‚æœ char æ¯” æœ€åä¸€ä½result[-1:] å°
                    # result åˆ é™¤æœ€åä¸€ä½
                    print("rindex[result[-1:]",rindex[result[-1:]])
                    result = result[:-1] 
                result += char
        return result

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        n = len(s)
        stack = [s[0]]
        for i in range(1,n):
            if s[i] not in stack and s[i]>stack[-1]:
                stack.append(s[i])
            elif s[i] not in stack:
                while stack and s[i]<stack[-1] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
        return "".join(stack)

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        n = len(s)
        for i in range(n):
            if s[i] in stack:
                continue
            else:
                while stack and stack[-1] > s[i] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
            
        return "".join(stack)

# æ€è·¯ä¸‰ï¼šæ ˆ
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        from collections import Counter
        c = Counter(s)
        stack = []
        existed = set()
        for a in s:
            # print(stack)
            if a not in existed:
            	# åˆ¤æ–­åé¢è¿˜æœ‰æ²¡æœ‰è¯¥å­—æ¯
                while stack and stack[-1] > a and c[stack[-1]] > 0:
                    existed.remove(stack.pop())
                stack.append(a)
                existed.add(a)
            c[a] -= 1
        return "".join(stack)

# æ€è·¯äºŒï¼šè¿­ä»£
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        res = ""
        while s:
            # ä»å³å¾€å·¦æ‰¾ï¼Œæ‰¾åˆ°æœ€å°ä½ç½®çš„ç´¢å¼•å·
            loc = min(map(s.rindex, s))
            # æ‰¾è¯¥ç´¢å¼•å‰é¢æœ€å°çš„å­—æ¯
            a = min(s[:loc + 1])
            res += a
            s = s[s.index(a):].replace(a, "")
        return res
```

###  1.147. <a name='-1'></a>318ã€ã€‘

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.fgtvti63s9c.webp)

```py
class Solution:
    def maxProduct(self, words: List[str]) -> int:
        masks = [reduce(lambda a, b: a | (1 << (ord(b) - ord('a'))), word, 0) for word in words]
        return max((len(x[1]) * len(y[1]) for x, y in product(zip(masks, words), repeat=2) if x[0] & y[0] == 0), default=0)


class Solution:
    def maxProduct(self, words: List[str]) -> int:
        def hepler(s:str):
            res = 0 
            for i in s:
                res |= 1 << (ord(i)-97) # ord('a') = 97ï¼Œå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºäºŒè¿›åˆ¶
            return res

        cache = dict()
        for i in words:
            digit = hepler(i)
            cache[digit] = max(cache.get(digit, 0), len(i))

        k = list(cache.keys())
        n = len(k)
        res = 0
        for i in range(n):
            for j in range(i+1, n):
                if (k[i] & k[j]) == 0: # æ²¡æœ‰ç›¸åŒä½çš„åˆ¤æ–­
                    res = max(res, cache[k[i]]*cache[k[j]])
        return res
```

###  1.148. <a name='-1'></a>319

```py
class Solution(object):
    def bulbSwitch(self, n):
        """
        :type n: int
        :rtype: int
        """
        bulb = [1] * n # å®é™…ä¸Šæ˜¯ä»ç¬¬ä¸€è½®åï¼Œå¼€å§‹ç®—èµ·çš„ï¼Œåˆšå¥½n=0çš„æƒ…å†µç¬¦åˆ
        print("bulb: ",bulb)
        for interval in range(2,n+1):
            for x in range(interval-1, n, interval): # ä»ç¬¬intervalå¼€å§‹ï¼Œé—´éš”intervalä¸ª
                # ---------åˆ‡æ¢å¼€å…³---------
                bulb[x] = 1 if bulb[x] == 0 else 0
                print("bulb: ",bulb)
                # ---------åˆ‡æ¢å¼€å…³---------
        return bulb.count(1)
```

###  1.149. <a name='CreateMaximumNumber'></a>321. Create Maximum Number

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11W411U7NR?spm_id_from=333.999.0.0)

###  1.150. <a name='dfsCoinChange'></a>322. ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + dfsã€‘Coin Change

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1SW411C7d1?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1tz4y1d7XM?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ty4y187dh?spm_id_from=333.999.0.0)

```py
åŠ¨æ€ğŸš€è§„åˆ’

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # è¿™é“é¢˜çš„éš¾ç‚¹åœ¨äºï¼šdpæ•°ç»„çš„åˆå§‹åŒ–
        dp = [10e9] * (amount + 1)
        dp[0] = 0

        for coin in coins:
            for i in range(coin, amount + 1):
                if i >= coin:
                    dp[i] = min(dp[i], dp[i-coin] + 1)
         # è¿™é“é¢˜çš„éš¾ç‚¹åœ¨äºï¼šæœ€åç»“æœçš„è¾“å‡º
        return dp[-1] if dp[-1] != 10e9 else -1


class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [10e9] * (amount + 1)
        dp[0] = 0

        # è¿™é“é¢˜ i å’Œ coin å€’æ˜¯æ— æ‰€è°“
        for i in range(1, amount + 1):
            for coin in coins:
                if i >= coin:
                    dp[i] = min(dp[i], dp[i-coin] + 1)
        return dp[-1] if dp[-1] != 10e9 else -1


# æ–¹æ³•ä¸€ï¼šè®°å¿†åŒ–æœç´¢

class Solution:
    def coinChange(self, coins, amount):
        # @functools.lru_cache(amount)
        def dp(rem) -> int:
            if rem < 0: return -1
            if rem == 0: return 0
            mini = int(1e9)
            for coin in self.coins:
                res = dp(rem - coin)
                if res >= 0 and res < mini:
                    mini = res + 1
            return mini if mini < int(1e9) else -1

        self.coins = coins
        if amount < 1: return 0
        return dp(amount)




# BFS

class Solution:
    def coinChange(self, coins, amount):
        from collections import deque
        queue = deque([amount])
        step = 0
        visited = set()
        while queue:
            n = len(queue)
            for _ in range(n):
                tmp = queue.pop()
                if tmp == 0:
                    return step
                for coin in coins:
                    if tmp >= coin and tmp - coin not in visited:
                        visited.add(tmp - coin)
                        queue.appendleft(tmp - coin)
            step += 1
        return -1

# å®½åº¦ä¼˜å…ˆ,é€Ÿåº¦é£•é£•çš„

class Solution:
    def coinChange(self, coins, amount):
        q = [[0, 0]]
        see = {0}
        while q:
            cur, cnt = q.pop(0)
            if cur == amount:
                return cnt
            for i in coins:
                t = cur + i
                if t <= amount and t not in see:
                    q.append([t, cnt + 1])
                    see.add(t)
        return -1
# è‡ªé¡¶å‘ä¸‹

class Solution:
    def coinChange(self, coins, amount):
        import functools
        @functools.lru_cache(None)
        def helper(amount):
            if amount == 0:
                return 0
            return min(helper(amount - c) if amount - c >= 0 else float("inf") for c in coins) + 1
        res = helper(amount)
        return res if res != float("inf") else -1

# DFS

class Solution:
    def coinChange(self, coins, amount):
        coins.sort(reverse=True)
        self.res = float("inf")
        
        def dfs(i, num, amount):
            if amount == 0:
                self.res = min(self.res, num)
                return 
            for j in range(i, len(coins)):
                # å‰©ä¸‹çš„æœ€å¤§å€¼éƒ½ä¸å¤Ÿå‡‘å‡ºæ¥äº†
                if (self.res - num) * coins[j] < amount:
                    break
                if coins[j] > amount:
                    continue
                dfs(j, num + 1, amount - coins[j])
                
        for i in range(len(coins)):
            dfs(i, 0, amount)
            
        return self.res if self.res != float("inf") else -1
```

```scala
/**
* dynamic programming: bottom up
* time complexity: O(S * N), S is the amount, N is the coin denomination count
* space complexity: O(S)
*/

object Solution {
    def coinChange(coins: Array[Int], amount: Int): Int = {
         
        val dp = Array.fill[Int](amount + 1)(amount + 1) // record the minimum needed coins of each denominations

        dp(0) = 0
        for (i <- 1 to amount; denominations <- coins) {

            if(denominations <= i) {
                dp(i) = dp(i) min (dp(i - denominations) + 1)
            }        
        }
    
        if (dp.last > amount) -1 else dp.last
    }
}

```

###  1.151. <a name='-1'></a>324

```py
class Solution(object):
    def wiggleSort(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        nums.sort()
        half = len(nums[::2])
        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]
```

###  1.152. <a name='PowerofThree'></a>326. Power of Three

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Gx411o7QC?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1h441137PM?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1sZ4y1F7Lr?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        while n and n % 3 == 0:
            n //= 3
        return n == 1

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode-solution-hnap/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and 1162261467 % n == 0

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode-solution-hnap/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        # ä¸€ç§æ˜¯åˆ©ç”¨å¯¹æ•°
        # fmod æ˜¯floatæ±‚ä½™ åœ¨mathä¸‹
        return n>0 and fmod(log10(n) / log10(3), 1) == 0
        # å¦ä¸€ç§æ–¹æ³•æ˜¯ï¼Œå› ä¸ºåœ¨ int èŒƒå›´å†… 3 çš„æœ€å¤§æ¬¡æ–¹æ˜¯ 3^19 = 1162261467ï¼Œ
        # å¦‚æœ n æ˜¯ 3 çš„æ•´æ•°æ¬¡æ–¹ï¼Œé‚£ä¹ˆ 1162261467 é™¤ä»¥ n çš„ä½™æ•°ä¸€å®šæ˜¯é›¶ã€‚
        # return n > 0 and 1162261467 % n == 0
 x*3 = x*(2+1) = x * 2 + x = (x<<1) + x

å¸¸è§„é€’å½’ï¼š

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n < 3:
            if n == 1: return True
            return False
        else:
            if n % 3 == 0:
                return self.isPowerOfThree(n//3)
            else:
                return False

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        b = 1
        while b < n:
            b = (b << 1) + b
        if b == n:
            return True
        return False
```

```py
ï¼Ÿï¼Ÿï¼Ÿ
è¿™ç§åœ¨å¾ªç¯ä¸­é€’å½’çš„å†™æ³•è¦æ€ä¹ˆæ”¹å‘€ï¼Ÿä¸ºä½•æ¯æ¬¡n=1ç„¶åreturn Trueä¹‹ånåˆå˜æˆäº†3å¼€å§‹é€’å½’ï¼Œä¸€ç›´åœ¨æ— é™å¾ªç¯

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        while n > 1 :
            if n % 3 != 0:
                return False
            else:
                self.isPowerOfThree(n//3)
        return True

ä½ çš„elseè¯­å¥å°‘äº†ä¸ªreturnï¼Œè€Œä¸”åˆ¤æ–­æ¡ä»¶ä¹Ÿä¸å¤ªå¯¹ï¼Œä¸¾ä¸ªä¾‹å­ n = 3 ï¼Œå¾ªç¯ä¼šè¿›å…¥elseåˆ†æ”¯ï¼Œä½†æ‰§è¡Œå®Œ self.isPowerOfThree(n//3) ï¼ˆå…ˆä¸ç®¡æ‰§è¡Œç»“æœï¼‰næ²¡å˜åŒ–åˆè¿›å…¥ä¸‹ä¸€è½®å¾ªç¯ï¼Œåˆè¿›å…¥elseåˆ†æ”¯ï¼Œè¿™ä¸å°±æ— é™å¾ªç¯äº†ï¼Ÿå¯ä»¥æ”¹æˆè¿™æ ·ï¼š

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n >= 1 :
            if n % 3 != 0:
                return n == 1
            else:
                return self.isPowerOfThree(n//3)
        return False
```

###  1.153. <a name='OddEvenLinkedList'></a>328. å¥‡å¶é“¾è¡¨ (Odd Even Linked List)

[æ´›é˜³](https://www.bilibili.com/video/BV1v64y1u7AH?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ag4y1B78z?spm_id_from=333.999.0.0)

```py
# éƒ½æ˜¯å¥‡å¶ä¿©ä¸ªé“¾è¡¨ç„¶ååˆå¹¶çš„ï¼Œæˆ‘æ€ä¹ˆå°±æ²¡æƒ³åˆ°ã€‚ã€‚ æˆ‘ç›´æ¥æƒ³çš„å°±æ˜¯å¿«æ…¢æŒ‡é’ˆç„¶ååªæŠŠå¥‡æ•°èŠ‚ç‚¹æ‹¿å‡ºæ¥æ’åˆ°å‰é¢ã€‚ã€‚ã€‚

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        if not head.next:
            return head
        if not head.next.next:
            return head
        p = head
        fast,slow = head.next.next,head
        fast_pre = head.next
        while fast:
            # æŠŠå½“å‰fast(å¥‡æ•°)èŠ‚ç‚¹æ”¾åœ¨slowåé¢ï¼Œè®°å½•fast_preä¿è¯å¤åŸ
            fast_pre.next,slow.next,fast.next= fast.next,fast,slow.next
            slow = slow.next
            fast_pre = fast_pre.next
            if not fast_pre or not fast_pre.next :
                break
            fast = fast_pre.next
        return head

# åŒæŒ‡é’ˆåˆ†åˆ«å¯¹åº”å¥‡å¶é“¾ï¼Œæœ€åä¸²èµ·æ¥ï¼šhttps://github.com/Brycexxx/leetcode/blob/master/oddEvenList.py

# Definition for singly-linked list.
class ListNode:
   def __init__(self, x):
       self.val = x
       self.next = None


class Solution:
   def oddEvenList(self, head: ListNode) -> ListNode:
       if head == None: return head
       point1, point2 = head, head.next
       p1, p2 = point1, point2
       while p2 != None and p2.next:
           p1.next = p1.next.next
           p2.next = p2.next.next
           p1 = p1.next
           p2 = p2.next
       p1.next = point2
       return point1

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        '''
        slow: ä¸Šä¸€ä¸ªå¥‡æ•°èŠ‚ç‚¹
        fast: ä¸‹ä¸€ä¸ªå¥‡æ•°èŠ‚ç‚¹
        pre: ä¸‹ä¸€ä¸ªå¥‡æ•°èŠ‚ç‚¹çš„å‰ç¼€èŠ‚ç‚¹
        post: ä¸Šä¸€ä¸ªå¥‡æ•°èŠ‚ç‚¹çš„åç¼€èŠ‚ç‚¹
        '''
        slow, pre, fast = head, head.next, head.next.next
        while slow and fast:
            q = fast.next.next if fast.next else None
            post = slow.next
            pre.next = fast.next
            fast.next = post
            slow.next = fast
            slow, pre, fast = fast, pre.next, q
        return head


# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        # å¥‡èŠ‚ç‚¹åœ¨å¶èŠ‚ç‚¹ä¹‹å‰
        if head == None:
            return None
        dummy_head_1 = ListNode(-1)
        dummy_head_2 = ListNode(-1)
        p1 = dummy_head_1  # å¥‡èŠ‚ç‚¹
        p2 = dummy_head_2  # å¶èŠ‚ç‚¹
        i = 1  # é¢˜ç›®è¦æ±‚ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¥‡èŠ‚ç‚¹
        while head:
            if i % 2 == 0:
                p2.next = head
                p2 = p2.next
                head = head.next
            else:
                p1.next = head
                p1 = p1.next
                head = head.next
            i += 1
        p2.next = None
        p1.next = dummy_head_2.next
        return dummy_head_1.next

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        evenHead = head.next
        odd, even = head, evenHead
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = evenHead
        return head

class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None:
            return head

        # odd used to keep track of the tail of odd nodes
        odd = oddHead = head
        # record how many swaps happend
        even = evenHead = head.next
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next 
            even = even.next
        odd.next = evenHead
        return head 
```

###  1.154. <a name='dfsLongestIncreasingPathinaMatrix'></a>329. ã€åŠ¨æ€ğŸš€è§„åˆ’ + dfsã€‘Longest Increasing Path in a Matrix

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1mW411d7q8?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1VK4y1K7SX?spm_id_from=333.999.0.0)

åŠ¨æ€ğŸš€è§„åˆ’

```py
å…ˆé¢„å¤„ç†ï¼Œå¯¹çŸ©é˜µçš„å€¼æŒ‰ä»å°åˆ°å¤§æ’åºï¼ŒæŒ‰å¤§å°é¡ºåºæ‰èƒ½ä¿è¯ä¾èµ–çš„å­é—®é¢˜éƒ½æ±‚è§£è¿‡äº†

dp[i][j]è¡¨ç¤ºä»¥matrix[i][j]ç»“å°¾çš„æœ€é•¿é€’å¢é•¿åº¦

åˆå§‹dp[i][j]éƒ½ç­‰äº1
è‹¥matrix[i][j]å››ä¸ªæ–¹å‘æœ‰ä»»æ„å°äºå®ƒï¼Œåˆ™å¯ä»¥æ›´æ–°dp[i][j] = max(dp[i][j], 1 + dp[r][c])

class Solution(object):
    def longestIncreasingPath(self, matrix):
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        lst = []
        for i in range(m):
            for j in range(n):
                lst.append((matrix[i][j], i, j))
        lst.sort()
        dp = [[0 for _ in range(n)] for _ in range(m)]
        for num, i, j in lst:
            dp[i][j] = 1
            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                r, c = i + di, j + dj
                if 0 <= r < m and 0 <= c < n:
                    if matrix[i][j] > matrix[r][c]:
                        dp[i][j] = max(dp[i][j], 1 + dp[r][c])
        return max([dp[i][j] for i in range(m) for j in range(n)])
```

```py
class Solution:
    
    DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        @lru_cache(None)
        def dfs(row: int, column: int) -> int:
            best = 1
            for dx, dy in Solution.DIRS:
                newRow, newColumn = row + dx, column + dy
                if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] > matrix[row][column]:
                    best = max(best, dfs(newRow, newColumn) + 1)
            return best

        ans = 0
        rows, columns = len(matrix), len(matrix[0])
        for i in range(rows):
            for j in range(columns):
                ans = max(ans, dfs(i, j))
        return ans


class Solution:

    DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        rows, columns = len(matrix), len(matrix[0])
        outdegrees = [[0] * columns for _ in range(rows)]
        queue = collections.deque()
        for i in range(rows):
            for j in range(columns):
                for dx, dy in Solution.DIRS:
                    newRow, newColumn = i + dx, j + dy
                    if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] > matrix[i][j]:
                        outdegrees[i][j] += 1
                if outdegrees[i][j] == 0:
                    queue.append((i, j))

        ans = 0
        while queue:
            ans += 1
            size = len(queue)
            for _ in range(size):
                row, column = queue.popleft()
                for dx, dy in Solution.DIRS:
                    newRow, newColumn = row + dx, column + dy
                    if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] < matrix[row][column]:
                        outdegrees[newRow][newColumn] -= 1
                        if outdegrees[newRow][newColumn] == 0:
                            queue.append((newRow, newColumn))
        
        return ans






```

```py
æ–¹æ³•ä¸€ï¼šä»£ç æ¸…æ™°

æ–¹æ³•äºŒï¼šæ•ˆç‡æœ€é«˜

æ–¹æ³•ä¸‰ï¼šä»£ç ç®€æ´

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]: return 0

        row = len(matrix)
        col = len(matrix[0])
        lookup = [[0] * col for _ in range(row)]

        def dfs(i, j):
            if lookup[i][j] != 0:
                return lookup[i][j]
            # æ–¹æ³•ä¸€
            res = 1
            for x, y in [[-1, 0], [1, 0], [0, 1], [0, -1]]:
                tmp_i = x + i
                tmp_j = y + j
                if 0 <= tmp_i < row and 0 <= tmp_j < col and \
                        matrix[tmp_i][tmp_j] > matrix[i][j]:
                    res = max(res, 1 + dfs(tmp_i, tmp_j))
            lookup[i][j] = max(res, lookup[i][j])
            # æ–¹æ³•äºŒ
            # val = matrix[i][j]
            # lookup[i][j] = 1 + max(
            #     dfs(i + 1, j) if 0 <= i + 1 < row and 0 <= j < col and matrix[i + 1][j] > val else 0,
            #     dfs(i - 1, j) if 0 <= i - 1 < row and 0 <= j < col and matrix[i - 1][j] > val else 0,
            #     dfs(i, j + 1) if 0 <= i < row and 0 <= j + 1 < col and matrix[i][j + 1] > val else 0,
            #     dfs(i, j - 1) if 0 <= i < row and 0 <= j - 1 < col and matrix[i][j - 1] > val else 0,
            # )
            # æ–¹æ³•ä¸‰
            # lookup[i][j] = 1 + max(
            #     [dfs(i + x, y + j) for x, y in [[-1, 0], [1, 0], [0, 1], [0, -1]] \
            #      if 0 <= (i + x) < row and 0 <= (j + y) < col and matrix[i + x][j + y] > matrix[i][j]] or [0]
            # )
            
            return lookup[i][j]

        return max(dfs(i, j) for i in range(row) for j in range(col))
```

###  1.155. <a name='ReconstructItinerary'></a>332 Reconstruct Itinerary

[å°æ˜](https://www.bilibili.com/video/BV1qa4y1h7Ti?spm_id_from=333.999.0.0)

###  1.156. <a name='IncreasingTripletSubseque'></a>334 Increasing Triplet Subseque

[å°æ˜](https://www.bilibili.com/video/BV1Kr4y1F7m9?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        # m - min, sm - second min
        m, sm = float('inf'), float('inf')

        for num in nums:
        	print (m, sm)
        	if m >= num:
        		m = num
        	elif sm >= num:
        		sm = num
        	else:
        		return True
        return False


class Solution:
    def increasingTriplet(self, nums):
        n = len(nums)
        if n < 3:
            return False
        small, mid = max(nums), max(nums)
        for i in range(n):
            if nums[i] <= small:
                small = nums[i]
            elif nums[i] <= mid:
                mid = nums[i]
            elif nums[i] > mid:
                return True
        return False

# å¾ªç¯éå†æ•°ç»„ï¼Œä¸æ–­æ›´æ–°æ•°ç»„å†…å‡ºç°çš„æœ€å°å€¼ä¸æœ€å¤§å€¼ï¼Œå¦‚æœå‡ºç°çš„ä¸€ä¸ªå¤§äºæœ€å¤§å€¼çš„æ•°ï¼Œåˆ™è¡¨ç¤ºå­˜åœ¨é•¿åº¦ä¸º 3 çš„é€’å¢å­åºåˆ—ã€‚

class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        length = len(nums)
        if length < 3:
            return False
        
        min_num = float('inf')
        max_num = float('inf')
        
        for n in nums:
            if n < min_num:
                min_num = n
            elif min_num < n and n <= max_num:
                max_num = n
            elif n > max_num:
                return True
        
        return False
```

###  1.157. <a name='HouseRobberIII'></a>337 House Robber III

[å°æ˜](https://www.bilibili.com/video/BV1WD4y1X7JQ?spm_id_from=333.999.0.0)

```py
# è¡¥å……ä¸€ä¸ªPythonçš„ï¼š

class Solution:
    def rob(self, root: TreeNode) -> int:
        def _rob(root):
            if not root: return 0, 0
            
            ls, ln = _rob(root.left)  # å‰ä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹å·ï¼Œåä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹ä¸å·
            rs, rn = _rob(root.right) # å‰ä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹å·ï¼Œåä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹ä¸å·
            
            return root.val + ln + rn, max(ls, ln) + max(rs, rn) # å‰ä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹å·ï¼Œåä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹ä¸å·

        return max(_rob(root))
# lsè¡¨ç¤ºå·å·¦å­æ ‘èƒ½å¸¦æ¥çš„æœ€å¤§æ”¶ç›Šï¼Œlnè¡¨ç¤ºä¸å·å·¦å­æ ‘èƒ½å¸¦æ¥çš„æœ€å¤§æ”¶ç›Šï¼Œrsã€rnåŒç†

# è¿™ä¸ªè§£æ³•å¥½åƒæœ‰ç‚¹å‰å®³

# ä»rootå¼€å§‹æŠ¢èµ·æ¥ï¼Œæœ€å¤§èƒ½æŠ¢åˆ°çš„ä¸¤ä¸ªå¯èƒ½ï¼š æŠ¢rootå’Œä¸æŠ¢root

# - rob_root = max(rob_L + rob_R , no_rob_L + no_nob_R + root.val)
# - no_rob_root = rob_L + rob_R


# è¿™ä¸ªé€’å½’å†™èµ·æ¥å°±å¾ˆå‰å®³äº†


# ```
class Solution(object):
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(root):
            if not root: return 0, 0
            rob_L, no_rob_L = dfs(root.left) # å‰ä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹å·ï¼Œåä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹ä¸å·
            rob_R, no_rob_R = dfs(root.right) # å‰ä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹å·ï¼Œåä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹ä¸å·
            return max(no_rob_R + no_rob_L + root.val , rob_L + rob_R), rob_L + rob_R # å‰ä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹å·ï¼Œåä¸€é¡¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹ä¸å·
        return dfs(root)[0]

class Solution:
    def rob(self, root: TreeNode) -> int:
        result = self.rob_tree(root)
        return max(result[0], result[1])
    
    def rob_tree(self, node):
        if node is None:
            return (0, 0) # (å·å½“å‰èŠ‚ç‚¹é‡‘é¢ï¼Œä¸å·å½“å‰èŠ‚ç‚¹é‡‘é¢)
        left = self.rob_tree(node.left)
        right = self.rob_tree(node.right)
        val1 = node.val + left[1] + right[1] # å·å½“å‰èŠ‚ç‚¹ï¼Œä¸èƒ½å·å­èŠ‚ç‚¹
        val2 = max(left[0], left[1]) + max(right[0], right[1]) # ä¸å·å½“å‰èŠ‚ç‚¹ï¼Œå¯å·å¯ä¸å·å­èŠ‚ç‚¹
        return (val1, val2)

class Solution:
    def rob(self, root: TreeNode) -> int:
        if root is None:
            return 0
        if root.left is None and root.right  is None:
            return root.val
        # å·çˆ¶èŠ‚ç‚¹
        val1 = root.val
        if root.left:
            val1 += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right:
            val1 += self.rob(root.right.left) + self.rob(root.right.right)
        # ä¸å·çˆ¶èŠ‚ç‚¹
        val2 = self.rob(root.left) + self.rob(root.right)
        return max(val1, val2)
```

###  1.158. <a name='CountingBits'></a>338 ã€åŠ¨æ€è§„åˆ’ + ä½è¿ç®—ğŸ˜œã€‘Counting Bits

[å°æ˜](https://www.bilibili.com/video/BV1VK411s7xi?spm_id_from=333.999.0.0)

```py
class Solution:
    def countBits(self, n: int) -> List[int]:
        def countOnes(x: int) -> int:
            ones = 0
            while x > 0:
                x &= (x - 1)
                ones += 1
            return ones
        
        bits = [countOnes(i) for i in range(n + 1)]
        return bits

åŠ¨æ€è§„åˆ’ æ–¹æ³•1ï¼š
class Solution:
    def countBits(self, n: int) -> List[int]:
        bits = [0]
        highBit = 0
        for i in range(1, n + 1):
            if i & (i - 1) == 0:
                highBit = i
            bits.append(bits[i - highBit] + 1) # åªå»æ‰æœ€å³è¾¹çš„ 1
        return bits

class Solution:
    def countBits(self, n: int) -> List[int]:
        bits = [0]
        for i in range(1, n + 1):
            bits.append(bits[i & (i - 1)] + 1) # åªå»æ‰æœ€å³è¾¹çš„ 1
        return bits

åŠ¨æ€è§„åˆ’ æ–¹æ³•äºŒï¼š
class Solution:
    def countBits(self, n: int) -> List[int]:
        bits = [0]
        for i in range(1, n + 1):
            bits.append(bits[i >> 1] + (i & 1)) # æœ€å³è¾¹çš„ 1 or 0
        return bits

class Solution:
    def countBits(self, num: int) -> List[int]:
        res=[0]
        for i in range(1,num+1):
            if i%2==0:
                res.append(res[i//2])
            else:
                res.append(res[i-1]+1)
        return res

```

```py
class Solution(object):
    def countBits(self, n):

        return [bin(i)[2:].count('1') for i in range(n+1)]
```


```scala

/**
* chosen solution
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution0 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}

object Solution1 {
    def countBits(num: Int): Array[Int] = {
        (0 to num).map(_counter).toArray
        
    }
    private def _counter(n: Int): Int = {
        var counter = 0
        var nn = n
        
        while(nn != 0) {
            counter += 1
            nn = nn & (nn - 1)
        }
        counter 
    }
}

/**
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution2 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}
```

###  1.159. <a name='PowerofFour'></a>342. ã€ä½è¿ç®—ğŸ˜œã€‘Power of Four

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Gx411o7D5?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1p5411a7h1?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and n % 3 == 1




class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and (n & 0xaaaaaaaa) == 0





class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and n & n - 1 == 0 and n & 0b1010101010101010101010101010101 == n

```

```py
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        while n > 1: n = n / 4
        return False if n != 1 else True 
```

###  1.160. <a name='-1'></a>343-æ•´æ•°æ‹†åˆ†

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Dp4y1U79P?spm_id_from=333.999.0.0)

###  1.161. <a name='ReverseString'></a>344. Reverse String

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Gx411o7Ha?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1nC4y1a7DR?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1nQ4y1R7nH?spm_id_from=333.999.0.0)

```py
class Solution: 
    def reverseString(self, s: List[str]) -> None:

    """
    Do not return anything, modify s in-place instead.
    """
    i, j = 0, len(s) - 1
    while i<j:
        s[i],s[j]=s[j],s[i]
        i+=1
        j-=1
    return s

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        
        # è¯¥æ–¹æ³•å·²ç»ä¸éœ€è¦åˆ¤æ–­å¥‡å¶æ•°ï¼Œç»æµ‹è¯•åæ—¶é—´ç©ºé—´å¤æ‚åº¦æ¯”ç”¨ for i in range(right//2)æ›´ä½
        # æ¨èè¯¥å†™æ³•ï¼Œæ›´åŠ é€šä¿—æ˜“æ‡‚
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

```py
class Solution:
    def reverseString(self, s):
        s.reverse()
        # s[:] = s[::-1]
        '''
        j = len(s)-1
        for i in range(len(s)//2):
            s[i],s[j] = s[j],s[i]
            j -= 1
       '''
```

```scala
object Solution {
    def reverseString(s: Array[Char]): Unit = {
        var begin = 0
        var end = s.length - 1
        while(begin < end){
            var temp = s(begin)
            s(begin) = s(end)
            s(end) = temp
            
            begin += 1
            end -= 1
        }
    }
}

```

###  1.162. <a name='ReverseVowelsofaString'></a>345. Reverse Vowels of a String

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Gx411o7JH?spm_id_from=333.999.0.0)

###  1.163. <a name='MovingAveragefromDataStream'></a>346 Moving Average from Data Stream

[å°æ˜](https://www.bilibili.com/video/BV1xV411m73u?spm_id_from=333.999.0.0)

###  1.164. <a name='TopKFrequentElements'></a>347. ã€æœ€å°å †ğŸŒµã€‘Top K Frequent Elements 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Mt411371T?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1sk4y1B7vj?spm_id_from=333.999.0.0)

```py
#æ—¶é—´å¤æ‚åº¦ï¼šO(nlogk)
#ç©ºé—´å¤æ‚åº¦ï¼šO(n)
import heapq
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        #è¦ç»Ÿè®¡å…ƒç´ å‡ºç°é¢‘ç‡
        map_ = {} #nums[i]:å¯¹åº”å‡ºç°çš„æ¬¡æ•°
        for i in range(len(nums)):
            map_[nums[i]] = map_.get(nums[i], 0) + 1
        
        #å¯¹é¢‘ç‡æ’åº
        #å®šä¹‰ä¸€ä¸ªå°é¡¶å †ï¼Œå¤§å°ä¸ºk
        pri_que = [] #å°é¡¶å †
        
        #ç”¨å›ºå®šå¤§å°ä¸ºkçš„å°é¡¶å †ï¼Œæ‰«é¢æ‰€æœ‰é¢‘ç‡çš„æ•°å€¼
        for key, freq in map_.items():
            heapq.heappush(pri_que, (freq, key))
            if len(pri_que) > k: #å¦‚æœå †çš„å¤§å°å¤§äºäº†Kï¼Œåˆ™é˜Ÿåˆ—å¼¹å‡ºï¼Œä¿è¯å †çš„å¤§å°ä¸€ç›´ä¸ºk
                heapq.heappop(pri_que)
        
        #æ‰¾å‡ºå‰Kä¸ªé«˜é¢‘å…ƒç´ ï¼Œå› ä¸ºå°é¡¶å †å…ˆå¼¹å‡ºçš„æ˜¯æœ€å°çš„ï¼Œæ‰€ä»¥å€’å™æ¥è¾“å‡ºåˆ°æ•°ç»„
        result = [0] * k
        for i in range(k-1, -1, -1):
            result[i] = heapq.heappop(pri_que)[1]
        return result
```

```py
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dic = {}
        for n in nums:
            if n in dic:
                dic[n] += 1
            else:
                dic[n] = 1
        return [k for k, v in sorted(dic.items(), key=lambda item:item[1],reverse=True)][0:k]

pythonå†™äº†ä¸€ä¸ªæœ¬ä»¥ä¸ºæ—¶é—´å¾ˆé•¿ç»“æœå‡»è´¥äº†97%çš„ä»£ç ï¼ˆä¸€å¼€å§‹éƒ½æ²¡æƒ³åˆ°ä¼˜å…ˆé˜Ÿåˆ—ã€æ‚è„¸ã€‘ï¼‰

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        sort_nums=sorted(Counter(nums).items(),reverse=True,key=lambda item:item[1])[:k]
        return list(zip(*sort_nums))[0]

Pythonä¸€è¡Œæå®šï¼š

from collections import Counter

class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        return [item[0] for item in Counter(nums).most_common(k)]
```

```scala
object Solution {
    def topKFrequent(nums: Array[Int], k: Int): Array[Int] = {
        var hm = scala.collection.mutable.Map.empty[Int, Int]
        for(elem <- nums){
            hm.get(elem) match{
                case Some(count) => hm += (elem -> (count+1))
                case None => hm += (elem -> 1)
            }
        }
        
        // hm.toList.sortBy(x => (x._2)*(-1)).take(k).map(_._1).toArray
        // The above is a sorting approach. We can use Heap/PriorityQueue to achieve better time complexity
        
        import scala.math.Ordering.Implicits._
        
        def orderByFrequency(tup: (Int, Int)) = tup._2
        
        val pq = new scala.collection.mutable.PriorityQueue[(Int, Int)]()(Ordering.by(orderByFrequency))
        
        for(entry <- hm){
            pq.enqueue(entry)
        }
        
        println(pq)
        (1 to k).map(_ => pq.dequeue).map(_._1).toArray
        
    }
}

```

###  1.165. <a name='IntersectionofTwoArrays'></a>349. Intersection of Two Arrays

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1zx411o7i1?spm_id_from=333.999.0.0)

###  1.166. <a name='IntersectionofTwoArraysII'></a>350. ã€åŠ¨æ€ğŸš€è§„åˆ’ + åŒæŒ‡é’ˆ + å“ˆå¸Œè¡¨ã€‘Intersection of Two Arrays II 

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1gx411X7q8?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV165411879H?spm_id_from=333.999.0.0)

```py
"""
åŠ¨æ€ğŸš€è§„åˆ’ï¼šå®¹æ˜“å‡ºé”™ï¼Œæœ€å¥½åˆ«ç”¨
"""
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # è¾“å…¥ï¼š
        # [2,1]
        # [1,2]
        # è¾“å‡ºï¼š
        # [1]
        # é¢„æœŸç»“æœï¼š
        # [1,2]
        # æ‰€ä»¥å¿…é¡»è¦æ’åº
        nums1.sort()
        nums2.sort()
        dp = [[[]] * (len(nums2) + 1) for _ in range(len(nums1) + 1)]
        # é”™è¯¯å†™æ³•ï¼šdp = [[] * (len(nums1) + 1) for _ in range(len(nums2) + 1)]

        for i in range(1, len(nums1)+1):
            for j in range(1, len(nums2)+1):
                if nums1[i-1] == nums2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + [nums1[i-1]] # æ˜“é”™ç‚¹ï¼šä¸èƒ½ç”¨append
                else:
                    # ç²¾ç®€çš„å†™æ³•ï¼šdp[i][j] = max(dp[i][j-1], dp[i-1][j], key = len).copy()
                    if len(dp[i][j-1]) > len(dp[i-1][j]):
                        dp[i][j] = dp[i][j-1]  
                    else:
                        dp[i][j] = dp[i-1][j]
        return dp[-1][-1]

"""
æ’åºåï¼Œå†ä½¿ç”¨åŒæŒ‡é’ˆ
"""
class Solution:
    def intersect(self, nums1, nums2):
        nums1, nums2 = sorted(nums1), sorted(nums2)
        l1, l2 = 0, 0
        res = []
        while l1 < len(nums1) and l2 < len(nums2):
            if nums1[l1] == nums2[l2]:
                res.append(nums1[l1])
                l1 += 1
                l2 += 1
            elif nums1[l1] < nums2[l2]:
                l1 += 1
            else:
                l2 += 1
        return res     


"""
å“ˆå¸Œè¡¨
"""
from collections import Counter
class Solution:
    def intersect(self, nums1, nums2):
        nums1 = Counter(nums1)
        res = []
        for i in nums2:
            if i in nums1 and nums1[i]:
                res.append(i)
                nums1[i] -= 1
        return res
```

```scala
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        
        val map1 = nums1.groupBy(identity).mapValues(_.length)
        val map2 = nums2.groupBy(identity).mapValues(_.length)
        
        val keys = map1.keySet intersect map2.keySet
        
        keys.map(key => {
            val count1 = map1.get(key).get
            val count2 = map2.get(key).get
            val count = if(count1 > count2) count2 else count1
            Array.fill(count)(key)
        }).toArray.flatten
    }
}


//Alternate solution to keep count in HashMap from 1st array & decrease from second array... whatever is left is intersection
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        var map = scala.collection.mutable.Map.empty[Int, Int]
        var output = List.empty[Int]
        for(item <- nums1){
            map.get(item) match{
                case Some(count) => map += (item -> (count + 1))
                case None => map += (item -> 1)
            }
        }
        
        for(item <- nums2){
            map.get(item) match{
                case Some(count) => {
                    output = output :+ item
                    if(count - 1 == 0) map.remove(item) else map += (item -> (count - 1))
                }
                case None => map.remove(item)
            }
        }
        
        output.toArray
    }
}

```

###  1.167. <a name='351AndroidUnlockingPattern'></a> 351 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Android Unlocking Pattern

[éƒ­éƒ­](https://www.bilibili.com/video/BV1Qq4y1r7WH?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

###  1.168. <a name='DesignTwitter'></a>355. è®¾è®¡æ¨ç‰¹ Design Twitter

[å®˜æ–¹](https://www.bilibili.com/video/BV1aQ4y1N72N?spm_id_from=333.999.0.0)

###  1.169. <a name='LoggerRateLimiter'></a>359 Logger Rate Limiter

[å°æ˜](https://www.bilibili.com/video/BV1k64y1F7dE?spm_id_from=333.999.0.0)

###  1.170. <a name='ValidPerfectSquare'></a>367. Valid Perfect Square

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Gx411X7Ke?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1DT4y1377H?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return float.is_integer(pow(num, 0.5))

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        x = 1
        square = 1
        while square <= num:
            if square == num:
                return True
            x += 1
            square = x * x
        return False

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 0, num
        while left <= right:
            mid = (left + right) // 2
            square = mid * mid
            if square < num:
                left = mid + 1
            elif square > num:
                right = mid - 1
            else:
                return True
        return False

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        x0 = num
        while True:
            x1 = (x0 + num / x0) / 2
            if x0 - x1 < 1e-6:
                break
            x0 = x1
        x0 = int(x0)
        return x0 * x0 == num

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return num**0.5 == int(num**0.5)

æ‰“è¡¨å…šå¤§èƒœåˆ©

ans = [i**2 for i in range(46342)]
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return num in ans

pythonç‰ˆäºŒåˆ†æ³•

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        low=1
        high=num
        while high>=low:
            mid=(high+low)//2
            if mid*mid == num:
                return True
            elif mid*mid < num:
                low=mid+1
            elif mid*mid > num:
                high=mid-1
        return False
```

###  1.171. <a name='LargestDivisibleSubset'></a>368 Largest Divisible Subset

[å°æ˜](https://www.bilibili.com/video/BV15D4y1Q74b?spm_id_from=333.999.0.0)

###  1.172. <a name='-1'></a>371ã€ä½è¿ç®—ğŸ˜œ + æœ‰ç‚¹éš¾ï¼Œå†çœ‹çœ‹ã€‘

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6oayqs4ig3g0.webp)

```py
MAX = 1024
MAX_INT = 1023
class Solution:
    def getSum(self, a: int, b: int) -> int:
        """
        a 001
        b 010
        a^b 011
        -------
        a 010
        b 011
        a^b 001
        ===> ç»Ÿè®¡æ‰€æœ‰è¿›ä½çš„1
        a^b^((a&b)<<1)
        -------
        a 010100
        b 011110
        a^b 001010
        æ‰€æœ‰è¿›ä½ 101010
        è¿›ä½çš„å¼‚æˆ–è¿˜å¯èƒ½æœ‰è¿›ä½!
        æ‰€ä»¥è¦ä½¿ç”¨å¾ªç¯orè¿­ä»£å¤„ç†
        -------
        è´Ÿæ•°è¡¥ç æ€»ä¼šæä¾›æœ€å·¦çš„1ï¼ŒæŒ‰ä½å–åï¼Œè¦ç‰¹æ®Šå¤„ç†è´Ÿæ•°
        Pythonéœ€è¦è¦åšæ•´æ•°çš„æº¢å‡º
        æ—¢ç„¶æ•°æ®èŒƒå›´æ˜¯1000ï¼Œé‚£æˆ‘ä»¬è®¤å®šæœ€å¤§çš„æ•´æ•°æ˜¯1024-1åšæº¢å‡ºå³å¯
        """
        def int_overflow(val):
            if not -MAX <= val <= MAX_INT:
                val = (val + MAX) % (2 * MAX) - MAX
            return val
        while b:
            a,b = int_overflow(a^b), int_overflow((a & b) << 1)
        return a

ä½œè€…ï¼šhimymBen
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/sum-of-two-integers/solution/pythonjava-wei-yun-suan-di-gui-or-die-da-7esn/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
MASK1 = 0x100000000  # 2^32
minInt1000 = 0x80000000  # 2^31
maxInt0111 = 0X7FFFFFFF  # 2^31-1

class Solution:
    def getSum(self, a: int, b: int) -> int:
        while b != 0:
            carry = ((a & b) << 1)
            a = (a ^ b) % MASK1
            b = carry
        return a if a <= maxInt0111 else ~((a % minInt1000) ^ maxInt0111)   

MM = 0xFFFFFFFF # 2^32-1
MASK1 = 0x100000000  # 2^32
minInt1000 = 0x80000000  # 2^31
maxInt0111 = 0X7FFFFFFF  # 2^31-1

class Solution:
    def getSum(self, a: int, b: int) -> int:
        while b != 0:
            carry = ((a & b) << 1)
            a = (a ^ b) % MASK1
            b = carry
        return a if a <= maxInt0111 else ~ (a ^ MM)

MASK1 = 0x100000000  # 2^32
minInt1000 = 0x80000000  # 2^31
maxInt0111 = 0X7FFFFFFF  # 2^31-1

class Solution:
    def getSum(self, a: int, b: int) -> int:
        while b != 0:
            carry = ((a & b) << 1)
            a = (a ^ b) % MASK1
            b = carry
        if a & minInt1000:  # è´Ÿæ•°ï¼Œä¹Ÿå°±æ˜¯ç¬¬31ä½æœ‰ä¸œè¥¿
            return ~((a ^ minInt1000) ^ maxInt0111)
        else:  # æ­£æ•°ï¼Œä¹Ÿå°±æ˜¯ç¬¬31ä½æ²¡æœ‰ä¸œè¥¿
            return a

MASK1 = 0x100000000  # 2^32
minInt1000 = 0x80000000  # 2^31
maxInt0111 = 0X7FFFFFFF  # 2^31-1

class Solution:
    def getSum(self, a: int, b: int) -> int:
        while b != 0:
            carry = ((a & b) << 1)
            a = (a ^ b) % MASK1
            b = carry
        return ~((a ^ minInt1000) ^ maxInt0111) if a & minInt1000 else a   

class Solution:
    def getSum(self, a: int, b: int) -> int:
        a &= 0xFFFFFFFF
        b &= 0xFFFFFFFF
        while b:
            carry = a & b
            a ^= b
            b = ((carry) << 1) & 0xFFFFFFFF
        return a if a < 0x80000000 else ~ (a ^ 0xFFFFFFFF)

Recursion

class Solution:
    def getSum(self, a: int, b: int) -> int:
        # 2 ^ 32
        MASK = 0x100000000
        MM = 0xFFFFFFFF
        MAX_INT = 0x7FFFFFFF
        MIN_INT = 0x80000000

        if 0 == b:
            return a if a <= MAX_INT else ~ (a ^ MM)

        carry = (a & b) << 1
        a = (a ^ b) % MASK
        b = carry        
        return self.getSum(a, b)
```

###  1.173. <a name='FindKPairswithSmallestSumsk'></a>373. Find K Pairs with Smallest SumsæŸ¥æ‰¾å’Œæœ€å°çš„kå¯¹æ•°å­—

[å›¾çµ](https://www.bilibili.com/video/BV1Mv4y1Z79v?spm_id_from=333.999.0.0)

###  1.174. <a name='GuessNumberHigherorLower'></a>374. Guess Number Higher or Lower

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Hx41197ou?spm_id_from=333.999.0.0)

###  1.175. <a name='-1'></a>376-æ‘†åŠ¨åºåˆ—

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1sk4y167wV?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV16X4y1376k?spm_id_from=333.999.0.0)

```py
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        up = [1] + [0] * (n - 1)
        down = [1] + [0] * (n - 1)
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up[i] = max(up[i - 1], down[i - 1] + 1)
                down[i] = down[i - 1]
            elif nums[i] < nums[i - 1]:
                up[i] = up[i - 1]
                down[i] = max(up[i - 1] + 1, down[i - 1])
            else:
                up[i] = up[i - 1]
                down[i] = down[i - 1]
        
        return max(up[n - 1], down[n - 1])

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        up = down = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up = max(up, down + 1)
            elif nums[i] < nums[i - 1]:
                down = max(up + 1, down)
        
        return max(up, down)

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        up = down = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up = down + 1
            elif nums[i] < nums[i - 1]:
                down = up + 1
        
        return max(up, down)

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        prevdiff = nums[1] - nums[0]
        ret = (2 if prevdiff != 0 else 1)
        for i in range(2, n):
            diff = nums[i] - nums[i - 1]
            if (diff > 0 and prevdiff <= 0) or (diff < 0 and prevdiff >= 0):
                ret += 1
                prevdiff = diff
        
        return ret

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
å¤§ä½¬çš„è¿™ä¸ªè§£æ³•å¥½å¼ºï¼Œåˆ©ç”¨æ‘†åŠ¨åºåˆ—ï¼Œæ³¢å³°å’Œæ³¢è°·çš„å·®å€¼æœ€å¤šä¸º1çš„ç‰¹ç‚¹ã€‚ä¸€æ¬¡éå†ï¼Œå¸¸æ•°ç©ºé—´ã€‚å­¦ä¸æ¥å­¦ä¸æ¥

class Solution:
    def wiggleMaxLength(self, nums):
        up ,down = 1,1
        if len(nums)<2:return len(nums)
        for i in range(1,len(nums)):
            if nums[i]>nums[i-1]:
                up = down+1
            if nums[i]<nums[i-1]:
                down = up+1
        return max(up,down)

Pythonï¼š

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        preC,curC,res = 0,0,1  #é¢˜ç›®é‡Œnumsé•¿åº¦å¤§äºç­‰äº1ï¼Œå½“é•¿åº¦ä¸º1æ—¶ï¼Œå…¶å®åˆ°ä¸äº†forå¾ªç¯é‡Œå»ï¼Œæ‰€ä»¥ä¸ç”¨è€ƒè™‘numsé•¿åº¦
        for i in range(len(nums) - 1):
            curC = nums[i + 1] - nums[i]
            if curC * preC <= 0 and curC !=0:  #å·®å€¼ä¸º0æ—¶ï¼Œä¸ç®—æ‘†åŠ¨
                res += 1
                preC = curC  #å¦‚æœå½“å‰å·®å€¼å’Œä¸Šä¸€ä¸ªå·®å€¼ä¸ºä¸€æ­£ä¸€è´Ÿæ—¶ï¼Œæ‰éœ€è¦ç”¨å½“å‰å·®å€¼æ›¿ä»£ä¸Šä¸€ä¸ªå·®å€¼
        return res

å•è°ƒå­åºåˆ—ä¿ç•™ä¸¤ä¸ªç«¯ç‚¹ï¼Œé‡å¤å­åºåˆ—ä¿ç•™ä¸€ä¸ªç‚¹ï¼Œå‰©ä¸‹çš„éƒ½æ˜¯ç¬¦åˆè¦æ±‚çš„

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        arr=[nums[0]]
        for x in nums:
            if x!=arr[-1]:
                arr.append(x)
        if len(arr)<2:
            return len(arr)
        res=2
        for i in range(1,len(arr)-1):
            if arr[i-1]>arr[i]<arr[i+1] or arr[i-1]<arr[i]>arr[i+1]:
                res+=1
        return res
```



###  1.176. <a name='CombinationSumIV'></a>377. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Combination Sum IV

####  1.176.1. <a name='416494377'></a>ç±»ä¼¼é¢˜ç›®ï¼š416é¢˜ï¼Œ494é¢˜ï¼Œä¸å¯ä»¥é‡å¤ï¼Œ377é‡å¤

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gW411y7uz?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1zA411L7nu?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0] * (target + 1)
        dp[0] = 1
        # æ˜“é”™ç‚¹ï¼šfor i in range(nums[0], target+1): ä¸é€‚ç”¨äº nums = [3,1,2,3]
        for i in range(1, target+1): # ä¸€å®šè¦å…ˆtargetå†numï¼Œè¿™æ ·æ‰èƒ½æœ‰é‡å¤
            for num in nums:
                if i >= num:
                    dp[i] += dp[i - num]
        return dp[-1]
```

###  1.177. <a name='K'></a>378-ã€æœ€å°å †ğŸŒµã€‘æœ‰åºçŸ©é˜µä¸­ç¬¬Kå°çš„å…ƒç´ 

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1mT4y1w7u2?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1Zy4y127qr?spm_id_from=333.999.0.0)

```py
# æ— è„‘æš´åŠ›æ³•ä¸€è¡Œç‰ˆ

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        return sorted(sum(matrix,[]))[k-1]
# æš´åŠ›pqä¸€è¡Œ
import heapq
class Solution(object):
    def kthSmallest(self, matrix, k):
        return heapq.nsmallest(k,sum(matrix,[]))[-1]
#  heapqä¸€è¡Œ
class Solution(object):
    def kthSmallest(self, matrix, k):
        return list(heapq.merge(*matrix))[k-1]

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        rec = sorted(sum(matrix, []))
        return rec[k - 1]

# æ— è„‘æš´åŠ›æ³•ä¼˜åŒ–ç‰ˆ
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        l=heapq.nlargest(len(lis)-k+1,lis)
        return l[-1]
# æ— è„‘æš´åŠ›æ³•
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        lis.sort()
        return lis[k-1]
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        n = len(matrix)
        pq = [(matrix[i][0], i, 0) for i in range(n)]
        heapq.heapify(pq)

        ret = 0
        for i in range(k - 1):
            num, x, y = heapq.heappop(pq)
            if y != n - 1:
                heapq.heappush(pq, (matrix[x][y + 1], x, y + 1))
        
        return heapq.heappop(pq)[0]
# binary search
# ```python
import bisect
class Solution(object):
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k
        :rtype
        """
        l, r = matrix[0][0], matrix[-1][-1]
        while l <= r:
            mid = l + ((r - l) >> 2)
            if sum(bisect.bisect_right(row, mid) for row in matrix) < k:
                l = mid + 1
            else:
                r = mid - 1
        return l
```


###  1.178. <a name='InsertDeleteGetRandomO1'></a>380 Insert Delete GetRandom O(1)

[å°æ˜](https://www.bilibili.com/video/BV1Fg4y1q7Ru?spm_id_from=333.999.0.0)

###  1.179. <a name='LinkedListRandomNode'></a>382 Linked List Random Node

[å°æ˜](https://www.bilibili.com/video/BV1xZ4y1G7ie?spm_id_from=333.999.0.0)

###  1.180. <a name='RansomNote'></a>383 Ransom Note

[å°æ˜](https://www.bilibili.com/video/BV1GQ4y1N7Q5?spm_id_from=333.999.0.0)

###  1.181. <a name='-1'></a>386

```py
class Solution:
    def lexicalOrder(self, n):
        def dfs(num):
            if num > n:
                return
            ans.append(num)
            for nxt in range(num * 10, num * 10 + 10):
                dfs(nxt)

        ans = []
        for num in range(1, 10):
            dfs(num)
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(i: int = 1) -> None:
            if i > n:
                return
            for j in range(i, min(n + 1, (10 if i < 10 else i + 10))):
                ans.append(j)
                dfs(j * 10)
        ans = []
        dfs()
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(rec, i, n):
            if i > n: return -1
            rec.append(i);
            child = i * 10
            for j in range(10):
                if dfs(rec, child+j, n) == -1:break
            return
        rec = []
        for i in range(1, 10):
            dfs(rec, i, n)
        return rec
```

```py
class Solution:
    def lexicalOrder(self, n):
        return sorted(list(range(1,n+1)),key=lambda x:str(x))

class Solution:
    def lexicalOrder(self, n):
        return [int(j) for j in sorted([str(i) for i in range(1, n + 1)])]

# å­—ç¬¦ä¸²æ’åº

class Solution:
    def lexicalOrder(self, n):
        l = sorted([str(i) for i in range(1, n + 1)])
        return [int(i) for i in l]
```

```py
class Solution:
    def lexicalOrder(self, n):
        orders = []
        stack = [(1, 8)]
        while len(stack) > 0:
            orders.append(stack[-1][0])
            (last, step) = stack.pop()
            if last+1 <= n and step > 0:
                stack.append((last+1, step-1))
            if last*10 <= n:
                stack.append((last*10, 9))
        return orders

class Solution:
    def lexicalOrder(self, n):
        ans = []
        num = 1
        while len(ans) < n:
            while num <= n:  # ä¸æ–­è¿›å…¥ä¸‹ä¸€å±‚
                ans.append(num)
                num *= 10
            while num % 10 == 9 or num > n:  # ä¸æ–­è¿”å›ä¸Šä¸€å±‚
                num //= 10
            num += 1  # éå†è¯¥å±‚ä¸‹ä¸€ä¸ªæ•°
        return ans

class Solution(object):
    def lexicalOrder(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        res = []
        cur = 1
        for i in range(n):
            res.append(cur)
            if (cur * 10 <= n):
                cur *= 10
            elif cur + 1 <= n and (cur + 1) % 10 != 0:
                cur += 1
            else:
                while (cur/10) % 10 == 9:
                    cur /= 10
                cur = cur / 10 + 1
        return res
```

###  1.182. <a name='FirstUniqueCharacterinaString'></a>387. First Unique Character in a String

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1y4411A7d2?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1b541147WU?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstUniqChar(self, s: str) -> int:
        frequency = collections.Counter(s)
        for i, ch in enumerate(s):
            if frequency[ch] == 1:
                return i
        return -1

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def firstUniqChar(self, s: str) -> int:
        position = dict()
        n = len(s)
        for i, ch in enumerate(s):
            if ch in position:
                position[ch] = -1
            else:
                position[ch] = i
        first = n
        for pos in position.values():
            if pos != -1 and pos < first:
                first = pos
        if first == n:
            first = -1
        return first
        éå†å­—ç¬¦ä¸²ï¼Œå¦‚æœå½“å‰å­—ç¬¦æ²¡å‡ºç°è¿‡å°±ç”¨å­—å…¸è®°å½•å®ƒåœ¨å­—ç¬¦ä¸²ä¸­çš„ä½ç½®ï¼Œ
        å‡ºç°è¿‡äº†å°±æŠŠå­—å…¸é‡Œçš„é‚£æ¡è®°å½•æ”¹æˆ-1ã€‚ç„¶åæ‰¾å­—å…¸é‡Œä½ç½®æœ€é å‰çš„ï¼ˆè€Œä¸”ä¸æ˜¯-1çš„ï¼‰é‚£ä¸ªå­—ç¬¦ã€‚

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def firstUniqChar(self, s: str) -> int:
        position = dict()
        q = collections.deque()
        n = len(s)
        for i, ch in enumerate(s):
            if ch not in position:
                position[ch] = i
                q.append((s[i], i))
            else:
                position[ch] = -1
                while q and position[q[0][0]] == -1:
                    q.popleft()
        return -1 if not q else q[0][1]

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨å­˜æ”¾å­—ç¬¦ä¸­å­—ç¬¦å‡ºç°çš„æ¬¡æ•°

ç„¶åä»å¤´éå†ï¼Œè¿”å›é‡åˆ°çš„ç¬¬ä¸€ä¸ªå‡ºç°æ¬¡æ•°ä¸º1çš„å­—ç¬¦ä¸‹æ ‡

å¦‚æœéå†å®Œéƒ½æ²¡æœ‰ï¼Œå°±è¯´æ˜ä¸å­˜åœ¨ï¼Œè¿”å›-1

from collections import Counter
class Solution:
    def firstUniqChar(self, s: str) -> int:
        sDict = Counter(s)
        for n in range(len(s)):
            if sDict[s[n]] == 1:
                return n
        return -1

python3è¡Œï¼Œç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®å’Œæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ç›¸ç­‰

class Solution(object):
    def firstUniqChar(self, s): 
        for i in range(len(s)):
            if s.find(s[i])==s.rfind(s[i]):
                return i
        return -1

ç”¨å­—å…¸è®°å½•å·²ç»æŸ¥æ‰¾è¿‡çš„å­—æ¯
æ‰§è¡Œç”¨æ—¶ï¼š44 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†99.25%çš„ç”¨æˆ·
class Solution:
    def firstUniqChar(self, s: str) -> int:
        d={}
        length=len(s)
        for i in range(length):
            if s[i] not in d:
                if s.find(s[i],i+1)==-1:return i
                d[s[i]]=None
        return -1

æˆ‘çš„å¦å¤–ä¸€ç§ç®—æ³•ï¼Œæ‰§è¡Œç”¨æ—¶ï¼š48 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†98.92%çš„ç”¨æˆ·

class Solution:
    def firstUniqChar(self, s: str) -> int:
        for k,v in collections.Counter(s).items():
            if v==1:
                return s.find(k)
        return -1
```

```scala
object Solution {
    def firstUniqChar(s: String): Int = {
        var map = scala.collection.mutable.Map.empty[Char, (Int, Int)]
        (0 to s.length-1).map(i =>
            map.get(s.charAt(i)) match{
                case Some(indexAndCount) => map += (s.charAt(i) -> (i, indexAndCount._2 + 1))
                case None => map += (s.charAt(i) -> (i, 1))
            }
        )
        map.toList.filter(x => x._2._2 == 1).map(_._2._1).sorted.headOption.getOrElse(-1)
    }
}

//Alternate/Better SCALA solution
object Solution {
    def firstUniqChar(s: String): Int = {
        val hmap =  s.toCharArray.groupBy(identity).mapValues(_.length)
        val uniqChar = s.toCharArray.zipWithIndex.find (p => hmap(p._1) == 1)
        if(uniqChar.nonEmpty) uniqChar.get._2 else -1 
    }
}

/**How the above solution works:
scala> val a = "akashs"
a: String = akashs

scala> a.toCharArray.groupBy(identity)
res0: scala.collection.immutable.Map[Char,Array[Char]] = Map(h -> Array(h), k -> Array(k), s -> Array(s, s), a -> Array(a, a))

scala> a.toCharArray.groupBy(identity).mapValues(_.length)
res1: scala.collection.immutable.Map[Char,Int] = Map(h -> 1, k -> 1, s -> 2, a -> 2)

scala> a.toCharArray.zipWithIndex
res2: Array[(Char, Int)] = Array((a,0), (k,1), (a,2), (s,3), (h,4), (s,5))

scala> a.toCharArray.zipWithIndex.find(x => res1(x._1) == 1)
res3: Option[(Char, Int)] = Some((k,1))
*/

```

###  1.183. <a name='FindtheDifference'></a>389. ã€ä½è¿ç®—ğŸ˜œã€‘Find the Difference

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Et411K7jP?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5j9pjpm6f080.webp)

```py
è¿™åº”è¯¥æ˜¯æœ€ç®€å•çš„æ–¹æ³•äº†å§

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        ret = 0
        for c in s + t:
            ret ^= ord(c)
        return chr(ret)

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        # åˆå§‹åŒ– ans ä¸º 0
        ans = 0
        # å¯¹å­—ç¬¦ä¸² s çš„å­—ç¬¦è¿›è¡Œå¼‚æˆ–
        for ch in s:
            ans ^= ord(ch)
        # å¯¹å­—ç¬¦ä¸² t çš„å­—ç¬¦è¿›è¡Œå¼‚æˆ–
        for ch in t:
            ans ^= ord(ch)
        # æœ€ç»ˆç»“æœè½¬æ¢ä¸º ASCII å­—ç¬¦
        return chr(ans)
```

æ³¨æ„ï¼šCounter å’Œ count çš„åŒºåˆ«

```py

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return [x for x in t if t.count(x)-s.count(x)==1][0]   


class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        # tä¸­å­—æ¯ä¸€å®šå¤š
        for c in t:
            if t.count(c)!=s.count(c):
                return c
        return ""

Counteræ˜¯ä¸€ä¸ªå®¹å™¨å¯¹è±¡,ä¸»è¦çš„ä½œç”¨æ˜¯ç”¨æ¥ç»Ÿè®¡æ•£åˆ—å¯¹è±¡,å¯ä»¥ä½¿ç”¨ä¸‰ç§æ–¹å¼æ¥åˆå§‹åŒ–

å‚æ•°é‡Œé¢å‚æ•°å¯è¿­ä»£å¯¹è±¡ Counter("success")

ä¼ å…¥å…³é”®å­—å‚æ•°Counter((s=3,c=2,e=1,u=1))

ä¼ å…¥å­—å…¸ Counter({"s":3,"c"=2,"e"=1,"u"=1})

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return next(iter(Counter(t)-Counter(s)))
        
iter(xxx) å’Œ xxx.elements() éƒ½æ˜¯è¿­ä»£å™¨

Counter O(n)ï¼š

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return next((Counter(t)-Counter(s)).elements())

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return (collections.Counter(t) - collections.Counter(s)).popitem()[0] # è¿”å› ('e', 1)
```

æ³¨æ„ï¼šreduce å’Œ map çš„ åŒºåˆ«

https://zhuanlan.zhihu.com/p/77311224

```py
Python 1è¡Œ ASCII å’Œä¹‹å·®

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return chr(sum(map(ord, t)) - sum(map(ord, s)))

æ¯ä¸€ä¸ªå­—ç¬¦éƒ½å¯¹åº”ä¸€ä¸ª ASCII æ•°å­—ï¼Œé‚£ä¹ˆé‚£ä¸ªä¸åŒçš„æ•°å­—çš„ ASCII ç å°±ç­‰äº t çš„æ‰€æœ‰å­—ç¬¦ç ä¹‹å’Œ - s çš„
ord å‡½æ•°å°†å•ä¸ªå­—ç¬¦è½¬æ¢ä¸º ASCII ç ï¼Œ chrç›¸å

ğŸ‘†ğŸ‘†ğŸ‘† py3 1è¡Œ(åˆ—è¡¨ç”Ÿæˆå™¨ and ç”Ÿæˆå™¨ï¼Œè¿™å°±æ˜¯ä½ py3å†™ä¸åˆ°ä¸€è¡Œä»£ç çš„å·®è· æ²¡è¯´ä½ )


ä½è¿ç®—ğŸ˜œ O(n)ï¼š

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return chr(reduce(xor, map(ord, s + t)))

python reduce+lambda ä¸€è¡Œã€‚ord()å–å­—ç¬¦å¯¹åº”asciiç ,chr()è¿”å›asciiç å¯¹åº”å­—ç¬¦

class Solution(object):
    def findTheDifference(self, s, t):
        return reduce(lambda x,y: chr(ord(x) ^ ord(y)), s + t)
# sum1 = reduce(add, [1,2,3,4,5])   # è®¡ç®—åˆ—è¡¨å’Œï¼š1+2+3+4+5
# sum2 = reduce(lambda x, y: x+y, [1,2,3,4,5])  # ä½¿ç”¨ lambda åŒ¿åå‡½æ•°
```




###  1.184. <a name='PerfectRectangle'></a>391. Perfect Rectangle

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV184411c7cs?spm_id_from=333.999.0.0)

###  1.185. <a name='IsSubsequence'></a>392. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Is Subsequence

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1fg4y1q7eT?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Za4y1a73v?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV19f4y197yS?spm_id_from=333.999.0.0)

åŠ¨æ€ğŸš€è§„åˆ’

```py
class Solution:
    def isSubsequence(self, t: str, s: str) -> bool:
        dp = [[False] * (len(s) + 1) for _ in range(len(t) + 1)]
        for j in range(len(s)+1):
            dp[0][j] = True
        for i in range(1, len(t)+1):
            for j in range(1, len(s)+1):
                if t[i-1] == s[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = dp[i][j-1]
        return dp[-1][-1]
```

```py
æ€è·¯ä¸‰ï¼šåŒæŒ‡é’ˆ

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i = 0
        j = 0
        while i < len(s) and j < len(t):
            # print(i, j)
            if s[i] == t[j]:
                i += 1
                j += 1
            else:
                j += 1    
        return i == len(s)

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        n, m = len(s), len(t)
        i = j = 0
        while i < n and j < m:
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == n

```

```py

æ€è·¯äºŒï¼šç”Ÿæˆè¿­ä»£å™¨
ç®€å•ç²—æš´.

class Solution(object):
    def isSubsequence(self, s, t):
        t = iter(t)
        return all(char in t for char in s) 


ç¿»è¯‘äº†ä¸€ä¸‹

class Solution(object):
    def isSubsequence(self, s, t):
        t = iter(t)
        res = []
        for c in s:
            if c in t:
                res.append(c)
            else:
                res.append(None)

        res = iter(res)
        return all(res)
```

###  1.186. <a name='UTF-8Validation'></a>393. UTF-8 Validation

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1SE411w7no?spm_id_from=333.999.0.0)

###  1.187. <a name='DecodeString'></a>394 Decode String

[å°æ˜](https://www.bilibili.com/video/BV145411V75E?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1GZ4y1p7pE?spm_id_from=333.999.0.0)

```py
# ç±»ä¼¼æ­£åˆ™è¡¨è¾¾å¼
# ç¥ä»™ç¥ä»™ï¼Œçœ‹äº†åŠå¤©æ‰çœ‹æ˜ç™½ï¼Œæ¯æ¬¡åªåŒ¹é…æœ€é‡Œå±‚çš„ï¼Œ
# å°†åŒ¹é…åˆ°çš„å­—ç¬¦ä¸²è‡ªåŠ¨åˆ†æˆæ•°å­—å’Œå­—æ¯ï¼Œç„¶åç”¨è½¬æ¢å‡½æ•°æ›¿æ¢æˆæ–°ä¸²ï¼Œ
# æ›¿æ¢å®Œå†…å±‚åå†å»æ›¿æ¢å¤–å±‚ï¼Œç›´åˆ°æ²¡æœ‰æ‹¬å·ä¸ºæ­¢ã€‚å‡½æ•°å¼ç¼–ç¨‹å’Œæ­£åˆ™è¡¨è¾¾å¼ç©çš„å¥½ç§€ã€‚
# ç‰›çš„ï¼Œçœ‹äº†åŠå¤©ç»ˆäºæ‡‚äº†ï¼Œä¸è¿‡è¿™é‡Œrçš„æ„æ€åº”è¯¥æ˜¯å–æ¶ˆpythonè½¬ä¹‰å§
import re

class Solution(object):
    def decodeString(self, s):
        """
        :type s: str
        :rtype: str
        """
        def f(m):
            print("m:",m)
            print("m.group(1):",m.group(1))
            print("m.group(2):",m.group(2))
            return int(m.group(1))* m.group(2)
        while '[' in s:
            s = re.sub(r'(\d+)\[([A-Za-z]*)\]', f, s)
        return s
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1a1r7x6jdqww.png" width="50%">

```py
# å½“å‰çš„ context æœ‰ä¸¤ä¸ªå€¼ï¼Œä¸€ä¸ªæ˜¯å½“å‰æ‰“å°çš„ä¸²ï¼Œä¸€ä¸ªæ˜¯é‡å¤çš„æ•°é‡ã€‚

# æˆ‘å†™äº†ä¸ªçŠ¶æ€æœºæ¥è§£è¿™ä¸ªé¢˜ç›®ï¼š

class Solution:
    def decodeString(self, s: str) -> str:
        res = ''       # å½“å‰æ‰“å°ä¸²
        count = 0   # ä¸‹ä¸€ä¸ª pattern çš„æ•°é‡
        stack = []
        for c in s:
            if ord('a') <= ord(c) <= ord('z'):
                res += c
            elif ord('0') <= ord(c) <= ord('9'):
                count = count * 10 + int(c)
            elif c == '[':
                stack.append((res, count))
                res = ''
                count = 0
            elif c == ']':
                ctx_res, ctx_count = stack.pop()
                res = ctx_res + res * ctx_count
        return res
class Solution:
    def decodeString(self, s: str) -> str:
        stk = []
        for ch in s:
            if ch == ']':
                sub = ''
                while stk[-1] != '[':
                    sub = stk.pop() + sub
                stk.pop()
                n = ''
                while stk and stk[-1].isdigit():
                    n = stk.pop() + n
                stk.append(int(n) * sub)
            else:
                stk.append(ch)
        return ''.join(stk)
# Python3ç®€æ´ä»£ç 

# æœ¬é¢˜æ ¸å¿ƒæ€è·¯æ˜¯åœ¨æ ˆé‡Œé¢æ¯æ¬¡å­˜å‚¨ä¸¤ä¸ªä¿¡æ¯, (å·¦æ‹¬å·å‰çš„å­—ç¬¦ä¸², å·¦æ‹¬å·å‰çš„æ•°å­—), 
# æ¯”å¦‚abc3[def], å½“é‡åˆ°ç¬¬ä¸€ä¸ªå·¦æ‹¬å·çš„æ—¶å€™ï¼Œå‹å…¥æ ˆä¸­çš„æ˜¯("abc", 3), 
# ç„¶åéå†æ‹¬å·é‡Œé¢çš„å­—ç¬¦ä¸²def, å½“é‡åˆ°å³æ‹¬å·çš„æ—¶å€™, ä»æ ˆé‡Œé¢å¼¹å‡ºä¸€ä¸ªå…ƒç´ (s1, n1), 
# å¾—åˆ°æ–°çš„å­—ç¬¦ä¸²ä¸ºs1+n1*"def", ä¹Ÿå°±æ˜¯abcdefdefdefã€‚å¯¹äºæ‹¬å·é‡Œé¢åµŒå¥—çš„æƒ…å†µä¹Ÿæ˜¯åŒæ ·å¤„ç†æ–¹å¼ã€‚
# å‡¡æ˜¯é‡åˆ°å·¦æ‹¬å·å°±è¿›è¡Œå‹æ ˆå¤„ç†ï¼Œé‡åˆ°å³æ‹¬å·å°±å¼¹å‡ºæ ˆï¼Œæ ˆä¸­è®°å½•çš„å…ƒç´ å¾ˆé‡è¦ã€‚
### ä»£ç 

class Solution:
    def decodeString(self, s: str) -> str:
        stack = []  # (str, int) è®°å½•å·¦æ‹¬å·ä¹‹å‰çš„å­—ç¬¦ä¸²å’Œå·¦æ‹¬å·å¤–çš„ä¸Šä¸€ä¸ªæ•°å­—
        num = 0
        res = ""  # å®æ—¶è®°å½•å½“å‰å¯ä»¥æå–å‡ºæ¥çš„å­—ç¬¦ä¸²
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c)
            elif c == "[":
                stack.append((res, num))
                res, num = "", 0
            elif c == "]":
                top = stack.pop()
                res = top[0] + res * top[1]
            else:
                res += c
        return res
```

###  1.188. <a name='LongestSubstringwithAtLeastK'></a>395 Longest Substring with At Least K

[å°æ˜](https://www.bilibili.com/video/BV1hD4y1X7rq?spm_id_from=333.999.0.0)

###  1.189. <a name='floydEvaluateDivision'></a>399. ã€ğŸ’å¹¶æŸ¥é›† + floyd ğŸŒã€‘Evaluate Division

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1iW41167Nb?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1XU4y1s7Lk?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Ko4y1f7eK?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1rZ4y1N7CW?spm_id_from=333.999.0.0)

[å°æ—­](https://www.bilibili.com/video/BV1rt411h7oZ?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)


```py
è¿™é“é¢˜éå¸¸å¥½,å¯ä»¥ç”¨çš„å›¾çš„DFS å’Œ BFSæ¥åš.

é¦–å…ˆ,æˆ‘ä»¬è¦æŠŠé™¤æ³•è¿ç®—è½¬åŒ–æˆå›¾è¡¨ç¤º,æ¯”å¦‚a->b = 2.0 b->c = 3.0,a,b,cçœ‹å‡ºèŠ‚ç‚¹,ç›¸å¤„æ‰€çš„å€¼ä¸ºæƒå€¼.é‚£ä¹ˆa/c = ?å°±æ˜¯ç›¸å½“äº,a->c <==> a->b->c = 2.0*3.0= 6,æ‰€ä»¥æˆ‘ä»¬è¦æŠŠå·²çŸ¥æ¡ä»¶å»ºå›¾!

æ¥ä¸‹æ¥,å°±æ˜¯éå†æ–¹æ³•,è¿™é‡Œæœ‰ä¸¤ç§æ–¹æ³•,

ä¸€ç§æ˜¯DFS,ä¸€ç§æ˜¯BFS

è¿™ä¸¤ç§æ–¹æ³•è¿˜æ˜¯çœ‹ä»£ç ä¸€æ­¥ä¸€æ­¥ç†è§£è¾ƒå¥½!


# DFS
  def calcEquation(self, equations, values, queries):
        """
        :type equations: List[List[str]]
        :type values: List[float]
        :type queries: List[List[str]]
        :rtype: List[float]
        """
        from collections import defaultdict
        graph = defaultdict(set)
        weight = defaultdict()
        lookup = {}
        # å»ºå›¾
        for idx, equ in enumerate(equations):
            graph[equ[0]].add(equ[1])
            graph[equ[1]].add(equ[0])
            weight[tuple(equ)] = values[idx]
            weight[(equ[1], equ[0])] = float(1 / values[idx])

        # æ·±åº¦éå†(DFS)
        def dfs(start, end, vistied):
            # å½“å›¾ä¸­æœ‰æ­¤è¾¹,ç›´æ¥è¾“å‡º
            if (start, end) in weight:
                return weight[(start, end)]
            # å›¾ä¸­æ²¡æœ‰è¿™ä¸ªç‚¹
            if start not in graph or end not in graph:
                return 0
            # å·²ç»è®¿é—®è¿‡
            if start in vistied:
                return 0
            vistied.add(start)
            res = 0
            for tmp in graph[start]:
                res = (dfs(tmp, end, vistied) * weight[(start, tmp)])
                # åªè¦éå†åˆ°æœ‰ä¸€ä¸ªä¸æ˜¯0çš„è§£å°±è·³å‡º
                if res != 0:
                    # æ·»åŠ æ­¤è¾¹,ä»¥åè®¿é—®èŠ‚çœæ—¶é—´
                    weight[(start, end)] = res
                    break
            vistied.remove(start)
            return res

        res = []
        for que in queries:
            # ç”¨é›†åˆè®°å½•æ˜¯å¦å·²ç»è®¿é—®èŠ‚ç‚¹
            tmp = dfs(que[0], que[1], set())
            if tmp == 0:
                tmp = -1.0
            res.append(tmp)
        return res
# BFS
    def calcEquation(self, equations, values, queries):
        from collections import defaultdict, deque
        graph = defaultdict(set)
        weight = defaultdict()
        lookup = {}
        # å»ºå›¾
        for idx, equ in enumerate(equations):
            graph[equ[0]].add(equ[1])
            graph[equ[1]].add(equ[0])
            weight[tuple(equ)] = values[idx]
            weight[(equ[1], equ[0])] = float(1 / values[idx])
        res = []
        for start, end in queries:
            if (start, end) in weight:
                res.append(weight[(start, end)])
                continue
            if start not in graph or end not in graph:
                res.append(-1)
                continue
            if start == end:
                res.append(1.0)
                continue
            stack = deque()
            # å°†ä»startç‚¹å¯ä»¥åˆ°è¾¾ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å‹å…¥æ ˆå†…
            for tmp in graph[start]:
                stack.appendleft((tmp, weight[(start, tmp)]))
            # è®°å½•è®¿é—®èŠ‚ç‚¹
            visited = {start}
            # ä¸ºäº†è·³å‡ºåŒå¾ªç¯
            flag = False
            while stack:
                c, w = stack.pop()
                if c == end:
                    flag = True
                    res.append(w)
                    break
                visited.add(c)
                for n in graph[c]:
                    if n not in visited:
                        weight[(start, n)] = w * weight[(c, n)]
                        stack.appendleft((n, w * weight[(c, n)]))
            if flag:
                continue
            res.append(-1.0)
        return res
```

```py
å¸¦æƒå›¾ä¸Šçš„å¹¿åº¦ä¼˜å…ˆæœç´¢

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:

        """BFS
        1.å°†ç»™å®šçš„æ¡ä»¶å­˜å‚¨æˆå›¾çš„å¸¦æƒé‚»æ¥è¡¨ã€‚ç»™å®ša/b=2ï¼Œå­˜å‚¨æˆa:{b:2}å’Œb:{a:0.5}
        2.ç»™å®šæŸ¥è¯¢x/yï¼Œä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†æŸ¥è¯¢xåˆ°yçš„è·¯å¾„ï¼Œç»“æœresä¸ºè·¯å¾„ä¸Šçš„æƒå€¼ä¹˜ç§¯
        """
        self.graph = defaultdict(dict)
        def bfs(start, end):
            queue = deque()
            visited = set()
            queue.append([start, 1])
            visited.add(start)
            while queue:
                cur, weight = queue.pop()
                if cur == end:
                    return weight
                for key, val in self.graph[cur].items():
                    if key not in visited:
                        visited.add(key)
                        queue.append([key, val * weight])
            return -1
        for nodes, val in zip(equations, values):
            self.graph[nodes[0]][nodes[1]] = val
            self.graph[nodes[1]][nodes[0]] = 1 / val
        res = []
        for node1, node2 in queries:
            if node1 not in self.graph or node2 not in self.graph:
                res.append(-1)
            else:
                res.append(bfs(node1, node2))
        return res
```

```py
åŸºäºå­—å…¸çš„Floydç®—æ³•ï¼Œæ‰§è¡Œæ—¶é—´å‡»è´¥äº†98%

from collections import defaultdict

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        edges = defaultdict(dict)
        verts = set()

        for (a, b), c in zip(equations, values):
            verts.add(a)
            verts.add(b)

            edges[a][b] = c
            edges[b][a] = 1 / c

        for k in verts:
            ek = edges[k]
            for i in verts:
                if i == k:
                    continue

                ei = edges[i]
                for j in verts:
                    if k == j or i == j or j in ei:
                        continue
                
                    if k in ei and j in ek:
                        ei[j] = ei[k] * ek[j]

        rst = []
        for a, b in queries:
            if a in edges and b in edges[a]:
                rst.append(edges[a][b])
            elif a == b and a in verts and b in verts:
                rst.append(1)
            else:
                rst.append(-1)

        return rst
```

###  1.190. <a name='RemoveKDigits'></a>402 Remove K Digits

[å°æ˜](https://www.bilibili.com/video/BV1PV411C79X?spm_id_from=333.999.0.0)

###  1.191. <a name='SumofLeftLeaves'></a>404. Sum of Left Leaves

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Et411K7wa?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV15a4y1779U?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        isLeafNode = lambda node: not node.left and not node.right

        def dfs(node: TreeNode) -> int:
            ans = 0
            if node.left:
                ans += node.left.val if isLeafNode(node.left) else dfs(node.left)
            if node.right and not isLeafNode(node.right):
                ans += dfs(node.right)
            return ans
        
        return dfs(root) if root else 0

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/sum-of-left-leaves/solution/zuo-xie-zi-zhi-he-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        isLeafNode = lambda node: not node.left and not node.right
        q = collections.deque([root])
        ans = 0

        while q:
            node = q.popleft()
            if node.left:
                if isLeafNode(node.left):
                    ans += node.left.val
                else:
                    q.append(node.left)
            if node.right:
                if not isLeafNode(node.right):
                    q.append(node.right)
        
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/sum-of-left-leaves/solution/zuo-xie-zi-zhi-he-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution:
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root==None:
            return 0
        if root.left and root.left.left==None and root.left.right==None:
            return root.left.val+self.sumOfLeftLeaves(root.right)
        else:
            return self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)

root.left ä¸ºnullæ—¶ï¼Œå†è°ƒç”¨self.sumOfLeftLeaves(root.left)æ˜¯ä¸æ˜¯æ²¡æœ‰å¿…è¦ï¼Œè™½ç„¶å®ƒè¿”å›0ï¼Ÿ

æœ€åä¸€ä¸ªelseä¸ä»…åŒ…æ‹¬root.leftä¸ºç©ºçš„æƒ…å†µï¼Œè¿˜åŒ…æ‹¬äº†æœ‰å·¦å­æ ‘ä½†æ˜¯å·¦å­æ ‘ä¸æ˜¯ä¸€ä¸ªå¶å­çš„æƒ…å†µï¼Œæ‰€ä»¥é‚£éƒ¨åˆ†è¿˜æ˜¯ä¸èƒ½çœæ‰å§ã€‚

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        self.res=0
        def dfs(root):
            if root.left:
                if not root.left.left and not root.left.right:
                    self.res+=root.left.val
                dfs(root.left)
            if root.right:
                dfs(root.right)
            return self.res
        return dfs(root)

dfs

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        def dfs(root, is_left):
            if not root: return 0
            if not root.left and not root.right and is_left: #leaf
                return root.val
            return dfs(root.left, 1) + dfs(root.right, 0)
        return dfs(root, 0)
bfs

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root: return 0
        Q,res = list(), 0
        Q.append((root,0))
        while len(Q)>0:
            node, is_left = Q.pop(0)
            if node.left:
                Q.append((node.left, 1))
            if node.right:
                Q.append((node.right, 0))
            if not node.left and not node.right and is_left:
                res+=node.val
        return res
```

###  1.192. <a name='ConvertaNumbertoHexadecimal'></a>405 ã€ä½è¿ç®—ğŸ˜œã€‘Convert a Number to Hexadecimal

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1pj411f7ds?spm_id_from=333.999.0.0)

```py
ä¸‰ç§æ–¹æ³•

1.ç¬¬ä¸€ç§åº“å‡½æ•°(æ±‰æ˜é‡é‡çš„é¢˜ç›®ä¹Ÿå¯ä»¥ä½¿ç”¨åº“å‡½æ•°)
2.ç¬¬äºŒç§ä¸ç”¨ä½è¿ç®—ğŸ˜œï¼Œæ•´é™¤æ±‚ä½™ä¸€é¡¿æ“ä½œï¼Œé€†å‘å–ä½™ï¼Œæå®š
3.ç¬¬ä¸‰ç§ä½¿ç”¨ä½è¿ç®—ğŸ˜œï¼ŒæŠŠç¬¬äºŒä¸­çš„æ•´é™¤æ¢åšä½ç§»ï¼Œæ±‚ä½™æ¢åšä¸è¿ç®—
è¯¦ç»†æ€è·¯çœ‹ä»£ç 
ä»£ç 

# åº“å‡½æ•°ä½œå¼Šé€šè¿‡
class Solution:
    def toHex(self, num: int) -> str:
        return hex(num & 0xFFFFFFFF)[2:] # 0xFFFFFFFF 2 ^ 32 - 1
```

```py
å­¦ä¹ å¤§ç‰›çš„æ€è·¯ï¼Œè®°ä¸‹æ¥æ…¢æ…¢
32ä½æ•´æ•°ï¼Œæ¯4ä½1ä¸ªå­—èŠ‚ï¼Œä¸€ä¸ªå­—èŠ‚è½¬æˆ16è¿›åˆ¶åˆšå¥½æ˜¯0â€”fä¹‹é—´çš„ä¸€ä¸ªå­—ç¬¦ï¼›æœ€å¤šéœ€è¦è½¬æ¢8æ¬¡ï¼Œå¯èƒ½æœ‰å‡ ä¸ªâ€œ0â€ï¼Œæœ€åå»æ‰å°±æ˜¯äº†ã€‚

ç›´æ¥ ans = []
class Solution:
    def toHex(self, num: int) -> str:
        if num == 0:
            return "0"
        template = "0123456789abcdef"
        ans = []
        for _ in range(8):
            ans.append(template[num % 16])
            num //= 16
        ans.reverse()
        return "".join(ans).lstrip("0")

ç›´æ¥ result = ""

class Solution(object):
    def toHex(self, num):

        num = num & 0xffffffff
        result = ""
        lib = "0123456789abcdef"
        if num == 0:
            return "0"
        while num:
            result = lib[num % 16] + result # ä¸€å®šè¦åŠ åœ¨å³è¾¹
            num //= 16

        return result

formatçš„ç”¨æ³•å¾ˆå¤šï¼Œå€¼å¾—æ·±å…¥å­¦ä¹ 

print((1 << 32) + (-32))
print(bin((1 << 32) + (-32)))
print(format(((1 << 32) + (-32)), '0o'))
print(format(((1 << 32) + (-32)), '0x'))
4294967264
0b11111111111111111111111111100000
37777777740
ffffffe0

class Solution:
    def toHex(self, num):

        if num < 0:
            num = (1 << 32) + num
        return format(num, '0x')
```

###  1.193. <a name='QueueReconstructionbyHeight'></a>406. Queue Reconstruction by Height 

[å°æ˜](https://www.bilibili.com/video/BV1xC4y1a72W?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV144411R7ch?spm_id_from=333.999.0.0)

```py
# ä»£ç å¾ˆç®€å•ï¼Œæ€è·¯è¿˜ä¸å¤ªå¥½æƒ³

class Solution(object):
    def reconstructQueue(self, people):
        people = sorted(people, key=lambda x: (-x[0], x[1]))
        result = []
        for each in people:
            result.insert(each[1], each)
        return result

class Solution:
    def reconstructQueue(self, people):
        q = []
        for item in sorted(people, key=lambda x: (-x[0], x[1])):
            q.insert(item[1], item)
        return q

class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x:(-x[0], x[1]))
        res = []
        for p in people:
            res.insert(p[1], p)
        return res

class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x: (-x[0], x[1]))
        n = len(people)
        ans = list()
        for person in people:
            ans[person[1]:person[1]] = [person]
        return ans
```

###  1.194. <a name='ValidWordAbbreviation'></a>408. Valid Word Abbreviation

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1A4411q74A?spm_id_from=333.999.0.0)

###  1.195. <a name='LongestPalindrome'></a>409. ã€å›æ–‡ğŸŒˆã€‘Longest Palindrome

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1B441127W2?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV19C4y1479a?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Lk4y1z7PG?spm_id_from=333.999.0.0)

```py
class Solution:
    def longestPalindrome(self, s: str) -> int:
        ans = 0
        count = collections.Counter(s)
        for v in count.values():
            ans += v // 2 * 2
            if ans % 2 == 0 and v % 2 == 1:
                ans += 1
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/longest-palindrome/solution/zui-chang-hui-wen-chuan-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
æ‰¾å‡ºå‡ºç°æ¬¡æ•°ä¸ºå¶æ•°çš„æ±‚å’Œï¼Œå†æ‰¾å‡ºæ‰€æœ‰å¥‡æ•°å‡ä¸€æ±‚å’Œã€‚å› ä¸ºå¥‡æ•°æ˜¯å¯ä»¥æ‹†æˆå¶æ•°ä½¿ç”¨çš„

class Solution:
    def longestPalindrome(self, s: str) -> int:
        dic = {}
        for i in s:
            if i not in dic:
                dic[i] = 0
            dic[i] += 1
        nums1 = []; nums2 = []
        for i in dic.values():
            if i%2 == 0: nums1.append(i)
            else: nums2.append(i - 1)
        a = sum(nums1) if nums1 != [] else 0
        b = sum(nums2) + 1 if nums2 != [] else 0
        return a + b

æ‰£å‹ä»¬å¥½ï¼Œæ‰£å‹ä»¬å†è§

class Solution:
    def longestPalindrome(self, s: str) -> int:
        flag = False
        res = 0
        for i in Counter(s).values():
            res += i//2*2
            if i % 2 != 0:
                flag = True       
        return res+1 if flag else res


pythonä»£ç è´´ä¸€ä¸‹ï¼Œé€Ÿåº¦æ‰“è´¥75%ï¼Œå†…å­˜æ‰“è´¥92%

class Solution:
    def longestPalindrome(self, s: str) -> int:
        cnt = [0] * 58 # å¤§å†™å’Œå°å†™å­—æ¯ä¹‹é—´éš”äº†6ä¸ªASCIIç 
        for i in s:
            cnt[ord(i)-ord('A')] += 1
        ans = 0
        for j in cnt:
            ans += (j // 2) * 2
        return ans + int(ans < len(s)) # å¦‚æœansæ¯”åŸå­—ç¬¦ä¸²çŸ­ï¼Œå°±è¯´æ˜å¯ä»¥æ‹¿ä¸€ä¸ªå­—ç¬¦åšä¸­å¿ƒ


ç›´æ¥ç»Ÿè®¡sï¼Œæœ€åæŒ‰ç…§å­—ç¬¦æ•°é™¤ä»¥2å‘ä¸‹å–æ•´ä¹˜ä»¥2ï¼Œå¦‚æœæŸä¸€ä¸ªå­—ç¬¦å‡ºç°å¥‡æ•°æ¬¡ï¼Œç»„åˆçš„å›æ–‡ğŸŒˆæ•°åŠ 1ï¼›


class Solution:
    def longestPalindrome(self, s: str) -> int:
        from collections import Counter
        counter_s = Counter(s)
        ans = 0
        c = 0
        for key, value in counter_s.items():
            if value >= 2:
                ans += value // 2 * 2
            if value % 2 == 1:
                c = 1
        return ans + c
```



###  1.196. <a name='SplitArrayLargestSum'></a>410. Split Array Largest Sum

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14W411d7D4?spm_id_from=333.999.0.0)

###  1.197. <a name='FizzBuzz'></a>412. Fizz Buzz

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1xE411R7yK?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1tD4y1m76j?spm_id_from=333.999.0.0)

```py
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        ans = []
        for i in range(1, n + 1):
            s = ""
            if i % 3 == 0:
                s += "Fizz"
            if i % 5 == 0:
                s += "Buzz"
            if s == "":
                s = str(i)
            ans.append(s)
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/fizz-buzz/solution/fizz-buzz-by-leetcode-solution-s0s5/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

python 3.10çš„è§£æ³• å¯æƒœç›®å‰ä¸æ”¯æŒ

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        res = []
        for i in range(1, n+1):
            match (i % 3 == 0), (i % 5 == 0):
                case True, True: res.append("Fizzbuzz")
                case True, _: res.append("Fizz")
                case _, True: res.append("Buzz")
                case _: res.append(i)
        return res
```

```py
ä¸€è¡Œæµ

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        return ['Fizz'*(not i%3)+'Buzz'*(not i%5) or str(i) for i in range(1,n+1)]

ä¸€è¡Œpythonå®Œäº‹

class Solution(object):
    def fizzBuzz(self, n):
        return ["FizzBuzz" if i % 15 == 0 else "Fizz" if i % 3 == 0 else "Buzz" if i % 5 == 0 else str(i) for i in range(1, n + 1)]
```

```scala
object Solution {
    def fizzBuzz(n: Int): List[String] = {
        (1 to n).map(num => {
            if(num%15 == 0)
                "FizzBuzz"
            else if(num%5 == 0)
                "Buzz"
            else if(num%3 == 0)
                "Fizz"
            else
                num.toString
        }).toList
    }
}

```

###  1.198. <a name='-1'></a>413-ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ç­‰å·®æ•°åˆ—åˆ’åˆ†

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV13a4y1i7tR?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV13f4y167YZ?spm_id_from=333.999.0.0)

```py
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        tmp = []
        for i in range(1,len(nums)):
            tmp.append(nums[i]-nums[i-1])
        
        dp = [0] * len(tmp)
        for i in range(1,len(tmp)):
            if tmp[i] == tmp[i-1]:
                dp[i] = 1 + dp[i-1]
        return sum(dp)

å…¶ä»–å†™æ³•ï¼š

class Solution:
    def numberOfArithmeticSlices(self, nums):
        n = len(nums)
        dp = [0]*n
        for i in range(2,n):
            dp[i] = dp[i-1]+1 if nums[i]-nums[i-1]==nums[i-1]-nums[i-2] else 0
        return sum(dp)
```

###  1.199. <a name='ThirdMaximumNumber'></a>414. Third Maximum Number

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1UE411X7k1?spm_id_from=333.999.0.0)

###  1.200. <a name='AddStrings'></a>415-Add Strings

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV18E411n7Cy?spm_id_from=333.999.0.0)

###  1.201. <a name='dfsstartIforPartitionEqualSubsetSum'></a>416. ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + dfs(startI)æ— forå¾ªç¯ã€‘Partition Equal Subset Sum

####  1.201.1. <a name='494'></a>ç›¸ä¼¼é¢˜ç›®ï¼š494é¢˜

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1AW411y7So?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1oZ4y1G7QY?spm_id_from=333.999.0.0)

â€œåŠ¨æ€ğŸš€è§„åˆ’â€ çš„è§£æ³•

```py
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 2:
            return False
        
        total = sum(nums)
        if total % 2 != 0:
            return False
        
        target = total // 2
        dp = [True] + [False] * target
        for i, num in enumerate(nums):
            for j in range(target, num - 1, -1):
                dp[j] |= dp[j - num]
                # dp[j] = dp[j] or dp[j-num]
        
        return dp[target]

æ ¹æ®494é¢˜ä¿®æ”¹çš„åŠ¨æ€è§„åˆ’ï¼š

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        # æ±‚å¾—æ–°çš„ç›®æ ‡
        sums = sum(nums)
        # æ³¨æ„ï¼Œéœ€è¦æ’é™¤æ‰ä¸€äº›ç‰¹æ®ŠçŠ¶å†µ
        if sums % 2 == 1: return False
        bagSize = sums // 2
        # æ„å»ºdpï¼ŒnumLenåœ¨å¤–å›´
        dp = [0] * (bagSize+1)
        # èµ‹å€¼ï¼Œdpçš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        dp[0] = 1
        for num in nums:
            for j in range(bagSize,num-1,-1):
                dp[j] += dp[j-num] # å¯¹äºæ²¡æœ‰å½“å‰numæ—¶çš„case + æœ‰äº†numæ—¶bagSize-numçš„cas
        # å«ä¹‰å°±æ˜¯ï¼š
        # å¯¹äº1ä¸ªnumï¼Œbagsizeçš„å¡«æ»¡æƒ…å†µ
        # å¯¹å¼ˆ2ä¸ªnumï¼Œbagsizeçš„å¡«æ»¡æƒ…å†µ
        return dp[-1] != 0
```

```py
# pythoné€’å½’...

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        # @lru_cache(None)
        def dp(i,N):                                #dp(i,N)è¿”å›nums[0...i]ä¸­ä¸”å½“å‰å’Œä¸ºNçš„çŠ¶æ€ä¸‹ï¼Œèƒ½å¦å‡‘æˆå’Œä¸ºtargetçš„ç»“æœ
            if N>target or i<0:return False
            if N==target: return True
            # è¿™ä¸ªå¾ˆå·§å¦™æ¯æ¬¡å¯ä»¥é€‰æ‹©å°†nums[i]åŠ è¿›Nï¼Œæˆ–è€…ä¸å°†nums[i]åŠ è¿›N
            return dp(i-1, N+nums[i]) or dp(i-1,N)   

        if sum(nums)%2 != 0: return False              #ç›®æ ‡å’Œä¸ºå¥‡æ•°æ—¶ä¸èƒ½åˆ†å‰²æˆä¸¤ä¸ªå…ƒç´ ç›¸ç­‰çš„å­é›†
        target = sum(nums) // 2                         #åŸé—®é¢˜ç­‰ä»·äºå°†numsåˆ’åˆ†ä¸ºå…ƒç´ å’Œä¸ºnumsä¸€åŠçš„ä¸¤ä¸ªå­é›†çš„åˆ’åˆ†æ–¹å¼æ˜¯å¦å­˜åœ¨
        return dp(len(nums)-1, 0)
```



###  1.202. <a name='PacificAtlanticWaterFlow'></a>417. ã€æ„é€ ğŸ°ã€‘Pacific Atlantic Water Flow

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Kb411K7ty?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1by4y1h7ab?spm_id_from=333.999.0.0)

```py
class Solution:
    def bfs(self, heights: List[List[int]], src: List[List[int]], cnt: List[List[int]]) -> None:
        direction = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        m, n = len(heights), len(heights[0])
        visited = [[False] * n for _ in range(m)]
        from collections import deque
        q = deque(src)
        while q:
            x, y = q.popleft()
            for i, j in direction:
                row, col = x + i, y + j
                if 0 <= row < m and 0 <= col < n and not visited[row][col] and \
                    (x in (-1, m) or y in (-1, n) or heights[row][col] >= heights[x][y]):
                    visited[row][col] = True
                    cnt[row][col] += 1
                    q.append((row, col))
    
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        cnt = [[0] * n for _ in range(m)]
        # 1. ä»å¤ªå¹³æ´‹é€†æµè€Œä¸Š
        self.bfs(heights, [(-1, col) for col in range(n)] + [(row, -1) for row in range(m)], cnt)

        # 2. ä»å¤§è¥¿æ´‹é€†æµè€Œä¸Š
        self.bfs(heights, [(m, col) for col in range(n)] + [(row, n) for row in range(m)], cnt)
        # 3. ç­›é€‰å‡º cnt[row][col] = 2 çš„åæ ‡
        return [[row, col] for row in range(m) for col in range(n) if cnt[row][col] == 2]
```

```py
Python ç‰ˆæœ¬é€†æµè€Œä¸Š

class Solution:
    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        res = []
        if not matrix or len(matrix) == 0:
            return res

        directions = [[0,1], [0,-1], [1, 0], [-1,0]]

        m = len(matrix)
        n = len(matrix[0])

        canP = [[0] * n for _ in range(m)]
        canA = [[0] * n for _ in range(m)]

        def dfs(row, col, ocean):
            if not ocean[row][col]:
                ocean[row][col] = 1
                for direction in directions:
                    x = row + direction[0]
                    y = col + direction[1]
                    if x >= m or x < 0  or y >= n or y < 0 or matrix[x][y] < matrix[row][col]:
                        continue
                    dfs(x, y, ocean)

        for i in range(m):
            dfs(i, 0, canP)
            dfs(i, n-1, canA)

        for j in range(n):
            dfs(0, j, canP)
            dfs(m-1, j, canA)

        for i in range(m):
            for j in range(n):
                if canA[i][j] and canP[i][j]:
                    res.append([i,j])
        return res

python ç®€æ´è§£æ³•

class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        A, B = set(), set()
        def dfs(i, j, vis):
            vis.add((i, j))
            for ni, nj in ((i+1, j), (i-1, j), (i, j-1), (i, j+1)):
                if -1<ni<m and -1<nj<n and heights[ni][nj]>=heights[i][j]\
                    and (ni, nj) not in vis:
                    dfs(ni, nj, vis)
        
        for i in range(m): dfs(i, 0, A);dfs(i, n-1, B)
        for j in range(n): dfs(0, j, A);dfs(m-1, j, B)
        return [list(i) for i in A&B]

python å¤šæº bfs

ä»ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—å¼€å§‹éå†éé€’å‡æ ¼å­ï¼Œå³å¯å¾—åˆ°æ‰€æœ‰èƒ½æµåˆ°â€œå¤ªå¹³æ´‹â€çš„æ ¼å­ã€‚ åŒç†ä»æœ€åä¸€è¡Œå’Œæœ€åä¸€åˆ—éå†ï¼Œå¾—åˆ°æ‰€æœ‰èƒ½æµåˆ°â€œå¤ªè¥¿æ´‹â€çš„æ ¼å­ï¼Œæ±‚äº¤é›†å³å¯ã€‚

class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        def bfs(A):
            queue, vis = deque(A), set(A)
            while queue:
                i, j = queue.popleft()
                for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                    if 0<=x<m and 0<=y<n and (x, y) not in vis and heights[x][y]>=heights[i][j]:
                        queue.append((x, y))
                        vis.add((x, y))
            return vis

        m, n = len(heights), len(heights[0])
        A = {(0, j) for j in range(n)} | {(i, 0) for i in range(m)}
        B = {(m-1, j) for j in range(n)} | {(i, n-1) for i in range(m)}
        return [[i, j] for i, j in bfs(A) & bfs(B)]
```

###  1.203. <a name='BattleshipsinaBoard'></a>419. Battleships in a Board 

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1TJ411j7QZ?spm_id_from=333.999.0.0)

###  1.204. <a name='MaximumXORofTwoNumbersinanArray'></a>421 Maximum XOR of Two Numbers in an Array

[å°æ˜](https://www.bilibili.com/video/BV1s64y1F7Wm?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMaximumXOR(self, nums):
        # æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
        HIGH_BIT = 30

        x = 0
        for k in range(HIGH_BIT, -1, -1):
            seen = set()
            # å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­
            for num in nums:
                # å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
                # åªéœ€å°†å…¶å³ç§» k ä½
                seen.add(num >> k)

            # ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
            # æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1
            x_next = x * 2 + 1
            found = False
            
            # æšä¸¾ i
            for num in nums:
                if x_next ^ (num >> k) in seen:
                    found = True
                    break

            if found:
                x = x_next
            else:
                # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0
                # å³ä¸º x = x*2
                x = x_next - 1
        
        return x

class Solution(object):
    def findMaximumXOR(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        answer = 0
        for i in range(32)[::-1]:
            answer <<= 1
            prefixes = {num >> i for num in nums}
            answer += any(answer^1 ^ p in prefixes for p in prefixes)
        return answer
```

###  1.205. <a name='ReconstructOriginalDigitsfromEnglish'></a>423 Reconstruct Original Digits from English

[å°æ˜](https://www.bilibili.com/video/BV1554y1h73S?spm_id_from=333.999.0.0)

###  1.206. <a name='LongestRepeatingCharacterReplacem'></a>424. æ›¿æ¢åçš„æœ€é•¿é‡å¤å­—ç¬¦ Longest Repeating Character Replacem

[å®˜æ–¹](https://www.bilibili.com/video/BV14r4y1K7rN?spm_id_from=333.999.0.0)

### 426ã€å‰‘æŒ‡36ã€‘. å°†äºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºæ’åºçš„åŒå‘é“¾è¡¨ã€å­—èŠ‚è·³åŠ¨ã€‘-
å°†ä¸€ä¸ª äºŒå‰æœç´¢æ ‘ å°±åœ°è½¬åŒ–ä¸ºä¸€ä¸ª å·²æ’åºçš„åŒå‘å¾ªç¯é“¾è¡¨ ã€‚

å¯¹äºåŒå‘å¾ªç¯åˆ—è¡¨ï¼Œä½ å¯ä»¥å°†å·¦å³å­©å­æŒ‡é’ˆä½œä¸ºåŒå‘å¾ªç¯é“¾è¡¨çš„å‰é©±å’Œåç»§æŒ‡é’ˆï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å‰é©±æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„åç»§æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚

ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬å¸Œæœ›å¯ä»¥ å°±åœ° å®Œæˆè½¬æ¢æ“ä½œã€‚å½“è½¬åŒ–å®Œæˆä»¥åï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å·¦æŒ‡é’ˆéœ€è¦æŒ‡å‘å‰é©±ï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å³æŒ‡é’ˆéœ€è¦æŒ‡å‘åç»§ã€‚è¿˜éœ€è¦è¿”å›é“¾è¡¨ä¸­æœ€å°å…ƒç´ çš„æŒ‡é’ˆã€‚

![](https://s3.bmp.ovh/imgs/2022/01/11d8ac60b4c3deb6.png)

```py
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: return
        path = []
        def inorder(root):
            if not root: return 
            inorder(root.left)
            path.append(root)
            inorder(root.right)    
        inorder(root)
        for i in range(len(path)):
            path[i].left = path[i-1]
            path[i].right = path[(i+1)%len(path)]
        return path[0]
        
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        a, f = [], lambda r: r and (f(r.left) or a.append(r) or f(r.right))
        f(root)
        n = len(a)
        for i, r in enumerate(a):
            r.left, r.right = a[i - 1], a[i + 1 - n]
        return n and a[0] or None

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        def dfs(cur):
            if not cur: return
            dfs(cur.left) # é€’å½’å·¦å­æ ‘
            if self.pre: # ä¿®æ”¹èŠ‚ç‚¹å¼•ç”¨
                self.pre.right, cur.left = cur, self.pre
            else: # è®°å½•å¤´èŠ‚ç‚¹
                self.head = cur
            self.pre = cur # ä¿å­˜ cur
            dfs(cur.right) # é€’å½’å³å­æ ‘
        
        if not root: return
        self.pre = None
        dfs(root)
        self.head.left, self.pre.right = self.pre, self.head
        return self.head

ä½œè€…ï¼šjyd
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

## æ€è·¯:

å…¶å®å°±æ˜¯å·¦å³èŠ‚ç‚¹æŒ‡å‘æ”¹å˜ï¼Œå³èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªæ¯”å®ƒå¤§çš„æ•°ï¼Œå·¦èŠ‚ç‚¹æŒ‡å‘æ¯”å®ƒå°çš„æ•°ã€‚åˆæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œè‡ªç„¶æƒ³åˆ°ä¸­åºéå†ã€‚

æ€è·¯ä¸€ï¼šä¸­åºéå†ï¼ˆéé€’å½’å’Œé€’å½’ï¼‰

å†™æ³•ä¸€ï¼šç”¨æ ˆ(éé€’å½’)

"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:return 
        # å½“ä¸€ä¸ªä¸­é—´èŠ‚ç‚¹
        head = Node(-1, None, None)
        # è®°å½•ä¸ºå…ˆå‰èŠ‚ç‚¹,æ‰¾åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰èƒ½ä¸²èµ·æ¥
        prev = head
        # ä¸­åºéå†çš„éé€’å½’
        stack = []
        p = root
        while p or stack:
            while p:
                stack.append(p)
                p = p.left
            p = stack.pop()
            # æ”¹å˜å·¦å³æ–¹å‘
            prev.right = p
            p.left = prev
            # æ”¹å˜å…ˆå‰èŠ‚ç‚¹
            prev = p
            p = p.right
        # å°†head åˆ æ‰   
        head.right.left = prev
        prev.right = head.right
        return head.right
å†™æ³•äºŒï¼šé€’å½’

"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:return 
        # å½“ä¸€ä¸ªä¸­é—´èŠ‚ç‚¹
        head = Node(-1, None, None)
        # è®°å½•ä¸ºå…ˆå‰èŠ‚ç‚¹,æ‰¾åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰èƒ½ä¸²èµ·æ¥
        prev = head

        # ä¸­åºéå†çš„é€’å½’
        def inorder(root):
            nonlocal prev
            if not root:
                return 
            inorder(root.left)
            prev.right = root
            root.left = prev
            prev = prev.right
            inorder(root.right)
        
        inorder(root)
        # å°†head åˆ æ‰   
        head.right.left = prev
        prev.right = head.right
        return head.right
æ€è·¯äºŒï¼šåˆ†æ²»

"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: return
        left = self.treeToDoublyList(root.left)
        right = self.treeToDoublyList(root.right)
        root.left = root
        root.right = root
        return self.connect(self.connect(left, root), right)

    def connect(self, node1, node2):
        if not (node1 and node2):
            return node1 or node2
        tail1, tail2 = node1.left, node2.left
        tail1.right = node2
        node2.left = tail1
        tail2.right = node1
        node1.left = tail2
        return node1
```

```py
"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def myinorderTraversal(self, root: 'Node') -> 'Node':
        ''' traversal order:  right subtree -> root -> left subtree '''

        # conrer case
        if not root: return None

        sentinel = Node()    # è™šæ‹Ÿå“¨å…µå°¾èŠ‚ç‚¹
        successor = sentinel # åé©±æŒ‡é’ˆ

        def inorder(r = root):
            nonlocal successor
            if not r: return
        
            inorder(r.right)
            # ä¸å»ºè®®åˆå­¦è¿™ä¹ˆå†™
            r.right, successor.left, successor = successor, r, r
            inorder(r.left)

        inorder()
        successor.left = sentinel.left
        sentinel.left.right = successor
        return successor

    def inorderTraversal(self, root: 'Node') -> 'Node':
        ''' traversal order:  left subtree -> root -> right subtree '''

        # conrer case
        if not root: return None

        sentinel = Node()      # è™šæ‹Ÿå“¨å…µå¤´èŠ‚ç‚¹
        predecessor = sentinel # å‰é©±æŒ‡é’ˆ

        def inorder(r = root):
            nonlocal predecessor
            if not r: return
        
            inorder(r.left)
            # ä¸å»ºè®®åˆå­¦è¿™ä¹ˆå†™
            predecessor.right, r.left, predecessor = r, predecessor, r
            inorder(r.right)

        inorder()
        sentinel.right.left = predecessor
        predecessor.right = sentinel.right
        return sentinel.right


    treeToDoublyList = myinorderTraversal
    # treeToDoublyList = inorderTraversal
```

```py
è¾…åŠ©æ ˆ

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:
            return root
        # è¾…åŠ©æ ˆ        
        helper, start = [], None
        current, pre = root, None
        while len(helper) != 0 or current != None:
            if current != None:
                helper.append(current)
                current = current.left
            else:
                current = helper.pop()
                if pre != None:
                    current.left = pre
                    pre.right = current
                else:
                    start = current
                pre = current
                current = current.right
        start.left = pre
        pre.right = start
        return start

è¿­ä»£

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        # left : pre right: nex
        dummy = Node(None)
        p = dummy
        if not root:
            return root
        stack = [[root, False]]
        while stack:
            node, visited = stack.pop()
            if not visited:
                if node.right:
                    stack.append([node.right, False])
                stack.append([node, True])
                if node.left:
                    stack.append([node.left, False])
            else:
                node.left = p
                node.right = None
                p.right = node
                p = p.right
        head = dummy.right
        head.left = p
        p.right = head
        return head

def treeToDoublyList(self, root: 'Node') -> 'Node':
        pre = None
        head = None
        def inorder(root):
            nonlocal pre
            nonlocal head
            if not root:
                return 

            inorder(root.left)
            if pre:
                pre.right, root.left = root, pre
            else:
                head = root #ç¬¬ä¸€ä¸ªèŠ‚ç‚¹,bstæœ€å°çš„èŠ‚ç‚¹
            pre = root
            inorder(root.right)

        if not root:
            return
        inorder(root)
        pre.right, head.left = head, pre
        return head
```

###  1.207. <a name='N-aryTreeLevelOrderTraversal'></a>429. N-ary Tree Level Order Traversal

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1CE411Q7BQ?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Uv411K77M?spm_id_from=333.999.0.0)

```py
def levelOrder(self, root: 'Node') -> List[List[int]]:
    if root is None:
        return []
    result = []
    queue = collections.deque([root])
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            queue.extend(node.children)
        result.append(level)
    return result

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

def levelOrder(self, root: 'Node') -> List[List[int]]:
    if root is None:
        return []        

    result = []
    previous_layer = [root]

    while previous_layer:
        current_layer = []
        result.append([])
        for node in previous_layer:
            result[-1].append(node.val)
            current_layer.extend(node.children)
        previous_layer = current_layer
    return result

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

def levelOrder(self, root: 'Node') -> List[List[int]]:

    def traverse_node(node, level):
        if len(result) == level:
            result.append([])
        result[level].append(node.val)
        for child in node.children:
            traverse_node(child, level + 1)

    result = []

    if root is not None:
        traverse_node(root, 0)
    return result

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
Pythonç‰ˆ

æ€è·¯ä¸€ï¼šDFS

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:

        res = []

        def dfs(root, depth):
            if not root: return 
            if len(res) <= depth:
                res.append([])
            res[depth].append(root.val)
            for ch in root.children:
                dfs(ch, depth+1)
        
        dfs(root, 0)
        return res
æ€è·¯äºŒï¼šBFS

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:return []
        res = []
        
        def bfs(root):
            queue = [root]
            while queue:
                nxt = []
                tmp = []
                for node in queue:
                    tmp.append(node.val)
                    for ch in node.children:
                        nxt.append(ch)
                res.append(tmp)
                queue = nxt
        
        bfs(root)
        return res
```

###  1.208. <a name='FlattenaMultilevelDoublyLinkedList'></a>430 Flatten a Multilevel Doubly Linked List

[å°æ˜](https://www.bilibili.com/video/BV1754y1q7Kb?spm_id_from=333.999.0.0)

###  1.209. <a name='AllOoneDataStructure'></a>432. All O`one Data Structure

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1XW411d7qR?spm_id_from=333.999.0.0)

###  1.210. <a name='Non-overlappingIntervals'></a>435-Non-overlapping Intervals

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1i7411p7pv?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ak4y1U7f8?spm_id_from=333.999.0.0)

```py
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0:
            return 0
        intervals.sort(key = lambda x:x[1])
        res = 0
        current = intervals[0][1]
        for i in intervals[1:]:
            if i[0] >= current:
                current = i[1]
            else:
                current = min(i[1], current)
                res += 1
        return res

# æœ€éš¾æƒ³é€šçš„å…¶å®æ˜¯æ ¹æ®å“ªä¸ªè¾¹ç•Œæ’åºï¼Œçœ‹äº†é¢˜è§£é‡Œå¤§ä½¬çš„ç†è§£ï¼Œ

# æƒ³è±¡æˆå‚åŠ æ´»åŠ¨ï¼Œå½±å“ä½ å‚åŠ æ›´å¤šæ´»åŠ¨çš„æ˜¯æ´»åŠ¨çš„ç»“æŸæ—¶é—´ï¼Œ

# åªæœ‰ä¸Šä¸€ä¸ªæ´»åŠ¨ç»“æŸäº†ï¼Œæ‰èƒ½å‚åŠ ä¸‹ä¸€ä¸ªï¼Œ

# å³ä¸Šä¸€ä¸ªæ´»åŠ¨çš„ç»“æŸæ—¶é—´è¦å°äºä¸‹ä¸€ä¸ªæ´»åŠ¨çš„å¼€å§‹æ—¶é—´ã€‚


class Solution(object):
    def eraseOverlapIntervals(self, intervals):
  
        if not intervals:
            return 0
        intervals.sort(key=lambda x:x[1])
        l=len(intervals)
        count=1
        end=intervals[0][1]
        for i in range(1,l):
            if intervals[i][0]>=end:
                count+=1
                end=intervals[i][1]
        return l-count

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0: return 0
        intervals.sort(key=lambda x: x[1])
        count = 1 # è®°å½•éäº¤å‰åŒºé—´çš„ä¸ªæ•°
        end = intervals[0][1] # è®°å½•åŒºé—´åˆ†å‰²ç‚¹
        for i in range(1, len(intervals)):
            if end <= intervals[i][0]:
                count += 1
                end = intervals[i][1]
        return len(intervals) - count

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        right = intervals[0][1]
        ans = 1

        for i in range(1, n):
            if intervals[i][0] >= right:
                ans += 1
                right = intervals[i][1]
        
        return n - ans

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort()
        n = len(intervals)
        f = [1]

        for i in range(1, n):
            f.append(max((f[j] for j in range(i) if intervals[j][1] <= intervals[i][0]), default=0) + 1)

        return n - max(f)
```


###  1.211. <a name='FindRightInterval'></a>436 Find Right Interval

[å°æ˜](https://www.bilibili.com/video/BV1YT4y1w7EP?spm_id_from=333.999.0.0)

###  1.212. <a name='PathSumIII'></a>437 ã€å‰ç¼€å’ŒğŸ¨ã€‘Path Sum III

[å°æ˜](https://www.bilibili.com/video/BV1tZ4y1M7JR?spm_id_from=333.999.0.0)

æ—¶é—´å¤æ‚åº¦ O(n), ç©ºé—´å¤æ‚åº¦ O(n)

```py
def pathSum(self, root, sum):
    
    self.dicts = {0: 1}
    self.res = 0
    def helper(root, prefix_sum, sum):
        if not root:
            return 0
            
        prefix_sum += root.val
        
        if prefix_sum - sum in self.dicts:
            self.res += self.dicts[prefix_sum - sum]
            
        
        self.dicts[prefix_sum] = self.dicts.get(prefix_sum, 0) + 1
        
        helper(root.left, prefix_sum, sum)
        
        helper(root.right, prefix_sum, sum)
        
        # Note: å›åˆ°ä¸Šä¸€å±‚æ—¶, éœ€è¦å°†å½“å‰çš„å‰ç¼€å’Œå¯¹åº”çš„è·¯å¾„æ•°ç›®å‡1      
        self.dicts[prefix_sum] -= 1
    
    helper(root, 0, sum)
    return res    
```

###  1.213. <a name='FindAllAnagramsinaString'></a>438. ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘Find All Anagrams in a String

#### ç±»ä¼¼567

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1iW411d7Nb?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1254y1X7HV?spm_id_from=333.999.0.0)

```py
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        tarDIC = collections.Counter(p)
        ns = len(s)
        np = len(p)
        res = []
        for i in range(len(s)-len(p)+1):
            if collections.Counter(s[i:i+np]) == tarDIC:
                res.append(i)
        return res
```

```py
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        tarDIC = sorted(p)
        ns = len(s)
        np = len(p)
        res = []
        for i in range(len(s)-len(p)+1):
            if sorted(s[i:i+np]) == tarDIC:
                res.append(i)
        return res
```

```scala
/**
* chosen solution
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/
object Solution0 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }
    ret.toList
  }
}

/**
* my first commit
* sliding window + hashMap within windows
* time complexity: O(NM): N: s.length, M: p.length
*/

object Solution1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap

     s.sliding(p.length).zipWithIndex.filter{ case (c, _) => pMap == c.groupBy(identity).mapValues(_.length).toMap}.map(_._2).toList
  }
}


/**
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/

object Solution2 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }

    ret.toList
  }
}

/**
* sliding window - two hashmap version
* using a mutable map storing current window's string element and amount
* time complexity: O(N)
* space complexity: O(2N) -> two hashMap
*/

object Solution2-1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap
    val sMap = scala.collection.mutable.Map[Char, Int]()
    val result = scala.collection.mutable.ListBuffer[Int]()

    for((char, right) <- s.zipWithIndex) {
      sMap.put(char, sMap.getOrElse(char, 0) + 1)

      if(right >= p.length) {
        val leftChar = s(right - p.length)
        sMap.get(leftChar) match {
          case Some(e) if e == 1 => sMap.remove(leftChar)
          case Some(e) => sMap.update(leftChar, e - 1)
          case _ =>
        }
      }
      if(pMap.equals(sMap)) result += (right - p.length + 1)
    }
    result.toList
  }
}

```

###  1.214. <a name='ArrangingCoins'></a>441 Arranging Coins

[å°æ˜](https://www.bilibili.com/video/BV1eV411k7rg?spm_id_from=333.999.0.0)

###  1.215. <a name='FindAllDuplicatesinanArray'></a>442 Find All Duplicates in an Array

[å°æ˜](https://www.bilibili.com/video/BV1Lh411d7AD?spm_id_from=333.999.0.0)

###  1.216. <a name='StringCompression'></a>443. String Compression

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1rE411f7Ld?spm_id_from=333.999.0.0)

###  1.217. <a name='AddTwoNumbersII'></a>445-Add Two Numbers II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Qj411f7Qz?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Pt4y1m78o?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV17a4y1s7BG?spm_id_from=333.999.0.0)

```py
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        s1, s2 = [], []
        while l1:
            s1.append(l1.val)
            l1 = l1.next
        while l2:
            s2.append(l2.val)
            l2 = l2.next
        ans = None
        carry = 0
        while s1 or s2 or carry != 0:
            a = 0 if not s1 else s1.pop()
            b = 0 if not s2 else s2.pop()
            cur = a + b + carry
            carry = cur // 10
            cur %= 10
            curnode = ListNode(cur)
            curnode.next = ans
            ans = curnode
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/add-two-numbers-ii/solution/liang-shu-xiang-jia-ii-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

åæ­£éƒ½æ˜¯è¦éå†ï¼Œç›´æ¥éå†è½¬æˆstringå–å‡ºæ¥ï¼Œç›¸åŠ å®Œäº†å†æ„é€ æˆé“¾è¡¨å³å¯ã€‚ä¸€éè¿‡ï¼Œä»£ç å¾ˆç®€æ´ã€‚

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        num1, num2 = "", ""
        while l1:
            num1 += str(l1.val)
            l1 = l1.next
        while l2:
            num2 += str(l2.val)
            l2 = l2.next
        resNum = str(int(num1) + int(num2))
        root = ListNode(0)
        p = root
        for digit in resNum:
            p.next = ListNode(int(digit))
            p = p.next
        return root.next
```

```py
pythonä¸æ€•æº¢å‡º

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        def f(node):
            num=0
            while node:
                num=num*10+node.val
                node=node.next
            return num
        class Node(ListNode):
            def __init__(self,y,x):
                super().__init__(x)
                self.next=y
        return functools.reduce(Node,map(int,reversed(str(f(l1)+f(l2)))),None)
```

###  1.218. <a name='NumberofBoomerangs'></a>447. Number of Boomerangs

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hE411o7V2?spm_id_from=333.999.0.0)

###  1.219. <a name='FindAllNumbersDisappearedinanArray'></a>448. Find All Numbers Disappeared in an Array

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1SE411d7FM?spm_id_from=333.999.0.0)

###  1.220. <a name='SerializeandDeserializeBST'></a>449. Serialize and Deserialize BST

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ab411c75V?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ty4y1r7FT?spm_id_from=333.999.0.0)

```py
class Codec:
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        """
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        return ' '.join(map(str, postorder(root)))

    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [int(x) for x in data.split(' ') if x]
        return helper()

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu-2/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Codec:
    def postorder(self, root):
        return self.postorder(root.left) + self.postorder(root.right) + [root.val] if root else []
        
    def int_to_str(self, x):
        """
        Encodes integer to bytes string.
        """
        bytes = [chr(x >> (i * 8) & 0xff) for i in range(4)]
        bytes.reverse()
        bytes_str = ''.join(bytes)
        return bytes_str
        
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        """
        lst = self.postorder(root)
        lst = [self.int_to_str(x) for x in lst]
        return 'Ã§'.join(map(str, lst))
    
    def str_to_int(self, bytes_str):
        """
        Decodes bytes string to integer.
        """
        result = 0
        for ch in bytes_str:
            result = result * 256 + ord(ch)
        return result
        
    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [self.str_to_int(x) for x in data.split('Ã§') if x]
        return helper() 

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu-2/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Codec:
    def postorder(self, root):
        return self.postorder(root.left) + self.postorder(root.right) + [root.val] if root else []
        
    def int_to_str(self, x):
        """
        Encodes integer to bytes string
        """
        bytes = [chr(x >> (i * 8) & 0xff) for i in range(4)]
        bytes.reverse()
        bytes_str = ''.join(bytes)
        return bytes_str
        
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        """
        lst = [self.int_to_str(x) for x in self.postorder(root)]
        return ''.join(map(str, lst))
    
    def str_to_int(self, bytes_str):
        """
        Decodes bytes string to integer.
        """
        result = 0
        for ch in bytes_str:
            result = result * 256 + ord(ch)
        return result
        
    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        n = len(data)
        # split data string into chunks of 4 bytes
        # and convert each chunk to int
        data = [self.str_to_int(data[4 * i : 4 * i + 4]) for i in range(n // 4)]
        return helper() 

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu-2/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

ç›´æ¥å°†å…¶ç”¨å…ˆåºéå†åºåˆ—åŒ–ï¼Œå› ä¸ºæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œæ‰€ä»¥æ’åºåå°±æ˜¯ä¸­åºéå†ï¼Œå› æ­¤ååºåˆ—åŒ–å°±è½¬æ¢æˆäº†105é¢˜çš„ä»å…ˆåºä¸ä¸­åºæ„é€ äºŒå‰æ ‘çš„é—®é¢˜ã€‚ æ—¶é—´è¶…è¿‡100%ã€‚

class Codec:
    def serialize(self, root):
        def preorder(root):
            out = []
            if root:
                out += [str(root.val)]
                out += preorder(root.left)
                out += preorder(root.right)
            return out
        return ','.join(preorder(root))
        
    def deserialize(self, data):
        if not data:
            return None
        def buildTree(pre_o, in_o):
            if not pre_o:
                return None
            mid = pre_o[0]
            i = in_o.index(mid)
            root = TreeNode(mid)
            root.left = buildTree(pre_o[1:i + 1], in_o[:i])
            root.right = buildTree(pre_o[i + 1:], in_o[i + 1:])
            return root
        pre_o = list(map(int, data.split(',')))
        in_o = sorted(pre_o)
        return buildTree(pre_o, in_o)


```

```py
**å…ˆåº:**

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        
        def preorder(root):
            if not root:
                res.append("#")
                return 
            res.append(str(root.val))
            preorder(root.left)
            preorder(root.right)
        preorder(root)
        return ",".join(res)

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        d = iter(data.split(","))
        def helper():
            tmp = next(d)
            # print(tmp)
            if tmp == "#":return 
            node = TreeNode(int(tmp))
            node.left = helper()
            node.right = helper()
            return node
        return helper()
**å±‚åº**

from collections import deque
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        
        res = []
        queue = deque()
        if root: queue.appendleft(root)
        while queue:
            tmp = queue.pop()
            if tmp:
                res.append(tmp.val)
                queue.appendleft(tmp.left)
                queue.appendleft(tmp.right)
            else:
                res.append("#")
        return ",".join(res)

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        data = iter(data.split(","))
        root = TreeNode(next(data))
        queue = deque([root])
        while queue:
            tmp = queue.pop()
            left_val = next(data)
            if left_val != "#":
                tmp.left = TreeNode(int(left_val))
                queue.appendleft(tmp.left)
            right_val = next(data)
            if right_val != "#":
                tmp.right = TreeNode(int(right_val))
                queue.appendleft(tmp.right)
        return root
```

###  1.221. <a name='DeleteNodeinaBST'></a>450. Delete Node in a BST

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1XW411d7yU?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1YK4y1h7Mw?spm_id_from=333.999.0.0)

```py
# python æç®€é€’å½’

class Solution(object):
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        if not root: return None;
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        else:
            if not root.left or not root.right: # å‡ºå£å°±æ˜¯
                root = root.left if root.left else root.right # å‡ºå£å°±æ˜¯ï¼Œåˆ é™¤root
            else:
                cur = root.right # æ‰¾åˆ°å³å­æ ‘æœ€å°å€¼
                while cur.left: cur = cur.left # æ‰¾åˆ°å³å­æ ‘æœ€å°å€¼
                root.val = cur.val # æ‰¾åˆ°å³å­æ ‘æœ€å°å€¼ çš„å€¼
                root.right = self.deleteNode(root.right, cur.val)  # åˆ é™¤æœ€å°å€¼
            
        return root;

# ä¸è€ƒè™‘å¹³è¡¡çš„è¯å¯ä»¥ç®€å•ç²—æš´ä¸€äº›ã€‚

# å‡å¦‚è¦åˆ é™¤çš„ä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œè½¬ä¸ºé€’å½’å­é—®é¢˜ã€‚

# å‡å¦‚åˆ é™¤çš„æ˜¯æ ¹èŠ‚ç‚¹ä¸”å·¦å­æ ‘ä¸ºç©ºï¼Œè¿”å›å³å­æ ‘å³å¯ã€‚

# å‡å¦‚åˆ é™¤çš„æ˜¯æ ¹èŠ‚ç‚¹ä¸”å·¦å­æ ‘éç©ºï¼Œæ‰¾åˆ°å·¦å­æ ‘ä¸­æœ€å¤§çš„èŠ‚ç‚¹ï¼ˆå…¶å¿…ç„¶æ˜¯æ²¡æœ‰å³å­æ ‘çš„ï¼‰ï¼Œ

# å°†æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ä½œä¸ºå…¶å³å­æ ‘å³å¯ã€‚

def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
    if not root:
        return None
    if root.val > key:
        root.left = self.deleteNode(root.left, key)
    elif root.val < key:
        root.right = self.deleteNode(root.right, key)
    elif not root.left:
        root = root.right
    else:
        p = root.left
        while p.right:
            p = p.right
        p.right = root.right
        root = root.left
    return root
```

```py
# åˆ†äº«ä¸€ä¸ªæœ€é«˜128msï¼Œ20.66%çš„æ²™æ¯”æ–¹æ³•ï¼ŒåŸç†å°±æ˜¯æ‰“å°é™¤äº†keyä»¥å¤–çš„æ’åºæ ‘ï¼Œç„¶åç”Ÿæˆä¸€ä¸ªåªæœ‰å³å­æ ‘çš„æ’åºæ ‘è¾“å‡º

class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        a=[]
        def f(r):
            if not r:return
            f(r.left)
            if r.val!=key:
                a.append(r.val)
            f(r.right)
        f(root)
        n=len(a)
        if not a:
            return 
        r=TreeNode(a[0])
        ans=r
        for i in range(1,n):
            r.right=TreeNode(a[i])
            r=r.right
        return ans
# ä½†è¿™ä¸ªå¤æ‚åº¦ä¸æ»¡è¶³è¦æ±‚å•Šï¼Œè™½ç„¶è¿™ä¸ªæ€è·¯æŒºæœ‰æ„æ€
# è¿™å®é™…å°±æ²¡å®ç°åˆ é™¤èŠ‚ç‚¹è¿™ä¸ªåŠŸèƒ½ï¼Œåªæ˜¯æŠŠç»“æœæ‰¾åˆ°äº†
```

###  1.222. <a name='SortCharactersByFrequency'></a>451 Sort Characters By Frequency

[å°æ˜](https://www.bilibili.com/video/BV18v411z7iy?spm_id_from=333.999.0.0)

###  1.223. <a name='SumII'></a>454 4Sum II

[å°æ˜](https://www.bilibili.com/video/BV1ny4y1D7UL?spm_id_from=333.999.0.0)

###  1.224. <a name='MinimumNumberofArrowstoBurstBalloons'></a>452. ã€è´ªå¿ƒğŸ§¡ã€‘Minimum Number of Arrows to Burst Balloons

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1bW411d77B?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1PZ4y1L7VM?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        
        points.sort(key=lambda balloon: balloon[1])
        pos = points[0][1]
        ans = 1
        for balloon in points:
            if balloon[0] > pos:
                pos = balloon[1]
                ans += 1
        
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

python3ï¼Œå•ªçš„ä¸€ä¸‹å°±è¿‡äº†ï¼Œå¾ˆå¿«å•Š

ä»€ä¹ˆè´ªå¿ƒæˆ‘ä¸æ‡‚ï¼Œæ±‚äº¤é›†å°±å®Œäº‹å„¿äº†

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort()
        i = 1
        while i < len(points):
            (al, ar), (bl, br) = points[i - 1], points[i]
            if bl <= ar:
                points[i - 1] = bl, min(ar, br)
                points.pop(i)
            else:
                i += 1
        return len(points)

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if len(points) == 0: return 0
        points.sort(key=lambda x: x[0])
        result = 1
        for i in range(1, len(points)):
            if points[i][0] > points[i - 1][1]: # æ°”çƒiå’Œæ°”çƒi-1ä¸æŒ¨ç€ï¼Œæ³¨æ„è¿™é‡Œä¸æ˜¯>=
                result += 1     
            else:
                points[i][1] = min(points[i - 1][1], points[i][1]) # æ›´æ–°é‡å æ°”çƒæœ€å°å³è¾¹ç•Œ
        return result

è´ªå¿ƒï¼Œæ¯æ¬¡å°„ç®­å°½é‡æ‰¾æ°”çƒæœ‰é‡å çš„ç‚¹ã€‚æ’åºåï¼Œè®°å½•é‡å åŒºé—´ï¼Œä¸‹ä¸€ä¸ªæ°”çƒæœ‰é‡å å°±è¿›ä¸€æ­¥å–äº¤é›†ï¼Œä¸é‡å å°±ç»“æœ+1

class Solution(object):
    def findMinArrowShots(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        if len(points) == 0: return 0
        points = sorted(points, key=lambda x: x[0])

        start = points[0][0]
        end = points[0][1]
        res = 0

        for point in points:
            if point[0] <= end:
                start = max(point[0], start)
                end = min(point[1], end)
            else:
                res += 1
                start = point[0]
                end = point[1]
        return res + 1
```

```py
è´ªå¿ƒ

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: [x[0], x[1]])
        # print(points)
        if not points: return 0
        interval = [points[0][0], points[0][1]]
        res = 1
        for start, end in points[1:]:
            if start <= interval[1]: # æœ‰äº¤é›†
                interval[0] = start
                interval[1] = min(interval[1], end)
            else:
                res += 1
                interval[0] = start
                interval[1] = end
        return res
```

###  1.225. <a name='AssignCookies'></a>455-Assign Cookies

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV157411s7b9?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1YE411r7UN?spm_id_from=333.999.0.0)

```py
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        n, m = len(g), len(s)
        i = j = count = 0

        while i < n and j < m:
            while j < m and g[i] > s[j]:
                j += 1
            if j < m:
                count += 1
            i += 1
            j += 1
        
        return count

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/assign-cookies/solution/fen-fa-bing-gan-by-leetcode-solution-50se/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        gg, ss, ans = 0, 0, 0
        while gg < len(g) and ss < len(s):
            if s[ss] >= g[gg]:
                ans += 1
                gg += 1
                ss += 1
            else:
                ss += 1
        return ans
```

```py
class Solution:
    # æ€è·¯1ï¼šä¼˜å…ˆè€ƒè™‘èƒƒé¥¼å¹²
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        res = 0
        for i in range(len(s)):
            if res <len(g) and s[i] >= g[res]:  #å°é¥¼å¹²å…ˆå–‚é¥±å°èƒƒå£
                res += 1
        return res
class Solution:
    # æ€è·¯2ï¼šä¼˜å…ˆè€ƒè™‘èƒƒå£
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        start, count = len(s) - 1, 0
        for index in range(len(g) - 1, -1, -1): # å…ˆå–‚é¥±å¤§èƒƒå£
            if start >= 0 and g[index] <= s[start]: 
                start -= 1
                count += 1
        return count
```

###  1.226. <a name='Pattern'></a>456 132 Pattern

[å°æ˜](https://www.bilibili.com/video/BV18f4y1i734?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1SZ4y1x74J?spm_id_from=333.999.0.0)

```py
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False
        
        # å·¦ä¾§æœ€å°å€¼
        left_min = nums[0]
        # å³ä¾§æ‰€æœ‰å…ƒç´ 
        right_all = SortedList(nums[2:])
        
        for j in range(1, n - 1):
            if left_min < nums[j]:
                index = right_all.bisect_right(left_min)
                if index < len(right_all) and right_all[index] < nums[j]:
                    return True
            left_min = min(left_min, nums[j])
            right_all.remove(nums[j + 1])

        return False

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        candidate_k = [nums[n - 1]]
        max_k = float("-inf")

        for i in range(n - 2, -1, -1):
            if nums[i] < max_k:
                return True
            while candidate_k and nums[i] > candidate_k[-1]:
                max_k = candidate_k[-1]
                candidate_k.pop()
            if nums[i] > max_k:
                candidate_k.append(nums[i])

        return False

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        candidate_i, candidate_j = [-nums[0]], [-nums[0]]

        for v in nums[1:]:
            idx_i = bisect.bisect_right(candidate_i, -v)
            idx_j = bisect.bisect_left(candidate_j, -v)
            if idx_i < idx_j:
                return True

            if v < -candidate_i[-1]:
                candidate_i.append(-v)
                candidate_j.append(-v)
            elif v > -candidate_j[-1]:
                last_i = -candidate_i[-1]
                while candidate_j and v > -candidate_j[-1]:
                    candidate_i.pop()
                    candidate_j.pop()
                candidate_i.append(-last_i)
                candidate_j.append(-v)

        return False

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        stack = []                   # top is number "3"
        mmax = float('-inf')         # number "2"
        for n in nums[::-1]:         # look for number "1"
            if n < mmax: return True
            while stack and n > stack[-1]:
                mmax = stack.pop()
            stack.append(n)
        return False

class Solution:
    def find132pattern(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        stack = []
        _MIN = float('-inf')
        
        for i in range(len(nums)-1, -1, -1):
            if nums[i] < _MIN:
                return True
            while stack and nums[i] > stack[-1]:
                _MIN = stack.pop()
            stack.append(nums[i])
            
        return False

æ ˆé‡Œæ˜¯å½“å‰æœ€å¤§çš„æ•°ï¼Œè®¾ä¸ºmaxï¼Œminæ˜¯maxå³è¾¹æœ€å¤§çš„æ•°ã€‚åªéœ€è¦nums[i] < minåˆ™å­˜åœ¨132æ¨¡å¼ã€‚ æˆ‘æƒ³é—®ä¸€ä¸‹ï¼Œèƒ½ä¸èƒ½æ”¹æˆ æ­£å‘éå†å‘¢
ä¸èƒ½ï¼Œ å› ä¸ºè¦ä¿è¯é€’å‡æ ˆpopå‡ºçš„_MINåœ¨åŸæ•°ç»„ä¸­ä¸‹æ ‡è¦æ˜¯æœ€å¤§çš„ï¼Œå…ˆå‹å…¥æ ˆçš„æ•°ä¸‹æ ‡è¦æœ€å¤§ï¼Œè¿™ä¸ª_MINå…¶å®å°±æ˜¯é¢˜ç›®æè¿°ä¸­çš„ak
```

###  1.227. <a name='PoorPigs'></a>458 Poor Pigs

[å°æ˜](https://www.bilibili.com/video/BV1g5411576M?spm_id_from=333.999.0.0)

###  1.228. <a name='RepeatedSubstringPattern'></a>459 Repeated Substring Pattern

[å°æ˜](https://www.bilibili.com/video/BV1Yt4y1S7XZ?spm_id_from=333.999.0.0)

###  1.229. <a name='LFUCacheO1'></a>460. ã€æ„é€ ğŸ°ã€‘LFU Cache / O(1)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gt411Y7PR?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Xb411c7m7?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1kA41147t8?spm_id_from=333.999.0.0)

```py
å®˜æ–¹æ–¹æ³•äºŒåŠ äº†äº›æ³¨é‡Š
pythonä»£ç ä¸­åŒå‘é“¾è¡¨freqMapåœ¨åé¢æ’å…¥tail.preï¼Œåˆ é™¤åœ¨å‰é¢åˆ head.nexï¼Œå’Œé¢˜è§£è¯´æ˜ç›¸å

import collections
class Node:
	def __init__(self, key, val, pre=None, nex=None, freq=0):
		self.pre = pre
		self.nex = nex
		self.freq = freq			#å½“å‰èŠ‚ç‚¹ä½¿ç”¨é¢‘ç‡
		self.val = val
		self.key = key
	
	#æ’å…¥èŠ‚ç‚¹
	# self-> nex-> self.nex
	def insert(self, nex):
		nex.pre = self
		nex.nex = self.nex
		self.nex.pre = nex
		self.nex = nex

# åˆ›å»ºåŒå‘é“¾è¡¨ï¼ŒåŒ…å«å€¼ä¸º0çš„headï¼Œtail
def create_linked_list():
	head = Node(0, 0)
	tail = Node(0, 0)
	head.nex = tail
	tail.pre = head
	return (head, tail)

class LFUCache:
	def __init__(self, capacity: int):
		self.capacity = capacity
		self.size = 0			#é”®å€¼å¯¹æ€»æ•°
		self.minFreq = 0		#è®°å½•æœ€å°çš„é¢‘ç‡ï¼Œæ¯æ¬¡å®¹é‡æ»¡äº†ï¼Œåˆ è¿™ä¸ªé¢‘ç‡çš„head.nex
		self.freqMap = collections.defaultdict(create_linked_list)	#keyæ˜¯é¢‘ç‡ï¼Œå€¼æ˜¯ä¸€æ¡åŒå‘é“¾è¡¨çš„head, tailï¼Œæœ€è¿‘æ“ä½œçš„èŠ‚ç‚¹æ’å…¥tailå‰é¢ï¼Œåˆ™head.nexæ˜¯æœ€å°ä½¿ç”¨é¢‘ç‡çš„èŠ‚ç‚¹ï¼Œåˆ é™¤æ—¶åˆ head.nex
		self.keyMap = {}		#å­˜å‚¨é”®å€¼å¯¹ï¼Œå€¼æ˜¯node ç±»å‹

	#åŒå‘é“¾è¡¨ä¸­åˆ é™¤æŒ‡å®šèŠ‚ç‚¹
	def delete(self, node):
		if node.pre:			#ä¸æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°±éœ€è¦åˆ é™¤ï¼Œ
			node.pre.nex = node.nex	#å‰åå‰æ¥èµ·æ¥
			node.nex.pre = node.pre						
			if node.pre is self.freqMap[node.freq][0] and node.nex is self.freqMap[node.freq][-1]: #æ–°çš„é¢‘ç‡ä¸­å·²å­˜åœ¨è¿™ä¸ªèŠ‚ç‚¹ï¼Œä¸”åªæœ‰è¿™ä¸ªèŠ‚ç‚¹ï¼Œé‚£å°±ç›´æ¥æŠŠè¿™ä¸ªæ–°é¢‘ç‡åˆ æ‰ï¼Œæ–¹ä¾¿åé¢æ’å…¥æœ€æ–°æ•°æ®
				self.freqMap.pop(node.freq)														   
		return node.key												
	
	#å¢åŠ 
	def increase(self, node):
		node.freq += 1			#å½“å‰èŠ‚ç‚¹é¢‘ç‡+1
		self.delete(node)		#æ—§é¢‘ç‡ä¸­ï¼Œåˆ é™¤æ­¤èŠ‚ç‚¹
		self.freqMap[node.freq][-1].pre.insert(node)	#æ–°é¢‘ç‡ä¸­ï¼ŒtailèŠ‚ç‚¹å‰æ’å…¥å½“å‰èŠ‚ç‚¹
		if node.freq == 1:		#å‡ºç°é¢‘ç‡ä¸º1çš„äº†ï¼Œè®°å½•ä¸€ä¸‹ï¼Œä¸‹æ¬¡å®¹é‡æ»¡äº†å…ˆä»è¿™é‡Œåˆ 
			self.minFreq = 1
		elif self.minFreq == node.freq - 1:	#æ“ä½œæœ€å°é¢‘ç‡çš„èŠ‚ç‚¹æ—¶ï¼Œä»æ—§é¢‘ç‡åˆ°æ–°é¢‘ç‡æ—¶éœ€è¦æ£€æŸ¥ä¸‹æ—§é¢‘ç‡ï¼Œåªæœ‰head,tailå°±ä¸å¯èƒ½ä»è¿™é‡Œåˆ æ•°æ®äº†ï¼Œé‚£å°±éœ€è¦æŠŠminFreqæ›´æ–°ä¸ºæ–°é¢‘ç‡ï¼Œä¸‹æ¬¡ä»è¿™é‡Œåˆ 
			head, tail = self.freqMap[node.freq - 1]
			if head.nex is tail:		#è¿™ä¸ªé¢‘ç‡é‡Œæ²¡æœ‰å®é™…èŠ‚ç‚¹ï¼Œåªæœ‰head,tail
				self.minFreq = node.freq#æœ€å°é¢‘ç‡æ›´æ–°ä¸ºèŠ‚ç‚¹å½“å‰é¢‘ç‡

	def get(self, key: int) -> int:
		if key in self.keyMap:
			self.increase(self.keyMap[key])
			return self.keyMap[key].val
		return -1

	def put(self, key: int, value: int) -> None:
		if self.capacity != 0:
			if key in self.keyMap:		#æœ‰ï¼Œæ›´æ–°value
				node = self.keyMap[key]
				node.val = value
			else:
				node = Node(key, value)	#æ²¡æœ‰ï¼Œæ–°å»ºä¸€ä¸ªnode
				self.keyMap[key] = node
				self.size += 1
			if self.size > self.capacity:	#å¤§äºå®¹é‡
				self.size -= 1										
				deleted = self.delete(self.freqMap[self.minFreq][0].nex)#åˆ é™¤head.nex
				self.keyMap.pop(deleted)
			self.increase(node)





class Node:
    def __init__(self, key, val, pre=None, nex=None, freq=0):
        self.pre = pre
        self.nex = nex
        self.freq = freq
        self.val = val
        self.key = key
        
    def insert(self, nex):
        nex.pre = self
        nex.nex = self.nex
        self.nex.pre = nex
        self.nex = nex
    
def create_linked_list():
    head = Node(0, 0)
    tail = Node(0, 0)
    head.nex = tail
    tail.pre = head
    return (head, tail)

class LFUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.size = 0
        self.minFreq = 0
        self.freqMap = collections.defaultdict(create_linked_list)
        self.keyMap = {}

    def delete(self, node):
        if node.pre:
            node.pre.nex = node.nex
            node.nex.pre = node.pre
            if node.pre is self.freqMap[node.freq][0] and node.nex is self.freqMap[node.freq][-1]:
                self.freqMap.pop(node.freq)
        return node.key
        
    def increase(self, node):
        node.freq += 1
        self.delete(node)
        self.freqMap[node.freq][-1].pre.insert(node)
        if node.freq == 1:
            self.minFreq = 1
        elif self.minFreq == node.freq - 1:
            head, tail = self.freqMap[node.freq - 1]
            if head.nex is tail:
                self.minFreq = node.freq

    def get(self, key: int) -> int:
        if key in self.keyMap:
            self.increase(self.keyMap[key])
            return self.keyMap[key].val
        return -1

    def put(self, key: int, value: int) -> None:
        if self.capacity != 0:
            if key in self.keyMap:
                node = self.keyMap[key]
                node.val = value
            else:
                node = Node(key, value)
                self.keyMap[key] = node
                self.size += 1
            if self.size > self.capacity:
                self.size -= 1
                deleted = self.delete(self.freqMap[self.minFreq][0].nex)
                self.keyMap.pop(deleted)
            self.increase(node)

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/lfu-cache/solution/lfuhuan-cun-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

ä¹Ÿæ˜¯ç”¨åŒå‘é“¾è¡¨åšçš„ï¼Œæ”¹äº†å¥½å‡ å¤„ç©ºæŒ‡é’ˆå¼‚å¸¸çš„åœ°æ–¹ã€‚è¿™ä¸ªé›¶å¯æ¶å¿ƒåˆ°æˆ‘äº†
```

```py

```

###  1.230. <a name='HammingDistance'></a>461 ã€ä½è¿ç®—ğŸ˜œã€‘Hamming Distance

[å°æ˜](https://www.bilibili.com/video/BV1M5411Y79g?spm_id_from=333.999.0.0)

```py
ç”¨(x&d) ^ (y&d)æ¥åˆ¤æ–­ä¸¤ä¸ªæ•°äºŒè¿›åˆ¶çš„æŸä¸€ä½æ˜¯å¦ä¸åŒ


class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        cnt, d = 0, 1
        for i in range(32):
            if (x&d) ^ (y&d) != 0:
                cnt += 1
            d <<= 1
        return cnt

ä½œè€…ï¼šbluegreenred
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/hamming-distance/solution/461-yi-ming-ju-chi-python-wei-yun-suan-b-ru8t/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

æ€è·¯å’Œå¿ƒå¾—ï¼š

1.åŸºæœ¬çš„ä½è¿ç®—ğŸ˜œï¼Œæ³¨æ„æ•°æ®èŒƒå›´

2.å¼‚æˆ–å¸¸è€ƒ

python3

class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        res = 0
        z = x ^ y
        for i in range(30, -1, -1):
            if (z >> i) & 1: 
                res += 1
        return res


ä½è¿ç®—ğŸ˜œ


class Solution:
    def hammingDistance(self, x, y):
        # å–å¼‚æˆ–å€¼å¾—åˆ°æ˜æ±‰å€¼ 0 ç›¸åŒ 1 ä¸åŒ 1çš„ä¸ªæ•°å°±æ˜¯æ˜æ±‰è·ç¦»
        s = x ^ y
        ret = 0
        while s:
            # ä¾æ¬¡ä½ç§»æ˜æ±‰å€¼ å’Œ1å–ä¸ï¼Œ1ä¸1çš„1 å°±ç´¯åŠ 
            ret += s & 1
            s >>= 1
        return ret

å†…ç½®å‡½æ•°

filter çš„ å‡½æ•° è¿”å›å¸ƒå°”å€¼


class Solution:
    def hammingDistance(self, x, y):
        return len(list(filter(lambda x: x == '1', bin(x ^ y))))


å…ˆæ±‚å¼‚æˆ–ï¼Œå†é€å…¥funcé€’å½’è®¡ç®—1çš„ä¸ªæ•°(LC191)

class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        def func(n):
            return 0 if n <= 0 else 1 + func(n & (n-1))
        return func(x ^ y)
        

class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        s = x ^ y
        res = 0
        while s:
            res += 1
            s ^= s & (-s)
            # æ‰¾åˆ°å¹¶æ¶ˆæ‰æœ€åçš„é‚£ä¸ª1
        return res


class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        num = x ^ y
        count = 0
        while num:
            if num & 1 == 1:
                count += 1
            num = num >> 1
        return count



class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        res = 0
        z = x ^ y
        while z:
            res += 1
            z = z & (z-1)
        return res

```

###  1.231. <a name='IslandPerimeter'></a>463 Island Perimeter

[å°æ˜](https://www.bilibili.com/video/BV16V41167bF?spm_id_from=333.999.0.0)

###  1.232. <a name='CanIWin'></a>464. Can I Win

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1KW411o7m2?spm_id_from=333.999.0.0)

###  1.233. <a name='CountTheRepetitions'></a>466. ç»Ÿè®¡é‡å¤ä¸ªæ•° Count The Repetitions

[å®˜æ–¹](https://www.bilibili.com/video/BV1Qk4y1678m?spm_id_from=333.999.0.0)

###  1.234. <a name='ValidateIPAddress'></a>468 Validate IP Address

[å°æ˜](https://www.bilibili.com/video/BV1tg4y1q7Kq?spm_id_from=333.999.0.0)

###  1.235. <a name='ImplementRand10UsingRand7'></a>470. Implement Rand10() Using Rand7()

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Ut411Z7KX?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1AD4y1m7Qb?spm_id_from=333.999.0.0)

```py
class Solution:
    def rand10(self) -> int:
        while True:
            row = rand7()
            col = rand7()
            idx = (row - 1) * 7 + col
            if idx <= 40:
                return 1 + (idx - 1) % 10

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def rand10(self) -> int:
        while True:
            a = rand7()
            b = rand7()
            idx = (a - 1) * 7 + b
            if idx <= 40:
                return 1 + (idx - 1) % 10
            a = idx - 40
            b = rand7()
            # get uniform dist from 1 - 63
            idx = (a - 1) * 7 + b
            if idx <= 60:
                return 1 + (idx - 1) % 10
            a = idx - 60
            b = rand7()
            # get uniform dist from 1 - 21
            idx = (a - 1) * 7 + b
            if idx <= 20:
                return 1 + (idx - 1) % 10

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

æœ€è¿‘åˆšåœ¨ç®—æ³•ä¹¦çœ‹åˆ°è¿™é“é¢˜ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚

class Solution:
    def rand10(self):
        while True:
            res = (rand7()-1)*7 + rand7()#æ„é€ 1~49çš„å‡åŒ€åˆ†å¸ƒ
            if res <= 40:#å‰”é™¤å¤§äº40çš„å€¼ï¼Œ1-40ç­‰æ¦‚ç‡å‡ºç°ã€‚
                break
        return res%10+1#æ„é€ 1-10çš„å‡åŒ€åˆ†å¸ƒ

ä¸ºä»€ä¹ˆres = (rand7()-1)*7 + rand7() ä¸å†™æˆres = (and7()* rand7(), æœ‰ä»€ä¹ˆåŒºåˆ«å—
ä½ æƒ³æƒ³6*7ç›¸ä¹˜ï¼Œæˆ–è€…7*7ç›¸ä¹˜ï¼Œèƒ½ç”Ÿæˆ48å—ï¼Œä½ è¯´çš„è¿™æ ·åªèƒ½ç”Ÿæˆä¹˜æ³•è¡¨é‚£å‡ ä¸ªè€Œä¸æ˜¯1-49å‡åŒ€çš„é‚£å‡ ä¸ª
```

```py
class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        start=None
        while start==None:
            cur=rand7()
            if 1<=cur<=3:
                start=0
            if 4<=cur<=6:
                start=5
        while True:
            cur=rand7()
            if cur>5:
                continue
            else:
                return start+cur


æ„Ÿè§‰å®˜æ–¹é¢˜è§£ä»¥åŠå…¶ä»–æ–¹æ³•æ¯”è¾ƒéš¾ä»¥ç†è§£ï¼Œçœ‹äº†å…¶ä»–äººçš„æ€è·¯åæœ‰æ‰€æ„Ÿæ‚Ÿã€‚

æˆ‘ä»¬å¯ä»¥å…ˆåˆ›é€ ä¸€ä¸ª1-5çš„å‡åŒ€åˆ†å¸ƒï¼Œå¾—åˆ°ä¸€ä¸ªç¬¦åˆçš„ç»“æœxã€‚

å…¶æ¬¡æˆ‘ä»¬å¯ä»¥é€šè¿‡æŸç§æ–¹æ³•å°†è¿™ä¸ª1-5çš„å‡åŒ€åˆ†å¸ƒå˜ä¸º1-10çš„å‡åŒ€åˆ†å¸ƒã€‚

æ–¹æ³•å¦‚ä¸‹æ‰€ç¤ºï¼šæˆ‘ä»¬å¯ä»¥åœ¨ç”Ÿæˆä¸€ä¸ªæ•°yï¼Œå› ä¸ºyæ˜¯1-7çš„æ•°å­—ï¼Œ

æˆ‘ä»¬å¯ä»¥æ’é™¤æ•°å­—4ï¼Œyä¸º7ç»§ç»­ç”Ÿæˆä¸€ä¸ªæ•°å­—ï¼Œå˜ä¸º1-3ä»¥åŠ5-7ä¸¤ä¸ªéƒ¨åˆ†ï¼Œ

è¿™æ ·è¿™ä¸¤ä¸ªéƒ¨åˆ†åªæœ‰3ä¸ªæ•°å­—ï¼Œå› ä¸ºæ˜¯ç­‰æ¦‚ç‡çš„ï¼Œ

å¦‚æœåœ¨å‰éƒ¨åˆ†ï¼Œ y = 0ï¼Œå¦‚æœä¸ºåéƒ¨åˆ†y=5ï¼Œå› æ­¤å¯ä»¥åˆ›é€ å‡º1-10çš„ç­‰æ¦‚ç‡åˆ†å¸ƒã€‚

class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        x = rand7()
        while x>5:
            x = rand7()
        y = rand7()
        while y == 4:
            y = rand7()
        if y < 4:
            y = 0
        else:
            y = 5
        return x+y
             
```

###  1.236. <a name='Heaters'></a>475. Heaters

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1vJ41117VH?spm_id_from=333.999.0.0)

###  1.237. <a name='NumberComplement'></a>476. ã€ä½è¿ç®—ğŸ˜œã€‘Number Complement

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1PW411y7mv?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.pvl104ml1dc.webp)

æ—¶é—´å¤æ‚åº¦ï¼šO(log num)ã€‚æ‰¾å‡º num äºŒè¿›åˆ¶è¡¨ç¤ºæœ€é«˜ä½çš„ 11 éœ€è¦çš„æ—¶é—´ä¸º O(log num)ã€‚

ç©ºé—´å¤æ‚åº¦ï¼šO(1) ã€‚


```py
class Solution:
    def findComplement(self, num: int) -> int:
        highbit = 0
        for i in range(1, 30 + 1):
            if num >= (1 << i):
                highbit = i
            else:
                break
        
        mask = (1 << (highbit + 1)) - 1
        return num ^ mask

```

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7057rnkw8r40.webp)

```py
A = 1111
B = 1100
C = 0011

C = A ^ B
C = A - B

class Solution:
    def findComplement(self, num):
        val = len(bin(num)) - 2
        return num ^ ((1 << val) - 1)


ç”±é¢˜å¯å¾—ï¼Œnumä¸è¡¥æ•°çš„å’Œï¼Œè½¬æ¢ä¸ºäºŒè¿›åˆ¶ï¼Œæ°å¥½ä¸ºä¸numç›¸åŒäºŒè¿›åˆ¶ä½æ•°çš„æ‰€æœ‰ä½å€¼ä¸º1çš„äºŒè¿›åˆ¶æ•°ï¼š
num + numçš„æ­¥æ•° == ä¸numäºŒè¿›åˆ¶ç›¸åŒä½æ•°çš„å„ä½ä¸º1çš„äºŒè¿›åˆ¶æ•°

class Solution:
    def findComplement(self, num: int) -> int:
        val = len(bin(num)) - 2
        return (pow(2, val) - 1) - num

```

###  1.238. <a name='TotalHammingDistance'></a>477. ã€ä½è¿ç®—ğŸ˜œã€‘Total Hamming Distance

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1SW411r78m?spm_id_from=333.999.0.0)

```py
# ç¬¬ä¸€æƒ³æ³•å°±æ˜¯æš´åŠ›ï¼Œç›´æ¥è¶…æ—¶
class Solution(object): # æ­¤æ³•è¶…æ—¶
    def totalHammingDistance(self, nums):
        res = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                res += bin(nums[i] ^ nums[j]).count('1')
        return res

class Solution(object): # æ­¤æ³•è¶…æ—¶
    def totalHammingDistance(self, nums):
        return sum(b.count('0') * b.count('1') for b in zip(*map('{:032b}'.format, nums)))
```

```py
è¿™ä¸ªæ–¹æ³•å¦™å•Šï¼
class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        s_nums = [bin(s)[2:].rjust(32, "0") for s in nums]
        res = 0
        for item in zip(*s_nums): # å­—ç¬¦ä¸²zipçš„æ—¶å€™è¦åŠ æ˜Ÿå·
            res += item.count("1") * item.count("0")
        return res

class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        c0, c1, sm=0,0,0
        for i in range(31):
            c0 = c1 = 0
            for n in nums:
                if (n >> i) & 1:
                    c1 += 1 # count("1")
                else:
                    c0 += 1 # count("0")
            sm += c0 * c1
        return sm
```

###  1.239. <a name='GenerateRandomPointinaCircle'></a>478 Generate Random Point in a Circle

[å°æ˜](https://www.bilibili.com/video/BV1Nz4y127a1?spm_id_from=333.999.0.0)

###  1.240. <a name='SlidingWindowMedian'></a>480. â˜…ã€æ»‘åŠ¨çª—å£ğŸ”¹ä¸­ä½æ•°æš´åŠ›ã€‘Sliding Window Median

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV15W411C7iy?spm_id_from=333.999.0.0)


```py
import bisect

class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        median = lambda a: (a[(len(a)-1)//2] + a[len(a)//2]) / 2
        a = sorted(nums[:k])
        res = [median(a)]
        for i, j in zip(nums[:-k], nums[k:]):
            a.remove(i)
            bisect.insort_left(a, j)
            res.append(median(a))
        return res
```


```py
import bisect

class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        median = lambda a: (a[(len(a)-1)//2] + a[len(a)//2]) / 2
        a = sorted(nums[:k])
        res = [median(a)]
        for i, j in zip(nums[:-k], nums[k:]):
            a.pop(bisect.bisect_left(a, i))
            bisect.insort_left(a, j)
            res.append(median(a))
        return res

```



ç›´æ¥æš´åŠ›æ±‚è§£

```py
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        res = []
        mididx, n = k//2, len(nums)
        for i in range(n-k+1):
            tmp = sorted(nums[i:i+k])
            mid = tmp[mididx] if k % 2 == 1 else 1.0*(tmp[mididx-1] + tmp[mididx])/2
            res.append(mid)
        return res

```

```py
import numpy as np
import scipy

class Solution(object):
    def medianSlidingWindow(self, nums, k):
        return [np.median(nums[i:i+k]) for i in range(len(nums)-k+1)]
```

###  1.241. <a name='FindPermutation'></a>484 Find Permutation

[å°æ˜](https://www.bilibili.com/video/BV1NT4y1L76i?spm_id_from=333.999.0.0)

###  1.242. <a name='MaxConsecutiveOnes'></a>485. Max Consecutive Ones

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1zJ411R7SJ?spm_id_from=333.999.0.0)

###  1.243. <a name='PredicttheWinner'></a>486. Predict the Winner

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1kW411d7R2?spm_id_from=333.999.0.0)

###  1.244. <a name='TheMaze'></a>490 The Maze

[å°æ˜](https://www.bilibili.com/video/BV1az4y1f7Hn?spm_id_from=333.999.0.0)

###  1.245. <a name='dfsstartIforTargetSum'></a>494. ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + dfs(startI)æ— forå¾ªç¯ã€‘Target Sum

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1WW411C7Mp?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…± ä¸‹](https://www.bilibili.com/video/BV1WW411C7Mr?spm_id_from=333.999.0.0)

0-1èƒŒåŒ…ï¼ˆäºŒç»´åŠ¨æ€è§„åˆ’ï¼‰

```py
class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        # æ±‚å¾—æ–°çš„ç›®æ ‡
        sums = sum(nums)
        # æ³¨æ„ï¼Œéœ€è¦æ’é™¤æ‰ä¸€äº›ç‰¹æ®ŠçŠ¶å†µ
        bagSize = sums + target
        # ä¹Ÿå¯ä»¥å†™æˆï¼šbagSize = sums - target

        if bagSize % 2 == 1 or bagSize < 0:
            return 0
        bagSize = bagSize // 2
        # æ„å»ºdpï¼ŒnumLenåœ¨å¤–å›´
        dp = [[0] * (bagSize+1) for _ in range(n+1)]
        # èµ‹å€¼ï¼Œdpçš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        dp[0][0] = 1
        for i in range(1,n+1):
            num = nums[i-1] # æ˜“é”™ç‚¹: num = nums[i-1]å•ç‹¬æå‡ºæ¥å†™ï¼Œä¸å®¹æ˜“å‡ºé”™
            for j in range(bagSize+1):
                if j-num >= 0: # æ˜“é”™ç‚¹: è¿™é‡Œå¿…éœ€è¦æ˜¯>=
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-num]
                else:
                    dp[i][j] = dp[i-1][j]
#    [[1, 0, 0, 0, 0], 
#     [1, 1, 0, 0, 0], 
#     [1, 2, 1, 0, 0], 
#     [1, 3, 3, 1, 0], 
#     [1, 4, 6, 4, 1], 
#     [1, 5, 10, 10, 5]]
        return dp[-1][-1]
```

0-1èƒŒåŒ…ï¼ˆä¸€ç»´åŠ¨æ€è§„åˆ’ï¼‰

```py
class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        # æ±‚å¾—æ–°çš„ç›®æ ‡
        sums = sum(nums)
        # æ³¨æ„ï¼Œéœ€è¦æ’é™¤æ‰ä¸€äº›ç‰¹æ®ŠçŠ¶å†µ
        bagSize = sums + target
        # ä¹Ÿå¯ä»¥å†™æˆï¼šbagSize = sums - target
        if bagSize % 2 == 1 or bagSize < 0:
            return 0
        bagSize = bagSize // 2
        # æ„å»ºdpï¼ŒnumLenåœ¨å¤–å›´
        dp = [0] * (bagSize+1)
        # èµ‹å€¼ï¼Œdpçš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        dp[0] = 1
        for num in nums:
            for j in range(bagSize,num-1,-1):
                dp[j] += dp[j-num] # å¯¹äºæ²¡æœ‰å½“å‰numæ—¶çš„case + æœ‰äº†numæ—¶bagSize-numçš„cas
        # å«ä¹‰å°±æ˜¯ï¼š
        # å¯¹äº1ä¸ªnumï¼Œbagsizeçš„å¡«æ»¡æƒ…å†µ
        # å¯¹å¼ˆ2ä¸ªnumï¼Œbagsizeçš„å¡«æ»¡æƒ…å†µ
        return dp[-1]

æ•°å­—ï¼š 1 dp: [1, 0, 0, 0, 0]
æ•°å­—ï¼š 1 dp: [1, 0, 0, 0, 0]
æ•°å­—ï¼š 1 dp: [1, 0, 0, 0, 0]
æ•°å­—ï¼š 1 dp: [1, 1, 0, 0, 0]
--------------------
æ•°å­—ï¼š 1 dp: [1, 1, 0, 0, 0]
æ•°å­—ï¼š 1 dp: [1, 1, 0, 0, 0]
æ•°å­—ï¼š 1 dp: [1, 1, 1, 0, 0]
æ•°å­—ï¼š 1 dp: [1, 2, 1, 0, 0]
--------------------
æ•°å­—ï¼š 1 dp: [1, 2, 1, 0, 0]
æ•°å­—ï¼š 1 dp: [1, 2, 1, 1, 0]
æ•°å­—ï¼š 1 dp: [1, 2, 3, 1, 0]
æ•°å­—ï¼š 1 dp: [1, 3, 3, 1, 0]
--------------------
æ•°å­—ï¼š 1 dp: [1, 3, 3, 1, 1]
æ•°å­—ï¼š 1 dp: [1, 3, 3, 4, 1]
æ•°å­—ï¼š 1 dp: [1, 3, 6, 4, 1]
æ•°å­—ï¼š 1 dp: [1, 4, 6, 4, 1]
--------------------
æ•°å­—ï¼š 1 dp: [1, 4, 6, 4, 5]
æ•°å­—ï¼š 1 dp: [1, 4, 6, 10, 5]
æ•°å­—ï¼š 1 dp: [1, 4, 10, 10, 5]
æ•°å­—ï¼š 1 dp: [1, 5, 10, 10, 5]
--------------------

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        sums = sum(nums)
        bagSize = sums + target
        if bagSize % 2 == 1 or bagSize < 0:
            return 0
        bagSize = bagSize // 2

        @cache
        def dfs(startI,total):
            # å¦‚æœè¦å†™é€’å½’ï¼Œé‚£ä¹ˆè¿™ä¸ªé€’å½’çš„ç»“æŸæ¡ä»¶ä¸€å®šè¦èƒŒå‡ºæ¥
            if startI == len(nums):
                return 1 if total == 0 else 0
            # å¦‚æœè¦å†™é€’å½’ï¼Œé‚£ä¹ˆè¿™ä¸ªé€’å½’çš„ç»“æŸæ¡ä»¶ä¸€å®šè¦èƒŒå‡ºæ¥
            return dfs(startI+1,total-nums[startI]) + dfs(startI+1,total)

        return dfs(0,bagSize)

```

```py
# æ€è·¯

# æ¯ä¸ªæ•°ï¼Œåªæœ‰å–æ­£ã€å–è´Ÿæ•°ï¼Œè¿™ä¸¤ç§å¤„ç†ã€‚å› æ­¤å¯ä»¥åšæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸ºäº†é¿å…é‡å¤è®¡ç®—ï¼ŒåŠ ä¸Šè®°å¿†æ³•ã€‚

# DFS åˆ° nums[i] æ—¶ï¼Œå–æ­£æ•°ï¼Œåˆ™è¦æ±‚åé¢çš„æ•°ï¼Œå¤„ç†åçš„ next_target = current_target - nums[i];
# å–è´Ÿæ•°çš„å¤„ç†åŒä¸Šï¼Œåç»­è¦å¤„ç†çš„ next_target = current_target + nums[i]ï¼›
# ç”¨ python è¯­æ³•ç³–ç®€å•æ¼”ç¤ºä¸‹ï¼š

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        # @lru_cache(None)
        def dfs(startIdx, sum) -> int:
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return dfs(startIdx + 1, sum - nums[startIdx]) + dfs(startIdx + 1, sum + nums[startIdx])

        return dfs(0, target)

# @lru_cache(None) å¥½ç¥å¥‡ï¼Œç¬é—´æé«˜æ•ˆç‡
# å¦‚æœä¸ç”¨@lru_cache(None)ï¼Œç”¨è¿™ç§æ–¹å¼ä¼šè¶…æ—¶ï¼ŒJavaçš„å°±ä¸ä¼šå•Š
# åŒæ ·çš„è§£æ³•ï¼ŒJava ä¸è¶…æ—¶æ˜¯å› ä¸º Java è¿è¡Œé€Ÿåº¦æ¯” Python å¿«å¾—å¤šã€‚
# è€Œ Python å¦‚æœä¸ç”¨ lru_cache æˆ–è€…æ˜¾å¼çš„è®°å¿†æ•°ç»„å­˜å‚¨ dfs çš„ç»“æœï¼Œ
# å¤§é‡é‡å¤è®¡ç®—ä¼šå¯¼è‡´è¶…æ—¶ï¼Œå› ä¸º Python è¿è¡Œé€Ÿåº¦æ…¢

# DFS

class Solution:
    def findTargetSumWays(self, nums: List[int], V) -> int:
        def dfs(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum==0 else 0
            res = 0
            res += dfs(sum-nums[startIdx], startIdx+1)
            res += dfs(sum+nums[startIdx], startIdx+1)
            return res
        return dfs(V, 0)


# é€’å½’ï¼ŒfindSum(s, start_idx) å‡½æ•°çš„æ„æ€æ˜¯ä»start_indexå¼€å§‹å‘åçš„å­é›†åˆèƒ½æœ‰å‡ ç§å¾—åˆ°sçš„æ–¹æ³•

class Solution(object):
    def findTargetSumWays(self, nums, S):
        def findSum(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return findSum(sum+nums[startIdx], startIdx+1) + findSum(sum-nums[startIdx], startIdx+1)
        return findSum(S, 0)
# ä½†æ˜¯è¿™æ ·ä¼šè¶…æ—¶ï¼Œæ‰€ä»¥ç”¨cache è®°ä¸€ä¸‹

class Solution(object):
    def findTargetSumWays(self, nums, S):
        def findSum(s, start_idx):
            if start_idx == len(nums):
                return 1 if s == 0 else 0
            if (s, start_idx) not in cache:
                cache[(s, start_idx)] = findSum(s+nums[start_idx], start_idx+1) + findSum(s-nums[start_idx], start_idx+1)
            return cache[(s, start_idx)]
            
        cache = {}
        return findSum(S, 0)
```



###  1.246. <a name='TeemoAttacking'></a>495 Teemo Attacking

[å°æ˜](https://www.bilibili.com/video/BV1LK4y1Y75e?spm_id_from=333.999.0.0)

###  1.247. <a name='INextGreaterElementI'></a>496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I (Next Greater Element I)

[æ´›é˜³](https://www.bilibili.com/video/BV1Ce411W7pW?spm_id_from=333.999.0.0)

###  1.248. <a name='RandomPointinNon-overlapping'></a>497 Random Point in Non-overlapping

[å°æ˜](https://www.bilibili.com/video/BV12K4y1Y7r6?spm_id_from=333.999.0.0)

