<!-- vscode-markdown-toc -->
* 1. [ç»éªŒ](#)
* 2. [ç®—æ³•](#-1)
* 3. [é¢˜ç›®](#-1)
	* 3.1. [1 Two Sum](#TwoSum)
	* 3.2. [2. Add Two Numbers](#AddTwoNumbers)
	* 3.3. [3. ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘æ•°ç»„ä¸­é‡å¤çš„æ•°å­— Longest Substring Without Repeating Characters](#LongestSubstringWithoutRepeatingCharacters)
	* 3.4. [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•° Median of Two Sorted Arrays](#MedianofTwoSortedArrays)
	* 3.5. [5. ã€å›æ–‡ğŸŒˆã€‘Longest Palindromic Substring -æœ€é•¿å›æ–‡ğŸŒˆå­ä¸²](#LongestPalindromicSubstring-)
	* 3.6. [6. ZigZag Conversion](#ZigZagConversion)
	* 3.7. [7 Reverse Integer](#ReverseInteger)
	* 3.8. [8. String to Integer(atoi)](#StringtoIntegeratoi)
	* 3.9. [9-ã€å›æ–‡ğŸŒˆã€‘Palindrome](#Palindrome)
	* 3.10. [11. Container With Most Water](#ContainerWithMostWater)
	* 3.11. [12. Integer to Roman](#IntegertoRoman)
	* 3.12. [13. æœºå™¨äººçš„è¿åŠ¨èŒƒå›´](#-1)
	* 3.13. [13. Roman to Integer](#RomantoInteger)
	* 3.14. [14-Longest common prefix](#Longestcommonprefix)
	* 3.15. [15. 3Sum](#Sum)
	* 3.16. [16. 3Sum Closest](#SumClosest)
	* 3.17. [17. Letter Combinations of a Phone Number](#LetterCombinationsofaPhoneNumber)
	* 3.18. [19-Remove Nth Node From End of List](#RemoveNthNodeFromEndofList)
	* 3.19. [20-Valid parentheses](#Validparentheses)
	* 3.20. [21-Merge two sorted lists](#Mergetwosortedlists)
	* 3.21. [22. Generate Parentheses](#GenerateParentheses)
	* 3.22. [23. ã€æœ€å°å †ğŸŒµã€‘Merge k Sorted Lists](#MergekSortedLists)
	* 3.23. [24-Swap Nodes in Pairs](#SwapNodesinPairs)
	* 3.24. [26-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray)
	* 3.25. [27-python-Remove element](#python-Removeelement)
	* 3.26. [28-Implement str](#Implementstr)
	* 3.27. [31 Next Permutation](#NextPermutation)
	* 3.28. [32 Longest Valid Parentheses](#LongestValidParentheses)
	* 3.29. [33. Search in Rotated Sorted Array](#SearchinRotatedSortedArray)
	* 3.30. [34-åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ª](#-1)
	* 3.31. [35-æœç´¢æ’å…¥ä½ç½®](#-1)
	* 3.32. [36-æœ‰æ•ˆçš„æ•°ç‹¬](#-1)
	* 3.33. [37. Sudoku Solver è§£æ•°ç‹¬](#SudokuSolver)
	* 3.34. [38-Count and say](#Countandsay)
	* 3.35. [39. Combination Sum 39-ç»„åˆæ€»å’Œ](#CombinationSum39-)
	* 3.36. [40. Combination Sum II 40-ç»„åˆæ€»å’Œ II](#CombinationSumII40-II)
	* 3.37. [41 First Missing Positive](#FirstMissingPositive)
	* 3.38. [42. Trapping Rain Water](#TrappingRainWater)
	* 3.39. [45 Jump Game II](#JumpGameII)
	* 3.40. [46-æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²](#-1)
	* 3.41. [46-å…¨æ’åˆ—](#-1)
	* 3.42. [47-å…¨æ’åˆ— II-å‰ªæç‰ˆ](#II-)
	* 3.43. [48. æ—‹è½¬å›¾åƒ Rotate Image](#RotateImage)
	* 3.44. [49 Group Anagrams](#GroupAnagrams)
	* 3.45. [50 Pow(x, n)](#Powxn)
	* 3.46. [51. æ•°ç»„ä¸­çš„é€†åºå¯¹](#-1)
	* 3.47. [53-ã€è´ªå¿ƒğŸ§¡ã€‘Maximum subarray](#Maximumsubarray)
	* 3.48. [54. Spiral Matrix](#SpiralMatrix)
	* 3.49. [55 Jump Game](#JumpGame)
	* 3.50. [56-I. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•°](#I.)
	* 3.51. [56. Merge Intervals](#MergeIntervals)
	* 3.52. [57. Insert Interval](#InsertInterval)
	* 3.53. [58. Lengh of Last Words](#LenghofLastWords)
	* 3.54. [59 - II. é˜Ÿåˆ—çš„æœ€å¤§å€¼ LCOF](#II.LCOF)
	* 3.55. [59. Spiral Matrix II](#SpiralMatrixII)
	* 3.56. [61. Rotate List](#RotateList)
	* 3.57. [62-ä¸åŒè·¯å¾„](#-1)
	* 3.58. [63 Unique Paths II](#UniquePathsII)
	* 3.59. [64. Minimum Path Sum 64-æœ€å°è·¯å¾„å’Œ](#MinimumPathSum64-)
	* 3.60. [65 Valid Number](#ValidNumber)
	* 3.61. [66 Plus one](#Plusone)
	* 3.62. [67-Add Binary](#AddBinary)
	* 3.63. [69 Sqrt(x)](#Sqrtx)
	* 3.64. [70. Climbing Stairs](#ClimbingStairs)
	* 3.65. [71. Simplify Path](#SimplifyPath)
	* 3.66. [72. Edit Distance 72-ç¼–è¾‘è·ç¦»](#EditDistance72-)
	* 3.67. [73. Set Matrix Zeroes](#SetMatrixZeroes)
	* 3.68. [74 Search a 2D Matrix](#Searcha2DMatrix)
	* 3.69. [75. Sort Colors](#SortColors)
	* 3.70. [76-ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘æœ€å°è¦†ç›–å­ä¸²](#-1)
	* 3.71. [77. ç»„åˆ](#-1)
	* 3.72. [78. ã€ä½è¿ç®—ğŸ˜œã€‘Subsets å­é›†](#Subsets)
	* 3.73. [79. Word Search](#WordSearch)
	* 3.74. [80 Remove Duplicates from Sorted Array II](#RemoveDuplicatesfromSortedArrayII)
	* 3.75. [82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II(Remove Duplicates from Sorted List](#IIRemoveDuplicatesfromSortedList)
	* 3.76. [83-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray-1)
	* 3.77. [84. æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢ Largest Rectangle in Histogram](#LargestRectangleinHistogram)
	* 3.78. [86. åˆ†éš”é“¾è¡¨(Partition List)](#PartitionList)
	* 3.79. [87. Scramble String](#ScrambleString)
	* 3.80. [88-Merge sorted array](#Mergesortedarray)
	* 3.81. [ 89. æ ¼é›·ç¼–ç ](#89.)
	* 3.82. [90-å­é›† II](#II)
	* 3.83. [91. Decode Ways](#DecodeWays)
	* 3.84. [92-Reverse Linked List II](#ReverseLinkedListII)
	* 3.85. [ 93. å¤åŸ IP åœ°å€](#93.IP)
	* 3.86. [94-Inorder wih stack](#Inorderwihstack)
	* 3.87. [94-Binary Tree Inorder Traversal](#BinaryTreeInorderTraversal)
	* 3.88. [95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II](#II-1)
	* 3.89. [96. Unique Binary Search Trees](#UniqueBinarySearchTrees)
	* 3.90. [98. Validate Binary Search Tree 98-éªŒè¯äºŒå‰æœç´¢æ ‘](#ValidateBinarySearchTree98-)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
##  1. <a name=''></a>ç»éªŒ

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14E411R7Wa?spm_id_from=333.999.0.0)

[Leetcodeåˆ·é¢˜é˜¶æ®µæ€§æ€»ç»“ï¼ˆä¸€äº›å»ºè®®ä¸æ€è€ƒï¼‰å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV14K4y1a7Yk?spm_id_from=333.999.0.0)

[LeetCodeé¢˜åº“è¿‡åƒï¼Œåˆ·é¢˜æ”¹å¦‚ä½•è§„åˆ’ï¼Ÿã€åˆ·é¢˜è§„åˆ’ç³»åˆ—ã€‘](https://www.bilibili.com/video/BV1Xp4y1a7Z3?spm_id_from=333.999.0.0)

[å¦‚ä½•æ­£ç¡®åˆ·é¢˜ï¼ŸLeetCodeåˆ·é¢˜è¯¯åŒºå’Œåˆ·é¢˜æ–¹æ³•è®ºåˆ†äº«](https://www.bilibili.com/video/BV1nz4y197U3?spm_id_from=333.999.0.0)

[ç®—æ³•æ–°æ‰‹å¦‚ä½•åˆ·åŠ›æ‰£ï¼ˆLeetCodeï¼‰ï¼Ÿã€å¹²è´§åˆ†äº«ã€‘](https://www.bilibili.com/video/BV17K411J7yR?spm_id_from=333.999.0.0)

[ç¡…è°·èµ„æ·±æŠ€æœ¯é¢è¯•å®˜æ•™ä½ æ‹¿é¡¶çº§ç§‘æŠ€å…¬å¸ Offerã€é¢è¯•ç¯‡ã€‘](https://www.bilibili.com/video/BV1fV411y743?spm_id_from=333.999.0.0)

[ACM é‡‘ç‰Œå¤§ç¥æ˜¯å¦‚ä½•å­¦ç®—æ³•çš„ï¼Ÿã€LeetCode å¹²è´§ã€‘](https://www.bilibili.com/video/BV1gv411179E?spm_id_from=333.999.0.0)

[ç¡…è°·èµ„æ·±æŠ€æœ¯é¢è¯•å®˜æ•™ä½ æ‹¿é¡¶çº§ç§‘æŠ€å…¬å¸ Offerã€å‡†å¤‡ç¯‡ã€‘](https://www.bilibili.com/video/BV1Kf4y197Rk?spm_id_from=333.999.0.0)

[BAT å¤§å‚ Offer æ”¶å‰²æœºæ˜¯æ€æ ·ç‚¼æˆçš„ï¼ŸæŠ€æœ¯é¢è¯•é€šå…³å…¨æ”»ç•¥](https://www.bilibili.com/video/BV1E5411h7Jr?spm_id_from=333.999.0.0)

##  2. <a name='-1'></a>ç®—æ³•

[å›¾çµæ˜Ÿçƒ - ä»€ä¹ˆæ˜¯æ•°æ®ç»“æ„å’Œç®—æ³•ï¼ŸäºŒåˆ†æœç´¢å‰–æ](https://www.bilibili.com/video/BV1H7411n79u?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ï¼Œå¤§Oè¡¨ç¤ºæ³•](https://www.bilibili.com/video/BV14j411f7DJ?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - æ’åºç®—æ³•ï¼šæ’å…¥æ’åºï¼Œå¿«æ’ï¼Œå½’å¹¶æ’åº](https://www.bilibili.com/video/BV1QE41177ST?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - é“¾è¡¨ Linked Listã€æ•°æ®ç»“æ„å’Œç®—æ³•å…¥é—¨4ã€‘](https://www.bilibili.com/video/BV1rE411g788?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - å †æ ˆStack, é˜Ÿåˆ—Queueã€æ•°æ®ç»“æ„å’Œç®—æ³•å…¥é—¨5ã€‘](https://www.bilibili.com/video/BV1QE41137tw?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - å“ˆå¸Œè¡¨HashMapã€æ•°æ®ç»“æ„å’Œç®—æ³•å…¥é—¨6ã€‘](https://www.bilibili.com/video/BV1si4y1b7Rs?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - äºŒå‰æœç´¢æ ‘ï¼ˆæ’åºäºŒå‰æ ‘ï¼‰ï¼Œæ ‘çš„éå†ï¼ˆå‰åºã€ä¸­åºã€ååºï¼‰](https://www.bilibili.com/video/BV1qQ4y1M7Z4?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - ä¼˜å…ˆé˜Ÿåˆ—PriorityQueueï¼Œå †Heap](https://www.bilibili.com/video/BV1ti4y1879c?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - å›¾Graph, æ·±åº¦ä¼˜å…ˆéå†(DFS), å¹¿åº¦ä¼˜å…ˆéå†(BFS)](https://www.bilibili.com/video/BV1254y1976m?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - Arrayé¢˜å‹ï¼šåŒæŒ‡é’ˆTwo Pointerså¥—è·¯](https://www.bilibili.com/video/BV1V54y1Q7bd?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - äºŒåˆ†æŸ¥æ‰¾Binary Searchå¥—è·¯å’Œè§£é¢˜æ¨¡æ¿](https://www.bilibili.com/video/BV1Ng4y1q7E3?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - Linked Listé“¾è¡¨é¢˜å‹è§£é¢˜å¥—è·¯å’Œæ¨¡æ¿](https://www.bilibili.com/video/BV1QD4y1D7av?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - Stackå †æ ˆè§£é¢˜å¥—è·¯](https://www.bilibili.com/video/BV1Hi4y1x7fX?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - Heapå †è§£é¢˜å¥—è·¯](https://www.bilibili.com/video/BV1XZ4y1M799?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - å“ˆå¸Œè¡¨HashMapè§£é¢˜å¥—è·¯](https://www.bilibili.com/video/BV1KC4y1h7zV?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - æ ‘Treeé¢˜å‹å¹¿åº¦ä¼˜å…ˆæœç´¢BFSå¥—è·¯](https://www.bilibili.com/video/BV1T5411e7D2?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - æ ‘Treeæ·±åº¦ä¼˜å…ˆæœç´¢DFSè§£é¢˜å¥—è·¯](https://www.bilibili.com/video/BV1xT4y1E7TD?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - Graphå›¾BFSå¹¿åº¦ä¼˜å…ˆæœç´¢å¥—è·¯](https://www.bilibili.com/video/BV1HA411v753?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - Graphå›¾Best-First Searché¢˜å‹å¥—è·¯](https://www.bilibili.com/video/BV1NK4y1v75h?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - Graphå›¾DFSæ·±åº¦ä¼˜å…ˆæœç´¢é¢˜å‹å¥—è·¯](https://www.bilibili.com/video/BV1vv411q769?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - Search, Dynamic Programming1](https://www.bilibili.com/video/BV1hf4y197w3?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - DynamicProgramming1Dè§£é¢˜å¥—è·¯](https://www.bilibili.com/video/BV1CD4y127CZ?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - DynamicProgramming2Dè§£é¢˜å¥—è·¯](https://www.bilibili.com/video/BV1sk4y1y7Dv?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - DynamicProgramming2Dè¿›é˜¶è§£é¢˜å¥—è·¯](https://www.bilibili.com/video/BV12k4y127nP?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - DynamicProgramming2Dé«˜çº§è§£é¢˜å¥—è·¯](https://www.bilibili.com/video/BV14z4y1f7hH?spm_id_from=333.999.0.0)

[å›¾çµæ˜Ÿçƒ - Backtrackingå›æº¯è§£é¢˜å¥—è·¯](https://www.bilibili.com/video/BV1Ty4y1E7RM?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ DSU(å¹¶æŸ¥é›†å®ç°)-Python](https://www.bilibili.com/video/BV19K4y1b7vT?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Tree-Python(å¹¿åº¦ä¼˜å…ˆéå†BFS)(1)](https://www.bilibili.com/video/BV1H7411D7Nm?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Tree-Python(æ·±åº¦ä¼˜å…ˆéå†DFS)(2)](https://www.bilibili.com/video/BV1H7411D73V?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ äºŒåˆ†æŸ¥æ‰¾(Binary Search)åˆé›†](https://www.bilibili.com/video/BV1254y1B7xK?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Bubble_sort(ç”¨Pythonå®ç°å†’æ³¡æ’åº)(1)](https://www.bilibili.com/video/BV19E411E7df?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Selected_sort(ç”¨Pythonå®ç°é€‰æ‹©æ’åº)(2)](https://www.bilibili.com/video/BV1AE411t7Pr?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Single linked list-Python(é“¾è¡¨åŠŸèƒ½æ‰©å±•-æœ‰æ¡ä»¶ç¿»è½¬é“¾è¡¨)ï¼ˆ2ï¼‰](https://www.bilibili.com/video/BV1n7411G7rc?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Inserted_sort(ç”¨Pythonå®ç°æ’å…¥æ’åº)(3)](https://www.bilibili.com/video/BV1SE411p7zn?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Tree-Python(æ·±åº¦ä¼˜å…ˆéå†çš„è¿­ä»£å®ç°)(3)](https://www.bilibili.com/video/BV1V54y197qo?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Shell_sort(ç”¨Pythonå®ç°å¸Œå°”æ’åº)(4)](https://www.bilibili.com/video/BV1SE411T7t1?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Quick_sort(ç”¨Pythonå®ç°å¿«é€Ÿæ’åº)(5)](https://www.bilibili.com/video/BV1d7411R75g?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ Merge_sort(ç”¨Pythonå®ç°åˆå¹¶æ’åº)(6)](https://www.bilibili.com/video/BV1gE411c7PR?spm_id_from=333.999.0.0)

[DP èŠ±èŠ±é…±](https://www.bilibili.com/video/BV16b411N7o7?spm_id_from=333.999.0.0)

[DP èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1hb411P7C2?spm_id_from=333.999.0.0)

[DP èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1wb4y1b7df?spm_id_from=333.999.0.0)

[Maximum Subarray DP èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yg411A7D4?spm_id_from=333.999.0.0)

[Maximum Product Subarray DP èŠ±èŠ±é…±](https://www.bilibili.com/video/BV18q4y1z7TC?spm_id_from=333.999.0.0)

[Fast Power for DP èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Je411s7NM?spm_id_from=333.999.0.0)

[Best Time to Buy and Sell Stock DP èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Tg411P7S9?spm_id_from=333.999.0.0)

[Disjoint-set/Union-find Forest èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1jW411d7vi?spm_id_from=333.999.0.0)

[Best Time to Buy and Sell Stock with  DP èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1sq4y1q768?spm_id_from=333.999.0.0)

[äºŒå‰æ ‘ èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Gt411e7zm?spm_id_from=333.999.0.0)

[èƒŒåŒ…é—®é¢˜ èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ot411m7wv?spm_id_from=333.999.0.0)

[èƒŒåŒ…é—®é¢˜ 2 èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Dt411U7eM?spm_id_from=333.999.0.0)

[æœ€å°ç”Ÿæˆæ ‘ (Minimum Spanning Tree)  èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1A7411Y7mT?spm_id_from=333.999.0.0)

[Binary Search èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yW411Z7um?spm_id_from=333.999.0.0)

[Binary Search II èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ub411V7gs?spm_id_from=333.999.0.0)

[Fenwick Tree / Binary Indexed Tree èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1EW411d75F?spm_id_from=333.999.0.0)

[Input Size V.S. Time Complexity èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1jW411d7a2?spm_id_from=333.999.0.0)

[Time/Space Complexity of Recursive Algorithms èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1JW411d714?spm_id_from=333.999.0.0)

[Segment Tree èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1bb411y78M?spm_id_from=333.999.0.0)

[Min Heap èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cy4y1q7P1?spm_id_from=333.999.0.0)

[Amortized Analysis å‡æ‘Šåˆ†æ èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1NW411C7v7?spm_id_from=333.999.0.0)

[Recursion unrolling and performance measurement](https://www.bilibili.com/video/BV1Gt411r7MS?spm_id_from=333.999.0.0)


##  3. <a name='-1'></a>é¢˜ç›®

###  3.1. <a name='TwoSum'></a>1 Two Sum

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1rE411Y7UN?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV19b411v7qp?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Zf4y1G7W4?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1rv411k7VY?spm_id_from=333.999.0.0)

æš´åŠ›æ±‚è§£ï¼š

* æ—¶é—´å¤æ‚åº¦:O(n2)

* æ—¶é—´å¤æ‚åº¦:O(1)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                if nums[i] + nums [j] == target:
                    return [i,j]
```

æŸ¥æ‰¾è¡¨æ³•:

* å“ˆå¸Œè¡¨(ä¸éœ€è¦ç»´æŠ¤è¡¨çš„é¡ºåºæ€§)

* å¹³è¡¡äºŒå‰æœç´ æ ‘

* æ—¶é—´å¤æ‚åº¦:O(n)

* æ—¶é—´å¤æ‚åº¦:O(n)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i,n in enumerate(nums):
            if n in dic:
                return [dic[n],i]
            dic[target - n] = i
```

```scala
object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        val nums_map = scala.collection.mutable.HashMap[Int, Int]()
        var result: Array[Int] = Array(0,0)
        var i = 0
        while(result.sum == 0) {
            val complement = target - nums(i)
            if (nums_map.contains(complement)) {
                result(0) = i
                result(1) = nums_map(complement)
            } else {
                nums_map(nums(i)) = i
            }
            i += 1
        }
        result     
    }
}



// Brute-force method, which takes more than two times of running time than the method above
object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        
        val result = for {i <- 0 until (nums.length - 1);
            j <- (i+1) until nums.length
            if nums(i) + nums(j) == target} yield Array(i, j)
        
        result(0)
        
    }
}

/**
* chosen solution
* time complexity: O(N)
*/


object Solution0 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}

/**
* HashTable
* time complexity: O(N)
*/

object Solution1 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    val ret = collection.mutable.ArrayBuffer[Int]()

    for ((n, idx) <- nums.zipWithIndex; if ret.length < 2) {
      val v2 = target - n
      value2Idx.get(v2) match {
        case Some(v2Idx) if v2Idx != idx =>
          ret ++= Array(idx, v2Idx)
        case _ =>
      }
    }
    ret.toArray
  }
}


/**
* more elegant
*/


object Solution1-2 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}
```

```scala
object leetcode01_two_sum extends App {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val sorted = nums.zipWithIndex.sortWith(_._1 < _._1)
    var left = 0
    var right = sorted.length - 1
    while(left < right) {
      val cal = sorted(left)._1 + sorted(right)._1
      if(cal > target) {
        right = right - 1
      } else if (cal < target) {
        left = left + 1
      } else {
        return Array(sorted(left)._2, sorted(right)._2)
      }
    }
    return Array.emptyIntArray
  }

  twoSum(Array(3,2,4), 6)
}


object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        var map = Map.empty[Int, Int]
        var result = Array.empty[Int]
        (0 until nums.length) foreach { i =>
            val v = nums(i)
            map.get(target - v) match {
                case Some(x)  =>
                    if (x != i){
                    result = Array(x, i)
                    }
                case _ => map += v -> i
            }
        }
        result
    }
}

```

###  3.2. <a name='AddTwoNumbers'></a>2. Add Two Numbers

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1EJ411h72z?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1gJ411V7gJ?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³](https://www.bilibili.com/video/BV1Wb411e77s?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1rZ4y1j7V3?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1DA411L7YQ?spm_id_from=333.999.0.0)

* æ—¶é—´å¤æ‚åº¦:O(max(m,n))

* æ—¶é—´å¤æ‚åº¦:O(max(m,n))

ç‰¹æ®Šæƒ…å†µï¼š

ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ä¸åŒã€‚

è¿›ä½

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = pointer = ListNode(0) # æ˜“é”™ç‚¹ï¼šå®šä¹‰ä¸€ä¸ªdummyå’Œä¸€ä¸ªpointerï¼Œéƒ½æŒ‡å‘ListNode(0)
        carry = 0 # æ˜“é”™ç‚¹ï¼šcarryéœ€è¦å…ˆèµ‹å€¼
        while l1 or l2 or carry: # æ˜“é”™ç‚¹ï¼šcarryè¦å­˜åœ¨
            # æ˜“é”™ç‚¹ï¼šl1,l2ä¸ä¸€å®šå­˜åœ¨ï¼Œæ‰€ä»¥ä¸èƒ½å†™æˆï¼šsumNode = l1 + l2
            # æ˜“é”™ç‚¹ï¼šè°ƒç”¨listnodeè¦æœ‰.val
            sumNode = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            tail = sumNode % 10
            carry = sumNode // 10
            pointer.next = ListNode(tail)
            pointer = pointer.next
            # # l1,l2ä¸ä¸€å®šå­˜åœ¨ï¼Œæ‰€ä»¥ä¸èƒ½å†™æˆï¼šl1 = l1.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */

 /**
 * my first commitment
 * time complexity O(max(l1.length, l2.length))
 */
object Solution1 {
    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
      val dummyHead = ListNode()
      var current = dummyHead
      var (p1, p2) = (l1, l2)
      var carry = 0
      while(p1 != null && p2 != null) {
        val sum = carry + p1.x + p2.x
        carry = sum / 10
        
        current.next = ListNode(sum % 10)
        current = current.next
        p1 = p1.next
        p2 = p2.next
      }
      
      while(p1 != null) {
        val sum = carry + p1.x
        carry = sum / 10
        current.next = ListNode(sum % 10)  
        current = current.next
        p1 = p1.next
      }
      while(p2 != null) {
        val sum = carry + p2.x
        carry = sum / 10
        current.next = ListNode(sum % 10)
        current = current.next
        p2 = p2.next
      }
      if (carry > 0)
        current.next = ListNode(carry)
      dummyHead.next
    }
}

object Solution {
    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
      var cur1 = l1
      var cur2 = l2
      val dummy = ListNode(0)
      var prev=dummy
      var carry = 0
      while (cur1!=null ||  cur2!=null || carry !=0) {
        val (s1,next1) = cur1 match {
          case null => (0,null)
          case _=> (cur1.x, cur1.next)
        }
        val (s2,next2) = cur2 match {
          case null => (0,null)
          case _=> (cur2.x,cur2.next)
        }
        val s = s1+s2+carry
        val node = ListNode(s % 10)
        prev.next = node
        prev=node
        carry=s/10
        cur1 = next1
        cur2=next2
      }
      dummy.next
    }
  }
```

###  3.3. <a name='LongestSubstringWithoutRepeatingCharacters'></a>3. ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘æ•°ç»„ä¸­é‡å¤çš„æ•°å­— Longest Substring Without Repeating Characters

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1h54y1B7No?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1CJ411G7Nn?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1va4y1J7Gx?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1ob411n7mv?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV18K411M7d2?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1DK4y1b7xp?spm_id_from=333.999.0.0)

æ–¹æ³•ä¸€ï¼šæš´åŠ›è§£æ³•

* æ—¶é—´å¤æ‚åº¦: 2ä¸ªæŒ‡é’ˆéå†å­—ç¬¦ä¸²O(n2) + hashsetåˆ¤æ–­æ˜¯å¦é‡å¤O(n) = O(n3)

* æ—¶é—´å¤æ‚åº¦: O(m), m ä¸ºæ‰€æœ‰å¯èƒ½å‡ºç°çš„æƒ…å†µ

æ–¹æ³•äºŒï¼šæ¶‰åŠ sub çš„é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ â€œæ»‘åŠ¨çª—å£â€

ç‰¹æ®Šæƒ…å†µï¼š

* å­—ç¬¦ä¸²ä¸ºç©º
  
* å­—ç¬¦ä¸²å‡ä¸ºé‡å¤å­—ç¬¦ä¸²

* æ—¶é—´å¤æ‚åº¦: O(n) + hashsetåˆ¤æ–­æ˜¯å¦é‡å¤O(n) = O(n3)

* æ—¶é—´å¤æ‚åº¦: O(m), m ä¸ºæ‰€æœ‰å¯èƒ½å‡ºç°çš„æƒ…å†µ

```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        dic = {}
        start = 0
        res = 0
        for i, char in enumerate(s):
            if char in dic and start <= dic[char]:
                # æ˜“é”™ç‚¹: and start <= dic[char]: 
                # å«ä¹‰ä¸º"tmmzuxt",
                # startåœ¨mï¼Œå½“æœ‰æ–°çš„tè¿›æ¥æ—¶ï¼Œä¸Šä¸€ä¸ªtåœ¨startçš„å‰é¢ï¼Œæ‰€ä»¥ï¼Œæ­¤æ—¶çš„startä¸éœ€è¦ä¿®æ”¹
                start = dic[char] + 1 # æ˜“é”™ç‚¹: è¿™é‡Œçš„dic[char]è¿˜æ˜¯å‰ä¸€ä¸ª,ä¸” +1
            else:
                res = max(res,i-start+1) # æ˜“é”™ç‚¹: +1
            dic[char] = i # æ˜“é”™ç‚¹: dic[char]æ»åæ›´æ–°
        return res
```

```scala
/**
* chosen solution
* two pointer to control sliding window
*   1. two pointer: left and right to control substring window
*   2. counter and hashmap to record whether current window is valid or not
* time  complexity: O(N), worst: O(2N) -> each char was visited twice
*/

object Solution0 {
  def lengthOfLongestSubstring(s: String): Int = {
    val sMap = scala.collection.mutable.Map[Char, Int]() ++ s.distinct.map(c => (c, 0)).toMap
    var left = 0
    var right = 0
    var counter = 0
    var length = 0
    while (right < s.length) {
      val rightChar = s(right)
      sMap.get(rightChar) match {
        case Some(v) if v >= 1 =>
          sMap.update(rightChar, v + 1)
          counter += 1
        case Some(v) =>
          sMap.update(rightChar, v + 1)
      }
      right += 1
      while (counter > 0) {
        val leftChar = s(left)
        sMap.get(leftChar) match {
          case Some(v) if v > 1 =>
            sMap.update(leftChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(leftChar, v - 1)
        }

        left += 1

      }
      length = length max (right - left)
    }
    length
  }
}


/**
* my first commit
* sliding windows
*  time  complexity: O(N), worst: O(2N) -> each char was visited twice
*/
object Solution1 {
    def lengthOfLongestSubstring(s: String): Int = {
        var right = 0
        var left = 0
        var current = ""
        var ret = ""
        
        while(right < s.length) {
            val char = s(right)
            if (current.contains(char)){
                current = current.drop(1)
                left += 1
                 
            }else {
                right += 1
                current += char
            }     
            if(current.length > ret.length) ret = current
        }
        ret.length
    }
}


/**
* sliding windows, slower than solution1
*   memo
*     1. using hashmap to record whether the current right char is duplicated or not
*/
object Solution1-2 {
    def lengthOfLongestSubstring(s: String): Int = {
        val map = scala.collection.mutable.Map[Char, Int]() ++ s.distinct.map(c => (c, 0))
        var left = 0
        var right = 0
        var length = 0
        
        while(right < s.length){
            val rightChar = s(right)
        
            map.update(rightChar, map(rightChar) + 1)
            right += 1
            
            /* iterate until meet condition */
            while(map(rightChar) > 1){
                val leftChar = s(left)
                
                map.get(leftChar) match {
                    case Some(v) if v > 0 =>  map.update(leftChar,  v - 1)
                    case _ =>
                }
                
                left += 1
            }

            length = length max (right - left)  // update minimum
               
        }
        length
    }
}

/**
* using substring problem template
*   1. two pointer: left and right to control substring window
*   2. counter and hashmap to record whether current window is valid or not
*/
object Solution1-3 {
  def lengthOfLongestSubstring(s: String): Int = {
    val sMap = scala.collection.mutable.Map[Char, Int]() ++ s.distinct.map(c => (c, 0)).toMap
    var left = 0
    var right = 0
    var counter = 0
    var length = 0
    while (right < s.length) {
      val rightChar = s(right)
      sMap.get(rightChar) match {
        case Some(v) if v >= 1 =>
          sMap.update(rightChar, v + 1)
          counter += 1
        case Some(v) =>
          sMap.update(rightChar, v + 1)
      }
      right += 1
      while (counter > 0) {
        val leftChar = s(left)
        sMap.get(leftChar) match {
          case Some(v) if v > 1 =>
            sMap.update(leftChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(leftChar, v - 1)
        }

        left += 1

      }
      length = length max (right - left)
    }
    length
  }
}

object Solution {
    //s.zipWithIndex.foreach(println) // =>tuple
    //   def foldLeft[B](z: B)(op: (B, A) => B): B = {
    // è§£é‡Š z: åˆå§‹å€¼,
    // op (B,A) => Bå‰ä¸€ä¸ªç»“æœï¼ŒAæœ¬æ¬¡è¾“å…¥,è¿”å›ä½œä¸ºä¸‹ä¸€ä¸ªè¾“å…¥
    def lengthOfLongestSubstring(s: String): Int = {
      s.zipWithIndex.foldLeft((0, -1, Map[Char, Int]())) {
        case ((len, start_pos, map), (char, i)) => {
          // åˆå§‹å€¼len=0,start_pos=-1,mapä¸ºç©º; case A,B; å‰è€…ä¸ºç´¯åŠ å€¼ï¼Œåè€…ä¸ºindex
          // å¦‚æœcharä¸å­˜åœ¨,last_pos=-1,æ›´æ–°mapä¸­çš„idx,len=i-start_pos
          // å¦‚æœlast_poså·²å­˜åœ¨,ä¾‹å¦‚abca,ç¬¬ä¸€ä¸ªaä¸º0,ç¬¬äºŒä¸ªaä¸º3,åˆ™len=3-0,è·Ÿæ–°start_pos
          val last_pos = map.getOrElse(char, -1)
          if (last_pos >= start_pos) (len.max(i - last_pos), last_pos, map + (char -> i))
          else (len.max(i - start_pos), start_pos, map + (char -> i))
        }
      }._1
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.lengthOfLongestSubstring("abcabcbb")==3)
    }
    val name = "003 Longest Non repeat str"
  }
```

###  3.4. <a name='MedianofTwoSortedArrays'></a>4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•° Median of Two Sorted Arrays

[å®˜æ–¹](https://www.bilibili.com/video/BV1Xv411z76J?spm_id_from=333.999.0.0)

###  3.5. <a name='LongestPalindromicSubstring-'></a>5. ã€å›æ–‡ğŸŒˆã€‘Longest Palindromic Substring -æœ€é•¿å›æ–‡ğŸŒˆå­ä¸²

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV18J411j7Pb?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1ra4y1Y7Gx?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7P6?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1so4y1o765?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1L54y1D7pa?spm_id_from=333.999.0.0)

æš´åŠ›è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(n3),åœ¨ä¸¤ä¸ªforå¾ªç¯é‡Œé¢ï¼Œè¿˜åšäº†ä¸€æ¬¡éå†

* æ—¶é—´å¤æ‚åº¦:O(1)

ä¸­å¿ƒæ‰©æ•£æ³•ï¼š

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.4sfvjkqc4qo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ur1lzo89kk0.png)

* æ—¶é—´å¤æ‚åº¦:O(n2)

* æ—¶é—´å¤æ‚åº¦:O(1)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        strLen = len(s)
        if strLen == 1:
            return s

        mid = 0
        strStart = strEnd = 0
        maxLen = 1



        while mid < strLen:

            # ä¼˜åŒ–ï¼š
            if strLen - mid <= maxLen/2:
                break

            start = end = mid
            
            # ç¬¬ä¸€æ­¥ï¼š
            while end + 1 < strLen and s[end] == s[end+1]: # æ³¨æ„è¾¹ç•Œ
                end += 1

            # ç¬¬äºŒæ­¥ï¼š
            while  end + 1 < strLen and start > 0 and s[start-1] == s[end+1]: # æ³¨æ„è¾¹ç•Œ
                start -= 1
                end += 1
            
            # ç¬¬ä¸‰æ­¥ï¼š
            if end - start + 1 > maxLen:
                maxLen = end - start + 1
                strStart = start
                strEnd = end

            mid += 1

        return s[strStart:strEnd+1]
```

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s


        def getLen(l,r) -> int:
            while l>=0 and r<lenStr and s[l] == s[r]: # æ³¨æ„ï¼šè¾¹ç•Œ
                l -= 1
                r += 1
            return r - l - 1 # æ³¨æ„ï¼šæ˜¯ â€œ-1â€

        start = 0  
        end = 1 # æ³¨æ„ï¼šåœ¨ç¬¬ä¸€æ¬¡çš„æ—¶å€™ï¼Œend = 1
        maxmaxLen = maxLen = 1

        for mid in range(lenStr):
            maxLen = max(getLen(mid,mid),getLen(mid,mid+1))
            
            if maxLen > maxmaxLen:
                maxmaxLen = maxLen
                start = mid - (maxLen-1) // 2 #æ˜“é”™ç‚¹ï¼š-1ï¼Œæœ€å¥½èƒŒä¸€èƒŒ
                end = start + maxLen
        return s[start:end]
```

åŠ¨æ€è§„åˆ’æ³•ï¼š

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.67y5euem0vo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.90ngy2t8j3k.png)

* æ—¶é—´å¤æ‚åº¦:O(n2)

* æ—¶é—´å¤æ‚åº¦:O(n2)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)
        maxlen = maxmaxlen = 1
        start = 0

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s

        dp = [[False for _ in range(lenStr)] for _ in range(lenStr)]
        for i in range(lenStr):
            dp[1][1] = True 
            # dp[1][1]æ˜¯æ­£ç¡®å†™æ³•ï¼Œdp[1,1]æ˜¯é”™è¯¯å†™æ³•

        for j in range(1,lenStr): # æŠŠä¸‰è§’å½¢ç”»å‡ºæ¥ï¼Œå…ˆjï¼Œå†iï¼Œ
            for i in range(j):
                if s[i] == s[j]:
                    if j-i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i+1][j-1]
                if dp[i][j]:
                    maxlen = j-i+1
                    if maxlen > maxmaxlen:
                        maxmaxlen = maxlen
                        start = i
        return s[start:start+maxmaxlen]
```

Manacherç®—æ³•ï¼š

ä¸è¦æ±‚

```scala
/**
* chosen solution
* expand around center
* time complexity: O(N * 2 * N) = O(N^2)
*        expandLengths: O(N)
* space complexity: O(1)
*/

object Solution0 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty) return ""
        
        // 0 1 2 3 4 5 6 7
        // r a c e c a r
        // r a c e e c a r
        // b b c e c a a
        val (head, maxlen) = s.indices.foldLeft((0, 1)){
            case ((h, maxlen), i) => 
                val oddlen =  expandLengths(s, i, i)
                val evenlen = expandLengths(s, i, i + 1)
                val len = oddlen max evenlen
                if(len > maxlen)  (i -  (len - 1) / 2, len)
                else (h, maxlen)
        }
        s.slice(head, head + maxlen)
    }
    // return length
    @annotation.tailrec
    def expandLengths(s: String, left: Int, right: Int): Int = {
        if(0 <= left && right < s.length && s(left) == s(right)) expandLengths(s, left - 1, right + 1)
        else right - left - 1
    }
}

/**
* my first commitment
* it's kind of brute force
* time complexity: O(N^3):
*    getPalindromeLength: O(N^2)
* space complexity: O(N)
*/

object Solution1 {
  def longestPalindrome(s: String): String = {
    /* palindromeLength(i) means  the maximum palindrome length ending at string s's index i
    *   ex:
    *     input
    *         "b a b a d"
    *          0 1 2 3 4
    *     palindromeLength(0) = 1: "b"'s max palindrome length must contains the last char => "b"
    *     palindromeLength(1) = 2: "ba"'s max palindrome length must contains the last char => "a"
    *     palindromeLength(2) = 3: "bab"'s max palindrome length must contains the last char => "bab"
    *     palindromeLength(3) = 3: "baba"'s max palindrome length must contains the last char => "baba"
    *     palindromeLength(4) = 1: "babad"'s max palindrome length must contains the last char => "babad"
    * 
    * */
    val palindromeLength = Array.ofDim[Int](s.length)
    for(right <- s.indices){

      palindromeLength(right) = getPalindromeLength(s.slice(0, right + 1))
      // println("---", right, s.slice(0, right + 1).mkString(""), cache(right))
    }
    // println(cache.mkString(","))
    val maxIdx = palindromeLength.indices.maxBy(palindromeLength)

    s.slice(maxIdx - palindromeLength(maxIdx) + 1, maxIdx + 1)

  }

  /**
    * find the letter part may contains palindrome
    * iterate left2right from 0 s.length. right2left decreases 1 if s(left2right) == s(right2left)
    * the result value of right2left is the index dividing s into two part, the latter part may contains palindrome
    * ex:
    *    input:
    *         "b a a c b a b c"
    *          0 1 2 3 4 5 6 7
    *    the splitIdx would be 2, so s[3: 7) may contains palindrome and we should recursively input s[3: 7) to check it
    */
  @annotation.tailrec
  def getPalindromeLength(s: String): Int = {
    if(s == null || s.isEmpty) return 0

    val splitIdx = s.indices.foldLeft(s.length - 1){
      case (right2left, left2right) =>
        if(s(right2left) == s(left2right)) right2left - 1
        else right2left
    }
    // println(s, splitIdx)
    if(splitIdx == -1) /* find the palindrome! */
      s.length
    else
      getPalindromeLength(s.slice(splitIdx + 1, s.length))
  }
}


/**
* brute force
* time complexity: O(N^3)
* space complexity: O(M) M is the length of longest palindrome
*/

object Solution2 {
    def longestPalindrome(s: String): String = {
        (for(i <- s.indices; j <- i until s.length) yield (i, j)).foldLeft("") {
            // pruning
            case (best, (i, j)) if best.length < (j - i + 1) && isPalindrome(s, i, j) => s.slice(i, j + 1)
            case (best, _) => best
        }

    }
    // r a c e e c a r
    // 0 1 2 3 4 5 6 7
    
    @annotation.tailrec
    def isPalindrome(s: String, l: Int, r: Int): Boolean = {
    
        if(s == null || s.isEmpty) false
        else if(l >= r) true
        else { // l < r
            // println(l, s(l), r, s(r))
            if(s(l) != s(r)) false
            else isPalindrome(s, l + 1, r - 1)
        }
        
    } 
}

/**
* dynamic programming
* state definition
*     dp(i)(j) represents wether substring s(i: j) is palindromic
*     ex: 
*       s: "r a c e c a r"
*           0 1 2 3 4 5 6
*       dp(1)(5) is true due to "a c e c a" is palindrome
* state transformation
*      1.dp(i)(j) = (s(i) == s(j)) && dp(i + 1)(j - 1) if  (j - i) - (i + 1) + 1 < 2 
*         due to dp(i + 1)(j - 1) exceeds the edge 
*         ex:
*         s: "l e e t c o d e"
*             0 1 2 3 4 5 6 7
*         let i = 3, j = 4 => i + 1 = 4, j - 1 = 3 => dp(i + 1)(j - 1) = dp(4)(3) => it doesn't make sense
*   
* time complexity: O(N^2)
* space complexity: O(N^2)
*/
object Solution3 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty ) return ""
        if(s.length < 2) return s
        
        /**
        * if we initial the dp table dp(i)(j) with iterating all of element, it's time consuming
        */
        // val dp = Array.tabulate(s.length, s.length){
        //     case (i, j) if i == j => true
        //     case _ => false
        // }
        val dp = Array.ofDim[Boolean](s.length, s.length)
        var maxLen = 1
        var head = 0
        /** dp(i)(j) = (s(i) == s(j)) && dp(i + 1)(j - 1)
        * dp(i)(j)  depends on dp(i + 1)(j - 1), so we need calculate dp(i + 1)(j - 1) before we calculate dp(i)(j)
        *    0 1 2 3 4 5 6
        *          j
        *   0  A B D G K P
        *   1    C E H L Q
        *   2      F I M R
        * i 3        J N S
        *   4          O T
        *   5            U 
        *   6
        *  the iterative order would be 
        *     * A -> B -> C -> D -> E -> F .... => (0, 1) -> (0, 2) -> (1, 2) -> (0, 3) -> (1, 3) -> (2, 3) ... and so on
        *      
        *     
        */
        for(j <- 1 until s.length; i <- 0 until j){
            val currentLen = j - i + 1
            if(s(i) != s(j))  dp(i)(j) = false
            else if(currentLen < 4)  dp(i)(j) = true // currentLen - 2 < 2
            else dp(i)(j) = dp(i + 1)(j - 1)
            
            
            if(dp(i)(j) && currentLen > maxLen){
                maxLen = currentLen
                head = i

            }
        }
        
        s.slice(head, head + maxLen)
    }
}


/**
* expand around center
* time complexity: O(N^2)
*        expandLengths: O(N)
* space complexity: O(1)
*/

object Solution4 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty) return ""
        
        // 0 1 2 3 4 5 6 7
        // r a c e c a r
        // r a c e e c a r
        // b b c e c a a

        // var head = 0
        // var maxlen = 1
        // for(i <- s.indices) {
        //     val oddlen =  expand(s, i, i)
        //     val evenlen = expand(s, i, i + 1)
        //     val len = oddlen max evenlen
        //     if(len > maxlen){
        //         head = i -  (len - 1) / 2
        //         maxlen = len
        //     }
        // }
        val (head, maxlen) = s.indices.foldLeft((0, 1)){
            case ((h, maxlen), i) => 
                val oddlen =  expandLengths(s, i, i)
                val evenlen = expandLengths(s, i, i + 1)
                val len = oddlen max evenlen
                if(len > maxlen)  (i - (len - 1) / 2, len)
                else (h, maxlen)
        }
        s.slice(head, head + maxlen)
    }
    // return length
    @annotation.tailrec
    def expandLengths(s: String, left: Int, right: Int): Int = {
        if(0 <= left && right < s.length && s(left) == s(right)) expandLengths(s, left - 1, right + 1)
        else right - left - 1
    }
}

```

###  3.6. <a name='ZigZagConversion'></a>6. ZigZag Conversion

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7uH?spm_id_from=333.999.0.0)

###  3.7. <a name='ReverseInteger'></a>7 Reverse Integer

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1sE411e73m?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Jb411i7bM?spm_id_from=333.999.0.0)

* æ—¶é—´å¤æ‚åº¦:O(log10(n)), æ¯æ¬¡è¿­ä»£éƒ½ä¼šé™¤ä»¥10

* æ—¶é—´å¤æ‚åº¦:O(1)

```py
class Solution:
    def reverse(self, x: int) -> int:
        res = 0 
        a = abs(x)

        if a < 10:
            return x

        while a != 0:
            tmp = a % 10
            res = res * 10 + tmp
            a = a // 10
        # è¦æ³¨æ„returnå’Œwhileçš„ç›¸å¯¹ä½ç½®
        # ä¸è¦å†™åœ¨whileå¾ªç¯å†…éƒ¨

        if x > 0 and res < 1<<31:
            return res 
        elif x<0 and res <= 1<<31:
            return -res
        else:
            return 0
```

```scala
object Solution {
    def reverse(x: Int): Int = {
        
        // METHOD-1
        if (x == 0) {
            0
        } else { 
            val xx = math.abs(x).toString.reverse
            var start_to_record = false
            val temp = collection.mutable.ArrayBuffer[Char]()

            for (x <- xx) {

                if (start_to_record == false && x != '0') {
                    start_to_record = true
                }

                if (start_to_record) {
                    temp += x
                }

            }

            try {
                ({if (x >= 0) "" else "-"} + temp.mkString).toInt    
            } catch {
                case e: java.lang.NumberFormatException => 0
            } 
        }
        
        
        // METHOD-2
        if (x == 0) {
            0
        } else {
            
            val xx = math.abs(x).toString.reverse
            
            // find the first element not equaling to 0
            // Here I used method `.find`. It finds and returns the first element of the list satisfying a predicate, if any.
            // `.find` returns Some(*), so need to use `.get`
            val intermediate_result = xx.slice(xx.zipWithIndex.find(_._1 != '0').get._2, xx.length)
            
            // 1. Use if-else to handle possible negative integers.
            // 2. use try-catch to handle cases like "1534236469"
            //      which will cause exception java.lang.NumberFormatException: For input string: "9646324351"
            //      due to Int.MaxValue is 2147483647
            try {
                ({if (x >= 0) "" else "-"} + intermediate_result).toInt    
            } catch {
                case e: java.lang.NumberFormatException => 0
            }

        }  
    }
}
```

```scala
object Solution {
    def reverse(x: Int): Int = {
        if(x == 0){
            0
        }else{
            var output = 0L
            var num = x
            var flag = false
            
            if(x < 0){
                num = Math.abs(num)
                flag = true
            }
            
        
            while(num!=0){
                var mod = num%10
            
                output = (output*10) + mod
            
                num = num/10
            }
            
            val res = if(flag){
                output * (-1)
            }else{
                output
            }
            //To avoid overflow
            if(res < Int.MinValue || res > Int.MaxValue) 0 else res.toInt
        }
    }
}
```

###  3.8. <a name='StringtoIntegeratoi'></a>8. String to Integer(atoi)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Cb411e7pz?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1AZ4y1s7TD?spm_id_from=333.999.0.0)

* æ—¶é—´å¤æ‚åº¦:O(n)

* æ—¶é—´å¤æ‚åº¦:O(1)

|æ¨¡å¼|æè¿°|
|---|---|
|^|åŒ¹é…å­—ç¬¦ä¸²çš„å¼€å¤´|
|[...]|ç”¨æ¥è¡¨ç¤ºä¸€ç»„å­—ç¬¦,å•ç‹¬åˆ—å‡ºï¼š[amk] åŒ¹é… 'a'ï¼Œ'm'æˆ–'k'|
|*|åŒ¹é…0ä¸ªæˆ–å¤šä¸ªçš„è¡¨è¾¾å¼ã€‚|
|?|åŒ¹é…0ä¸ªæˆ–1ä¸ªç”±å‰é¢çš„æ­£åˆ™è¡¨è¾¾å¼å®šä¹‰çš„ç‰‡æ®µï¼Œéè´ªå©ªæ–¹å¼|
|+|åŒ¹é…1ä¸ªæˆ–å¤šä¸ªçš„è¡¨è¾¾å¼ã€‚|
|\d|åŒ¹é…ä»»æ„æ•°å­—ï¼Œç­‰ä»·äº [0-9]ã€‚|
|\D|åŒ¹é…ä»»æ„éæ•°å­—ï¼Œç­‰ä»·äº [^0-9]ã€‚|

[æ­£åˆ™è¡¨è¾¾å¼ä¸­å°æ‹¬å·ã€ä¸­æ‹¬å·ã€å¤§æ‹¬å·çš„ä½œç”¨](https://blog.csdn.net/weixin_45621662/article/details/103921232)

```py
class Solution:
    def myAtoi(self, s: str) -> int:
        import re
        at_oi_re = re.compile('^[ ]*([+-]?\d+)')
        # æ˜“é”™ç‚¹ï¼šè¦æ³¨æ„ä¸­æ‹¬å·[]å’Œå°æ‹¬å·()çš„åŒºåˆ«
        # æ˜“é”™ç‚¹ï¼šè¦æ³¨æ„å°æ‹¬å·()çš„ä½ç½®ï¼Œå°æ‹¬å·çš„ä½œç”¨æ˜¯åŒ¹é…å¹¶æå–ï¼Œæ‰€ä»¥+-è¦åŒ…æ‹¬èµ·æ¥
        # æ˜“é”™ç‚¹ï¼šä¸èƒ½æ¼æ‰*ï¼Ÿ

        # å­—ç¬¦ä¸²çš„ å¼€å¤´ åŒ¹é… 0ä¸ªæˆ–å¤šä¸ª[ç©ºæ ¼]
        # åŒ¹é… 0ä¸ªæˆ–å¤šä¸ª[+-]
        # åŒ¹é… 0ä¸ªæˆ–å¤šä¸ª[0-9]
        if not at_oi_re.search(s):
            return 0
        res = int(at_oi_re.findall(s)[0])
        # æ˜“é”™ç‚¹ï¼šfindallè¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œæ‰€ä»¥å¿…é¡»æœ‰[0]
        # æ˜“é”™ç‚¹ï¼šå¿…é¡»æœ‰int()
        return min(max(res, -(1<<31)), (1<<31) - 1) # åœ¨ä¸¤è€…ä¹‹é—´ï¼ŒèƒŒä¸€èƒŒ
        # è¦åŠ å°æ‹¬å·(1<<31)
```

###  3.9. <a name='Palindrome'></a>9-ã€å›æ–‡ğŸŒˆã€‘Palindrome

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1hJ411S7kt?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Jb411i7YG?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Af4y1m7kk?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        return True if str(x) == str(x)[::-1] else False
```

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False

        if x < 10:
            return True

        bkp = x
        res = 0

        while x != 0:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return bkp == res
```

ç¿»è½¬ä¸€åŠå­—ç¬¦æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(log10(n)), æ¯æ¬¡è¿­ä»£éƒ½ä¼šé™¤ä»¥10

* æ—¶é—´å¤æ‚åº¦:O(1)

ç»è¿‡å°è¯•ï¼Œè¿™ä¸ªæ–¹æ³•åœ¨è¾¹ç•Œå¤„ç†ä¸Šå®¹æ˜“å‡ºé”™ï¼Œä¸æ¨èã€‚

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 10 and x >= 0:
            return True

        if x < 0 or x % 10 == 0:
            return False

        res = 0

        # ç¿»è½¬ä¸€åŠå­—ç¬¦ä¸²

        while x > res:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return x == res or x == res//10
```

```scala
package lc009 {
  object Solution {
    def isPalindrome(x: Int): Boolean = {
      if (x<0) return false
      if (x==0) return true
      if (x%10==0) return false
      val y=x.toString.reverse
      return y==x.toString
    }
  }
}
```

###  3.10. <a name='ContainerWithMostWater'></a>11. Container With Most Water 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1CW41167qB?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7Gn?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1A5411E7oM?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1TK41157jH?spm_id_from=333.999.0.0)

æš´åŠ›è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(n2)

* æ—¶é—´å¤æ‚åº¦:O(1)

åŒæŒ‡é’ˆæ³•ï¼š

ç”±äºç››æ°´é¢ç§¯ç”±è¾ƒçŸ­è¾¹æ§åˆ¶ï¼Œæ‰€ä»¥ï¼ŒæŒ‡é’ˆæ”¾åœ¨ä¸¤ç«¯ï¼Œæ¯æ¬¡åªç§»åŠ¨è¾ƒçŸ­è¾¹ã€‚å› ä¸ºï¼Œç§»åŠ¨è¾ƒé•¿è¾¹çš„è¯ã€‚ä¸€å®šä»ç„¶æ˜¯ä¸å˜çš„ã€‚

* æ—¶é—´å¤æ‚åº¦:O(n)

* æ—¶é—´å¤æ‚åº¦:O(1)



```py
# è¿™ä¸ªå†™èµ·æ¥è¶…çº§ç®€å•ï¼
# NO BUG
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        maxRes = res = 0
        while left < right:
            res = (right - left)*min(height[left],height[right])
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
            maxRes = max(maxRes,res)
        return maxRes
```

```scala
/**
* brute force not AC
* time complexity: O(n^2)
*/

object Solution1 {
    def maxArea(height: Array[Int]): Int = {
      
      var currentMax = 0

      for(left <- height.indices; right <- (left + 1) until height.length) {
        val limit = height(right) min height(left)
        val width =  (right - left)
        val volume = limit * width

        currentMax = currentMax max volume
      }
      currentMax
    }  
}


/**
* two pointer version
* memo
*  1. fix left side,, the volume is bounded by left side if left side is shorter 
*  2. fix right side. the volume is bounded by right side if right side is shorter
*/

object Solution2 {
    def maxArea(height: Array[Int]): Int = {
      
      var left = 0
      var right = height.length - 1
      var volume = 0
      
      while(left < right) {
        val current = (right - left) * (height(right) min height(left))
        volume = volume max current
        
        if (height(left) < height(right)) // left is shorter
          left += 1
        else // right is shorter
          right -= 1
      }
      volume
    }
         
}

/**
* two - pointer version recursive version
*/
object Solution2-1 {
    def maxArea(height: Array[Int]): Int = {
  
     maxArea(height, 0, height.length - 1, 0)
    }
  
    @annotation.tailrec
    def maxArea(height: Array[Int], left: Int, right: Int, maxVolume: Int): Int = {
      if (left >= right)  maxVolume
      else {
        val currentVolume = (right - left) * (height(right) min height(left))
        var newMaxVolume = currentVolume max maxVolume
        
        if (height(right) > height(left)) 
          maxArea(height, left + 1, right, newMaxVolume)
        else
          maxArea(height, left, right - 1, newMaxVolume)
      }
    }
}
```

###  3.11. <a name='IntegertoRoman'></a>12. Integer to Roman

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Lb411x7Wf?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1hN411Q7ka?spm_id_from=333.999.0.0)

```py
# è¿™ä¸ªå†™èµ·æ¥è¶…çº§ç®€å•ï¼
# NO BUG
class Solution:
    def intToRoman(self, num: int) -> str:
        strlist = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"]
        numlist = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        res = ''
        for i in range(len(numlist)):
            while num >= numlist[i]:
                num -= numlist[i]
                res = res + strlist[i]
        return res
```

```py
# å…¶ä»–æ–¹æ³•
class Solution:

    VALUE_SYMBOLS = [
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    ]
    print(type(VALUE_SYMBOLS))
    def intToRoman(self, num: int) -> str:
        roman = list()
        for value, symbol in Solution.VALUE_SYMBOLS:
            while num >= value:
                print("-"*20)
                print(num)
                num -= value
                roman.append(symbol)
                print(roman)
            if num == 0:
                break
        return "".join(roman)
```

```scala
package com.zhourui.leetcode

//class Solution {
//  public:
//    string intToRoman(int num) {
//      vector<int> t1{1000,900,500,400,100,90,50,40,10,9,5,4,1};
//      vector<string> t2{"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
//      string ret="";
//      for (int i=0;i<t1.size();i++) {
//      if (num>=t1[i]) {
//      int c = num/t1[i];
//      for (int j=0;j<c;j++) {
//      ret+=t2[i];
//    }
//      num=num%t1[i];
//    } else if (num==0) {
//      break;
//    }
//    }
//      return ret;
//    }
//};


//object Solution {
//  case class RomanNumber(decValue: Int, romanStr: String)
//  val numbers = Seq(
//    RomanNumber(1000, "M"),
//    RomanNumber(900, "CM"),
//    RomanNumber(500, "D"),
//    RomanNumber(400, "CD"),
//    RomanNumber(100, "C"),
//    RomanNumber(90, "XC"),
//    RomanNumber(50, "L"),
//    RomanNumber(40, "XL"),
//    RomanNumber(10, "X"),
//    RomanNumber(9, "IX"),
//    RomanNumber(5, "V"),
//    RomanNumber(4, "IV"),
//    RomanNumber(1, "I")
//  )
//  def intToRoman(num: Int): String = {
//    def loop(num:Int, romans: Seq[RomanNumber]): String = {
//      romans match {
//        case RomanNumber(x, romanStr) :: _ if x < num => romanStr + loop(num-x, romans)
//        case RomanNumber(x, romanStr) :: _ if x == num => romanStr
//        case RomanNumber(x, _) :: tail if x > num => loop(num, tail)
//      }
//    }
//    loop(num, numbers)
//  }
//}
package lc0012_integertoroman {
  object Solution {
    case class RomanNumber(s:String, i: Int)
    def intToRoman(num: Int): String = {
      val numbers:Seq[RomanNumber] = Seq(
        RomanNumber("M",1000),
        RomanNumber("CM",900),
        RomanNumber("D",500),
        RomanNumber("CD",400),
        RomanNumber("C",100),
        RomanNumber("XC",90),
        RomanNumber("L",50),
        RomanNumber("XL",40),
        RomanNumber("X",10),
        RomanNumber("IX",9),
        RomanNumber("V",5),
        RomanNumber("IV",4),
        RomanNumber("I",1)
      )
      // å¾ˆå·§å¦™ åˆ©ç”¨seqçš„head å’Œtail é€’å½’è°ƒç”¨
      // :: ç›¸å½“äºæ‹¼æ¥

      def loop(num:Int, romans:Seq[RomanNumber]): String = {
        romans match {
          case RomanNumber(romanStr, v) :: lst if v == num => romanStr
          case RomanNumber(romanStr, v) :: lst if v < num => romanStr+loop(num-v,romans)
          case RomanNumber(romanStr, v) :: tail => loop(num,tail)
        }
      }
      loop(num, numbers)
    }
  }
}

```

###  3.12. <a name='-1'></a>13. æœºå™¨äººçš„è¿åŠ¨èŒƒå›´ 

[å®˜æ–¹](https://www.bilibili.com/video/BV1dz411B7rt?spm_id_from=333.999.0.0)

###  3.13. <a name='RomantoInteger'></a>13. Roman to Integer

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1vJ411J7Up?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1hJ411S7kQ?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Jb411i7ue?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1cp4y1H75L?spm_id_from=333.999.0.0)

```py
# çœ‹ä¸æ‡‚ä¸‹æ–¹ä»£ç ï¼Œå°±çœ‹å°æ˜çš„è®²è§£
class Solution:
    def romanToInt(self, s: str) -> int:
        dic = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
        res = 0
        for i in range(len(s)-1):
            if dic[s[i]] < dic[s[i+1]]:
                res -= dic[s[i]]
            else:
                res += dic[s[i]]
        res += dic[s[-1]]
        return res
```

```scala
object Solution {
    def romanToInt(s: String): Int = {
        val exceptionsMap = Map(
            ('I' -> List('V', 'X')),
            ('X' -> List('L', 'C')),
            ('C' -> List('D', 'M'))
                     )
        
        val valuesMap = Map(
            ('I' -> 1),
            ('V' -> 5),
            ('X' -> 10),
            ('L' -> 50),
            ('C' -> 100),
            ('D' -> 500),
            ('M' -> 1000)
        )
        
        val exceptionalValues = Map(
            ("IV" -> 4),
            ("IX" -> 9),
            ("XL" -> 40),
            ("XC" -> 90),
            ("CD" -> 400),
            ("CM" -> 900)
        )
        
        var sum = 0
        var i = 0
        val len = s.length
        while(i < len){
            var c1 = s.charAt(i) 
            c1 match{
                case 'I' | 'X' | 'C' => {
                    if(i+1 < s.size && exceptionsMap.get(c1).get.contains(s.charAt(i+1))){
                        sum += exceptionalValues.get(c1.toString + s.charAt(i+1)).get
                        i+=2
                    }else{
                        sum += valuesMap.get(c1).get
                        i += 1
                    }
                }
                case _ => {
                    sum += valuesMap.get(c1).get
                    i += 1
                }
            }
        }
        sum
    }
}


//Alternate SCALA solution
object Solution {
	def convert(c: Char) = c match{
		case 'I' => 1
		case 'V' => 5
		case 'X' => 10
		case 'L' => 50
		case 'C' => 100
		case 'D' => 500
		case 'M' => 1000
		case _ => throw new UnsupportedOperationException("This case should not be called unless the input is invalid")
	}

	def romanToInt(s: String): Int = s.foldRight(0){
		(v, sum) => (convert(v), sum) match{
			case (add, _) if sum < 5*add => add + sum
			case (sub, _) => sum - sub
		}
	}
	
}

```

```scala
package com.zhourui.leetcode

/*
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.
 */
package lc0013_romantointeger {

  object Solution {
    def romanToInt(s: String): Int = {
      val m:Map[Char,Int] = Map(
        'I' -> 1,
        'V' -> 5,
        'X' -> 10,
        'L' -> 50,
        'C' -> 100,
        'D' -> 500,
        'M' -> 1000
      )

      def loop(p:Seq[Char], m:Map[Char,Int]): Int = p match {
        case Seq(a, b, t@_*) if m(a) < m(b) => m(b) - m(a) + loop(t, m)
        case Seq(a, t@_*) => m(a) + loop(t,m)
        case _ => 0
      }
      return loop(s,m)
    }
  }
}


/*
//case Seq(xs @ _*) // Identifier xs is bound to the whole matched sequence.
 def romanToInt(s: Seq[Char]): Int = s match {
      case Seq(a, b, t@_*) if dict(a) < dict(b)  =>  dict(b) - dict(a) + romanToInt(t)
      case Seq(a, t@_*) => dict(a) + romanToInt(t)
      case _ => 0
    }
 */
```

###  3.14. <a name='Longestcommonprefix'></a>14-Longest common prefix

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1cJ411D7qU?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Eb411i7QN?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1tV411k7GY?spm_id_from=333.999.0.0)

* æ—¶é—´å¤æ‚åº¦:O(mn),mæ˜¯å­—ç¬¦ä¸²å¹³å‡é•¿åº¦,næ˜¯å­—ç¬¦ä¸²æ•°é‡

* æ—¶é—´å¤æ‚åº¦:O(1)

```py
# å‚è€ƒäº†å°æ¢¦æƒ³å®¶,é¦–æ¬¡å­¦ä¹ while trueå¾ªç¯:
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        lookup = set()
        res = ''
        i = 0
        while True:
            # ç”±äºstringçš„é•¿åº¦æ˜¯ä¸ç¡®å®šçš„ï¼Œæ‰€ä»¥
            try:
                lookup = set(string[i] for string in strs)
                if len(lookup) == 1:
                    res += lookup.pop()
                    i += 1
                else:
                    break
            except Exception as e:
                break
        return res
```

```py
# å¦‚æœä¸ä½¿ç”¨try catch
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if strs == [""]:
            return strs[0]
        lookup = set()
        res = ''
        i = 0
        minlen = min(len(string) for string in strs)
        while i< minlen:
            lookup = set(string[i] for string in strs)
            if len(lookup) == 1:
                res += lookup.pop()
                i += 1
            else:
                break
        return res
```

```scala
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var flag = true
            var count = 1
            var output = ""
        
            var minLength = strs.map(_.length).min
        
        while(flag && count <= minLength){
            
            /**
            lst.forall(_ == lst.head)  // true  if empty or all the same
            lst.exists(_ != lst.head)  // false if empty or all the same
            */
            
            if(strs.map(s => s.substring(0, count)).distinct.length == 1){
                output = strs(0).substring(0, count)
                count += 1
            }else{
                flag = false
            }
        }
        
        output
        }
    }
}

//Alternate solution (better complexity)
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var prefix = strs(0)
            
            (1 until strs.length).map(i => {
                
                while(strs(i).indexOf(prefix) != 0){
                    prefix = prefix.substring(0, prefix.length - 1)
                }
                
            })
            
            prefix
        }
    }
}

```

###  3.15. <a name='Sum'></a>15. 3Sum

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1wp4y1W72o?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Tb411578b?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV19K4y1s7co?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV19i4y1s7VZ?spm_id_from=333.999.0.0)

æš´åŠ›è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(n3)

* æ—¶é—´å¤æ‚åº¦:O(1)

åŒæŒ‡é’ˆæ³•ï¼š

å…ˆæ’åºï¼šæ—¶é—´å¤æ‚åº¦:O(n log(n)) + O(n2)

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        # nums.sort() # å¦ä¸€ç§å†™æ³•
        nums = sorted(nums)
        res = []
        for i in range(n-2):
            # ä¼˜åŒ–éƒ¨åˆ†ï¼š
            if nums[i] > 0: break
            if nums[i] + nums[i+1] + nums[i+2] > 0: break
            # è¿™ä¸ªå†™æ³•ä¸å¯¹ï¼šif i+1 < n-2 and nums[i] == nums[i+1]: continue
            # è¿™æ ·å¯èƒ½ç›´æ¥è·³è¿‡äº†[-1,-1,2,3]çš„å‰ä¸‰ä¸ª
            # è¿™ä¸ªå†™æ³•æ˜¯æ­£ç¡®çš„â†“ï¼š
            if i - 1 >= 0 and nums[i] == nums[i-1]: continue
            if nums[i] + nums[n-2] + nums[n-1] < 0:continue
            # åŒæŒ‡é’ˆéƒ¨åˆ†ï¼š
            left = i + 1
            right = n - 1
            while left < right: 
                if nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                elif nums[i] + nums[left] + nums[right] < 0:
                    left += 1
                else:
                    res.append([nums[i],nums[left],nums[right]])
                    # å»é‡ï¼š
                    while nums[left] == nums[left + 1] and left + 1 < right: # æ³¨æ„è¾¹ç•Œ
                        left += 1
                    left +=1
                    while nums[right] == nums[right - 1] and left < right - 1: # æ³¨æ„è¾¹ç•Œ
                        right -= 1
                    right -=1
        return res
```

```scala
/**
* chosen solution
* 1. two pointer in twoSum
* 2. result storing in hashSet to avoid duplicate pairs
* time complexity: O(N^2)
* space complexity: O(N): due to sorted list 
*/
object Solution0 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted
    l.indices.foldLeft(Set[List[Int]]()) {
          /* only send value less than zero and those num which was duplicated only once into twoSum */
      case (ans, idx) if l(idx) <= 0 && (idx == 0 || (idx >= 1 && l(idx) != l(idx - 1))) =>
        twoSum(-l(idx), l, idx + 1, ans)
      case (set, _) => set

    }.toList

  }

  def twoSum(target: Int, nums: Array[Int], from: Int, ans: Set[List[Int]]): Set[List[Int]] = {

    @annotation.tailrec
    def loop(i: Int, j: Int, ans: Set[List[Int]]): Set[List[Int]] = {

      if(i < j) {
        val sum = nums(i) + nums(j)
        if(sum > target) loop(i, j - 1, ans)
        else if(sum < target) loop(i + 1, j, ans)
        else loop(i + 1, j - 1, ans + List(-target, nums(i), nums(j)))
      }else {
        ans
      }
    }
    loop(from, nums.length - 1, ans)
  }
}
/**
* my first commit
* hashset in twoSum
* a very time consuming version
* O(N^2)
*/
object Solution1 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {

      val l = nums.groupBy(identity).mapValues(aa => if(aa.length >=3) aa.take(3) else aa ).values.flatten.toList

     l.zipWithIndex.flatMap {
      case (value, index) =>
        val ll = collection.mutable.ListBuffer(l: _*)
        ll.remove(index)

        twoSum(ll.toList, -value).filter(_.nonEmpty)
          .map(_ :+ value)
    }.map(pair => (pair.toSet, pair)).toMap.values.toList

  }

   def twoSum(nums: List[Int], target: Int): List[List[Int]] = {
    val valueCounter = nums.groupBy(identity).mapValues(_.length)

    nums.collect {
      case value if target - value == value && valueCounter.get(target - value).exists(_ >= 2) =>
        List(value, target - value)
      case value if target - value != value && valueCounter.contains(target - value) =>
        List(value, target - value)

    }
  }

}

/**
* hashset in twoSum
* sorted nums and not to run duplicate num twice into twoSum
* O(N^2)
*/
object Solution1-2 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
   
    val l = nums.sorted
    val ret = for((value, index) <- l.zipWithIndex; if index >= 1 && l(index) != l(index - 1)) yield  {
      val ll = l.toBuffer
      ll.remove(index)
      twoSum(ll.toArray, -value).filter(_.nonEmpty).map(_ :+ value)
    }

    l.slice(0, 3) match {
      case Array(0, 0, 0 ) =>  ret.flatten.map(l => (l.toSet, l)).toMap.values.toList :+ List(0, 0, 0) // edge case (0, 0, 0)
      case _ => ret.flatten.map(l => (l.toSet, l)).toMap.values.toList
    }

  }

  def twoSum(nums: Array[Int], target: Int): List[List[Int]] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collect {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>

        List(value, target - value)
    }.map(l => (l.toSet, l)).toMap.values.toList
  }

/**
* improvement:
*   1. only call twoSum when  l(idx) under zero,  because the array was sorted, there won't be any chance the next entries sum to 0.
*   2. only send the remaining nums which were after idx into twoSum
* O(N^2)
*/

  object Solution1-3 {
    def threeSum(nums: Array[Int]): List[List[Int]] = {
        val l = nums.sorted
        l.indices.foldLeft(collection.mutable.ListBuffer.empty[List[Int]]){
        case (r, idx) if l(idx) <=0 && (idx == 0 || (idx > 0 && l(idx) != l(idx-1))) =>
            r ++= twoSum(l.slice(idx + 1, l.length), -l(idx)).map(_ :+ l(idx))
        case (r, idx)  => r

        }.toList
        
    }

    def twoSum(nums: Array[Int], target: Int): List[List[Int]] = {

        val value2Idx = nums.zipWithIndex.toMap
        nums.zipWithIndex.collect {
        case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
            List(value, target - value)
        }.map(l => (l.toSet, l)).toMap.values.toList
    }
  
}


/**
*  Using a hashset to erase duplicate in twoSum
*/
object Solution1-3-2 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted
    l.indices.foldLeft(collection.mutable.ListBuffer.empty[List[Int]]){
      case (r, idx) if l(idx) <=0 && (idx == 0 || (idx > 0 && l(idx) != l(idx-1))) =>
        r ++= twoSum(l.slice(idx + 1, l.length), -l(idx))
      case (r, idx)  => r

    }.toList

  }

  def twoSum(nums: Array[Int], target: Int): List[List[Int]] = {

    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.foldLeft(Set[List[Int]]()) {
      case (s, (value, index)) if value2Idx.get(target - value).exists(_ != index) =>
        val t_sub_v = target - value
        if(index < value2Idx(t_sub_v)) {
          s + List(-target, value, t_sub_v)
        } else {
          s + List(-target, t_sub_v, value)
        }
      case (s, _) => s

    }.toList
  }
}
/**
* more readable and simpler
*/
object Solution1-3-3 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted

    l.zipWithIndex.foldLeft(Set[List[Int]]()) {
      /* only send value less than zero and those num which was duplicated only once into twoSum */
      case (set, (v, idx)) if v <=0 && (idx == 0 || (idx > 0 && l(idx) != l(idx - 1)))  =>
        set ++ twoSum(-v, l.slice(idx + 1, l.length))
      case (set, _) => set
    }.toList

  }

  def twoSum(target: Int, nums: Array[Int]): List[List[Int]] = {
    val map = nums.zipWithIndex.toMap
    nums.zipWithIndex.foldLeft(Set[List[Int]]()){
      case (set, (n, idx)) =>
        val n2 = target - n
        map.get(n2) match {
          case Some(e) if e != idx =>
            /* using  n n2 order to help hashset to eliminate duplicate */
            if(n < n2)
              set + List(-target, n, n2)
            else
              set + List(-target, n2, n)
          case _ => set
        }
    }.toList
  }
}

/**
* two pointer in twoSum
* time complexity: O(N^2)
* space complexity: O(N): due to sorted list 
*/

object Solution2 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted
    l.indices.foldLeft(Set[List[Int]]()) {
      case (ans, idx) if l(idx) <= 0 && (idx == 0 || (idx >= 1 && l(idx) != l(idx - 1))) =>
        twoSum(-l(idx), l, idx + 1, ans)
      case (set, _) => set

    }.toList

  }

  def twoSum(target: Int, nums: Array[Int], from: Int, ans: Set[List[Int]]): Set[List[Int]] = {

    @annotation.tailrec
    def loop(i: Int, j: Int, ans: Set[List[Int]]): Set[List[Int]] = {

      if(i < j) {
        val sum = nums(i) + nums(j)
        if(sum > target) loop(i, j - 1, ans)
        else if(sum < target) loop(i + 1, j, ans)
        else loop(i + 1, j - 1, ans + List(-target, nums(i), nums(j)))
      }else {
        ans
      }
    }
    loop(from, nums.length - 1, ans)
  }
}
```

###  3.16. <a name='SumClosest'></a>16. 3Sum Closest

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV11441187Rr?spm_id_from=333.999.0.0)

```py
# å’Œä¸Šä¸€é¢˜å·®ä¸å¤š
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        minAim = sum(nums[0:3]) - target
        n = len(nums)
        for i in range(n-2):
            left = i+1
            right = n-1
            while left<right:
                aim = nums[i] + nums[left] + nums[right] - target
                if abs(aim) < abs(minAim): minAim = aim
                if aim == 0: 
                    return target
                elif aim > 0:
                    right -= 1
                else:
                    left += 1
        return minAim + target
```

```py
# ï¼ˆpythonï¼‰ä¸‰é‡æš´åŠ›ç ´è§£ O(n**3)

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        result=1000
        for i in range(0,len(nums)):
            for j in range(i+1,len(nums)):
                for k in range(j+1,len(nums)):
                    a=nums[i]+nums[j]+nums[k]-target
                    if abs(a) < result:
                        result=abs(a)
                        end=nums[i]+nums[j]+nums[k]
        return end
```

```scala

/**
* my first commitment
* two pointer approximate
* 
* time complexity: O(N^2)
*/
object Solution1 {
  def threeSumClosest(nums: Array[Int], target: Int): Int = {
    val l = nums.sorted
    // slice(0, 3) is slower 
    l.indices.foldLeft(l.take(3).sum){
      case (closestSum, idx) => twoSum(l, target, idx, closestSum)
    }

  }

  def twoSum(nums: Array[Int], target: Int, from: Int, closestSum: Int): Int = {
    val fromValue = nums(from)

    @annotation.tailrec
    def _twoSum(left: Int, right: Int, previousSum: Int): Int = {
      if(left >= right) return previousSum


      val currentSum = fromValue + nums(left) + nums(right)

      val currentDiff = math.abs(target - currentSum)
      val previousDiff = math.abs(target - previousSum)

      val newClosest = if(currentDiff > previousDiff) previousSum else currentSum


      if(currentSum < target) _twoSum(left + 1, right, newClosest)
      else if(currentSum > target) _twoSum(left, right - 1, newClosest)
      else _twoSum(left + 1, right - 1, newClosest)

    }

    _twoSum(from + 1, nums.length - 1, closestSum)
  }
}
```

###  3.17. <a name='LetterCombinationsofaPhoneNumber'></a>17. Letter Combinations of a Phone Number 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1PW411y7r2?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7sL?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ti4y1A73M?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Sp4y1r7YP?spm_id_from=333.999.0.0)

æ·±åº¦ä¼˜å…ˆ or å¹¿åº¦ä¼˜å…ˆ

* æ—¶é—´å¤æ‚åº¦:O(3m Ã— 4n), mæ˜¯å¯¹åº”3ä¸ªå­—æ¯çš„æ•°å­—, næ˜¯å¯¹åº”4ä¸ªå­—æ¯çš„æ•°å­—

* æ—¶é—´å¤æ‚åº¦:O(3m Ã— 4n), mæ˜¯å¯¹åº”3ä¸ªå­—æ¯çš„æ•°å­—, næ˜¯å¯¹åº”4ä¸ªå­—æ¯çš„æ•°å­—

```py
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: # æ˜“é”™ç‚¹ï¼šä¸€å®šè¦åˆ¤æ–­åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©º
            return [] 
        dic = {'2':'abc','3':'def','4':'ghi','5':'kjl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        res = [char for char in dic[digits[0]]] # å‰é¢çš„æ’åœ¨å‰é¢
        for num in digits[1:]:
            res = [string + char for string in res for char in dic[num]]
        return res
```

```py
class Solution:
    def letterCombinations(self, digits):
        if not digits:
            return list()
        
        phoneMap = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }

        groups = (phoneMap[digit] for digit in digits)
        return ["".join(combination) for combination in itertools.product(*groups)]
```

###  3.18. <a name='RemoveNthNodeFromEndofList'></a>19-Remove Nth Node From End of List

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Q7411V7DQ?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1eL411n7KE?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1654y1R7Xe?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1KK4y1E7st?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Z5411c79y?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ccdr2kcw7c0.png)

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        fast = ListNode(0)
        slow = ListNode(0)
        fast.next = head
        slow.next = head
        for _ in range(n):
            fast = fast.next

        # æ˜“é”™ç‚¹ï¼š
        # è¦è€ƒè™‘ç‰¹æ®Šæƒ…å†µï¼Œæ¯”å¦‚è¯´ï¼Œé“¾è¡¨é•¿åº¦å’Œnä¸€æ ·æ—¶

        if fast.next == None: # æ˜“é”™ç‚¹ï¼š== åƒä¸‡ä¸è¦å†™é”™
            return head.next

        while fast.next != None:
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next

        return head
```

```scala
/**
* my first commitment - fast & slow pointer
* time complexity O(N + N / 2)
*/

object Solution1 {
    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
      val dummyHead = ListNode(0, head)
      var slow = dummyHead
      var fast = dummyHead
      var counter = 0
      
      while(fast != null && fast.next != null) {
        slow = slow.next
        fast = fast.next.next
        counter += 1
      }
      
      val length = if (fast == null) counter * 2 - 1 else counter * 2
      val targetNodeIndex = length - n + 1
      val slowNodeIndex = counter
      // println(length, targetNodeIndex, slowNodeIndex)
      if (counter < targetNodeIndex) {
        removeIdx(slow, slowNodeIndex, targetNodeIndex)
      }else {
        removeIdx(dummyHead, 0, targetNodeIndex)
      }
      dummyHead.next
    }
  
    def removeIdx(node: ListNode, nodeIdx: Int, targetIdx: Int) {
      var nodeT = node
      var nodeIdxV = nodeIdx
      var preNodeindex = targetIdx - 1
     
      while (nodeIdxV < preNodeindex) {
        nodeIdxV += 1
        nodeT = nodeT.next
      }
      var preNode = nodeT
      var nextNode = nodeT.next.next
      preNode.next = nextNode
    }
}


/**
* two pointer fast & slow 
* memo
*   1. keep fast pointer is n + 1 ahead to slow pointer
*   2. if fast == null, slow pointer would points to the  preNode of target removing node
*
*           t 
*   0 1 2 3 4 5
*   s     f
*     s     f
*       s     f
*         s     f
*/
object Solution1-2 {
    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
      val dummyHead = ListNode(0, head)
      var slow = dummyHead
      var fast = dummyHead
      
      for (i <- 0 until (n + 1) if fast != null) {
        fast = fast.next
      }
      
      while(fast != null) {
        slow = slow.next
        fast = fast.next
      }
      
      slow.next = slow.next.next
      dummyHead.next
    }
  
}
```

###  3.19. <a name='Validparentheses'></a>20-Valid parentheses

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1DJ41127uA?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7ek?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Hr4y1M7Sc?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1sC4y1H7Hs?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1QA411L7y7?spm_id_from=333.999.0.0)

å…ˆè¿›åå‡ºï¼Œæ‰€ä»¥ç”¨æ ˆ

* æ—¶é—´å¤æ‚åº¦:O(n)

* æ—¶é—´å¤æ‚åº¦:O(n)

```py
# è¿™é“é¢˜èƒŒä¸€èƒŒï¼
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {'{':'}','[':']','(':')'}
        stack = [] # stack è¦æå‰å®šä¹‰å¥½
        for char in s:
            if char in dic: # æ˜¯â€œkeyâ€
                stack.append(char) # ä¸€ä¸ªcharè¿›æ¥ï¼Œè¦ä¹ˆè¢«append
            elif not stack or dic[stack.pop()] != char: 
                # å¦‚æœä¸Šä¸€æ­¥ä¸è¢«appendå°±æ˜¯ä¸å¯¹çš„
                # å¦‚æœè¿™ä¸€æ­¥ä¸åŒ¹é…ä¹Ÿæ˜¯ä¸å¯¹çš„
                return False
        return not stack # å¦‚æœappendä¸Šäº†ï¼Œä½†æ²¡æœ‰è¢«å®Œå…¨popä¹Ÿæ˜¯ä¸å¯¹çš„
```

```scala
/**
* chosen solution
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution0 {
    def isValid(s: String): Boolean = {

        val parenthesesMap = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        val stack = scala.collection.mutable.ArrayStack[Char]()
        s.forall{ c =>
            if(parenthesesMap.contains(c)){
              stack.push(c)
              true
            }else{
               stack.nonEmpty && parenthesesMap(stack.pop).equals(c)
            }
        } && stack.isEmpty
    }
}


/**
* my first commitment
* using stack
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def isValid(s: String): Boolean = {
        if(s.isEmpty || s.length % 2 != 0) return false
        val stack = scala.collection.mutable.Stack[Char]()
        
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')

        s.foreach{c => 
            
            if (mapping.contains(c)){
                stack push c
            }else{
                if(stack.isEmpty || mapping(stack.pop) != c) return false 
             
            }
        }
        stack.isEmpty
        
    }
}

/**
* stack and avoid return in foreach block
*/
object Solution1-2 {
    def isValid(s: String): Boolean = {

        val parenthesesMap = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        val stack = scala.collection.mutable.ArrayStack[Char]()
        s.forall{ c =>
            if(parenthesesMap.contains(c)){
              stack.push(c)
              true
            }else{
               stack.nonEmpty && parenthesesMap(stack.pop).equals(c)
            }
        } && stack.isEmpty
    }
}

/**
* using stack X FP
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1-3 {
    def isValid(s: String): Boolean = {
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        s.foldLeft(List.empty[Char]){ (stack, c) => 
            stack match {
                case pop :: stackAfterPop if  c.equals(mapping.getOrElse(pop, None)) => stackAfterPop
                case _ => c +: stack
            }
           
        }.isEmpty
        
    }
}

```

```scala
object Solution {
    def isValid(s: String): Boolean = {
        if(s.length % 2 != 0){
            false
        }else{
        import scala.collection.mutable._
        val openingHashSet: HashSet[Char] = HashSet('(', '{', '[')
        val closingMap: Map[Char, Char] = Map(
             (')' -> '('),
             ('}' -> '{'),
             (']' -> '[')
         )                                                       
        val stack = Stack.empty[Char]
                       
        var output = true               
        import scala.util.control.Breaks._
        
        breakable{
            for(c <- s){
                if(stack.isEmpty){
                    if(openingHashSet.contains(c)){
                        stack.push(c)
                    }else{
                        output = false
                        break
                    }
                }else{
                    if(openingHashSet.contains(c)){
                        stack.push(c)
                    }else{
                        closingMap.get(c) match{
                            case Some(v) =>{
                                val top = stack.top
                                if(v == top){
                                    stack.pop()
                                }else{
                                    output = false
                                    break
                                }
                            }
                            case None =>{
                                output = false
                                break
                            }
                        }
                    }
                }
            }
        }               
        
        if(stack.isEmpty) output else false
    }
    }
}

```

###  3.20. <a name='Mergetwosortedlists'></a>21-Merge two sorted lists

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1rJ41127ry?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7D7?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1my4y127bK?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1qZ4y1j7Jb?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ck4y1k7J9?spm_id_from=333.999.0.0)

æš´åŠ›è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(M+N)

* æ—¶é—´å¤æ‚åº¦:O(1)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        cur = dummy # dummyæ˜¯å›ºå®šèŠ‚ç‚¹ï¼Œcuræ˜¯ç§»åŠ¨æŒ‡é’ˆ
        while list1 and list2: # è¿™é‡Œæ˜¯and
            if list1.val < list2.val: # æ˜“é”™ç‚¹ï¼šè¿™é‡Œæ˜¯list.valï¼Œè€Œä¸æ˜¯list
                cur.next = list1
                list1 = list1.next # å‘åè¿›ä¸€ä½
            else:
                cur.next = list2
                list2 = list2.next # å‘åè¿›ä¸€ä½
            cur = cur.next # å‘åè¿›ä¸€ä½
        cur.next = list1 or list2 # æ˜“é”™ç‚¹ï¼šè¿™é‡Œæ˜¯cur.nextï¼Œè€Œä¸æ˜¯curã€‚è¿™é‡Œæ˜¯or
        # ç­‰æ•ˆäºï¼š
        # if list1:
        #     cur.next = list1
        # else:
        #     cur.next = list2
        return dummy.next
```

é€’å½’è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(M+N)

* æ—¶é—´å¤æ‚åº¦:O(M+N)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        elif not list2:
            return list1
        elif list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next,list2) # æ‰¾åˆ°è¾ƒå°å¤´ç»“ç‚¹ï¼Œæå–å‡ºæ¥
            return list1
        else:
            list2.next = self.mergeTwoLists(list1,list2.next) # æ‰¾åˆ°è¾ƒå°å¤´ç»“ç‚¹ï¼Œæå–å‡ºæ¥
            return list2
```

```scala
/**
* chosen solution
* time complexity: O(N + M), N is the length of l1, M is the length of l2
*/

object Solution0 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        val headNode = new ListNode(-1, null)
        var cur = headNode
        
        var no1 = l1;
        var no2 = l2;
        
        while(no1 != null && no2 != null) {
            if (no1.x >= no2.x){
                
                cur.next = no2
                no2 = no2.next
            }else {
                cur.next = no1
                no1 = no1.next
            }
            cur = cur.next
        }
        (no1, no2) match {
            case (_, null) => cur.next = no1
            case (null, _) => cur.next = no2
            case _ => throw new RuntimeException()
        }
        
        headNode.next
    }
}



/**
* iterative version
* time complexity: O(N + M), N is the length of l1, M is the length of l2
*/
object Solution1 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        val headNode = new ListNode(-1, null)
        var cur = headNode
        
        var no1 = l1;
        var no2 = l2;
        
        while(no1 != null && no2 != null) {
            if (no1.x >= no2.x){
                
                cur.next = no2
                no2 = no2.next
            }else {
                cur.next = no1
                no1 = no1.next
            }
            cur = cur.next
        }
        (no1, no2) match {
            case (_, null) => cur.next = no1
            case (null, _) => cur.next = no2
            case _ => throw new RuntimeException()
        }
        
        headNode.next
    }
}



/**
* recursive version
*/

object Solution1-2 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        (l1, l2) match {
            case (null, _) => l2
            case (_, null) => l1
            case (a, b) => 
                if (a.x >= b.x){
                    b.next = mergeTwoLists(b.next, a)
                    b
                } else {
                    a.next = mergeTwoLists(a.next, b)
                    a   
                }
        }
    }
}
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        if(l1 == null){
            l2
        } else if(l2 == null){
            l1
        }else{
            var (ll1, ll2) = (l1, l2)
            var firstNext = if(ll1.x < ll2.x) ll1 else ll2
            var head = ListNode(0, firstNext)
            var curr = head
            
            
            while(ll1 != null && ll2 != null){
                if(ll1.x < ll2.x){
                    curr.next = ll1
                    curr = ll1
                    ll1 = ll1.next
                } else{
                    curr.next = ll2
                    curr = ll2
                    ll2 = ll2.next
                }
            }
            
            if(ll1 == null){
                curr.next = ll2
            }else{
                curr.next = ll1
            }
            
            head.next
        }
    }
}


//Alternate & Simpler solution
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
    if(l1 == null) return l2
    if(l2 == null) return l1

    if (l1.x < l2.x) {
      l1.next = mergeTwoLists(l1.next, l2)
      l1
    } else {
      l2.next = mergeTwoLists(l1, l2.next)
      l2
    }
  }
}

```

###  3.21. <a name='GenerateParentheses'></a>22. Generate Parentheses

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7t7?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1vK4y1b744?spm_id_from=333.999.0.0)

å›æº¯æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O($\frac{4^n}{\sqrt{n}}$)

* æ—¶é—´å¤æ‚åº¦:O($\frac{4^n}{\sqrt{n}}$)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.ud5vx6kpbvk.png" width="50%">

```py
# åŸºäºå°æ¢¦æƒ³å®¶
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm,res):
            if left == 0 and right == 0:
                res.append(itm)
                # é”™è¯¯å†™æ³•ï¼šreturn res = res.append(itm)ï¼Œè¿™é‡Œä¸éœ€è¦return
            if left > right: # ç›¸å½“äºn-left<n-right,è¡¨ç¤ºæ®‹ä½™çš„éƒ¨åˆ†
                return
            if left > 0:
                helper(left-1,right,itm + '(',res)
                # é”™è¯¯å†™æ³•ï¼šreturn item = '(' + helper(left-1,right,itm,res)ï¼Œè¿™é‡Œä¸éœ€è¦return
            if right > 0:
                helper(left,right-1,itm + ')',res)
                # é”™è¯¯å†™æ³•ï¼šreturn item = ')' + helper(left,right-1,itm,res)ï¼Œè¿™é‡Œä¸éœ€è¦return
        
        res = []
        helper(n,n,'',res)
        return res
```

```py
# åŸºäºä¸Šæ–¹ç­”æ¡ˆä¿®æ”¹
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm,res):
            if left == 0 and right == 0:
                res.append(itm)
                return # è¿™é‡Œreturnå†™ä¸å†™å±…ç„¶éƒ½acäº†ï¼Œå¯èƒ½æ˜¯å› ä¸ºæ²¡æœ‰å¾ªç¯å§
            if left > 0:
                helper(left-1,right,itm + '(',res)
            if right > left:
                helper(left,right-1,itm + ')',res)
        
        res = []
        helper(n,n,'',res)
        return res
```

```py
# åŸºäºä¸Šæ–¹ç­”æ¡ˆä¿®æ”¹ï¼Œhelperä¸­çš„åˆ é™¤res

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm):
            if left == 0 and right == 0:
                res.append(itm)
                return # è¿™é‡Œreturnå†™ä¸å†™å±…ç„¶éƒ½acäº†ï¼Œå¯èƒ½æ˜¯å› ä¸ºæ²¡æœ‰å¾ªç¯å§
            if left > 0:
                helper(left-1,right,itm + '(')
            if right > left:
                helper(left,right-1,itm + ')')
        
        res = []
        helper(n,n,'')
        return res
```

```py
class Solution:
    def generateParenthesis(self, n):
        ans = []
        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(''.join(S))
                return
            if left < n:
                S.append('(')
                backtrack(S, left+1, right)
                S.pop()
                # å‚è€ƒä¸Šæ–¹ï¼Œå¯ä»¥ç›´æ¥æŠŠ'('å†™åˆ°é€’å½’å‡½æ•°é‡Œé¢ï¼Œè¿™æ ·å°±ä¸éœ€è¦è¿˜åŸç°åœºã€‚
            if right < left:
                S.append(')')
                backtrack(S, left, right+1)
                S.pop()

        backtrack([], 0, 0)
        return ans
# ä¸Šæ–¹ç­”æ¡ˆï¼Œä¿®æ”¹åå¦‚ä¸‹ï¼š
```

```py
# ä¸Šæ–¹ç­”æ¡ˆï¼Œä¿®æ”¹åå¦‚ä¸‹ï¼š
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(S)
                return
            if left < n:
                backtrack(S + '(', left+1, right)
            if right < left:
                backtrack(S + ')', left, right+1)

        ans = []
        backtrack('', 0, 0)
        return ans
```

```py
# ä½œè€…è¯´ï¼šå¤´çš®å‘éº»ã€‚æˆ‘æ„Ÿè§‰æˆ‘æ˜¯å¤©æ‰ï¼Œ
# ä½œè€…è¯´ï¼šä½ ä»¬ä¸çŸ¥é“ç”¨æœ€åŸºæœ¬çš„å•ä½â€œ()â€è¿›è¡Œç»„è£…å—ã€‚
# ä½œè€…è¯´ï¼šç»å¯¹æ˜¯åŸåˆ›ä¸€æ¬¡è¿‡

class Solution:
    def generateParenthesis(self, n):
        if n == 1:
            return list({'()'})
        res = set()
        for i in self.generateParenthesis(n - 1):
            for j in range(len(i) + 2):
                res.add(i[0:j] + '()' + i[j:])
        return list(res)


# æˆ‘çš„æ¨¡ä»¿ğŸ˜
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # è¿™æ˜¯æˆ‘å†™çš„æ„šè ¢çš„ç»“æŸæ¡ä»¶ï¼š
        # if len(res[0]) == n:
        #     return
        if n == 1:
            return ['()']

        res = set()
        for itm in self.generateParenthesis(n-1):
            for j in range(len(itm)+1): # å¦‚æœitemçš„é•¿åº¦ä¸º4ï¼Œé‚£ä¹ˆå°±æœ‰5ä¸ªå¯ä»¥æ’å…¥çš„ä½ç½®
                # é”™è¯¯å†™æ³•ï¼š
                # itm = itm[:j] + '()' + itm[j:]
                # res = res.add(itm)
                # é”™è¯¯å†™æ³•ï¼š
                # res = res.add(itm[:j] + '()' + itm[j:])
                # æ­£ç¡®å†™æ³•ï¼š
                res.add(itm[:j] + '()' + itm[j:])
        return list(res)
```

```py
# ç›¸å½“äºæ¯”ä¸Šä¸€å±‚å°‘äº†ä¸€å±‚å¾ªç¯ã€‚
# ä¸æ‡‚æ˜¯ä¸æ˜¯åŠ¨æ€è§„åˆ’ï¼Œæ¯æ–°å¢ä¸€å¯¹æ‹¬å·ï¼Œ
# å°±æ˜¯åœ¨ä¸Šä¸€æ¬¡çš„ç»“æœçš„å„ä¸ªä½ç½®æ’å…¥ä¸€ä¸ª"()"ï¼Œç”¨é›†åˆé˜²æ­¢é‡å¤

class Solution:
    def generateParenthesis(self, n):
        result = {''}
        for i in range(n):
            temp = set()
            for s in result:  # åœ¨ä¸Šä¸€æ¬¡çš„ç»“æœçš„æ‰€æœ‰å­—ç¬¦ä¸²çš„å„ä¸ªä½ç½®ä¸Šæ’å…¥'()'
                for j in range(len(s) + 1):
                    temp.add(s[:j] + '()' + s[j:])
            result = temp
        return list(result)
```

```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        stack=[('',0,0)]
        ans=[]
        while stack:
            print("stack: ",stack)

            p,left,right=stack.pop() # å…ˆæŠŠpå¼¹å‡ºæ¥
            
            if left==right==n: #å¦‚æœç¬¦åˆæ¡ä»¶,å°±å›æ”¶
                ans.append(p)
                continue
            
            if left<n: #å¦‚æœç¬¦åˆæ¡ä»¶,å°±åŠ left
                stack.append((p+'(',left+1,right))
            if right<n and right<left: #å¦‚æœç¬¦åˆæ¡ä»¶,å°±åŠ right
                stack.append((p+')',left,right+1))
        return ans

# æˆ‘çš„æ¨¡ä»¿ğŸ˜ 
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        stack = [('',0,0)]
        res = []
        while stack:
            itm, left, right = stack.pop()
            if left == right == n:
                # é”™è¯¯å†™æ³•ï¼šres = res.append(itm)
                res.append(itm)
                # continue å†™æˆ–è€…ä¸å†™éƒ½èƒ½acï¼Œæˆ‘è¿·æƒ‘äº†

            if left < n:
                # é”™è¯¯å†™æ³•ï¼šitm, left, right = itm + '(', left + 1, right
                # é”™è¯¯å†™æ³•ï¼šstack.append(itm + '(', left + 1, right),åº”è¯¥è¦æœ‰åŒå±‚æ‹¬å·
                stack.append((itm + '(', left + 1, right))
            if right < left:
                # é”™è¯¯å†™æ³•ï¼šitm, left, right = itm + ')', left, right + 1
                # é”™è¯¯å†™æ³•ï¼šstack.append(itm + ')', left, right + 1),åº”è¯¥è¦æœ‰åŒå±‚æ‹¬å·
                stack.append((itm + ')', left, right + 1))
        return res
```

```py
# æ¯”è¾ƒè´¹è„‘å­ï¼Œå¯ä»¥ä¸çœ‹ğŸ˜ 
class Solution:
    def generateParenthesis(self, n):
        if n == 0:
            return [""]
        if n == 1:
            return ["()"]
        # è¿™ä¸¤è¡Œå…¶å®å¯æœ‰å¯æ— ï¼š
        # elif n == 2: 
        #     return ["()()", "(())"] 
        result = []
        for i in range(n):
            j = n - 1 - i
            temp1 = self.generateParenthesis(i)
            temp2 = self.generateParenthesis(j)
            result.extend(["(%s)%s" % (p, q) for p in temp1 for q in temp2])
        return result
# result.extend(["(%s)%s" % (p, q) for p in temp1 for q in temp2]) è¿™å¥æ˜¯ä»€ä¹ˆæ„æ€å‘€ï¼Ÿ
# %æ˜¯æ ¼å¼åŒ–å­—ç¬¦ä¸²è¾“å‡ºï¼Œextendæ˜¯æŠŠç»“æœå‡‘èµ·æ¥ã€‚è¿™è¡Œä»£ç å¹²çš„äº‹å…¶å®æ˜¯é€’å½’ç”Ÿæˆæ‹¬å·ã€‚
# å¦‚æœæŠŠæ‰€æœ‰çš„æƒ…å†µåˆ†è§£æ‹†å¼€ï¼Œå‘ç°æœ€åº•å±‚çš„å½¢å¼æ— én=0, 1è¿™2ç§æƒ…å†µï¼Œ
# é‚£ä¹ˆæˆ‘ä»¬å…¶å®å¯ä»¥è®©æ‹¬å·ä¸€å±‚ä¸€å±‚åŒ…è£¹èµ·æ¥ã€‚è¿™è¡Œä»£ç å…¶å®å°±æ˜¯ä¸€å±‚ä¸€å±‚åŒ…è£¹æ‹¬å·ã€‚
# forå¾ªç¯é‡Œé¢å­˜åœ¨é‡å¤è®¡ç®—å§ï¼Œæ¯”å¦‚è¯´n=7çš„æ—¶å€™ï¼Œi=2,j=4è®¡ç®—äº†2å’Œ4ä¸ªæ‹¬å·çš„å…¨æ’åˆ—ï¼Œi=4ï¼Œj=2çš„æ—¶å€™åˆè®¡ç®—äº†ä¸€éï¼Œå…¶å®å¯ä»¥åªè®¡ç®—ä¸€åŠï¼Œç„¶åå…¨æ’åˆ—çš„æ—¶å€™på’Œqè°ƒä¸€ä¸‹ä½ç½®å°±è¡Œäº†ã€‚

# æˆ‘çš„æ¨¡ä»¿ğŸ˜ 
class Solution:
    def generateParenthesis(self, n):
        res = []
        if n == 0:
            return ['']
        if n == 1:
            return ['()']
        for i in range(n):
            j = n-1-i
            tmplist1 = self.generateParenthesis(i)
            tmplist2 = self.generateParenthesis(j)
            # é”™è¯¯å†™æ³•ï¼šreturn res.extend(['(%s)%s' for item1 in tmplist1 for item2 in temlist2])
            res.extend(['(%s)%s' % (item1,item2) for item1 in tmplist1 for item2 in tmplist2])
        return res
```

```scala
/**
* my first commitment 
* DFS + backtracking
* time complexityï¼š O(4^n / square(n))
*     n-th Catalan number
*/

object Solution1 {
  def generateParenthesis(n: Int): List[String] = {
    val buffer = scala.collection.mutable.ListBuffer[String]()
    val l = "("
    val r = ")"

    def _generateParenthesis(right: Int, left: Int, n: Int, pair: String) {

      if (right == n && left == n) {
        buffer += pair
      } else {
        if (left < n) _generateParenthesis(right, left + 1, n, pair + l) // you can add open whenever you want if it's smaller then n
        if (left > right && right < n) _generateParenthesis(right + 1, left, n, pair + r)
      }
    }
    _generateParenthesis(0, 0, n, "")
    buffer.toList
  }
}

/**
* closure number
* a very genius and beautiful sol
*/
object Solution2 {
  def generateParenthesis(n: Int): List[String] =
    n match {
      case 0 => List("")
      case _ =>
        for{
          m <- (0 until n).toList  // ensure yield type is List instead of indexSeq
          leftString <- generateParenthesis(m)
          rightString <- generateParenthesis(n - m - 1)
        } yield "(" ++ leftString ++ ")" ++ rightString
    }
}

```

```scala
//Backtracking approach
//Memory limit exceeds from n=6
//works till n=5

object Solution {
    var output = scala.collection.mutable.Set.empty[String]
    var qualified = scala.collection.mutable.Set.empty[String]
    
    def isBalanced(chars: Array[Char]): Boolean = {
        var count = 0
        var flag = true
        var stack = scala.collection.mutable.Stack[Char]()
        
        stack.pushAll(chars)
        
        import scala.util.control.Breaks._
        
        breakable{
            while(!stack.isEmpty){
                val pop = stack.pop()
                if(count <= 0 && pop == '('){
                    flag = false
                    break
                }else if(pop == ')'){
                    count += 1
                }else{
                    count -= 1
                }
            }
        }
         
        if(flag && count == 0){
            true
        }else{
            false
        }
    }
    
    def backtrack(chars: Array[Char], l: Int, r: Int): Unit = {
        
        def swap(a: Int, b: Int) = {
            val temp = chars(a)
            chars(a) = chars(b)
            chars(b) = temp
        }
        
        
        if(l == r){
            val str = chars.mkString
            if(! qualified.contains(str)){
                qualified.add(str)
                if(isBalanced(chars)){
                    output.add(str)
                }
            }
        }else{
                (l to r).map(i => {
                swap(l, i)
                backtrack(chars, l+1, r)
                swap(l, i) //backtrack step
                })
        }
    }
    
    def generateParenthesis(n: Int): List[String] = {
        output = scala.collection.mutable.Set.empty[String]
        qualified = scala.collection.mutable.Set.empty[String]
        
        val inputString = (1 to n).map(_ => '(').mkString + (1 to n).map(_ => ')').mkString
        var inputCharArray = inputString.toCharArray
        
        backtrack(inputCharArray, 0, n+n-1)
        
        output.toList
    }
}


/**
In the above approach, what we are basically doing is getting all possible combinations and then filtering the ones that are balanced.
that is kinda brute force actually
In the below approach (also backtracking), we apply constraints, during forming the string itself
*/

object Solution {
    
    def generateParenthesis(n: Int): List[String] = {
        import scala.collection.mutable._
        def backtrack(acc: ListBuffer[String], curr: String, left: Int, right: Int): Unit = {
            if (left == 0 && right == 0) acc.append(curr)
            else {
                if (left > 0) backtrack(acc, curr + "(", left-1, right)
                if (right > left) backtrack(acc, curr + ")", left, right-1)
            }
        }
      
        val acc = ListBuffer[String]()
        backtrack(acc, "", n, n)
        acc.toList
    }
}

```

###  3.22. <a name='MergekSortedLists'></a>23. ã€æœ€å°å †ğŸŒµã€‘Merge k Sorted Lists

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1X4411u7xF?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ty4y1178e?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1GK41157mu?spm_id_from=333.999.0.0)

æš´åŠ›æ±‚è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦: O(N) + O(N logN) + O(N)

* ç©ºé—´å¤æ‚åº¦: O(N) + O(N)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.65tcjjz2oy80.png" width="50%">

```py
# so easyï¼Œä¸€éè¿‡
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        arr = []
        for listhead in lists:
            while listhead:
                arr.append(listhead.val)
                listhead = listhead.next
        arr.sort()
        dummy = ListNode(0)
        cur = dummy
        for value in arr:
            cur.next = ListNode(value)
            cur = cur.next
        return dummy.next
```

ä¼˜å…ˆé˜Ÿåˆ—ï¼š

* æ—¶é—´å¤æ‚åº¦: O(N logk) 

* ç©ºé—´å¤æ‚åº¦: O(N) + O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3tftyqf2g4s0.png" width="50%">

```py
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        q = []  # æ˜“é”™ç‚¹ï¼šå…ˆè¦å®šä¹‰ä¸€ä¸ªç©º
        dummy = ListNode(0)
        cur = dummy
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(q,(lists[i].val,i))  # æ˜“é”™ç‚¹ï¼šè¦å¯ä»¥æ’åºçš„
                lists[i] = lists[i].next # æ˜“é”™ç‚¹ï¼šæ³¨æ„ï¼Œå‘åä¸€ä½
        while q: # æ˜“é”™ç‚¹ï¼šæ³¨æ„è¿™ä¸ªå¾ªç¯æ¡ä»¶
            val, idx = heapq.heappop(q)
            cur.next = ListNode(val)
            cur = cur.next
            if lists[idx]:
                heapq.heappush(q,(lists[idx].val,idx))
                lists[idx] = lists[idx].next # æ˜“é”™ç‚¹ï¼šæ³¨æ„ï¼Œå‘åä¸€ä½
        return dummy.next
```

ä¸¤ä¸¤åˆå¹¶ï¼š

* æ—¶é—´å¤æ‚åº¦: O(N logk) 

* ç©ºé—´å¤æ‚åº¦: O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.60itjgowwpo0.png" width="50%">

```py
class Solution:
    def merge2Lists(self, list1, list2):
        dummy = ListNode(0)
        cur = dummy # dummyæ˜¯å›ºå®šèŠ‚ç‚¹ï¼Œcuræ˜¯ç§»åŠ¨æŒ‡é’ˆ
        while list1 and list2: # è¿™é‡Œæ˜¯and
            if list1.val < list2.val: # æ˜“é”™ç‚¹ï¼šè¿™é‡Œæ˜¯list.valï¼Œè€Œä¸æ˜¯list
                cur.next = list1
                list1 = list1.next # å‘åè¿›ä¸€ä½
            else:
                cur.next = list2
                list2 = list2.next # å‘åè¿›ä¸€ä½
            cur = cur.next # å‘åè¿›ä¸€ä½
        cur.next = list1 or list2 # æ˜“é”™ç‚¹ï¼šè¿™é‡Œæ˜¯cur.nextï¼Œè€Œä¸æ˜¯curã€‚è¿™é‡Œæ˜¯or
        return dummy.next

    def mergeKLists(self, lists: List[ListNode]) -> ListNode:     
        amount = len(lists)
        interval = 1
        while amount > interval:
            for i in range(0,amount-interval,2*interval):
                lists[i] = self.merge2Lists(lists[i], lists[i+interval]) # æ˜“é”™ç‚¹ï¼šæ–¹æ‹¬å·å’Œå°æ‹¬å·ä¸è¦ç”¨é”™
            interval *= 2
        return lists[0] if amount>0 else None
```

###  3.23. <a name='SwapNodesinPairs'></a>24-Swap Nodes in Pairs

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1M7411n7FT?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV13J411V7hG?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ih411f7YK?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1VC4y1s75E?spm_id_from=333.999.0.0)

```py
# æ–¹æ³•ä¸€ï¼šé€’å½’
class Solution(object):
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        # è¿™æ ·å†™ä¹Ÿå¯ä»¥ï¼š
        # if not head or not head.next:
        #     return head
        if not head:
            return None
        if not head.next:
            return head
        tmp = head.next
        head.next = self.swapPairs(head.next.next)
        tmp.next = head
        return tmp # æ˜“é”™ç‚¹ï¼šæ³¨æ„ï¼Œæ–°çš„å¤´å·²ç»å˜æˆäº†tmp
``` 

```py
# æ–¹æ³•äºŒï¼šè¿­ä»£
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head # æ˜“é”™ç‚¹ï¼šè¿™å¥è¯ä¸è¦æ¼
        cur = dummy
        while cur.next and cur.next.next:

            first = cur.next
            second = cur.next.next
            
            # æŠŠå›¾ç”»å‡ºæ¥
            first.next = second.next
            second.next = first
            cur.next = second

            cur = cur.next.next
        return dummy.next
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */

/**
* chosen solution
* iterative version
* memo
*   1. dummyHead
*   2. need two pointer: pre node and current node
*  time complexity: O(N), each node only visit once
*/
object Solution0 {
    def swapPairs(head: ListNode): ListNode = {
        val nHead = new ListNode(0, head)
        var pre: ListNode  = nHead
        var curr = pre.next

        while (curr != null && curr.next != null) {
            val (pos1, pos2, next) = (curr, curr.next, curr.next.next)
            pre.next = pos2
            pos2.next = pos1
            pos1.next = next

            pre = pre.next.next
            curr = pre.next  
        }
        
        nHead.next
    }
}


/**
* iterative version
* memo
*   1. dummyHead
*   2. need two pointer: pre node and current node
*  time complexity: O(N), each node only visit once
*/
object Solution1 {
    def swapPairs(head: ListNode): ListNode = {
        val nHead = new ListNode(0, head)
        var pre: ListNode  = nHead
        var curr = pre.next

        while (curr != null && curr.next != null) {
            val (pos1, pos2, next) = (curr, curr.next, curr.next.next)
            pre.next = pos2
            pos2.next = pos1
            pos1.next = next

            pre = pre.next.next
            curr = pre.next  
        }
        
        nHead.next
    }
}


/**
* recursive version
*/
object Solution2 {
    def swapPairs(head: ListNode): ListNode = {
        _swap(head)
    }   
    
    def _swap(n: ListNode): ListNode = {
        if(n == null) n
        else {
            (n, n.next) match {
                case (a, null) => a
                case (a: ListNode, b: ListNode) => 
                    /** a b è¦äº¤æ›ä½å­
                     */
                    a.next = _swap(b.next) // a æŒ‡å‘ b çš„ next (å·²äº¤æ›å®Œæˆï¼‰
                    b.next = a // b çš„ next æ¥ä¸Š a å°±äº¤æ›å®Œæˆ
                    b
            }
        } 
    }
}
```

###  3.24. <a name='Removeduplicatesfromsortedarray'></a>26-Remove duplicates from sorted array

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1UJ411m7Pz?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i77e?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV13V41177Mq?spm_id_from=333.999.0.0)

> forå¾ªç¯æ³•ï¼š

```py
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        if n == 0: return 0
        left = 0
        for right in range(1, n):
            if nums[right] != nums[left]:
                left += 1
                nums[left] = nums[right]
        return left + 1

# ğŸ˜æˆ‘çš„æ¨¡ä»¿
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        count = 0 #æ³¨æ„ï¼šcountæ˜¯ä»0å¼€å§‹çš„
        for i in range(len(nums)):
            if nums[i] != nums[count]:
                count += 1
                nums[count] = nums[i]
        return count + 1
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.xxd39w8j94g.png" width="30%">

> whileå¾ªç¯æ³•

```py
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        i = 0
        while i < (len(nums) - 1):
            if nums[i] == nums[i+1]:
                nums.remove(nums[i])
                ç­‰æ•ˆäºï¼šnums.pop(i)
            else:
                i += 1
        return len(nums)

# ğŸ˜æˆ‘çš„æ¨¡ä»¿ï¼š
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        i = 0
        while i < len(nums) - 1:
            if nums[i] == nums[i+1]:
                nums.pop(i)
                i -= 1 # å½“popä»¥åï¼ŒiæŒ‡é’ˆä¸åº”è¯¥å˜åŒ–
            i += 1
        return len(nums)
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6zs7v6d4w740.png" width="60%">

```scala

object Solution {
    def removeDuplicates(nums: Array[Int]): Int = {
        
        // Two-pointer idea
        
        if (nums.length == 0){
            0
        } else {
            // if the Array is not empty, we start from index 1 rather than 0
            // since the 1st element (at index 0) will be included for sure.
            // For the same reason, the initial value of `count` is 1 instead of 0
            
            var count = 1
            
            // NOTE: start from 1 rathr than 0 here
            for (i <- 1 until nums.length) {
                if (nums(i) != nums(count-1)) {
                    nums(count) = nums(i)
                    count += 1
                }
            }
            
            count
        }
         
    }
}
```

```scala
object Solution {
    def removeDuplicates(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var head = 0
            var find = 1
            while(find < nums.length){
                if(nums(find) != nums(head)){
                    head += 1
                    nums(head) = nums(find)
                }
                find += 1
            }
            head + 1
        }
    }
}

```

###  3.25. <a name='python-Removeelement'></a>27-python-Remove element

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1mJ411m7ir?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7hZ?spm_id_from=333.999.0.0)

å’Œä¸Šé¢ä¸€ä½“å·®ä¸å¤šï¼Œå¾ˆç®€å•

```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        while i < len(nums):
            if nums[i] == val:
                nums.pop(i)
            else:
                i += 1
        return len(nums)
```

###  3.26. <a name='Implementstr'></a>28-Implement str

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1eL411n7YS?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1BJ41117d6?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1UK411K7zB?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7cG?spm_id_from=333.999.0.0)

è§£æ³•ä¸€ï¼šç›´æ¥ç”¨.index()

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle == "":
            return 0
        if needle in haystack:
            return haystack.index(needle)
        else:
            return -1
```

è§£æ³•äºŒï¼šåœ¨å¯¹æ•´ä¸ªneedleå­—ç¬¦ä¸²æ¯”è¾ƒ

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        for i in range(len(haystack)-len(needle)+1):
            if haystack[i:i+len(needle)] == needle:
                return i 
        return -1
```

```scala
object Solution {
    def strStr(haystack: String, needle: String): Int = {
        if(needle.isEmpty){
            0
        }else if(haystack.isEmpty){
            -1
        }else{
            var needleLength = needle.length
            var head = 0
            var end = head + needleLength
            var flag = true
            
            while(flag && (end <= haystack.length)){
                if(needle.equals(haystack.substring(head, end))){
                    flag = false
                }else{
                    head += 1
                    end += 1
                }
            }
            
            if(flag) -1 else head
        }
    }
}

```

###  3.27. <a name='NextPermutation'></a>31 Next Permutation

[å°æ˜](https://www.bilibili.com/video/BV1Uz4y1m72N?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1SK4y1V7ch?spm_id_from=333.999.0.0)

```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # å…³é”®åœ¨äºä»åå¾€å‰ï¼Œæ‰¾åˆ°éé€’å‡åºåˆ—
        i = len(nums) - 2
        while i >= 0:
            if nums[i] >= nums[i+1]:
                i -= 1
            else:
                # å¯»æ‰¾iåé¢æ¯”iå¤§çš„æ•°ï¼Œäº¤æ¢ä½ç½®,å¹¶ä¸”æ’åº
                for j in range(len(nums)-1,i,-1): # æ˜“é”™ç‚¹:len(nums)-1,içš„åŒºé—´
                    # 12(3)5(4)
                    if nums[j] > nums[i]:
                        nums[i],nums[j] = nums[j],nums[i]
                        nums[i+1:] = sorted(nums[i+1:])
                        return
        nums.reverse() # æ˜“é”™ç‚¹:å¯¹äº[3,2,1]è¿™ç§æƒ…å†µï¼Œi = 0
```

```scala
/**
* my first commitment
* memo
* 1. find the first index i which breaks the increasing order
* 2. find the last index  j which is larger than index i
* 3. swap(i, j)
* 4. sorting: reverse sequence from i + 1 to the end 
* time complexity: O(n)
*/

object Solution1 {
    def nextPermutation(nums: Array[Int]): Unit = {
        /**
        * find the first index i which breaks the increasing order
        * 0 1 2 3 4 5 6
        * 5 4 7 6 5 4 3
        *   i     j 
        */
      ((nums.length - 2) to 0 by -1).find(idx => nums(idx) < nums(idx + 1)) match {
        case Some(idx) => 
          /* 
          * find the last index  j which  is larger than index i
          */
          val j = ((idx + 1) until nums.length).findLast(i => nums(idx) < nums(i)).getOrElse(idx)
          swap(nums, idx, j)
          reverse(nums, idx + 1, nums.length - 1)
        case None => reverse(nums, 0, nums.length - 1)
      }
    }
    @annotation.tailrec
    def reverse(nums: Array[Int], from: Int, to: Int) {
      if (from < to) {
        swap(nums, from, to)
        reverse(nums, from + 1, to - 1)
      }
    }
  
    def swap(nums: Array[Int], index1: Int, index2: Int) {
      val tmp = nums(index2)
      nums(index2) = nums(index1)
      nums(index1) = tmp
    }
}


```

###  3.28. <a name='LongestValidParentheses'></a>32 Longest Valid Parentheses

[å°æ˜](https://www.bilibili.com/video/BV1RZ4y1F7nJ?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1yi4y1G74d?spm_id_from=333.999.0.0)

åŠ¨æ€è§„åˆ’ï¼š

* æ—¶é—´å¤æ‚åº¦: O(n) 

* ç©ºé—´å¤æ‚åº¦: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6dkova4yjvk0.png)

```py
# èƒŒä¸€èƒŒå§ï¼Œå¥½éš¾ã€‚
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0]*n
        if n == 0: return 0
        for i in range(n):
            if s[i] == ')' and s[i-dp[i-1]-1] == '(' and i - dp[i-1] - 1 >= 0:
                dp[i] = 2 + dp[i-1] + dp[i-dp[i-1]-2]
        return max(dp)
```

æ ˆï¼š

* æ—¶é—´å¤æ‚åº¦: O(n) 

* ç©ºé—´å¤æ‚åº¦: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1dgqk0ervhb4.png)

```py
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        length = maxlength = 0
        for i,c in enumerate(s):
            if c == '(':
                stack.append(i)
            if c == ')':
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    length = i - stack[-1]
                    maxlength = max(maxlength,length)
        return maxlength

```

```scala



/**
* using stack to record the char index in oder to calculate the valid length
* memo:
* 1. always only have one invalid symbol at stack and its position index is 0
* time complexity O(n)
* space complexity O(n)
*/
object Solution1 {

  import collection.mutable

  def longestValidParentheses(s: String): Int = {
    val mapping = Map('(' -> ')')
    val stack = mutable.Stack[Int]()
    stack.push(-1)
    s.indices.foldLeft(0) {
      case (maxLength, idx) =>
        val char = s(idx)
        if (mapping.contains(char)) {
          stack push idx
          maxLength
        } else {
          stack.pop()
          if (stack.isEmpty) {
            stack push idx
            maxLength
          } else {
            (idx - stack.head) max maxLength
          }
        }
    }
  }
}
```

###  3.29. <a name='SearchinRotatedSortedArray'></a>33. Search in Rotated Sorted Array

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1gJ411V7Sq?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV14t4y127hK?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV16A41147Fp?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # å®šä¹‰ç¬¬ä¸€ä¸ªå…ƒç´ å’Œæœ€åä¸€ä¸ªå…ƒç´ 
        left, right = 0, len(nums) - 1
        while left <= right:
            # æ‰¾åˆ°äºŒåˆ†çš„ä½ç½®ï¼š
            # mid = l + ((r - l) >> 2)
            # mid = (l + r) // 2
            mid = (right + left) // 2
            # ç¬¬ä¸€æ­¥
            if nums[mid] == target:
                return mid

            # --------------ç¬¬äºŒæ­¥ï¼šæ ¸å¿ƒä»£ç --------------
            # åªå­˜åœ¨ä¸€ä¸ªä¸Šå‡åºåˆ—
            if nums[mid] < nums[right]:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
            else:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            # --------------ç¬¬äºŒæ­¥ï¼šæ ¸å¿ƒä»£ç --------------
        return -1

# æˆ‘çš„æ¨¡ä»¿ï¼å•ŠğŸ˜‹

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1

        while l <= r:
            m = (l+r) // 2
            if nums[m] == target:
                return m
            if nums[l] <= nums[m]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else: 
                    l = m + 1
            else:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else: 
                    r = m - 1
        
        return -1
```

```py
# è¿™é“é¢˜ç®€ç›´æ˜¯åœ¨è·Ÿæˆ‘å¼€ç©ç¬‘ï¼ˆç‹—å¤´ï¼‰

class Solution(object):
    def search(self, nums, target):
        return nums.index(target) if target in nums else -1
```

```scala


/**
* my first commitment
* binary search
* memo
* 1. check if it is sorted side first. if side is sorted, using the normal binary search function , or else using the search function 
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
        search(nums, target, 0 , nums.length - 1)
    }
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      
      val mid = left + (right - left) / 2
      val midValue = nums(mid)
      
      if (midValue == target) return mid
      
      val leftAns = if (nums(left) < midValue)  
        searchOrder(nums, target, left, mid - 1)
      else 
        search(nums, target, left, mid - 1)
      
      if (leftAns != -1) 
        leftAns
      else {
        if (midValue < nums(right))
           searchOrder(nums, target, mid + 1, right)
        else
          search(nums, target, mid + 1, right)
      } 
    }
  
    def searchOrder (nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      val mid = left + (right - left) / 2
      val midValue = nums(mid)
      if (midValue == target) 
       mid
      else if (target > midValue)
        searchOrder(nums, target, mid + 1, right)
      else 
        searchOrder(nums, target, left, mid - 1)
    }
}


/**
* binary search - iterative version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      
      var ans = -1
      while(ans == -1 && left <= right) {
        val mid = left + (right - left) / 2

        if (target == nums(mid) ){
          ans = mid

        } else if (nums(left) <= nums(mid)){ // left part is in order
          if (nums(mid) > target && target >= nums(left)) { // target is in left part
            right = mid - 1
          } else {
            left = mid + 1
          }
        } else { // right part is in order
          if (nums(mid) < target && target <= nums(right)) { // target is in right part
            left = mid + 1
          } else {
            right = mid - 1
          }
        } 
      }
      ans
    }
}


```

###  3.30. <a name='-1'></a>34-åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ª

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Zv411y71t?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1GU4y1j7dq?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ef4y1v7Vz?spm_id_from=333.999.0.0)

```py
# Python äºŒåˆ†æ³•

class Solution:
    def searchRange(self, nums, target):
        left = 0
        right = len(nums)-1
        res = [0,0]
        
        if target not in nums:
            return [-1,-1]

        # å¯»æ‰¾å·¦ä¾§è¾¹ç•Œ
        while(left<=right):
            mid = (right + left) // 2
            if nums[mid] == target:
                right = mid - 1 # ç»“æŸæ¡ä»¶
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[0] = left

        # å¯»æ‰¾å³ä¾§è¾¹ç•Œ
        right = len(nums)-1
        while left<=right:
            mid = (right + left) // 2
            if nums[mid] == target:
                left = mid + 1 # ç»“æŸæ¡ä»¶
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[1] = right

        return res
```

```py
# äºŒåˆ†æœç´¢ç®—æ³•è¿”å›é¦–ä¸ªä¸å°äºï¼ˆå³ï¼šç­‰äºæˆ–å¤§äºï¼‰targetçš„å…ƒç´ çš„ä¸‹æ ‡ï¼Œè¿™æ ·åªéœ€è¿›è¡Œä¸¤æ¬¡ç›¸ä¼¼çš„äºŒåˆ†æœç´¢å³å¯

# è¿™ç§æ–¹æ³•å¾ˆæ¼‚äº®ï¼Œä½†æ˜¯å¾ˆå®¹æ˜“å‡ºé”™ï¼Œä¸æ¨èã€‚

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = self.binarySearch(nums, target)
        end = self.binarySearch(nums, target+1)
        if start < end:
            return [start,end-1]
        else:
            return [-1,-1]
    
    def binarySearch(self, nums, target):
        l = 0
        r = len(nums)  # ç²¾å,åƒä¸‡ä¸èƒ½-1ï¼Œ
        while l < r: # ç²¾å,åƒä¸‡ä¸èƒ½åŒ…æ‹¬==ï¼Œ
            m = (l + r) // 2
            # ç”±äºè¿™é‡Œå­˜åœ¨å¤šä¸ªé‡å¤æ•°å­—ï¼Œæ‰€ä»¥ç®€å•çš„äºŒåˆ†æŸ¥æ‰¾ä¸é¡¶ç”¨
            # è¿™é‡Œçš„æ€æƒ³æ˜¯æ‰¾åˆ°left
            if target > nums[m]: # ç²¾å,åƒä¸‡ä¸èƒ½åŒ…æ‹¬==ï¼Œä¸ç„¶leftä¸èƒ½ç§»åŠ¨
                l = m + 1 # ç²¾å
            else:
                r = m
        return l

```

```scala


/**
* my first commitment
*
*/
object Solution1 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
      val hit = search(nums, target, 0, nums.length - 1)
      if (hit == -1)
        Array(-1, -1)
      else  {
        var left = hit
        while (left - 1 >= 0 && nums(left) == nums(left - 1)){
          left -= 1
        }
        var right = hit
        while(right + 1 < nums.length && nums(right) == nums(right + 1)){
          right += 1
        }
        Array(left, right)
      }
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if (left > right) return -1
      
      val mid = left + (right - left) / 2
       
      if (nums(mid) == target)
        mid
      else if (nums(mid) > target)
        search(nums, target, left, mid - 1)
      else 
        search(nums, target, mid + 1, right)
      
      
    }
 }

/**
* function programming
*/

 object Solution1-2 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
      val hit = search(nums, target, 0, nums.length - 1)
      if (hit == -1)
        Array(-1, -1)
      else {
        val left = (hit to 0 by -1 ).findLast(l => nums(l) == nums(hit)).getOrElse(-1)
        val right = (hit to (nums.length - 1)).findLast(r => nums(r) == nums(hit)).getOrElse(-1)
        Array(left, right)
      } 
    }
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if (left > right) return -1
      val mid = left + (right - left) / 2
       
      if (nums(mid) == target)
        mid
      else if (nums(mid) > target)
        search(nums, target, left, mid - 1)
      else 
        search(nums, target, mid + 1, right)
    }
 }

/**
* modify binary search template
* memo
*  1. search first and last the the same function
*  2. if nums(mid) == target we could move left to check if left part exists target number
*  3. finding last by target + 1,  then we could get last position of target by first position of (target + 1) - 1
* tricky:
*  1. ans = nums.length
*  2. first > last  means that target doesn't exists
*
* time complexity: O(2logN)
*/
 
 object Solution2 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
        val first = search(nums, target)
        val last = search(nums, target + 1) - 1
        if (first > last) Array(-1, -1) else Array(first, last)
    }

    def search(nums: Array[Int], target: Int): Int = {
      var ans = nums.length
      var left = 0
      var right = nums.length - 1
      while (left <= right) {
        val mid = left + (right - left) / 2
        if (nums(mid) >= target) {
          ans = mid
          right = mid - 1
        }else {
          left = mid + 1
        } 
      }
      ans
    }
}

/**
* recursive version
*/
object Solution2-1 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
      val first = search(nums, target, 0, nums.length - 1, nums.length)
      val last = search(nums, target + 1, 0, nums.length - 1, nums.length) - 1
      if (first > last) Array(-1, -1) else Array(first, last)
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int, ans: Int): Int = {
      if (left > right) return ans
      val mid = left + (right - left) / 2
      
      if (nums(mid) == target)
        search(nums, target, left, mid - 1, mid)
      else if (nums(mid) > target)
        search(nums, target, left, mid - 1, mid)
      else
        search(nums, target, mid + 1, right, ans)
      
    }
}

```

###  3.31. <a name='-1'></a>35-æœç´¢æ’å…¥ä½ç½®

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1HD4y1m7U2?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1eb411i7Aj?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1dA411a7CB?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1wf4y1m7Ue?spm_id_from=333.999.0.0)

* æ—¶é—´å¤æ‚åº¦: O(logn) 

* ç©ºé—´å¤æ‚åº¦: O(1)

```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if target == nums[m]:
                return m
            elif target < nums[m]:
                r = m - 1
            else: 
                l = m + 1
        return l #æ˜“é”™ç‚¹ï¼šè®°ä½ï¼Œè¿™é‡Œéœ€è¦è¾“å‡ºï¼Œä¸”è¾“å‡ºleft
```

```scala

/**
* my first commitment
*/
object Solution1 {
    def searchInsert(nums: Array[Int], target: Int): Int = {
        search(nums, target)
    }
    
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        val mid = left + (right - left) / 2
        
        if (nums(mid) == target)
          ans = mid
        else if (nums(mid) > target)
          right = mid - 1
        else
          left = mid + 1
        
      }
      if (ans == -1) left else ans
    }
}
```

###  3.32. <a name='-1'></a>36-æœ‰æ•ˆçš„æ•°ç‹¬

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Cf4y1R7PR?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1MJ411p7FT?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ZL4y1e7oo?spm_id_from=333.999.0.0)

```py
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        cols = [set() for _ in range(9)]
        rows = [set() for _ in range(9)]
        grids = [[set() for _ in range(3)] for _ in range(3)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    if board[i][j] in cols[j] or \
                    board[i][j] in rows[i] or \
                    board[i][j] in grids[i//3][j//3]:
                        return False
                    else:
                        cols[j].add(board[i][j])
                        rows[i].add(board[i][j])
                        grids[i//3][j//3].add(board[i][j])
        return True
```

```scala
object Solution {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        
        
        import util.control.Breaks._
        
        def check_a_single_array(l: Array[Char]): Boolean = {
            // input: Array of char, an Array of 9 elments to check using the three rules
            // return: Boolean, if the array given can pass the exam
            val temp = l.filter(_ != '.')
            if (temp.length != temp.distinct.length) {
                false
            } else {
                true
            }
        }
        
        
        var error_flag = 0
        
        breakable {
            
            // check rule-1
            for (i <- 0 until 9) {
                if (check_a_single_array(board(i)) ==  false) {
                    error_flag += 1
                    break
                }
              }

            // check rule-2
            for (i <- 0 until 9) {
                val temp_list = board.map(_(i))
                
                if (check_a_single_array(temp_list) == false) {
                    error_flag += 1
                    break
                }
            }
            
            // check rule-3
            for (i <- 0 until 3; j <- 0 until 3) {
                // get each 3x3 sub-boxes and flatten it to a 9-length Array
                val temp_list = board.slice(i * 3, i * 3 + 3).flatMap(_.slice(j * 3, j*3 + 3))
                
                if (check_a_single_array(temp_list) == false) {
                    error_flag += 1
                    break
                }
            }
 
        }

 
        if (error_flag > 0) false else true
         
    }
}
```

```scala

/**
* chosen solution
* memo
*   1. three array recording whether current value is valid
*        1. rows array
*        2. columns array
*        3. blocks array
* time complexity: O(1), just one iteration
* space complexity: O(3), all sudoku are 9 x 9 
*/
object Solution0 {
  def isValidSudoku(board: Array[Array[Char]]): Boolean = {
      val size = board.length
      val rows = Array.ofDim[Boolean](size, size)
      val cols =  Array.ofDim[Boolean](size, size)
      val blocks =  Array.ofDim[Boolean](size, size)
      
      val coords = for(i <- board.indices.view; j <- board.indices.view; if board(i)(j) != '.') yield (i, j)
      
      coords.forall{ case (i, j) => 
          val num = board(i)(j).asDigit - 1
          val blockIdx = (i / 3) * 3 + (j / 3)
          if(!rows(i)(num) && !cols(j)(num) && !blocks(blockIdx)(num)){
            rows(i)(num) = true
            cols(j)(num) = true
            blocks(blockIdx)(num) = true
            true
        
          } else false
      }
  }
}

  
  /**
  *  recursive version : DFS
  *  memo
  *    1. three array recording whether current value is valid
  *        1. rows array
  *        2. columns array
  *        3. blocks array
  * time complexity: O(1), just one iteration
  * space complexity: O(3), all sudoku are 9 x 9
  */
  object Solution1 {

    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
      def _isValidSudoku(currentRow: Int, currentCol: Int, cols: Array[collection.mutable.Set[Char]], rows: Set[Char], blocks: Array[collection.mutable.Set[Char]]): Boolean = {
        (currentRow < board.length, currentCol < board.length) match {
          case (false, _) => true
          case (true, true) => // current line next position
            val v = board(currentRow)(currentCol)
            val blockIndex = 3 * (currentRow / 3) + currentCol / 3
            if (v == '.') {
              _isValidSudoku(currentRow, currentCol + 1, cols, rows, blocks)

            } else {
              if (cols(currentCol).contains(v) || rows.contains(v) || blocks(blockIndex).contains(v)) {
                false
              }
              else {
                blocks(blockIndex) += v
                cols(currentCol) += v
                _isValidSudoku(currentRow, currentCol + 1, cols, rows + v, blocks)
              }
            }
          case (true, false) => _isValidSudoku(currentRow + 1, 0, cols, Set[Char](), blocks) // next line
        }
      }
      _isValidSudoku(0, 0, Array.fill(board.length)(collection.mutable.Set[Char]()), Set[Char](), Array.fill(board.length)(collection.mutable.Set[Char]()))
    }

  }



/**
* iterative
* memo
*   1. three array recording whether current value is valid
*        1. rows array
*        2. columns array
*        3. blocks array
* time complexity: O(1), just one iteration
* space complexity: O(3), all sudoku are 9 x 9
*/
object Solution2 {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        val rows = Array.ofDim[Boolean](board.length, board.length)
        val cols = Array.ofDim[Boolean](board.length, board.length)
        val blocks = Array.ofDim[Boolean](board.length, board.length)
        var result = true
        for {
            (row, rowIndex) <- board.zipWithIndex
            (v, colIndex) <- row.zipWithIndex
            if result
        } {
            if (v != '.') {
            val blockIndex = 3 * (rowIndex / 3) + (colIndex / 3)
            val value = v.asDigit - 1
            if (rows(rowIndex)(value) || cols(colIndex)(value) || blocks(blockIndex)(value)) {
                result = false
            } else {
                rows(rowIndex)(value) = true
                cols(colIndex)(value) = true
                blocks(blockIndex)(value) = true
            }
            }

        }
            result
        }
}

/**
* it's no need for zipWithIndex: faster
*/
object Solution2-2 {
  def isValidSudoku(board: Array[Array[Char]]): Boolean = {
    val size = board.length
    val rows = Array.ofDim[Boolean](size, size)
    val cols =  Array.ofDim[Boolean](size, size)
    val blocks =  Array.ofDim[Boolean](size, size)


    var result = true
    for(i <- 0 until size; j <- 0 until size; if board(i)(j) != '.' && result) {
       val num = board(i)(j).asDigit - 1
       val blockIdx = (i / 3) * 3 + (j / 3)
      if(!rows(i)(num) && !cols(j)(num) && !blocks(blockIdx)(num)){
          rows(i)(num) = true
          cols(j)(num) = true
          blocks(blockIdx)(num) = true
          
      }else {
          result = false
      }

    }
    result
  }
}

/**
* function programming way without key word return in loop block
*/

object Solution2-3 {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        val size = board.length
        val rows = Array.ofDim[Boolean](size, size)
        val cols =  Array.ofDim[Boolean](size, size)
        val blocks =  Array.ofDim[Boolean](size, size)
        
        val coords = for(i <- board.indices.view; j <- board.indices.view; if board(i)(j) != '.') yield (i, j)
        
        coords.forall{ case (i, j) => 
            val num = board(i)(j).asDigit - 1
            val blockIdx = (i / 3) * 3 + (j / 3)
            if(!rows(i)(num) && !cols(j)(num) && !blocks(blockIdx)(num)){
              rows(i)(num) = true
              cols(j)(num) = true
              blocks(blockIdx)(num) = true
              true
          
            } else false
        }
    }
}


```

###  3.33. <a name='SudokuSolver'></a>37. Sudoku Solver è§£æ•°ç‹¬

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Tt41137Xr?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1f5411h7er?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3k462gpgb5k0.png)

```py
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows = [set() for _ in range(9)]
        cols = [set() for _ in range(9)]
        grids = [[set() for _ in range(3)] for _ in range(3)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    if  board[i][j] not in rows[i] and \
                        board[i][j] not in cols[j] and \
                        board[i][j] not in grids[i//3][j//3]:
                        rows[i].add(board[i][j])
                        cols[j].add(board[i][j])
                        grids[i//3][j//3].add(board[i][j])

        def dfs(i,j):
            if board[i][j] != '.': # è¢«æ•°å­—å¡«æ»¡

                if i == 8 and j == 8:
                    self.flag = True
                    return
                if j < 8:
                    dfs(i,j+1)
                if j == 8:
                    dfs(i+1,0)
                    
            else:
                for num in range(1,10):
                    item = str(num)
                    if  item not in rows[i] and \
                        item not in cols[j] and \
                        item not in grids[i//3][j//3]:
                        board[i][j] = item
                        rows[i].add(item)
                        cols[j].add(item)
                        grids[i//3][j//3].add(item)

                        # æ˜“é”™ç‚¹:æ³¨æ„ç¼©è¿›å…³ç³»
                        if i == 8 and j == 8:
                            self.flag = True
                            return
                        if j < 8:
                            dfs(i,j+1)
                        if j == 8:
                            dfs(i+1,0)
                        if self.flag:
                            return
                            
                        board[i][j] = '.'
                        rows[i].remove(item)
                        cols[j].remove(item)
                        grids[i//3][j//3].remove(item)

        self.flag = False
        dfs(0,0)

```

```scala
/**
* chosen solution
* DFS + pruning + queue
* time complexity: O(N^2)
*/

object Solution0 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    val coords = for(i <- board.indices.toList; j <- board.indices; if board(i)(j) == '.') yield (i, j)
    if (!solveSudoku(board.map(_.clone), coords, board))
      println("cannot solve under this condition")
  }

  private def solveSudoku(board: Array[Array[Char]], coordQueue: List[(Int, Int)] , ansBoard: Array[Array[Char]]): Boolean = {
    coordQueue match {
      case coord :: newQueue if coordQueue.nonEmpty =>
        ('1' to '9').filter(isValid(board, coord, _)).exists{ char =>
          board(coord._1)(coord._2) = char
          val ret = solveSudoku(board, newQueue, ansBoard)
          board(coord._1)(coord._2) = '.'
          ret
        }
      case _ if coordQueue.isEmpty =>
        board.zipWithIndex.foreach{case (arr: Array[Char], idx: Int) => ansBoard(idx) = arr.clone()}
        true
      case _ =>
        false
    }
  }

  private def isValid(board: Array[Array[Char]], coord: (Int, Int), value: Char): Boolean = {
    val (rowIdx, colIdx) = coord
    val rowValid = ! board(rowIdx).contains(value)
    val columnValid = board.forall(row => row(colIdx) != value)
    val blockValid = generateBlockIdx(rowIdx, colIdx) forall  {case (r, c) => board(r)(c) != value}

    rowValid && columnValid && blockValid
  }

  private def generateBlockIdx(rowIdx: Int, colIdx: Int): Iterator[(Int, Int)] = {
    val blockRowIdx = (rowIdx / 3) * 3
    val blockColIdx = (colIdx / 3) * 3
    for(i <- (blockRowIdx until blockRowIdx + 3).toIterator ; j <- blockColIdx until blockColIdx + 3) yield (i,j)
  }
}



/**
* my first commitment
* DFS + pruning
*/
object Solution1 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    _solveSudoku(board)
  }
  def _solveSudoku(board: Array[Array[Char]]): Boolean = {

    for {
      (rows, rowIdx) <- board.zipWithIndex
      (v, colIdx) <- rows.zipWithIndex
    } {
      if (v == '.') {
        for (c <- '1' to '9') {

          if (_isValid(rowIdx, colIdx, c, board)) {
            board(rowIdx)(colIdx) = c
            if (_solveSudoku(board)) return true
            else board(rowIdx)(colIdx) = '.'
          }
        }
        return false
      }
    }
    true
  }

  def _isValid(row: Int, col: Int, char: Char, board: Array[Array[Char]]): Boolean = {

    val boardRowIndex = 3 * (row / 3)
    val boardColIndex = 3 * (col / 3)
    if (board(row).contains(char)
      || board.exists(r => r(col) == char)
      || board.slice(boardRowIndex, boardRowIndex + 3).map(_.slice(boardColIndex, boardColIndex + 3)).exists(r => r.contains(char))) false
    else true
  }
}



/**
*  DFS + pruning + queue
*  memo:
*    using a queue storing unfilled index
*/
object Solution1-2 {

  import scala.collection.immutable.Queue

  def solveSudoku(board: Array[Array[Char]]): Unit = {

    val indexes = scala.collection.mutable.Queue[(Int, Int)]()
    for {
      (row, rowIdx) <- board.zipWithIndex
      (value, colIdx) <- row.zipWithIndex
    } {
      if (value == '.') {
        indexes.enqueue((rowIdx, colIdx))
      }
    }
    _solveSudoku(Queue(indexes.dequeueAll(_  => true): _*), board.map(_.clone()), board)
  }


  def _solveSudoku(indexes: Queue[(Int, Int)], currentBoard: Array[Array[Char]], finalBoard: Array[Array[Char]]): Boolean = {
    if (indexes.isEmpty) {
      // end condition
      currentBoard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
      true
    } else {
      val ((row, col), newIndexes) = indexes.dequeue
      ('1' to '9').filter(_isValid(row, col, _, currentBoard)).find ( c =>_solveSudoku(newIndexes, copyBoard(currentBoard)(row, col, c), finalBoard))
       match {
        case Some(_) => true
        case None => false
      }
    }

  }
  def _isValid(row: Int, col: Int, char: Char, board: Array[Array[Char]]): Boolean = {

    val checkBoardExits = (rr: Int, cc: Int, c: Char) => {
      var result = false
      for {
        i <- 0 until 3
        j <- 0 until 3
        if !result
      } {
        if (board(i + rr)(j + cc) == c) result = true
      }
      result
    }
    val boardRowIndex = 3 * (row / 3)
    val boardColIndex = 3 * (col / 3)
    if (board(row).contains(char)
      || board.exists(r => r(col) == char)
      || checkBoardExits(boardRowIndex, boardColIndex, char)) {
      false
    } else {
      true
    }
  }

  val copyBoard = (b: Array[Array[Char]]) => (row: Int, col: Int, c: Char) => {
    val newB = b.map(_.clone())
    newB(row)(col) = c
    newB
  }
}


/**
*  DFS + pruning + queue
*/
object Solution1-3 {

  import scala.collection.immutable.Queue

  def solveSudoku(board: Array[Array[Char]]): Unit = {
    val indices = scala.collection.mutable.Queue[(Int, Int)]()

    for (i <- 0 until board.length; j <- 0 until board.length) {
      val v = board(i)(j)
      if (v == '.') indices.enqueue((i, j))
    }
    _solveSudoku(Queue(indices.dequeueAll(_ => true): _*), board.map(_.clone()), board)
  }


  def _solveSudoku(indices: Queue[(Int, Int)], currentBoard: Array[Array[Char]], finalBoard: Array[Array[Char]]): Boolean = {
    if (indices.isEmpty) {
      currentBoard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
      return true
    }

    val ((row, col), newIndices) = indices.dequeue
    ('1' to '9').filter(_checkValid(_, (row, col), currentBoard)).find { // find: æ‰¾å‡ºç¬¬ä¸€å€‹åˆæ³•æ•¸å­—ï¼Œä»£è¡¨å…¶å¾Œçš„è¿­ä»£æœ‰è§£
      c =>
        currentBoard(row)(col) = c
        if (_solveSudoku(newIndices, currentBoard, finalBoard)) true
        else {
          currentBoard(row)(col) = '.'
          false
        }
    } match {
      case Some(_) => true
      case None => false  // é€™å€‹ç›¤å‹¢ä¸ç®¡å¡«ä»€éº¼å¾ŒçºŒéƒ½ç„¡è§£
    }
  }

  def _checkValid(c: Char, index: (Int, Int), currentBoard: Array[Array[Char]]): Boolean = {
    val (row, col) = index
    val blockRowIdx = 3 * (row / 3)
    val blockColIdx = 3 * (col / 3)
    val checkBoard = (rowAnchar: Int, colAnchar: Int) => {
      val pairs = for (i <- 0 until 3; j <- 0 until 3) yield (rowAnchar + i, colAnchar + j)
      pairs.exists { case (i, j) => currentBoard(i)(j) == c }
    }
    if (currentBoard(row).contains(c) || currentBoard.exists(a => a(col) == c) || checkBoard(blockRowIdx, blockColIdx)) false
    else true
  }
}

/**
*  DFS + pruning + queue
*    improvement: isValid is more concise
*/
object Solution1-4 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    val coords = for(i <- board.indices.toList; j <- board.indices; if board(i)(j) == '.') yield (i, j)
    if (!solveSudoku(board.map(_.clone), coords, board))
      println("cannot solve under this condition")
  }

  private def solveSudoku(board: Array[Array[Char]], coordQueue: List[(Int, Int)] , ansBoard: Array[Array[Char]]): Boolean = {
    coordQueue match {
      case coord :: newQueue if coordQueue.nonEmpty =>
        ('1' to '9').filter(isValid(board, coord, _)).exists{ char =>
          board(coord._1)(coord._2) = char
          val ret = solveSudoku(board, newQueue, ansBoard)
          board(coord._1)(coord._2) = '.'
          ret
        }
      case _ if coordQueue.isEmpty =>
        board.zipWithIndex.foreach{case (arr: Array[Char], idx: Int) => ansBoard(idx) = arr.clone()}
        true
      case _ =>
        false
    }
  }

  private def isValid(board: Array[Array[Char]], coord: (Int, Int), value: Char): Boolean = {
    val (rowIdx, colIdx) = coord
    val rowValid = ! board(rowIdx).contains(value)
    val columnValid = board.forall(row => row(colIdx) != value)
    val blockValid = generateBlockIdx(rowIdx, colIdx) forall  {case (r, c) => board(r)(c) != value}

    rowValid && columnValid && blockValid
  }

  private def generateBlockIdx(rowIdx: Int, colIdx: Int): Iterator[(Int, Int)] = {
    val blockRowIdx = (rowIdx / 3) * 3
    val blockColIdx = (colIdx / 3) * 3
    for(i <- (blockRowIdx until blockRowIdx + 3).toIterator ; j <- blockColIdx until blockColIdx + 3) yield (i,j)
  }
}



object Solution2 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    _solveSudoku(0, 0, board.map(_.clone()), board)
  }

  def _solveSudoku(currentRow: Int, currentCol: Int, currenBboard: Array[Array[Char]], finalBoard: Array[Array[Char]]): Boolean = {
    (currentRow < finalBoard.length, currentCol < finalBoard.length) match {
      case (false, _) => // end condition
        currenBboard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
        true
      case (true, false) => // next line (row)
        _solveSudoku(currentRow + 1, 0, currenBboard, finalBoard)
      
      case (true, true) if currenBboard(currentRow)(currentCol) == '.' => 
        ('1' to '9').filter(c => _isValid(currentRow, currentCol, c, currenBboard))
          .find(c => _solveSudoku(currentRow , currentCol + 1, copyBoard(currenBboard)(currentRow, currentCol, c), finalBoard)) match { // fix row shift col
          case Some(_) => true
          case None => false
        }

      case _ => _solveSudoku(currentRow, currentCol + 1, currenBboard, finalBoard) // fix row, next col 
    }
  }

  val copyBoard = (b: Array[Array[Char]]) => (row: Int, col: Int, c: Char) => {
    val newB = b.map(_.clone())
    newB(row)(col) = c
    newB
  }

  def _isValid(row: Int, col: Int, char: Char, board: Array[Array[Char]]): Boolean = {

    val checkBoardExits = (rr: Int, cc: Int, c: Char) => {
      var result = false
      for {
        i <- 0 until 3
        j <- 0 until 3
        if !result
      } {
        if (board(i + rr)(j + cc) == c) result = true
      }
      result
    }
    val boardRowIndex = 3 * (row / 3)
    val boardColIndex = 3 * (col / 3)
    if (board(row).contains(char)
      || board.exists(r => r(col) == char)
      || checkBoardExits(boardRowIndex, boardColIndex, char)) {
      false
    } else {
      true
    }
  }

}


/**
* DFS + pruning + extra space
* using extra three two dimension array to store col row and block's information
* a mutable collection method
*/


object Solution4 {
  import scala.reflect.ClassTag
  import scala.collection.immutable.Queue
  def solveSudoku(board: Array[Array[Char]]): Unit = {
    val indexes = scala.collection.mutable.Queue[(Int, Int)]()
    val rows = Array.ofDim[Boolean](board.length, board.length)
    val cols = Array.ofDim[Boolean](board.length, board.length)
    val blocks = Array.ofDim[Boolean](board.length, board.length)
    for {
      (row, rowIdx) <- board.zipWithIndex
      (value, colIdx) <- row.zipWithIndex
    } {
      if (value == '.') {
        indexes.enqueue((rowIdx, colIdx))
      } else {
        val blockIdx = 3 * (rowIdx / 3) + (colIdx / 3)
        val v = value.asDigit - 1
        rows(rowIdx)(v) = true
        cols(colIdx)(v) = true
        blocks(blockIdx)(v) = true

      }

    }

    _solveSudoku( Queue(indexes.dequeueAll(_ => true): _*),
      rows,
      cols,
      blocks,
      board
    )

  }

  def _solveSudoku(indexes: Queue[(Int, Int)],
                   rows: Array[Array[Boolean]],
                   cols: Array[Array[Boolean]],
                   blocks: Array[Array[Boolean]],
                   currentBoard: Array[Array[Char]]
                  ): Boolean = {
    if (indexes.isEmpty) {
//      currentBoard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
      true
    } else {
      val ((row, col), newIndexes) = indexes.dequeue
      ('1' to '9').filter(_isValid((row, col), _, rows, cols, blocks))
        .find { c =>
          val v = c.asDigit - 1
          rows(row).update(v, true)
          cols(col).update(v, true)
          blocks( 3 * (row / 3) + (col / 3)).update(v, true)
          currentBoard(row)(col) = c
          if (_solveSudoku(newIndexes,
            rows,
            cols,
            blocks,
            currentBoard
            //            copyBoard(rows)(row, v, true),
            //            copyBoard(cols)(col, v, true),
            //            copyBoard(blocks)(3 * (row / 3) + (col / 3), v, true),
            //            copyBoard(currentBoard)(row, col, c),
          //  finalBoard
          )) {
            true
          } else {
            rows(row).update(v, false)
            cols(col).update(v, false)
            blocks( 3 * (row / 3) + (col / 3)).update(v, false)
            currentBoard(row)(col) = '.'
            false
          }
        } match {
        case Some(_) => true
        case None => false
      }
    }
  }
  def _isValid(index: (Int, Int),
               char: Char,
               rows: Array[Array[Boolean]],
               cols: Array[Array[Boolean]],
               blocks: Array[Array[Boolean]]): Boolean = {


    val (row, col) = index
    val v = char.asDigit - 1
    val blockIdx = 3 * (row / 3) + (col / 3)

    if (rows(row)(v) || cols(col)(v) || blocks(blockIdx)(v)) false
    else true
  }

//  def copyBoard[T](b: Array[Array[T]])(row: Int, col: Int, c: T)(implicit ctg: ClassTag[T]): Array[Array[T]] = {
//    val newB = b.map(_.clone())
//    newB(row)(col) = c
//    newB
//  }
}

object Solution4-2 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {
    /* three extra tables to record whether coordinate is occupied */
    val columns = Array.ofDim[Boolean](board.length, board.length)
    val rows = Array.ofDim[Boolean](board.length, board.length)
    /**
      * block index:
      *     1 2 3
      *     4 5 6
      *     7 8 9
      * convert (rowIndex, columnIndex) to blockIndex:  ( rowIndex / 3 ) * 3 + ( columnIndex / 3)
      */
    val blocks = Array.ofDim[Boolean](board.length, board.length)

    /* DFS worker*/
    def _solveSudoku(board: Array[Array[Char]], coordQueue: List[(Int, Int)], ans: Array[Array[Char]], checkValid: ((Int, Int), Char) => Boolean): Boolean = {
      coordQueue match {
          /* DFS not complete case : coordinate queue non empty */
        case coord :: newQueue if coordQueue.nonEmpty =>
          ('1' to '9').filter(checkValid(coord, _)).exists { char =>
            val (rowIdx, colIdx) = coord

            /* set board with char value by coordinate */
            board(rowIdx)(colIdx) = char
            rows(rowIdx)(char.asDigit - 1) = true
            columns(colIdx)(char.asDigit - 1) = true
            blocks((rowIdx / 3) * 3 + (colIdx / 3))(char.asDigit - 1) = true

            val ret = _solveSudoku(board, newQueue, ans, checkValid)

            /* recover to status before calling  _solveSudoku 
            *  reset board table, rows table, columns table and blocks table
            * */
            board(rowIdx)(colIdx) = '.'
            rows(rowIdx)(char.asDigit - 1) = false
            columns(colIdx)(char.asDigit - 1) = false
            blocks((rowIdx / 3) * 3 + (colIdx / 3))(char.asDigit - 1) = false
            ret
          }

          /* coordinate queue ran out, answer should shows up */
        case _ if coordQueue.isEmpty =>
          board.zipWithIndex.foreach { case (r, idx) => ans(idx) = r.clone }
          true

        case _ => false
      }
    }

    /* generate all empty coordinates */
    val coords = for (i <- board.indices.toList; j <- board.indices; if board(i)(j) == '.') yield (i, j)

    /* initial rows table, columns table, blocks table */
    for (i <- board.indices.toList; j <- board.indices; if board(i)(j) != '.') {
      val charIdx = board(i)(j).asDigit - 1  // index range from 0 to 9
      rows(i)(charIdx) = true
      columns(j)(charIdx) = true
      blocks((i / 3) * 3 + (j / 3))(charIdx) = true
    }
    val isValidFunc = isValid(_, _, rows, columns, blocks)

    _solveSudoku(board.map(_.clone), coords, board, isValidFunc)
  }

  /* check input char value is valid at the coordinate */
  def isValid(coord: (Int, Int), value: Char, rows: Array[Array[Boolean]], columns: Array[Array[Boolean]], blocks: Array[Array[Boolean]]): Boolean = {
    val (row, col) = coord
    val charIdx = value.asDigit - 1
    val blockIdx = (row / 3) * 3 + (col / 3)
    !rows(row)(charIdx) && !columns(col)(charIdx) && !blocks(blockIdx)(charIdx)
  }
}
```

###  3.34. <a name='Countandsay'></a>38-Count and say

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1QJ411R7MF?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i717?spm_id_from=333.999.0.0)

```py
import itertools
class Solution:
    def countAndSay(self, n: int) -> str:
        res = '1'
        for _ in range(n-1):
            res = ''.join([str(len(list(g))) + k for k,g in itertools.groupby(res)])
        return res
```

```py
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1: 
            return '1'

        res = ''
        count = 1
        s = self.countAndSay(n-1)
        for i in range(len(s)):
            if i+1 < len(s) and s[i] == s[i+1]:
                count += 1
            else:
                res += str(count) + s[i]
                count = 1
        return res
```

```py
# æˆ‘çš„æ¨¡ä»¿ğŸ˜‹

class Solution:
    def countAndSay(self, n: int) -> str:
        s = '1'
        for _ in range(n-1):
            tmp = ''
            count = 1  # æ˜“é”™ç‚¹ï¼šcountçš„ä½ç½®
            for j in range(len(s)):
                if j+1 < len(s) and s[j] == s[j+1]:
                    count += 1
                else:
                    tmp += str(count) + s[j]
                    count = 1  # æ˜“é”™ç‚¹ï¼šcounté‡æ–°ç½®ä¸º1
            s = tmp
        return s
```

```scala
object Solution {
    def countAndSay(n: Int): String = {
        if(n == 1){
            "1"
        }else{
            val prev = countAndSay(n-1)
            val prevIntArray = prev.toCharArray.map(x => x - '0')
            
            var output = ""
            var count = 0
            if(!prevIntArray.isEmpty){
                var element = prevIntArray(0)
            
                for(elem <- prevIntArray){
                    if(elem == element){
                        count += 1
                    }else{
                        output = output + count + element
                        element = elem
                        count = 1
                    }
                }
                output = output + count + element
            }
            
            output
        }
    }
}


//Just using StringBuilder put the solution from 16% -> 93.5% in terms of time efficiency

object Solution {
    def countAndSay(n: Int): String = {
        if(n == 1){
            "1"
        }else{
            val prev = countAndSay(n-1)
            val prevIntArray = prev.toCharArray.map(x => x - '0')
            
            var output = new scala.collection.mutable.StringBuilder()
            var count = 0
            if(!prevIntArray.isEmpty){
                var element = prevIntArray(0)
            
                for(elem <- prevIntArray){
                    if(elem == element){
                        count += 1
                    }else{
                        output.append(count)
                        output.append(element)
                        element = elem
                        count = 1
                    }
                }
                output.append(count)
                output.append(element)
            }
            
            output.toString
        }
    }
}

```


###  3.35. <a name='CombinationSum39-'></a>39. Combination Sum 39-ç»„åˆæ€»å’Œ

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gb411u7dy?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Wz411e79d?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV12Z4y157nE?spm_id_from=333.999.0.0)

![Snipaste_2021-12-18_11-30-10](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/Snipaste_2021-12-18_11-30-10.5b1q5zh7t4w0.png)

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []

        def dfs(firstIdx):
            if sum(path) == target:
                res.append(path[:]) 
                # æ˜“é”™ç‚¹ï¼Œè¿™é‡Œæ˜¯res.append(path[:])ï¼Œè€Œä¸æ˜¯res.append(path)
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    path.append(candidates[i])
                    dfs(i)
                    path.pop()
        dfs(0)
        return res
```

```scala
/**
* chosen solution - backtracking + dfs + pruning
* time complexity: O(N^target)
* space complexity: O(target)
*/

object Solution0 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(arr: Array[Int], idx: Int, currentSum: Int, list: List[Int], ans: mutable.ListBuffer[List[Int]]): Unit = {
        if (currentSum == target) {
          ans += list
          return
        }
        val diff = target - currentSum
        (idx until arr.length).filter(i => arr(i) <= diff).foreach(i => dfs(arr, i, currentSum + arr(i), list :+ arr(i), ans)) 
      }
      
      val ans = mutable.ListBuffer.empty[List[Int]]
      
      dfs(candidates, 0, 0, List.empty, ans)
      ans.toList
        
    }
}

/**
* my first commitment: dfs - backtracking
*/

object Solution1-1 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(combination: List[Int], ans: mutable.Set[List[Int]]): Unit = {
        val currentSum = combination.sum
        
        if (currentSum == target) {
          ans += combination.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          candidates.filter(n => n <= diff).foreach{ case n => dfs(n :: combination, ans)}
        }
      }
      val ans = mutable.Set.empty[List[Int]]
      dfs(List.empty[Int], ans)
      ans.map(l => l.groupBy(identity).mapValues(_.length).toMap -> l).toMap.values.toList // distinct 
    }
}

/**
* optimize from 1-1: sort combination before appending to ans
*/
object Solution1-2 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(combination: List[Int], currentSum: Int, ans: mutable.Set[List[Int]]): Unit = {
        
        if (currentSum == target) {
          ans += combination.sorted.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          candidates.filter(n => n <= diff).foreach{ case n => dfs(n :: combination, currentSum + n, ans)}
        }
      }
      val ans = mutable.Set.empty[List[Int]]
      dfs(List.empty[Int], 0, ans)
      ans.toList
    }
}

/**
* optimize from 1-2: pruning some case- recording candidates array index i 
*/
object Solution1-3{
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(i: Int, combination: List[Int], currentSum: Int, ans: mutable.Set[List[Int]]): Unit = {
        if (currentSum == target) {
          ans += combination.sorted.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          (i until candidates.length).filter(idx => candidates(idx) <= diff).foreach{ case idx => dfs(idx, candidates(idx) :: combination, currentSum + candidates(idx), ans)}
        }
      }
      
      val ans = mutable.Set.empty[List[Int]]
      dfs(0, List.empty[Int], 0, ans)
      ans.toList
    }
}

/**
* using ListBuffer instead of Set
* memo
* 1.candidates array should be in ascending order
* time complexity: O(N^target)
* space complexity: O(target)
*/
object Solution1-4 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(arr: Array[Int], idx: Int, currentSum: Int, list: List[Int], ans: mutable.ListBuffer[List[Int]]): Unit = {
        if (currentSum == target) {
          ans += list
          return
        }
        val diff = target - currentSum
        (idx until arr.length).filter(i => arr(i) <= diff).foreach(i => dfs(arr, i, currentSum + arr(i), list :+ arr(i), ans)) 
      }
      
      val ans = mutable.ListBuffer.empty[List[Int]]
      
      dfs(candidates, 0, 0, List.empty, ans)
      ans.toList
        
    }
}
```

```scala
package com.zhourui.leetcode
import scala.util.control.Breaks._
import scala.collection.mutable.Stack

package lc0039_combinationsum {
  object Solution {
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      var arr = candidates
      scala.util.Sorting.quickSort(arr)
      var ans = Vector[List[Int]]()
      var subset  = Stack[Int]()

      def helper(nums:Array[Int], start:Int, rest:Int): Unit = {
        if (rest == 0) {
          ans = ans :+ subset.toList
          return
        }
        breakable {
          for (i<- start until nums.length) {
            if (rest>=nums(i)) {
              subset.push(nums(i))
              helper(nums,i,rest-nums(i))
              subset.pop
            } else {
              break()
            }
          }
        }
      }
      helper(arr,0,target)
      ans.toList
    }
  }
}


```

###  3.36. <a name='CombinationSumII40-II'></a>40. Combination Sum II 40-ç»„åˆæ€»å’Œ II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Pb411u7Yd?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1gT4y1J7JE?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        candidates.sort()
        # candidates.reverse()
        def dfs(firstIdx):
            if sum(path) == target:
                res.append(path[:])
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    # æ˜“é”™ç‚¹ï¼šéœ€è¦å‰ªæ
                    if i > firstIdx and candidates[i] == candidates[i-1]: continue
                    # [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]ä¼šè¶…æ—¶
                    path.append(candidates[i])
                    dfs(i+1)
                    path.pop()
        dfs(0)
        return res
```

###  3.37. <a name='FirstMissingPositive'></a>41 First Missing Positive

[å°æ˜](https://www.bilibili.com/video/BV1fy4y1k7pV?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        nums.append(0)
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0 or nums[i] >= n:
                nums[i] = 0
        # for num in nums:
            # if num >= n or num <= 0:
            #     num = 0
            # æ˜“é”™ç‚¹ï¼šfor num in nums,å…¶ä¸­numåªèƒ½è¿›è¡Œè¯»æ“ä½œï¼Œä¸èƒ½è¿›è¡Œå†™æ“ä½œã€‚
            # å®¹æ˜“å‡ºé”™
        
        for num in nums:
            nums[num % n] += n  
            # æ˜“é”™ç‚¹ï¼š% n,ä¸€å®šè¦å–ä½™æ•°ï¼Œä¸ç„¶ä¼šindex out of range

        for i,num in enumerate(nums):
            if num < n:
                return i

        return n
```

###  3.38. <a name='TrappingRainWater'></a>42. Trapping Rain Water

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1hJ41177gG?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1fi4y1t7BP?spm_id_from=333.999.0.0)

åŠ¨æ€è§„åˆ’ï¼š

* æ—¶é—´å¤æ‚åº¦: O(n)

* ç©ºé—´å¤æ‚åº¦: O(n)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        
        n = len(height)
        leftMax = [height[0]] + [0] * (n - 1)
        for i in range(1, n):
            leftMax[i] = max(leftMax[i - 1], height[i])

        rightMax = [0] * (n - 1) + [height[n - 1]]
        for i in range(n - 2, -1, -1):
            rightMax[i] = max(rightMax[i + 1], height[i])

        ans = sum(min(leftMax[i], rightMax[i]) - height[i] for i in range(n))
        return ans
```

æ ˆï¼š

* æ—¶é—´å¤æ‚åº¦: O(n)

* ç©ºé—´å¤æ‚åº¦: O(n)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = list()
        n = len(height)
        
        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                ans += currWidth * currHeight
            stack.append(i)
        
        return ans
```

åŒæŒ‡é’ˆï¼š

* æ—¶é—´å¤æ‚åº¦: O(n)

* ç©ºé—´å¤æ‚åº¦: O(1)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        left, right = 0, len(height) - 1
        leftMax = rightMax = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1
        
        return ans

#   ğŸ˜‹æˆ‘çš„æ¨¡ä»¿

class Solution:
    def trap(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        leftmax = 0
        rightmax = 0
        res = 0
        while left < right:
            if height[left] < height[right]:
                leftmax = max(leftmax,height[left])
                # æ˜“é”™ç‚¹ï¼šæ³¨æ„reså’Œleftçš„æ¬¡åºï¼šå…ˆresï¼Œåleft
                res += leftmax-height[left] 
                left += 1
            else:
                rightmax = max(rightmax,height[right])
                # æ˜“é”™ç‚¹ï¼šæ³¨æ„reså’Œrightçš„æ¬¡åºï¼šå…ˆresï¼Œåright
                res += rightmax-height[right]
                right -= 1
        return res
```

###  3.39. <a name='JumpGameII'></a>45 Jump Game II

[å°æ˜](https://www.bilibili.com/video/BV1fb4y1Z77x?spm_id_from=333.999.0.0)

```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        maxPos, end, step = 0, 0, 0
        for i in range(n - 1):
            if maxPos >= i:
                maxPos = max(maxPos, i + nums[i])
                if i == end:
                    end = maxPos
                    step += 1
        return step

#   ğŸ˜‹æˆ‘çš„æ¨¡ä»¿

class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        jump = 0
        cover = 0
        stop = 0
        i = 0
        while cover >= i and i < n-1: 
            #æ˜“é”™ç‚¹ï¼šæ˜¯n-1ï¼Œä¸æ˜¯nï¼Œåªè¦è°ƒåˆ°æœ€åä¸€æ ¼å°±ç®—æˆåŠŸ
            cover = max(cover,i + nums[i])
            if i == stop:
                jump += 1
                stop = cover
            i += 1
        return jump
```

###  3.40. <a name='-1'></a>46-æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Bz411i7cs?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV125411W7eC?spm_id_from=333.999.0.0)

åŠ¨æ€è§„åˆ’ï¼š

* æ—¶é—´å¤æ‚åº¦: O(n)

* ç©ºé—´å¤æ‚åº¦: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.66thg6sgm600.png)

```py
class Solution:
    def translateNum(self, num: int) -> int:
        s = str(num)
        n = len(s)
        dp = [1]*n
        if '10' <= s[0:2] <= '25':
            dp[1] = 2
        for i in range(2,n):
            if '10' <= s[i-1:i+1] <= '25':
                dp[i] = dp[i-1] + dp[i-2]
            else:
                dp[i] = dp[i-1]
        return dp[-1]
```

###  3.41. <a name='-1'></a>46-å…¨æ’åˆ—

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1YA411v7zF?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7fm?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1oa4y1v7Kz?spm_id_from=333.999.0.0)

```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        # n = len(nums)
        def dfs(nums):
            # æ˜“é”™ç‚¹ï¼šif len(path) == n:
            if not nums: # åˆ¤æ–­æ¡ä»¶åº”è¯¥æ˜¯è¿™ä¸ª
                res.append(path[:]) # æ˜“é”™ç‚¹ï¼špath[:]
                return
            else:
                for i in range(len(nums)):
                    path.append(nums[i])
                    dfs(nums[:i]+nums[i+1:]) # æ˜“é”™ç‚¹ï¼šnæ˜¯ä¸æ–­å˜å°çš„
                    path.pop()
        dfs(nums)
        return res

# å¦ä¸€ç§å†™æ³•ğŸ˜‹
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def dfs(nums,path):
            if not nums: 
                res.append(path[:]) 
                return
            else:
                for i in range(len(nums)):
                    dfs(nums[:i]+nums[i+1:],path + [nums[i]]) 
        dfs(nums,[])
        return res
```

```scala
object Solution {
    var output = List.empty[List[Int]]
    
    def backtrack(nums: Array[Int], l: Int, r: Int): Unit = {
        def swap(a: Int, b: Int) = {
            val temp = nums(a)
            nums(a) = nums(b)
            nums(b) = temp
        }
        
        /**
        In backtracking, we collect all the leaf nodes of the tree
        In this question, we fix the first letter and swap the others till we reach (l==r), i.e. no swap needed since its the leaf node
        So we add it to output
        */
        
        if(l == r){
            output = output :+ nums.toList
        }else{
            (l to r).map(i => {
                swap(l, i)
                backtrack(nums, l+1, r)
                swap(l, i) //backtrack step
            })
        }
    }
    
    def permute(nums: Array[Int]): List[List[Int]] = {
        output = List.empty[List[Int]]
        var input = nums
        backtrack(input, 0, input.length - 1)
        output
    }
}

```

###  3.42. <a name='II-'></a>47-å…¨æ’åˆ— II-å‰ªæç‰ˆ

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Ev411672A?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1qK4y1x7Qs?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1z54y1a7rQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        def dfs(nums,path):
            if not nums:
                res.append(path[:])
            else:
                for i in range(len(nums)):
                    if i>0 and nums[i] == nums[i-1]:
                        continue
                    dfs(nums[:i]+nums[i+1:],path + [nums[i]])

        dfs(nums,[])
        return res
```

###  3.43. <a name='RotateImage'></a>48. æ—‹è½¬å›¾åƒ Rotate Image

[å®˜æ–¹](https://www.bilibili.com/video/BV1mf4y1e7ox?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Wy4y1s7fs?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3kl7avrsvhi0.png" width="30%">

```py
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n//2):
            for j in range((n+1)//2):
                matrix[i][j],matrix[j][n-1-i],matrix[n-1-i][n-1-j],matrix[n-1-j][i] = \
                matrix[n-1-j][i],matrix[i][j],matrix[j][n-1-i],matrix[n-1-i][n-1-j]
        return matrix
```

```scala
/**
* my first commitment
* rotate 4 cell in each iteration
*
*   pattern:  (row, col) -> (col, n - 1- row)
*       1. (i, j) - > (j, n - 1 -i)
*       2. (j, n - 1 -i) -> (n - 1 - i, n - 1 - j)
*       3. (n - 1 - i, n - 1 - j) -> (n -1 -j, n - 1 - (n -1 - i) ) =  (n - 1 -j, i)
*       4. (n - 1 -j, i) -> (i, n - 1 - (n - 1 - j)) = (i, j)
*
* ((0,0) -> (0,3) -> (3,3) -> (3,0))
* ((0,1) -> (1,3) -> (3,2) -> (2,0))
* ((1,0) -> (0,2) -> (2,3) -> (3,1))
* ((1,1) -> (1,2) -> (2,2) -> (2,1))
* 
*/
object Solution1 {
    def rotate(matrix: Array[Array[Int]]): Unit = {
      val n = matrix.size
      printMatrix(n)
      
      for (i <- 0 until (n / 2).toInt + n % 2; j <- 0 until (n / 2).toInt){      
        val tmp = matrix(n - 1 -j)(i)
        matrix(n - 1 - j)(i) = matrix(n - 1 - i)(n - j - 1)
        matrix(n - 1 - i)(n - j - 1) = matrix(j)(n - 1 - i)
        matrix(j)(n - 1 - i) = matrix(i)(j)
        matrix(i)(j) = tmp
      }
    }
    def printMatrix(size: Int): Unit = {
      for (i <- 0 until size) {
        for (j <- 0 until size) {
          print(s"($i, $j) ")
        }
        println(" ")
      }
    }
    /**
        (0, 0) (0, 1) (0, 2) (0, 3)  
        (1, 0) (1, 1) (1, 2) (1, 3)  
        (2, 0) (2, 1) (2, 2) (2, 3)  
        (3, 0) (3, 1) (3, 2) (3, 3)  
    */
}
/**
* clockwise rotate = transpose + horizontal flip
*/
object Solution2 {
    def rotate(matrix: Array[Array[Int]]): Unit = {
        transpose(matrix)
        horizontalFlip(matrix)
    }
  
    def transpose(matrix: Array[Array[Int]]): Unit = {
      for (i <- matrix.indices; j <- i until matrix(i).length; if i != j) {
        val tmp = matrix(i)(j)
        matrix(i)(j) = matrix(j)(i)
        matrix(j)(i) = tmp
      }
    }
    def horizontalFlip(matrix: Array[Array[Int]]): Unit = {
      for(row <- matrix) {
        var from = 0 
        var to = row.length - 1 
        while(from < to) { // reverse row elements
          val tmp = row(to)
          row(to) = row(from)
          row(from) = tmp
          from += 1
          to -= 1
        }
      }
    }
}

/**
* optimize: reversArray by recursion
*/
object Solution2-1{
    def rotate(matrix: Array[Array[Int]]): Unit = {
        transpose(matrix)
        horizontalFlip(matrix)
    }
  
    def transpose(matrix: Array[Array[Int]]): Unit = {
      for (i <- matrix.indices; j <- i until matrix(i).length; if i != j) {
        val tmp = matrix(i)(j)
        matrix(i)(j) = matrix(j)(i)
        matrix(j)(i) = tmp
      }
    }
    def horizontalFlip(matrix: Array[Array[Int]]): Unit = {
      matrix.foreach(row => reverseArray(row, 0, row.length  - 1))
    }
  
    @annotation.tailrec
    def reverseArray(arr: Array[Int], from: Int, to: Int) {
      if (from > to) return
      val tmp = arr(to)
      arr(to) = arr(from)
      arr(from) = tmp
      reverseArray(arr, from + 1, to - 1)
    }
}
```

###  3.44. <a name='GroupAnagrams'></a>49 Group Anagrams

[å°æ˜](https://www.bilibili.com/video/BV1n5411t79G?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Yf4y1e7gJ?spm_id_from=333.999.0.0)

```py
# è´¨æ•°å¯¹åº”å­—æ¯ ä¹˜ç§¯å“ˆå¸Œ
# è¿™ä¸ªæ€æƒ³å¯ä»¥å­¦ä¹ ï¼ä½†æˆ‘è¿˜æ²¡çœ‹
from functools import reduce
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]
        chars = "abcdefghijklmnopqrstuvwxyz"
        ch_pr = {chars[i]:prime[i] for i in range(26)}
        for s in strs:
            keys = reduce(lambda x,y :x*y,[ch_pr[i] for i in s], 1)
            if keys in dic:
                dic[keys].append(s)
            else:
                dic[keys] = [s]
        return list(dic.values())
```

```py
# python3 : å¸¸è§„åšæ³•

class Solution:
    def groupAnagrams(self, strs):
        res = []
        dic = {}
        for s in strs:
            keys = "".join(sorted(s))
            if keys not in dic:
                dic[keys] = [s]
            else:
                dic[keys].append(s)
        return list(dic.values())

# æˆ‘çš„æ¨¡ä»¿ğŸ˜‹

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        for s in strs:
            keys = ''.join(sorted(s)) #æ˜“é”™ç‚¹ï¼šsè¢«sortedä»¥åï¼Œä¼šå˜æˆlist
            if keys not in dic:
                dic[keys] = [s] #æ˜“é”™ç‚¹ï¼š[s],è€Œä¸æ˜¯s
            else:
                dic[keys].append(s)
        # print(dic.values())è¾“å‡ºdict_values([['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']])
        return list(dic.values())
```

```py
# æ›´ç®€å•çš„å†™æ³•ï¼š
class Solution:
    def groupAnagrams(self, strs):
        dic = collections.defaultdict(list)

        for s in strs:
            keys = "".join(sorted(s))
            dic[keys].append(s)
        
        return list(dic.values())
```

```scala
object Solution {
    def groupAnagrams(strs: Array[String]): List[List[String]] = {
        
        import collection.mutable.HashMap
        import collection.mutable.ListBuffer
        
        val mapping = HashMap[String, ListBuffer[String]]()
        
        for (s <- strs) {
            if (mapping.contains(s.sorted)) {
                mapping(s.sorted) += s
            } else {
                mapping(s.sorted) = ListBuffer(s)
            }
        }
        

        mapping.values.map(_.toList).toList

    }
}
```

```scala
/**
* chosen solution
* time complexity: O(N KLogK) : N: strs.length, K: the longest string in strs 
*/
object Solution0 {
    def groupAnagrams(strs: Array[String]): List[List[String]] =
        strs.groupBy(_.sorted.hashCode).values.map(_.toList).toList
}

/**
* my first commit
* convert all strs into hashmap and group them by the hash value
* time complexity:  O(N K) , but groupBy op is slower
*/
object Solution1 {
  def groupAnagrams(strs: Array[String]): List[List[String]] = {
    strs.groupBy(str => str.groupBy(identity).mapValues(_.length).toMap).values.map(_.toList).toList
  }
}

/**
* inner groupBy is hands-on
* memo:
*   1. categorize by count
*/
object Solution1-2{
  def groupAnagrams(strs: Array[String]): List[List[String]] = {
        strs.toList.groupBy{str => 
            val hashmap = scala.collection.mutable.Map.empty[Char, Int]
            str.foreach(char => hashmap.update(char, hashmap.getOrElse(char, 0) + 1))
            hashmap.hashCode
        }.values.toList
        
    }
}

/**
* sort each string and groupby the sorted list's hashvalue
* time complexity: O(N KLogK) : N: strs.length, K: the longest string in strs
*/
object Solution2 {
    def groupAnagrams(strs: Array[String]): List[List[String]] =
        strs.groupBy(_.sorted.hashCode).values.map(_.toList).toList
}


```

```scala
package com.zhourui.leetcode

import scala.collection.mutable._
//import scala.collection.immutable.{HashMap, HashSet}
package lc0049_groupanagram {



  object Solution {
    def groupAnagrams(strs: Array[String]):List [List[String]] = {
      val hm = HashMap[String,List[String]]()
      strs.foreach{
          case s if hm.contains(s.sorted) => hm(s.sorted) = hm(s.sorted) :+(s)
          case s => hm(s.sorted)=List[String](s)
      }
      hm.values.toList
    }
  }
}

```

###  3.45. <a name='Powxn'></a>50 Pow(x, n)

[å°æ˜](https://www.bilibili.com/video/BV1W54y1q7CV?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Ai4y147kr?spm_id_from=333.999.0.0)

```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        res = 1

        if n < 0:
            x = 1/x
            n = -n

        if n == 0:
            return res

        while n>0:
            if n % 2 == 1:
                res *= x
            n >>= 1
            # ç­‰ä»·äº n //= 2
            x *= x
        return res
```

```scala
/**
* chosen solution
* recursive - bottom-up
* memo
*   1. n may be negative or positive
*   2. n may be odd or even
*   3. do not care n during recursive
* time complexity: O(logN)
*/

object Solution0 {
    def myPow(x: Double, n: Int): Double = {
      if (n == 0) return 1
      val ans = _myPow(x, math.abs(n))
      if (n < 0) 1 / ans else ans 
    }
    
    def _myPow(x: Double, n: Int): Double = {
      if (n == 1 || n == 0) x
      else if ((n & 1) == 1) _myPow(x * x, n / 2) * x
      else _myPow(x * x, n / 2)
    }
}


/**
* recursive version : bottom-up
* memo
*   1. n may be negative or positive
*   2. n may be odd or even
* O(logN) in time
*/
object Solution1 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) 1
    else if(n > 0) {
      n % 2 match{
        case 1 => myPow(x * x, n / 2) * x
        case 0 => myPow(x * x, n / 2)
      }
    }else{
      val t = myPow(x, n / 2)
      math.abs(n % 2) match{
        case 1 => t * t * (1 / x)
        case 0 => t * t
      }
    }

  }
}
/**
* recursive version : bottom-up
*/
object Solution1-2 {
    def myPow(x: Double, n: Int): Double = {
        if(n == 0) return 1
        
        val t = myPow(x, n / 2)
        
        if(n % 2  == 0){
            t * t
        }else{
            if(n < 0) t * t * (1 / x)
            else t * t * x
        }
    }
}

/**
*  bottom-up -recursive,
*   do not care n during recursive
*/
object Solution1-3 {
    def myPow(x: Double, n: Int): Double = {
      if (n == 0) return 1
      val ans = _myPow(x, math.abs(n))
      if (n < 0) 1 / ans else ans 
    }
    
    def _myPow(x: Double, n: Int): Double = {
      if (n == 1 || n == 0) x
      else if ((n & 1) == 1) _myPow(x * x, n / 2) * x
      else _myPow(x * x, n / 2)
    }
}


/**
* top-down - iterative version 
* Binary Exponentiation with negative n
*
* each iteration is calculate pow(base, nn) * ans
*   ex: input x = 2, n = 10
*    0. base: 2.0, nn: 10 ans: 1.0 => pow(2, 10) * 1 =  1024
*    1. base: 4.0, nn: 5, ans: 1.0  => pow(4, 5) * 1 = 1024
*    2. base: 16.0, nn: 2, ans: 4.0 => pow(16, 2) * 4 = 1024
*    3. base: 256.0, nn: 1, ans: 4.0 => pow(256, 1) * 4 = 1024
*    4. base: 65536.0, nn: 0, ans: 1024.0 => pow(65536, 0) * 1024 = 1024
*
* time complexity: O(logN)
*/

object Solution2 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) return 1
    var ans = 1.0
    var nn = n
    var base = x

    while (nn != 0) {
     /* nn could be -1 if nn < 0 and run nn % 2, so using nn & 1 here */
      if((nn & 1) == 1)  ans = ans * base
      nn = nn / 2
      base = base * base
    }
    // judge n to decide whether reverse ans
    if (n < 0) 1.0 / ans else ans  
  }
}

/**
*  top-down - recursive with tail recursive
*/
object Solution2-1 {
    def myPow(x: Double, n: Int): Double = {
      val ans = _myPow(1, x, n)
      if(n < 0) 1 / ans else ans
    }
    
    @annotation.tailrec
    def _myPow(current: Double, base: Double, pow: Int): Double = {
        if(pow == 0) current
        else{
            if((pow & 1) == 1) _myPow(current * base, base * base, pow / 2)
            else _myPow(current, base * base, pow / 2)
        }
    }
}


```

###  3.46. <a name='-1'></a>51. æ•°ç»„ä¸­çš„é€†åºå¯¹

[å®˜æ–¹](https://www.bilibili.com/video/BV1Qk4y1r7u5?spm_id_from=333.999.0.0)

###  3.47. <a name='Maximumsubarray'></a>53-ã€è´ªå¿ƒğŸ§¡ã€‘Maximum subarray

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1QJ411R75H?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i7dn?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV11A41187AR?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Ta4y1i7Sh?spm_id_from=333.999.0.0)

è´ªå¿ƒ

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5qrso4wuc440.png)

```py
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = preSum = nums[0]
        for num in nums[1:]:
            preSum = max(preSum + num, num)
            res = max(res,preSum)
        return res
```

æ—¶é—´å¤æ‚åº¦ï¼šO(n)
æ—¶é—´å¤æ‚åº¦ï¼šO(1)

```scala
object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
        
        // IDEA:
        // Go through the whole Array,
        // and change each element into the possible maximum sum of the subarray ENDING at its index 
        
        // During each iteration, the element at i-th index will be updated into the possible maximum sum of subarray ENDING at i-th index
        // then for (i+1)th index, if updated i-th value is positive, it can be used to update (i+1)th value as well.
        
        for (i <- Range(1, nums.length)) {
            if (nums(i-1) > 0) {
                nums(i) += nums(i-1)
            }
        }
        
        nums.max
    }
}
```

```scala
/**
* chosen solution
* dynamic programming
*    dp[i] defined as the sum of subarray that ending with ith element and must contains i-th element number   *
* actually, we don't need storing all previous status of nums.length
* we just need two status: one for maximum so far, the other one for the maximum accumulated value which containing with nums[i]
*
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution0{
    def maxSubArray(nums: Array[Int]): Int = {
        if (nums == null || nums.isEmpty) return 0
        var maxSoFar = nums(0)
        var maxEndingHere = nums(0)

        for(i <- 1 until nums.length) {
           maxEndingHere = (maxEndingHere +  nums(i))  max nums(i)
           maxSoFar = maxEndingHere max  maxSoFar
        }
        maxSoFar
        
    }
}

/**
* my first commit version
* time complexity: O(N^2)
* space complexity: O(N)
*/

object Solution1 {
    def maxSubArray(nums: Array[Int]): Int = {
     
        (1 to nums.length).map(n => _maxSubArray(nums, nums(n - 1), n)).max
        
    }
    
    def _maxSubArray(nums: Array[Int], preSum: Int, currentIdx: Int): Int = {
        if(nums.length == currentIdx) return preSum
        
        val currentSum = preSum + nums(currentIdx)
        val nexLevelSum = _maxSubArray(nums, currentSum, currentIdx + 1)
        preSum max currentSum max nexLevelSum
    }
    
}

/**
* dynamic programming
* memo:
*    1. dp[i] defined as the sum of subarray that ending with ith element and must contains i-th element number   
* time complexity: O(N)
* space complexity: O(N)  due to dp array
*/

object Solution2 {
    def maxSubArray(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.ofDim[Int](nums.length, 2)  // dp(0) ... dp(i) storing each status corresponding to  nums' index, means max subarray sum ending with nums[i]
        dp(0)(0) = nums(0)  // dim0: accumulate calculator which reset while new element is larger value inside,
        dp(0)(1) = nums(0) // dim1: maximum so far
        
        for(i <- 1 until nums.length) {
            
            dp(i)(0) = (dp(i - 1)(0) + nums(i))  max nums(i)
            dp(i)(1) = dp(i)(0) max dp(i - 1)(1) 
        }
        dp.last.last
    }
}

/**
* dynamic programming
* memo
*   1. one dimension array
* time complexity O(N)
* space complexity O(N)
*/
object Solution2-1 {
    def maxSubArray(nums: Array[Int]): Int = {
      val dp  = Array.ofDim[Int](nums.length)
      dp(0) = nums(0)
      for (i <- 1 until nums.size) {
        dp(i) = nums(i) max (nums(i) + dp(i - 1))
      }
      
      dp.max
    }
}

/**
* dynamic programming
* actually, we don't need storing all previous status of nums.length
* we just need two status: one for maximum so far, the other one for the maximum accumulated value which containing with nums[i]
*
* time complexity: O(N)
* space complexity: O(1)
*/

object Solution2-2 {
    def maxSubArray(nums: Array[Int]): Int = {
        if (nums == null || nums.isEmpty) return 0
        var maxSoFar = nums(0)
        var maxEndingHere = nums(0)

        for(i <- 1 until nums.length) {
           maxEndingHere = (maxEndingHere +  nums(i))  max nums(i)
           maxSoFar = maxEndingHere max  maxSoFar
        }
        maxSoFar
        
    }
}
/**
*  functional programming: foldLeft
*/
object Solution2-3 {
    def maxSubArray(nums: Array[Int]): Int = {
      if(nums == null || nums.isEmpty) return 0
      (1 until nums.length).foldLeft((nums(0), nums(0))){
          case ((maxEndingI, maxSofar), i) => 
            val maxEndingT = nums(i) max (nums(i) + maxEndingI)
            (maxEndingT, maxSofar max maxEndingT )
      }._2
    }
}
```

```scala
object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
        if(nums.length == 1){
            nums(0)
        }else{
            var sum = nums(0)
            var max = nums(0)
            var i = 1
            while (i < nums.length){
                val elem = nums(i)
                sum = sum + elem
                if(sum > max){
                    max = sum
                    i += 1
                }else if(sum < elem){
                    sum = elem
                    i += 1
                }else{
                    i += 1
                }
                
                if(elem > max){
                    max = elem
                    sum = elem
                }
            }
            max
        }
    }
}

```

```scala
package com.zhourui.leetcode

import scala.math.{abs, max}
import com.zhourui.codech.BaseExtension

package lc0053_maxsubarr {




  object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
      var maxsum:Int=Int.MinValue
      nums.foldLeft(0) {
        case (a,b) => { // ç¬¬ä¸€æ¬¡è¿›å…¥æ—¶,a=0
          val cursum = max(a+b,b)
          maxsum = max(maxsum, cursum)
          cursum
        }
      }
      return maxsum
    }
  }

  class Test extends BaseExtension {
    def init {
      val arr = Array(-2, 1, -3, 4, -1, 2, 1, -5,4)
      println(Solution.maxSubArray(arr) == 6)

    }
    val name = "053 max sub array"
  }
}



/*
[-2,1,-3,4,-1,2,1,-5,4]
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int cursum = nums[0];
        int maxsum = cursum;

        for (int i=1;i<nums.size();i++) {
            cursum = max(cursum+nums[i],nums[i]);
            maxsum = max(maxsum, cursum);
        }
        return maxsum;
    }
};
 */
```

###  3.48. <a name='SpiralMatrix'></a>54. Spiral Matrix

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1N7411h7i1?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        # print(list(matrix.pop(0)))
        print(list(zip(*matrix)))
        print(list(zip(*matrix))[::-1])
        return matrix and list(matrix.pop(0)) + self.spiralOrder(list(zip(*matrix))[::-1])
        # å«ä¹‰æ˜¯ï¼Œå¦‚æœmatrixä¸ºç©ºï¼Œåˆ™è¿”å›matrix
```

```py
return a and b
 
ç­‰ä»·äº
 
return b if a else a
```

```py
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            res += matrix.pop(0) # æ˜“é”™ç‚¹ï¼šæ³¨æ„æ˜¯+=
            matrix = list(zip(*matrix))[::-1] # æ˜“é”™ç‚¹ï¼šæ³¨æ„[::-1]çš„æ‘†æ”¾
        return res
```

```scala
/**
* my first commitment: using extra seen matrix
* memo:
*  1. check next coordination, if have seen it, increase the direction index
* time complexity : O(N)
* space complexity: O(2N): seen matrix + output list
*/
object Solution1 {
    import collection.mutable
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {
      val n = matrix.length
      val m = matrix(0).length
      val seen = Array.ofDim[Boolean](n, m)
      val ans = mutable.ListBuffer.empty[Int]
      
      @annotation.tailrec
      def run(directionIdx: Int, coord: (Int, Int), ans: mutable.ListBuffer[Int], targetSize: Int): Unit = {
        if (ans.size == targetSize) return

        val (row, col) = coord
        ans += matrix(row)(col)  
        seen(row)(col) = true


        if (checkNextCoordAvailable(coord, directionIdx, seen)) {
          val direction = getDirection(directionIdx)
          val nextCoord = (row + direction._1, col + direction._2)
          run(directionIdx, nextCoord, ans, targetSize)
        }else {
          val newD = (d + 1) % 4
          val direction = getDirection(newD)
          val nextCoord = (row + direction._1, col + direction._2)
          run(newD, nextCoord, ans, targetSize)
        }

      }

      run(0, (0, 0), ans, n * m)
      ans.toList
    }
  
    
    def checkNextCoordAvailable(coord: (Int, Int), directionIdx: Int, seen: Array[Array[Boolean]]): Boolean = {
      val (row, col) = coord
      val direction = getDirection(directionIdx)
      val nextCoord = (row + direction._1, col + direction._2)

      
      0 <= nextCoord._1 && nextCoord._1 < seen.length && 0 <= nextCoord._2 && nextCoord._2 < seen(0).length && !seen(nextCoord._1)(nextCoord._2)
    }
   
    def getDirection(idx: Int): (Int, Int) = {
      val direction = List (
        (0, 1), // right
        (1, 0), // go down
        (0, -1), // go left
        (-1, 0) // go up
      )
      direction(idx)
    }
}


/**
* counterclockwise rotate matrix
* step:
*  1. add first line to list
*  2. counter-clockwise rotate remaining matrix: transpose + entire reverse
*  
*  remaining:
*  4 5 6
*  7 8 9
* 
* transpose:
*   4 7
*   5 8
*   6 9
* 
* reverse:
*   6 9
*   5 8
*   4 7
*/

object Solution2-1 {
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = { 
        def dfs(mx: Array[Array[Int]]): List[Int] = mx match {
            case mx if mx.isEmpty => List()
            case mx if mx.length == 1 => mx.head.toList
            case _ => mx.head.toList ::: spiralOrder(mx.tail.transpose.reverse)  // counter-clockwise
        }
        dfs(matrix)

    }    
}



/**
* bounded range: 
*  memo:
*    1. direction pattern: right -> down -> left -> up
* time complexity O(N)
* space complexity O(N) : output list
*/
object Solution3-1 {
    import collection.mutable
  
    sealed trait Direction
    case object Right extends Direction
    case object Down extends Direction
    case object Left extends Direction
    case object Up extends Direction
  
    def getNextDirection(direction: Direction): Direction = 
      direction match {
        case Right => Down
        case Down => Left
        case Left => Up
        case Up => Right
      }

  
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {
      if (matrix.isEmpty) List.empty
      val n = matrix.length
      val m = matrix(0).length
      val ans = mutable.ListBuffer.empty[Int]
      run(matrix, ans, Right, 0, m - 1, 0, n - 1, n * m)
      ans.toList
    }
  
    def run(matrix: Array[Array[Int]], ans: mutable.ListBuffer[Int], direction: Direction, colLo: Int, colHi: Int, rowLo: Int, rowHi: Int, targetSize: Int): Unit = {
      if (ans.size < targetSize) {
        
        direction match {
          
          case Right => 
          /** 
          * fix rowLo and increase rowLo after traversing right
          */
            (colLo to colHi).foreach(colIdx => ans += matrix(rowLo)(colIdx))
            run(matrix, ans, getNextDirection(direction), colLo, colHi, rowLo + 1, rowHi, targetSize)
          case Down =>
           /** 
          * fix colHi and decrease colHi after traversing down
          */
            (rowLo to rowHi).foreach(rowIdx => ans += matrix(rowIdx)(colHi))
            run(matrix, ans, getNextDirection(direction), colLo, colHi - 1, rowLo, rowHi, targetSize)
          case Left =>
          /** 
          * fix rowHi and decrease rowHi after traversing left
          */
          
            (colHi to colLo by -1).foreach(colIdx => ans += matrix(rowHi)(colIdx))
            run(matrix, ans, getNextDirection(direction), colLo, colHi, rowLo, rowHi - 1, targetSize)
          case Up => 

            /** 
          * fix colLo and increase colLo after traversing up
          */
            (rowHi to rowLo by -1).foreach(rowIdx => ans += matrix(rowIdx)(colLo))
            run(matrix, ans, getNextDirection(direction), colLo + 1, colHi, rowLo, rowHi, targetSize)
          
        }
      }
    }
}
```

###  3.49. <a name='JumpGame'></a>55 Jump Game

[å°æ˜](https://www.bilibili.com/video/BV14K4y1b7Fw?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1be411s7XX?spm_id_from=333.999.0.0)

```py
# é¦–é€‰whileå¾ªç¯ğŸ˜
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)
        i = 0

        while cover >= i:
            cover = max(cover, i+nums[i])
            if cover >= n -  1:
                return True
            i += 1
        return False



# ç²¾ç®€ä¸€ä¸‹çš„forå¾ªç¯ğŸ˜
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)

        for i in range(n):
            if i <= cover: # æ˜“é”™ç‚¹ï¼šåœ¨åˆ¤æ–­ä¸‹ä¸€ä¸ªcoverå‰ï¼Œå…ˆè¦åˆ¤æ–­iæ˜¯å¦èƒ½å¤Ÿåˆ°è¾¾
                cover = max(cover, i+nums[i])
                # if cover == i:
                    # return False # æ˜“é”™ç‚¹ï¼šåº”è¯¥è€ƒè™‘ç‰¹æ®Šæƒ…å†µ[0,1,2]

                if cover >= n -  1:
                    return True
        return False
```

```py
object Solution {
    def canJump(nums: Array[Int]): Boolean = {
        
        // We should look at this probelm in REVERSE ORDER:
        // The target is to check whether we can arrive at the last index,
        // then we should reversely check the elements,
        // meanwhile, update the smallest index that we must arrive (`target`) in order to arrive at the last index
        
        // For example, if the i-2 index index is 2,
        // we know we can make it as long as the earlier elements can send us to i-2 index.
        // My target should be updated to i-2 index rather than the last index.
        
        val n = nums.length 
     
        var target = n-1 // the initial target
        var i = n - 2
        
        // update the target
        while (i > 0) {
            if (nums(i) + i >= target) {
                target = i
            }
            i -= 1
        }
        
        // check if the first element can trigger the "chain effect"
        if (nums(0) >= target) {
            true
        } else {
            false
        }
 
    }
}
```

```scala


/**
* my first commitment: backtracking + dp - top-down
* memo:
*   1. cache array record which position could jump to destination
*   2. run the loop of jump step size  backward
*/

object Solution1-1 {
    sealed trait Index
    case object Good extends Index 
    case object Bad extends Index
    case object Unknown extends Index
  
    def canJump(nums: Array[Int]): Boolean = {
        val cache = Array.fill[Index](nums.length)(Unknown)
        cache(cache.length-1) = Good
        dfs(nums, 0, cache)

    }
  
    def dfs(nums: Array[Int], pos: Int, cache: Array[Index]): Boolean = {
      if (cache(pos) != Unknown) {
        return cache(pos) == Good
      }
      
      val furthestJump = ((nums.length - 1) - pos) min nums(pos) // don't jump exceed array's length
      val ret = (furthestJump to 1 by -1).collectFirst {  // 1 to  furthestJump would lead to TLE
        case j if dfs(nums, pos + j, cache) =>  true
      }.getOrElse(false)
      
      
      if (ret) cache(pos) = Good else cache(pos) = Bad
      ret
    }
}

/**
* backtracking: DP bottom-up: more simpler
* memo
* 1. solve problem from tail to head
* 2. cache value: true for GOOD position, false for Bad position
* 3. if cache(0) is true, we could jump to last position from position zero
*/

object Solution1-2 {
    def canJump(nums: Array[Int]): Boolean = {
      val cache = Array.ofDim[Boolean](nums.length)
      cache(cache.length - 1) = true
      
      (nums.length - 2 to 0 by -1).foreach { pos =>
        val furthestJump = ((nums.length - 1) - pos) min nums(pos)
        (furthestJump to 1 by -1).collectFirst {
          case step if cache(pos + step) => 
          cache(pos) = true
          cache(pos)
        }.getOrElse(false)
      }
      cache(0)
    }
}


/**
* Greedy - check each position could jump to last good position
* memo:
*  1. solve problem backward
*  2. record last good position which could jump to last position within multi-hop
*  3. check zero position could jump to last position by checking last position equals to zero
* time complexity: O(N)
*/

object Solution2-1 {
    def canJump(nums: Array[Int]): Boolean = {
      var lastPosition = nums.length - 1
      
      (nums.length - 2 to 0 by -1).foreach{ pos =>
        if((nums(pos) +  pos) >= lastPosition) {
          lastPosition = pos
        }
        
      }
      lastPosition == 0
    }
}


/**
* Greedy: check max reach position
* memo
*  1. record max reach position: if current position is larger than max reach position, it means we couldn't jump to current position and it wouldn't be able to jump to last position
* time complexity: O(N)
*/

object Solution3-1 {
    def canJump(nums: Array[Int]): Boolean = {
      var maxReachPos = nums(0)
      nums.indices.forall { pos =>  
          if (pos > maxReachPos) false  
          else {
            maxReachPos = maxReachPos max (pos + nums(pos))
            true
          }
        }        
    }
}

```

###  3.50. <a name='I.'></a>56-I. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•°

[å®˜æ–¹](https://www.bilibili.com/video/BV1Qe411s7Kc?spm_id_from=333.999.0.0)

###  3.51. <a name='MergeIntervals'></a>56. Merge Intervals

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11t411J7zV?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1w7411a7Wo?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1pV411a7t4?spm_id_from=333.999.0.0)

```py
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        # ç­‰ä»·äºï¼šintervals.sort(key = lambda x: x[0])
        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1],interval[1])
                # æ˜“é”™ç‚¹ï¼šä¸æ˜¯interval[1]ï¼Œè€Œæ˜¯max(res[-1][1],interval[1])
                # æ¯”å¦‚ï¼Œ[[1,4],[2,3]]
        return res
```

```py
# ä¸ä½¿ç”¨é¢å¤–çš„å‚¨å­˜ç©ºé—´ï¼Œç›´æ¥åœ¨åŸçŸ©é˜µä¸Šé¢ä¿®æ”¹çš„åŸåœ°ç®—æ³•ï¼ˆåæ­£æ’åºçš„æ—¶å€™å·²ç»ä¿®æ”¹äº†åŸçŸ©é˜µï¼‰ï¼š
# pop(i)æ“ä½œå’Œappend()æ“ä½œè€—æ—¶ä¸€æ ·å—ã€‚
# å¦‚æœä½ ç›´æ¥intervals.pop()è€Œä¸æ˜¯intervals.pop(i) ï¼Œé‚£è€—æ—¶ä¸€æ ·ï¼Œéƒ½æ˜¯o(1)ï¼Œ
# ä½†æ˜¯ä½ æŒ‡å®šä½ç½®popï¼Œé‚£å°±æ˜¯o(n)äº†ã€‚

class Solution:
    def merge(self, intervals):
        intervals.sort()
        i = 1
        while(i < len(intervals)):
            if intervals[i][0] > intervals[i-1][1]:
                i += 1
            else:
                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])
                intervals.pop(i)       
        return intervals
```

```scala

/**
*  my first commitment: sort array
*  time complexity: O(nlogn) + O(n) = O(nlogn) 
*  space complexity: O(n): sorted array
*/

object Solution1-1 {
    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {
      val sortedL = intervals.sortBy(_(0))
      val ans = collection.mutable.Set.empty[Array[Int]]
      
      var begin = sortedL(0)(0)
      var end = sortedL(0)(1)
      (1 to sortedL.length - 1).foreach { idx =>
        val l = sortedL(idx)
        if (end < l(0)){
          ans += Array(begin, end)
          begin = l(0)
          end = l(1) 
        }else {
          end = l(1) max end
        }
      }
      ans += Array(begin, end)
      ans.toArray
    }
}

/**
* simplify 1-1
* 1.not using Set
* 2. record uncertain (begin, end) pair in answer list
*/

object Solution1-2 {
    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {
      intervals.sortBy(_(0)).foldLeft(List.empty[Array[Int]]){
        case (last::ans, arr) =>
          if (last.last < arr.head) {
            arr::last::ans
          } else {
            Array(last.head, last.last max arr.last)::ans
          }
        case (ans, arr) => arr::ans // for empty ans list
      }.toArray
    }
}
```

###  3.52. <a name='InsertInterval'></a>57. Insert Interval 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11t411J74e?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ja4y1j7cG?spm_id_from=333.999.0.0)

```py
# æ ¹æ®ä¸Šä¸€é—®ä¿®æ”¹ã€‚
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        intervals.append(newInterval)
        intervals.sort()
        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1],interval[1])
        return res
```

```scala
/**
* my first commitment
* memo
*  1. insert newInterval to intervals according to its first element value
*  2. combine overlapping range 
* time complexity: O(2N) = O(N)
* space complexity: O(N)
*/

object Solution1-1 {
    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {
      if (intervals.isEmpty) return Array(newInterval)
      (_insert(_, newInterval)).andThen(combine).apply(intervals).reverse.toArray
    }  
    val _insert = (intervals: Array[Array[Int]], newInterval: Array[Int]) => {
    /**
    * find the position to split intervals into two parts
    */
      val pos = intervals.indices.find(idx => intervals(idx).head > newInterval.head).getOrElse(intervals.length)
      intervals.slice(0, pos).toList ::: List(newInterval) ::: intervals.slice(pos, intervals.length).toList
    }
  
    val combine = (input: List[Array[Int]])  => input.foldLeft(List.empty[Array[Int]]) {
        case (last::ans, arr) =>
          if (last.last < arr.head) arr::last::ans
          else Array(last.head, arr.last max last.last)::ans
        case (ans, arr) => //for empty ans
            arr::ans
      }
}

/**
* optimize from 1-1
* 1.span
*/
object Solution1-2 {
    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {
      // if (intervals.isEmpty) return Array(newInterval)
      (insert(_, newInterval)).andThen(combine).apply(intervals.toList).reverse.toArray
    }
  
    val insert = (intervals: List[Array[Int]], newInterval: Array[Int]) => {
      val (a, b) = intervals.span(arr => arr.head < newInterval.head)
      a:::List(newInterval):::b
    }
  
    val combine = (input: List[Array[Int]])  => input.foldLeft(List.empty[Array[Int]]) {
        case (last::ans, arr) => if (last.last < arr.head) arr::last::ans else Array(last.head, arr.last max last.last)::ans
        case (ans, arr) => arr::ans //for empty ans
      }
}
```

###  3.53. <a name='LenghofLastWords'></a>58. Lengh of Last Words

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i7so?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ay4y1y7d2?spm_id_from=333.999.0.0)

```py
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        s.strip()
        return len(s.split()[-1]) if s else 0
```

```py
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        res = 0
        tmp = 0
        for i in range(len(s)):
            if s[i] == ' ':
                tmp = 0
            else:
                tmp += 1
                res = tmp # æ˜“é”™ç‚¹ï¼šç”¨reså­˜å‚¨tmpå˜é‡ï¼Œé˜²æ­¢æœ«å°¾çš„ç©ºæ ¼
        return res
```

###  3.54. <a name='II.LCOF'></a>59 - II. é˜Ÿåˆ—çš„æœ€å¤§å€¼ LCOF

[å®˜æ–¹](https://www.bilibili.com/video/BV1L54y1z7ae?spm_id_from=333.999.0.0)

###  3.55. <a name='SpiralMatrixII'></a>59. Spiral Matrix II 

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1J741157Kt?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1q5411G7MY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[0 for _ in range(n)] for _ in range(n)]
        x,y,dx,dy = 0,0,0,1 
        # 0,1 -> 1,0 -> 0,-1 -> -1,0
        for num in range(1,n*n + 1):
            res[x][y] = num

            if not 0 <= x+dx < n or not 0 <= y+dy < n or res[x+dx][y+dy] != 0:
            # æ˜“é”™ç‚¹ï¼šor res[x+dx][y+dy] != 0 é¡ºåºå¾ˆé‡è¦ï¼Œä¸€å®šè¦åœ¨æœ€å
                dx,dy = dy, -dx

            x += dx
            y += dy
        return res
```

###  3.56. <a name='RotateList'></a>61. Rotate List

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14y4y1r728?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV117411L7UG?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1jK411N7e6?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1Xk4y1d7gF?spm_id_from=333.999.0.0)

```py
# python è§£æ³• æ€è·¯ï¼šå…ˆæŠŠé“¾è¡¨é¦–å°¾ç›¸è¿ï¼Œå†æ‰¾åˆ°ä½ç½®æ–­å¼€å¾ªç¯
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # æ˜“é”™ç‚¹ï¼šè¦æ’é™¤ä¸€äº›ç‰¹æ®Šæƒ…å†µ
        if not head or not head.next:
            return head
            
        cur = head
        nodeNum = 1
        # é“¾æ¥æˆä¸€ä¸ªç¯
        while cur.next:
            cur = cur.next
            nodeNum += 1
        cur.next = head


        # curæŒ‡é’ˆæŒ‡å‘å¼€å¤´
        cur = cur.next
        # stepsåˆ°è¾¾new headçš„å‰ä¸€ä¸ªnode
        steps = nodeNum - k % nodeNum - 1
        for _ in range(steps):
            cur = cur.next


        res = cur.next
        cur.next = None
        return res
```

###  3.57. <a name='-1'></a>62-ä¸åŒè·¯å¾„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1mC4y1W7Je?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Sg4y1v7PM?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1cp4y167qx?spm_id_from=333.999.0.0)

äºŒç»´åŠ¨æ€è§„åˆ’ï¼š

æ—¶é—´å¤æ‚åº¦ï¼šO(mn)

ç©ºé—´å¤æ‚åº¦ï¼šO(mn)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # æ˜“é”™ç‚¹ï¼šdpåƒä¸‡ä¸è¦å†™é”™
        # å…¶ä»–å†™æ³•ï¼šdp = [[1 for i in range(n)] for j in range(m)]
        # å…¶ä»–å†™æ³•ï¼šdp = [[1]*n]*m
        dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

ä¸€ç»´åŠ¨æ€è§„åˆ’ï¼š

æ—¶é—´å¤æ‚åº¦ï¼šO(mn)

ç©ºé—´å¤æ‚åº¦ï¼šO(n)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # æ˜“é”™ç‚¹ï¼šdpåƒä¸‡ä¸è¦å†™é”™
        dp = [1]*n
        for i in range(1,m):
            for j in range(1,n):
                dp[j] += dp[j-1]
        return dp[-1]
```

```scala

/**
* my first commitment: math combination
* memo:
*  1. the total walk steps is (m-1) + (n -1) : (m-1) steps go down and (n-1) steps go right
*  2. unique paths is calculated by C^{m - 1 + n - 1}_{ m - 1} * C^{n-1}_{n-1}
*/
object Solution1 {
    def uniquePaths(m: Int, n: Int): Int = {
      val allStep = (m - 1)  +  (n - 1)
      calCombination(allStep, (m - 1))     
    }
    def calCombination(a: Int, b: Int): Int = {
      val c = a - b
      val max = c max b
      val min = c min b
      val numerator = (BigInt(a) until max by -1).product
      val denominator = (BigInt(min) to 1 by -1).product
      (numerator / denominator).toInt
    }
}

/**
* long type
*/
object Solution1-2 {
    def uniquePaths(m: Int, n: Int): Int = {
      val allStep = (m - 1)  + (n - 1)
      calCombination(allStep.toLong, (m - 1).toLong).toInt 
    }
    def calCombination(a: Long, b: Long): Long = {
      val c = a - b
      val max = c max b
      val min = c min b
      val numerator = (a until max by -1).product
      val denominator = (min to 1 by -1).product
      (numerator / denominator)
    }
}

/**
* dynamic programming
* time complexity: O(N *M)
* space complexity: O(N * M)
*/
object Solution2 {
    def uniquePaths(m: Int, n: Int): Int = {
      val dp = Array.tabulate[Int](m, n) {
        case (0, j) => 1
        case (i, 0) => 1
        case _ => 0
      }
      for (i <- 1 until m; j <- 1 until n) {
        dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)
      }
      
      dp.last.last
    }
}

/**
* fill dp array with 1
*/
object Solution2-1{
    def uniquePaths(m: Int, n: Int): Int = {
      val dp = Array.fill[Int](m, n)(1)
      for (i <- 1 until m; j <- 1 until n) {
        dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)
      }
      
      dp.last.last
    }
}
```

###  3.58. <a name='UniquePathsII'></a>63 Unique Paths II

[å°æ˜](https://www.bilibili.com/video/BV1Sv411L7qe?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Pp4y1v7KR?spm_id_from=333.999.0.0)

```py
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        # æ˜“é”™ç‚¹ï¼šæ³¨æ„è¾¹ç•Œä¸Šä¹Ÿå¯èƒ½æœ‰obstacle
        # æ˜“é”™ç‚¹ï¼šdp = [[0]*(n+1)]*(m+1)è¿™äº›å†™æ³•æ˜¯é”™è¯¯çš„
        dp = [[0]*(n+1) for _ in range(m+1)]
        # æ˜“é”™ç‚¹ï¼šdp[1][1] = 1,è¿™ä¸ªæ•°å­—ä¼šè¢«é‡æ–°è®¡ç®—ï¼Œæ‰€ä»¥åº”è¯¥å†™æˆï¼š
        dp[0][1] = 1
        # æ„å»ºäº†ä¸€ä¸ªå¤§ä¸€åœˆçš„çŸ©é˜µï¼Œä½†å®é™…è®¡ç®—çš„æ—¶å€™ï¼Œä»ç„¶æ˜¯mnçš„å¤§å°
        for i in range(1,m+1):
            for j in range(1,n+1):
                if not obstacleGrid[i-1][j-1]:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        print(dp)
        return dp[-1][-1]
```

###  3.59. <a name='MinimumPathSum64-'></a>64. Minimum Path Sum 64-æœ€å°è·¯å¾„å’Œ

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV12W411679S?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Ka4y1i7Vu?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1JC4y1x7j1?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1vi4y1u7a6?spm_id_from=333.999.0.0)

```py
# å¯ä»¥ç›´æ¥åœ¨åŸæ•°ç»„ä¸Šè¿›è¡Œè®°å¿†ï¼Œä¸éœ€è¦é¢å¤–çš„ç©ºé—´
# so easy,ç›´æ¥AC
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == j == 0:
                    continue
                if i == 0:
                    grid[i][j] += grid[i][j-1]
                if j == 0:
                    grid[i][j] += grid[i-1][j]
                if i > 0 and j > 0:
                    grid[i][j] += min(grid[i-1][j],grid[i][j-1])
        return grid[-1][-1]
```

###  3.60. <a name='ValidNumber'></a>65 Valid Number

[å°æ˜](https://www.bilibili.com/video/BV1hK4y1975b?spm_id_from=333.999.0.0)

###  3.61. <a name='Plusone'></a>66 Plus one

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1jJ411d7Ry?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i7b1?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1gi4y137GW?spm_id_from=333.999.0.0)



```py
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        for i in range(len(digits)-1,-1,-1):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
        return [1] + digits

# ç®€å•é¢˜é‡æ‹³å‡ºå‡»ï¼Œæœ€åä¸€ä½åŠ 1ï¼Œ
# ç­‰äº10å°±è¿›ä½ï¼Œæ²¡æœ‰è¿›ä½å°±è¾“å‡ºï¼Œ
# è¿›ä½åˆ°å¤´å°±åœ¨outputå‰é¢åŠ ä¸ª1ï¼Œç®€å•æ˜“æ‡‚
```

```scala
object Solution {
    def plusOne(digits: Array[Int]): Array[Int] = {
        var size = digits.length
        var add = 1
        
        var output = List.empty[Int]
        
        (0 to (size-1)).reverse.map(i => {
            
            val x = digits(i)
            
            if(x == 9 && add == 1 && i == 0){
                output = List(1, 0) ++ output
            }else if(x == 9 && add == 1){
                output = 0 +: output
            }else{
                if(add == 1){
                    output = (x+1) +: output
                    add = 0
                }else{
                    output = x +: output
                }
            }
        })
        output.toArray
    }
}

```

###  3.62. <a name='AddBinary'></a>67-Add Binary

[å“ˆå“ˆå“ˆï¼ˆå¸¸è§„æ–¹æ³•ï¼‰](https://www.bilibili.com/video/BV1N7411F73K?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV17J411d7G1?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i7Bo?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Q5411h7gc?spm_id_from=333.999.0.0)

å¸¸è§„åšæ³•:

```py
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        res = ''
        carry = 0
        i = len(a)-1
        j = len(b)-1
        while i >= 0 or j >= 0 or carry: # æ˜“é”™ç‚¹ï¼š ä¸è¦æ¼ or carry
            val = carry
            if i >= 0: val += int(a[i]) # æ˜“é”™ç‚¹ï¼š[i],ä¸è¦å†™æˆ(i)
            if j >= 0: val += int(b[j])
            carry = val // 2
            res += str(val % 2)
            i -= 1
            j -= 1
        return res[::-1]
```

###  3.63. <a name='Sqrtx'></a>69 Sqrt(x) è§ HJ107 æ±‚è§£ç«‹æ–¹æ ¹

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1WW411C7YN?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1gJ411R7XR?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i7TN?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1PK411s72g?spm_id_from=333.999.0.0)

è¢–çè®¡ç®—å™¨:

æ—¶é—´å¤æ‚åº¦ï¼šO(1)

ç©ºé—´å¤æ‚åº¦ï¼šO(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        ans = int(math.exp(0.5 * math.log(x)))
        return ans + 1 if (ans + 1) ** 2 <= x else ans
```

äºŒåˆ†æŸ¥æ‰¾:

æ—¶é—´å¤æ‚åº¦ï¼šO(logN)

ç©ºé—´å¤æ‚åº¦ï¼šO(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r, ans = 0, x, -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x:
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans

# äºŒåˆ†æ³•ä¸éœ€è¦ans
# ä½†æ˜¯ä¸å¥½ç†è§£

class Solution:
    def mySqrt(self, x: int) -> int:
        l = 0
        r = x
        while l <= r:
            m = (l + r) // 2 # lå’Œ1ï¼Œä¸è¦æ‰“é”™ï¼Œå“ˆå“ˆå“ˆ
            if m**2 > x:
                r = m - 1
            else:
                l = m + 1
        return r
```

ç‰›é¡¿è¿­ä»£æ³•:

æ—¶é—´å¤æ‚åº¦ï¼šO(logN)

ç©ºé—´å¤æ‚åº¦ï¼šO(1)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3g2xmodb40u0.png)

```py
class Solution:
    def mySqrt(self, num: int) -> int:
        x = 1 # èƒŒä¸€èƒŒè¿™ä¸ªå¥—è·¯
        while abs(x**2 - num) > 0.001:
            x -= (x**2 - num) / (2 * x) # æ³¨æ„è¿™é‡Œæ˜¯å‡å·
        return floor(x)
```

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x <= 1:
            return x
        
        C, res = float(x), float(x)
        while True:
            xi = 0.5 * (res + C / res)
            if abs(res - xi) < 1e-7:
                break
            res = xi
        
        return int(res)

class Solution:
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        if x <= 1:
            return x
        res = x # åˆå§‹å€¼
        c = x # ç‰›é¡¿è¿­ä»£æ³•ä¸­çš„å¸¸æ•°
        while res > c / res:
            res = (res + c / res) // 2
        return int(res)
```

```scala
/**
* chosen solution
* binary search - recursive
* memo:
*   1. maintain max and min
* time complexity: O(logN)
*/
object Solution0 {
    def mySqrt(x: Int): Int = {
        if(x == 0 || x == 1) return x
        _mySqrt(0, x, x, math.pow(10, -5)).toInt
    }
    
    @annotation.tailrec
    def _mySqrt(min:Double, max: Double, target:Int, precision: Double): Double = {
        val guess = min + (max - min) / 2
        val estimate = guess * guess
        if(math.abs(estimate - target) < precision) guess
        else{ 
            if(estimate > target) _mySqrt(min, guess, target, precision)
            else _mySqrt(guess, max, target, precision)
        } 
    }
}


/**
* my first commitment
* binary search- iterative
* time complexity: O(LogN)
*/
object Solution1 {
  def mySqrt(x: Int): Int = {
    if(x == 0 || x== 1) return x

    val precision = math.pow(10, -5)
    var high: Double = if (x > 1) x else 1
    var low: Double = 0

    while(true) {
      val mid: Double = low + ((high - low) / 2)
      val estimate = mid * mid

      if(math.abs(estimate - x) < precision){
        return mid.toInt

      }else if(estimate > x) {
        high = mid
      }else {
        low = mid
      }
    }
    x
  }
}
/**
* binary search - iterative
* not return while in while block
*/
object Solution1-2 {
    def mySqrt(x: Int): Int = {
        if(x == 0 || x == 1) return x
        val precision = math.pow(10, -5)
        var max: Double = if(x > 1) x.toDouble else 1.0
        var min = 0.0
        var mid = min + (max - min) / 2 
        var condition = true
        
        while(condition){
            mid = min + (max - min) / 2 
            val estimate = mid * mid
            
            if(math.abs(estimate - x) < precision){
                condition = false
            }else if(estimate > x){
              max = mid  
            } else {
              min = mid
            }
        }
        mid.toInt
    }
}


/**
* binary search - recursive - top-down
* memo:
*   1. maintain max and min
*/
object Solution1-3 {
    def mySqrt(x: Int): Int = {
        if(x == 0 || x == 1) return x
        _mySqrt(0, x, x, math.pow(10, -5)).toInt
    }
    
    @annotation.tailrec
    def _mySqrt(min:Double, max: Double, target:Int, precision: Double): Double = {
        val guess = min + (max - min) / 2
        val estimate = guess * guess
        if(math.abs(estimate - target) < precision) guess
        else{
            if(estimate > target) _mySqrt(min, guess, target, precision)
            else _mySqrt(guess, max, target, precision)
        } 
    }
}

/**
* Newton's method - iterative
* y = x^2 => f(x) = x^2 - y
* x_{k+1} = x_k - f(x_k) / f'(x_k)
* x_{k+1} = x_k - (x_k^2 - y) / (2x_k) = (x_k + y / x_k) / 2
* time complexity: O(logN)
*/

object Solution2 {
     def mySqrt(x: Int): Int = {
        val precision = math.pow(10, -5)
        
        var ans: Double = x
        while(math.abs(ans * ans - x) > precision){
            ans = (ans + x / ans) / 2
            // println(ans)
        }
        ans.toInt
    }
}

/**
*  newton-method - recursive - top-down
*/

object Solution2-1 {
    def mySqrt(x: Int): Int = {
        _mySqrt(x, x, math.pow(10, -5)).toInt
    }

    @annotation.tailrec
    def _mySqrt(guess: Double, target: Int, precision: Double): Double = {
        /* see? (guess * guess - target) is just our f(x) =  x^2 - y */
        if(math.abs(guess * guess - target) < precision) guess
        else _mySqrt((guess + (target / guess)) / 2, target, precision)
    }
}


```

```scala
object Solution {
    def mySqrt(x: Int): Int = {
        if(x == 0){
            0
        }else if(x == 1){
            1
        }else{
            var num: Int = x/2
            var flag = true
            
            while(flag){
                // val sqr = num*num
                // if(sqr == x)
                
                //If we do num*num it may exceed Int range
                //Since we want to check: num*num < x
                //we can instead do num < x/num
                
                if(num > x/num){
                    num = num/2
                }else{
                    val temp = num + 1
                    if(temp > x/temp){
                        flag = false
                    }else{
                        num += 1
                    }
                }
            }
            num
        }
    }
}

//Better solution: in the above solution we are only decreasing the range on 1 side by half, but other side by only 1 number
//This solution decreases by half for both side (binary search pattern)

object Solution {
    def mySqrt(x: Int): Int = {
        if(x == 0){
            0
        }else if(x == 1){
            1
        }else{
            var start = 1
            var end = x
            var result = 0
            
            while(start <= end){
                var mid = start + (end - start)/2
                if(mid <= x/mid){
                    result = mid
                    start = mid+1
                }else{
                    end = mid-1
                }
            }
            result
        }
    }
}

```

###  3.64. <a name='ClimbingStairs'></a>70. Climbing Stairs

[5:32 èŠ±èŠ±é…± DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1gJ411R7X1?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ 70(é‡åˆ¶ç‰ˆ)](https://www.bilibili.com/video/BV1G54y197eZ?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7s9?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1DZ4y1H7k9?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ki4y1u7tn?spm_id_from=333.999.0.0)

```py
class Solution:
    def climbStairs(self, n: int) -> int:
        b1, b2 = 1, 1
        for i in range(n-1):
            b1, b2 = b2, b1 + b2
        return b2

# æˆ‘çš„æ¨¡ä»¿

class Solution:
    def climbStairs(self, n: int) -> int:
        dp0 = 1
        dp1 = 1
        for _ in range(n-1):
            dp1, dp0 = dp0 + dp1, dp1
            # ç”¨2ä¸ªæ•°å­—åˆ†åˆ«å­˜å‚¨
        return dp1
```

```scala
/**
* chosen solution
* dynamic programming
* memo
*   1. dp(i) represent climb to i floor's distinct ways
*   2. dp(i) could be calculate from dp(i - 1) + dp(i - 2)
*           (1) taking a single step from dp(i - 1)
*           (2) taking a step of two from dp(i - 2)
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution0 {
    def climbStairs(n: Int): Int = {
        val dp = Array.ofDim[Int](n + 1)
        dp(0) = 1
        dp(1) = 1
        (2 to n).foreach(i => dp(i) = dp(i - 1) + dp(i - 2))
        dp(n)
    }
}

/**
* my first commitment
* dynamic programming
* memo:
*   1. dp(i) represent climb to i floor's distinct ways
*   2. dp(i) could be calculate from dp(i - 1) + dp(i - 2)
*           (1) taking a single step from dp(i - 1)
*           (2) taking a step of two from dp(i - 2)
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def climbStairs(n: Int): Int = {
        if(n <= 2) n
        else {
            val cache = Array.ofDim[Int](n + 1)
            cache(0) = 1
            cache(1) = 1
            (2 to n).foreach{ nn =>
                cache(nn) = cache(nn - 1) + cache(nn - 2)
            }
            cache(n)
        }
    }
}

/**
*  simplify from 1
*/
object Solution1-2 {
    def climbStairs(n: Int): Int = {
        val dp = Array.ofDim[Int](n + 1)
        dp(0) = 1
        dp(1) = 1
        (2 to n).foreach(i => dp(i) = dp(i - 1) + dp(i - 2))
        dp(n)
    }
}



/**
* DP: only use two extra space to keep previous two value
* time complexity: O(N)
* space complexity: O(1)
*/

object Solution1-3 {
    def climbStairs(n: Int): Int = {
        if(n <= 2) n
        else {
            var a = 1
            var b = 2
            (3 to n).foreach{ nn =>
                val c = a + b
                a = b
                b = c    
            }
            b
        }
    }
}

/**
* dp: index from 0 until n
*   it would be confusing with index i original meaning which is the ways of climbing to stair i
* memo:
*  1. keep two previous status
*/
object Solution1-4 {
    def climbStairs(n: Int): Int = {
        var a = 0
        var b = 1
        for (_ <- 0 until n) {
            val c = a + b
            a = b
            b = c
        }
        b
    }
}
```

```scala
object Solution {
    
    def climbStairs(n: Int): Int = {
        if(n==1){
            1
        }else if(n == 2){
            2
        }else{
            climbStairs(n-1) + climbStairs(n-2)
        }
    }
}

/**
n = 3
1 1 1
1 2
-------
2 1
==================> 2 + 1
n = 4
 1 1 1 1
 1 1 2
 1 2 1
 --------
 2 1 1
 2 2
 =================> 3 + 2
*/

/**Alternate approach:
In the above approach we are doing repeated call for some numbers
example: 
climbStairs(5) -> 4 & 3
climbStairs(4) -> 3 & 2 | climbStairs(3) -> 2 & 1
climbStairs(3) -> 2 & 1 | climbStairs(2) | climbStairs(2) | climbStairs(1)
climbStairs(2) | climbStairs(1) | climbStairs(1)

To avoid recalculation again & again we can just store the results for the previous numbers at their indexes
*/
object Solution {
    
    def climbStairs(n: Int): Int = {
        if(n == 1){
            1
        }else{
            var dpArray = Array.fill(n+1)(0)
            dpArray(1) = 1
            dpArray(2) = 2
            (3 to n).map(i => {
                dpArray(i) = dpArray(i-1) + dpArray(i-2)
            })
            dpArray(n)
        }
    }
}

```

###  3.65. <a name='SimplifyPath'></a>71. Simplify Path

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1V7411w7jX?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1D5411J72c?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def simplifyPath(self, path):
        stack = []
        for i in path.split('/'):
            if i not in ['', '.', '..']:
                stack.append(i)
            elif i == '..' and stack:
                stack.pop()
        return "/" + "/".join(stack)
```

```py
# cool
from os.path import abspath

class Solution:
    def simplifyPath(self, path: str) -> str:
        return abspath(path)

from functools import reduce
class Solution:
    def simplifyPath(self, path: str) -> str:
        return "/"+"/".join(reduce(lambda x, y: x[:-1] if y == ".." else x + [y] if y and y != "." else x, path.split("/"), []))

# ç­‰æ•ˆäº:

class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        for i in path.split('/'):
            if i == '..':
                if stack:
                    stack.pop()
                else:
                    continue
            elif i and i != '.': # æ³¨æ„è¿™é‡Œæ˜¯elif,è€Œä¸æ˜¯if
                stack.append(i)
        return "/" + "/".join(stack)
```

###  3.66. <a name='EditDistance72-'></a>72. Edit Distance 72-ç¼–è¾‘è·ç¦»

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cb411u7uX?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1wv411P7aQ?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV13Z4y1W7UB?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ea4y147FK?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5kci5ryyi3k0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7fq2ehol7rg0.png)

```py
#@author:leacoder
#@des:  åŠ¨æ€è§„åˆ’  ç¼–è¾‘è·ç¦»

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
        # åˆå§‹
        for i in range(len1+1):
            DP[i][0] = i
        for j in range(len2+1):
            DP[0][j] = j
        for i in range(1,len1+1):
            for j in range(1,len2+1):
                
                if word1[i - 1] == word2[j -1]:
                    DP[i][j] =  DP[i-1][j-1]
                else:
                    DP[i][j]  =  min(DP[i-1][j] + 1,DP[i][j-1] + 1,DP[i-1][j-1]+1)
        return DP[len1][len2]

# æ¢ä¸ªå†™æ³•

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
        
        for i in range(0,len1+1):
            for j in range(0,len2+1):
                if i == 0:               # åˆå§‹åŒ–
                    DP[i][j] = j
                elif j == 0:             # åˆå§‹åŒ–
                    DP[i][j] = i
                elif word1[i - 1] == word2[j -1]:
                    DP[i][j] =  DP[i-1][j-1]
                else:
                    DP[i][j]  =  min(DP[i-1][j],DP[i][j-1],DP[i-1][j-1]) + 1
                    
        return DP[-1][-1]
```

```py
æ¯”è¾ƒå¥½ç†è§£ï¼Œbutä¼šè¶…æ—¶ï¼Œå“­å”§å”§

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        @cache
        def dp(i, j) -> int:
            if i == -1:
                return j + 1
            if j == -1:
                return i + 1
            # åšå‡ºé€‰æ‹©
            if word1[i] == word2[j]:
                return dp(i - 1, j - 1) # ä»€ä¹ˆéƒ½ä¸åš
            else:
                return min(
                    dp(i, j-1) + 1,  # insert
                    dp(i-1, j) + 1,  # delete
                    dp(i-1, j-1) + 1 # replace
                )
        return dp(len(word1)-1, len(word2)-1)
```

```scala
/**
* dynamic programming  - Levenshtein distance
* memo
*    1. dp(i)(j) represent the minimum edit distance from the length i substring from word1 to the length j substring from word2
*    2. dp(i)(j) is solved by its sub-optimal problem 
*         1, delete op: dp(i -1)(j)
*         2. replacement op: dp(i -1)(j - 1)
*         3. insertion op: dp(i)(j - 1)
* time complexity: O(NM) N is the length of word1, N is the length of word2
* space complexity: O(NM)
*/
object Solution1 {
  def minDistance(word1: String, word2: String): Int = {
    val m = word1.length
    val n = word2.length
    /* initial  Levenshtein distance table 
    * dp(i)(j) represent the minimum distance transforming from length i of substring word1 to length j of substring word2
    */
    val dp = Array.tabulate(m + 1, n + 1) {
      case (0, j) => j
      case (i, 0) => i
      case _ => 0
    }

    for (i <- 1 to m; j <- 1 to n) {
      /* i-1 is word1 index, j-1 is word2 index */
      if (word1(i - 1) == word2(j - 1)) {
        // do nothing case
        dp(i)(j) = dp(i - 1)(j - 1)
      } else {
        /**
        *       i-1,    i
        * j-1 replace  insertion     
        *  j   delete  dp(i)(j)
        */
        val replace = dp(i - 1)(j - 1)
        val insert = dp(i)(j - 1)
        val delete = dp(i - 1)(j)
        dp(i)(j) = (replace min insert min delete) + 1
      }
    }
    dp(m)(n)
  }
}
```

###  3.67. <a name='SetMatrixZeroes'></a>73. Set Matrix Zeroes

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1W7411T7rX?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1X64y1Y7kG?spm_id_from=333.999.0.0)

```py
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        tmp = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == 0:
                    tmp.append([i,j])
        for r,c in tmp:
            for j in range(len(matrix[0])):
                matrix[r][j] = 0
            for i in range(len(matrix)):
                matrix[i][c] = 0
        return matrix
```

```scala

/**
* my first commitment
* time complexity: O(N * M)
* space complexity: O(N + M)
*/
object Solution1 {
    import collection.mutable
    def setZeroes(matrix: Array[Array[Int]]): Unit = {
      val cols = mutable.Set.empty[Int]
      val rows = mutable.Set.empty[Int]
      
      for (i <- matrix.indices; j <- matrix(i).indices; if matrix(i)(j) == 0) {
        rows += i
        cols += j
      }
      
      rows.foreach(row => matrix(row).indices.foreach(matrix(row)(_) = 0))
      cols.foreach(col => matrix.indices.foreach(matrix(_)(col) = 0))
    }
}



/**
* using first column and row to record cell to be set to zero
* memo:
*  1. we should set first columns and first row in the last, otherwise we cannot distinguish the zero between set by us and originally is
* time complexity: O(NM)
* space complexity: O(1)
*/
object Solution2 {
    import collection.mutable
    def setZeroes(matrix: Array[Array[Int]]): Unit = {
      var rowZero = false
      var colZero = false
      
      /**
      * using first row and first column as flag 
      */
      for (i <- matrix.indices; j <- matrix(i).indices; if matrix(i)(j) == 0) {
        if (i == 0) rowZero = true
        if (j == 0) colZero = true
        matrix(i)(0) = 0
        matrix(0)(j) = 0
      }
    
      /**
      * set one row to zero except first cell
      */
      (1 until matrix.length).foreach {
        case rowIdx if matrix(rowIdx)(0) == 0 => matrix(rowIdx).indices.foreach(matrix(rowIdx)(_) = 0)
        case _ =>
      }
      
      /**
      * set one column to zero except first cell
      */
      (1 until matrix(0).length).foreach {
        case colIdx if matrix(0)(colIdx) == 0 => matrix.indices.foreach(matrix(_)(colIdx) = 0)
        case _ => 
      }
      
      /**
      * set first column and first row to zero if true
      */
      if(rowZero) matrix(0).indices.foreach(matrix(0)(_) = 0)
      if(colZero) matrix.indices.foreach(matrix(_)(0) = 0)
      
    }
}
```

###  3.68. <a name='Searcha2DMatrix'></a>74 Search a 2D Matrix

[å°æ˜](https://www.bilibili.com/video/BV1aK4y1h7Bb?spm_id_from=333.999.0.0)

```py
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix)
        n = len(matrix[0])
        l = 0
        r = m*n-1
        while l <= r:
            mid = (l + r) // 2
            midRow = mid // n
            midCol = mid % n
            if matrix[midRow][midCol] == target:
                return True
            elif matrix[midRow][midCol] > target:
                r = mid - 1 # æ˜“é”™ç‚¹ï¼š+1,-1ä¸è¦å†™åäº†
            else:
                l = mid + 1
        return False
```

###  3.69. <a name='SortColors'></a>75. Sort Colors

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1rE411n7mL?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ua4y1v7yd?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1tz4y1o7n5?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5l1bfbznzwc0.png)

```py
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        idx, left, right = 0, 0, len(nums) - 1
        while idx <= right:
            if nums[idx] == 2 and idx < right:
                nums[idx], nums[right] = nums[right], 2
                right -= 1
            elif nums[idx] == 0 and idx > left:
                nums[idx], nums[left] = nums[left], 0
                left += 1
            else:
                idx += 1
```

###  3.70. <a name='-1'></a>76-ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘æœ€å°è¦†ç›–å­ä¸²

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1PM4y1K7p6?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1aK4y1t7Qd?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1ud8tslp4vz4.png)

```py
class Solution:
    def minWindow(self, s: str, t: str) -> str:
    
        def isContains(windic,targetdic):
            for key in targetdic:
                if windic[key] < targetdic[key]:
                    return False # åªè¦æœ‰ä¸€ä¸ªä¸æ»¡è¶³ï¼Œåˆ™ä¸æ»¡è¶³
            return True

        
        tdic = defaultdict(int)
        wdic = defaultdict(int)
        for char in t:
        	tdic[char] += 1
        for char in t:
            wdic[char] = 0

        minlen = len(s)
        l = 0
        res = ''

        for r in range(len(s)): 
            # å³è¾¹ç•Œç§»åŠ¨,å¹¶æŠŠå³è¾¹ç•ŒåŠ å…¥å­—å…¸
            if s[r] in tdic:
                wdic[s[r]] += 1
            while isContains(wdic,tdic):
                if r-l+1 <= minlen:
                    # æ»¡è¶³åŒ…å«æ¡ä»¶ï¼Œå¹¶ä¸”minlen
                    minlen = r-l+1
                    res = s[l:r+1]
                if s[l] in wdic:
                    wdic[s[l]] -= 1
                l += 1 # å¦‚æœwindowæ»¡è¶³æ¡ä»¶ï¼Œé‚£å°±æ”¶ç¼©å·¦è¾¹ç•Œï¼Œä½†éœ€è¦è¿›è¡Œå¦‚ä¸Šæ“ä½œ
        return res
```

```scala
/**
* chosen solution
*   time complexity: O(|S| + |T|)
*   space complexity: O(|s| + |T|)
* sliding windows: faster version
* @param
* left right : two pointer for enlarging and reducing windows size
* head and len: storing minWindow
* count: count = 0 when the range between left index and right index satisfy condition
*/
object Solution0{
    import collection.mutable
    def minWindow(s: String, t: String): String = {
      val sMap = mutable.Map.empty[Char, Int] ++ t.groupBy(identity).mapValues(_.length).toMap
      var counter = sMap.size
      
      var left = 0
      var minLength = s.length + 1
      var head = 0

      for (right <- s.indices) {
        val rightChar = s(right)
        sMap.get(rightChar) match {
          case Some(v) if v == 1 =>
            sMap.update(rightChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(rightChar, v - 1)
          case None => 
        }
        
        while(counter == 0) {

          val leftChar = s(left)
          if (minLength > (right - left  + 1)) {
            head = left
            minLength = right - left + 1
          }
          
          sMap.get(leftChar) match {
            case Some(v) if v == 0 =>
              sMap.update(leftChar, v + 1)
              counter += 1
            case Some(v) =>
              sMap.update(leftChar, v + 1)
            case None =>
          }
          
          left += 1
        }
        
      }
      if (minLength == (s.length + 1)) "" else s.slice(head, head + minLength)
      
      
    }
}
/**
* my first commitment
* sliding windows with two pointer: left and right
* time complexity: O(|S| + |T|)
*/
object Solution1 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    val tMap = t.groupBy(identity).mapValues(_.length).toMap

    /**
    * storing how far to reach t string's anagrams, the element's value could be negative. 
    * If negative, it means we could drop more char of this key from currentString
    */
    val budgetMap = scala.collection.mutable.Map() ++ tMap
    var currentString = ""
    var answer = ""

    for (char <- s) {
        budgetMap.get(char) match {

          case Some(e) => budgetMap.update(char, e - 1)
          case None =>
        }
      
      currentString += char

      while(!budgetMap.exists{case (_, v) => v > 0}) {
        /**
        *  drop first element from currentString if  currentString  still contains t string 
        */
        val tempChar = s(left)
        if(tMap.contains(tempChar)){
          budgetMap.update(tempChar, budgetMap.getOrElse(tempChar, 0) + 1)
        }

        if(answer.length > currentString.length || answer.isEmpty) {
          answer = currentString
        }
        currentString = currentString.drop(1)
        left += 1
      }
    }

    answer
  }
}


/**
* sliding windows : don't record string during process
*/
object Solution1-2 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    var head = 0
    var len = s.length + 1

    val budgetMap = scala.collection.mutable.Map() ++ t.groupBy(identity).mapValues(_.length)

    for ((char, right) <- s.zipWithIndex) {
      
        budgetMap.get(char) match {
          case Some(e) => budgetMap.update(char, e - 1)
          case None =>
        }
      
      while(!budgetMap.exists{case (_, v) => v > 0}) {
        val tempChar = s(left)
        if(budgetMap.contains(tempChar)){
          budgetMap.put(tempChar, budgetMap(tempChar) + 1)
        }
         /* update minWindow */
        if(len > (right - left)) {
          len = right - left + 1
          head  = left
        }
        left += 1
      }
    }
    // println(budgetMap)
    if(len == (s.length + 1)) "" else s.substring(head, head + len)
  }
}

/**
* sliding windows: faster version
* left right : two pointer for enlarging and reducing windows size
* head and len: storing minWindow
* count: count = 0 when the range between left index and right index satisfy condition
*/

object Solution1-3 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    var right = 0
    var head = 0
    var len = s.length + 1
    val budgetMap = scala.collection.mutable.Map() ++ t.groupBy(identity).mapValues(_.length)
    var count = budgetMap.size

    while (right < s.length) {
      val char = s(right)
     
        budgetMap.get(char) match {
            case Some(e) if e == 1 =>
            budgetMap.update(char, e - 1)
            count -= 1
            case Some(e) =>
            budgetMap.update(char, e - 1)
            case None =>
        }
      
      right += 1
      while(count == 0) {
        val tempChar = s(left)
        budgetMap.get(tempChar) match {
          case Some(e) if e == 0 =>
            budgetMap.update(tempChar, e + 1)
            count += 1
          case Some(e) =>
            budgetMap.update(tempChar, e + 1)
          case None =>
        }
        /* update minWindow*/
        if(len > (right - left)) {
          len = right - left
          head  = left
        }
        left += 1
      }
    }
    println(budgetMap)
    if(len == (s.length + 1)) "" else s.substring(head, head + len)
  }
}

/**
* 1. for loop auto increment right index
* 2. update minLength and head index before updating counter and left index
*/

object Solution1-4 {
    import collection.mutable
    def minWindow(s: String, t: String): String = {
      val sMap = mutable.Map.empty[Char, Int] ++ t.groupBy(identity).mapValues(_.length).toMap
      var counter = sMap.size
      
      var left = 0
      var minLength = s.length + 1
      var head = 0

      for (right <- s.indices) {
        val rightChar = s(right)
        sMap.get(rightChar) match {
          case Some(v) if v == 1 =>
            sMap.update(rightChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(rightChar, v - 1)
          case None => 
        }
        
        while(counter == 0) {

          val leftChar = s(left)
          if (minLength > (right - left  + 1)) {
            head = left
            minLength = right - left + 1
          }
          
          sMap.get(leftChar) match {
            case Some(v) if v == 0 =>
              sMap.update(leftChar, v + 1)
              counter += 1
            case Some(v) =>
              sMap.update(leftChar, v + 1)
            case None =>
          }
          
          left += 1
        }
        
      }
      if (minLength == (s.length + 1)) "" else s.slice(head, head + minLength)
      
      
    }
}
```

###  3.71. <a name='-1'></a>77. ç»„åˆ

```py
class Solution:
    def combine(self, n, k):
            res = []
            path = []
            def backtrack(StartIndex):
                if len(path) == k:
                    res.append(path[:])
                    return
                for i in range(StartIndex, n+1):
                    path.append(i)
                    backtrack(i+1)
                    path.pop()
            backtrack(1)
            return res
```

###  3.72. <a name='Subsets'></a>78. ã€ä½è¿ç®—ğŸ˜œã€‘Subsets å­é›†

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1jt411k7py?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1HD4y1Q7Te?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1YK4y1s7pq?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1154y1R72Q?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.xmmpwe7mlzk.webp)

æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ·2^n)

```py

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        size = len(nums)
        n = 1 << size
        res = []
        # i = 0,1,2,3,4,5,6,7
        for i in range(n):
            cur = []
            # j = 0,1,2
            for j in range(size):
                if i >> j & 1:
                    cur.append(nums[j])
            res.append(cur)
        return res

```

```py
class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = [[]]
        for num in nums:
            res.extend([tmp+[num] for tmp in res])
        return res  

# bfs
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        q=[[]]
        n=len(nums)
        for i in range(n):
            for j in range(len(q)):
                q.append(q[j]+[nums[i]])
        return q

        # ç­‰æ•ˆ

        res = [[]]
        n = len(nums)
        for num in nums:
            for subres in res[:]:
                res.append(subres+[num])
        return res

# æ³¨æ„ä»£ç ä¸­res[:]æ˜¯å¿…é¡»çš„ï¼Œå› ä¸ºåˆ‡ç‰‡æ˜¯å¼•ç”¨æ–°çš„å¯¹è±¡ï¼Œ
# æ­¤æ—¶åœ¨å¾ªç¯ä¸­res[:]æ˜¯ä¸æ›´æ–°çš„ï¼Œè€Œresæ˜¯ä¸æ–­æœ‰å…ƒç´ pushè¿›å»çš„ï¼Œå¾ˆtrick
```

```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  
        path = []  
        def backtrack(startIndex):
            res.append(path[:])  #æ”¶é›†å­é›†ï¼Œè¦æ”¾åœ¨ç»ˆæ­¢æ·»åŠ çš„ä¸Šé¢ï¼Œå¦åˆ™ä¼šæ¼æ‰è‡ªå·±
            for i in range(startIndex,len(nums)):  #å½“startIndexå·²ç»å¤§äºæ•°ç»„çš„é•¿åº¦äº†ï¼Œå°±ç»ˆæ­¢äº†ï¼Œforå¾ªç¯æœ¬æ¥ä¹Ÿç»“æŸäº†ï¼Œæ‰€ä»¥ä¸éœ€è¦ç»ˆæ­¢æ¡ä»¶
                path.append(nums[i])
                backtrack(i+1)  #é€’å½’
                path.pop()  #å›æº¯
        backtrack(0)
        return res
```

```scala
object Solution {
    //We either use or don't use the current item at the given index and continue until we are at the end of the array.
    
    def subsets(nums: Array[Int]): List[List[Int]] = {
        def backtrack(nums: List[Int], returnValue: List[Int]): List[List[Int]] = {
            nums
            .headOption
            .map(currentElem => 
                 backtrack(nums.tail, returnValue) ++ backtrack(nums.tail, currentElem +: returnValue))
            .getOrElse(List(returnValue))
        }
        
        backtrack(nums.toList, List.empty[Int])
    }
}

```

###  3.73. <a name='WordSearch'></a>79. Word Search

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1yE411g7Tb?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1iZ4y1T78D?spm_id_from=333.999.0.0)

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def dfs(i, j, word):
            # å•è¯æ˜¯å¦å‡ºç°åœ¨ä»¥iï¼Œjä¸ºèµ·ç‚¹çš„ç½‘æ ¼ä¸­
            # word[0] å’Œ word[1:] åˆ’åˆ†
            # ç»“æŸæ¡ä»¶ï¼š
            if len(word) == 1:
                return word[0] == board[i][j]
            # ç»“æŸæ¡ä»¶ï¼š
            if board[i][j] != word[0]:
                return False
            
            # è®¾ç½®ç°åœº
            visit[i][j] = True
            for dire in direction: # å¯¹å››ä¸ªæ–¹å‘è¿›è¡Œæœç´¢
                newi, newj = i + dire[0], j + dire[1]
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]) and not visit[newi][newj]:
                    if dfs(newi, newj, word[1:]): # dfsæˆåŠŸ
                        return True
            # è¿˜åŸç°åœº
            visit[i][j] = False

        direction = [(0,1), (0, -1), (1, 0), (-1, 0)]
        m = len(board)
        n = len(board[0])
        visit = [[False]*n for _ in range(m)]
        for i in range(m): # éå†æ‰€æœ‰æ ¼å­ä½œä¸ºå•è¯èµ·ç‚¹
            for j in range(n):
                if dfs(i,j,word): # dfsæˆåŠŸ
                    return True
        return False
```

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                return False
            if k == len(word) - 1: # k + 1ç­‰ä»·äºword[1:]
                return True
            
            visited.add((i, j)) # ç”¨é›†åˆè¡¨ç¤ºvisited
            for di, dj in directions:
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if check(newi, newj, k + 1): # k + 1ç­‰ä»·äºword[1:]
                            return True
            visited.remove((i, j)) # ç”¨é›†åˆè¡¨ç¤ºvisited

        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        h, w = len(board), len(board[0])
        visited = set() # ç”¨é›†åˆè¡¨ç¤ºvisited
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True
        
        return False
```

```scala
/**
* chosen solution
* directly compare char by char
* if there are only one word should be checked in board, brute force is a more efficient method
*/

object Solution0 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    dfs(word, board)
  }

  def dfs(word: String, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), wordIdx: Int): Boolean = {
      val char = board(coord._1)(coord._2)

      if(wordIdx >= word.length || char != word.charAt(wordIdx)) false
      else if(char == word.charAt(wordIdx) && wordIdx == word.length - 1) true
      else {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), wordIdx + 1)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      }
    }
    
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, 0))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
*  my first commitment
*    using Tries
*    watch out that uppercase is different from lower case => "POLAND" != "poland"
*/
object Solution1 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    val tries = new Tries()
    tries.insert(word)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), prePrefix: String): Boolean = {
      val char = board(coord._1)(coord._2)
      val newPrefix = prePrefix + char
      if(tries.search(newPrefix)) true

      else if(tries.startsWith(newPrefix)) {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), newPrefix)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      } else false
    }
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, ""))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
* helper class 
*   Tries Node is implemented with Map
*/
case class Node(child: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map.empty[Char, Node], var isWord: Boolean = false) {
  def update(char: Char, node: Node): Unit = child(char) = node
  def apply(char: Char): Option[Node] = child.get(char)
}

class Tries() {
  val root = Node()

  def insert(word: String): Unit = {
    var node = root
    word.foreach{
      case c if node(c).isDefined => node = node(c).get
      case c =>
        node(c) = Node()
        node = node(c).get
    }
    node.isWord = true
  }

  def search(word: String): Boolean = searchUtil(word).exists(_.isWord)

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined

  private def searchUtil(string: String): Option[Node] = {
    var node = root

    string.foreach{
      case c if node(c).isDefined => node = node(c).get
      case _ => return None
    }
    Some(node)
  }
}


/**
* directly compare with char by char
* if there are only one word should be checked in board, brute force is a more efficient method
*/

object Solution2 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    dfs(word, board)
  }

  def dfs(word: String, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), wordIdx: Int): Boolean = {
      val char = board(coord._1)(coord._2)

      if(wordIdx >= word.length || char != word.charAt(wordIdx)) false
      else if(char == word.charAt(wordIdx) && wordIdx == word.length - 1) true
      else {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), wordIdx + 1)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      }
    }
    
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, 0))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

###  3.74. <a name='RemoveDuplicatesfromSortedArrayII'></a>80 Remove Duplicates from Sorted Array II

[å°æ˜](https://www.bilibili.com/video/BV1vy4y1S7sN?spm_id_from=333.999.0.0)

###  3.75. <a name='IIRemoveDuplicatesfromSortedList'></a>82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II(Remove Duplicates from Sorted List

[æ´›é˜³](https://www.bilibili.com/video/BV1Fi4y187pj?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0,head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                while cur.next.next and cur.next.val == cur.next.next.val:
                    cur.next = cur.next.next # åˆ å»é‡å¤èŠ‚ç‚¹çš„å‰ä¸€ä¸ª
                cur.next = cur.next.next # åˆ å»é‡å¤èŠ‚ç‚¹çš„å‰©ä½™ä¸€ä¸ª
            else:
                cur =  cur.next
        return dummy.next

# å¦ä¸€ç§å†™æ³•
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0,head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                x = cur.next.val
                while cur.next and cur.next.val == x:
                    cur.next = cur.next.next
            else:
                cur =  cur.next
        return dummy.next
```

###  3.76. <a name='Removeduplicatesfromsortedarray-1'></a>83-Remove duplicates from sorted array

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1yJ411R7FZ?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7s7?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1zK411L7Gg?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur =  cur.next
        return head
```

###  3.77. <a name='LargestRectangleinHistogram'></a>84. æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢ Largest Rectangle in Histogram

[å®˜æ–¹](https://www.bilibili.com/video/BV16D4y1D7ed?spm_id_from=333.999.0.0)

###  3.78. <a name='PartitionList'></a>86. åˆ†éš”é“¾è¡¨(Partition List)

[æ´›é˜³](https://www.bilibili.com/video/BV1t64y1u7Ei?spm_id_from=333.999.0.0)

```py
        dummy1 = ListNode(0)
        dummy2 = ListNode(0)
        slow,fast,cur = dummy1, dummy2, head
        while cur:
            if cur.val < x:
                slow.next = cur # dummy1 æŒ‡å‘ç¬¬ä¸€ä¸ªå°äºxçš„node
                slow = slow.next
            else:
                fast.next = cur # dummy2 æŒ‡å‘ç¬¬ä¸€ä¸ªå¤§äºxçš„node
                fast = fast.next
            cur = cur.next
        slow.next = dummy2.next
        fast.next = None
        return dummy1.next
```

###  3.79. <a name='ScrambleString'></a>87. Scramble String

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1QE41137MG?spm_id_from=333.999.0.0)

###  3.80. <a name='Mergesortedarray'></a>88-Merge sorted array

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV14J411X7JE?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7bg?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1g54y1s7ZG?spm_id_from=333.999.0.0)

ç›´æ¥åˆå¹¶åæ’åº

```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # ä¸‰ä¸ªæŒ‡é’ˆ
        cur1 = m - 1
        cur2 = n - 1
        i = m + n -1
        while cur1 >= 0 and cur2 >= 0:
            if nums1[cur1] < nums2[cur2]:
                nums1[i] = nums2[cur2]
                cur2 -= 1
            else:
                nums1[i] = nums1[cur1]
                cur1 -= 1
            i -= 1
        if cur2 >= 0:
            nums1[:cur2+1] = nums2[:cur2+1] # æ˜“é”™ç‚¹ï¼šä¸åŒ…æ‹¬å³è¾¹ç•Œ

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()
```

```scala
object Solution {
    def merge(nums1: Array[Int], m: Int, nums2: Array[Int], n: Int): Unit = {
        var trail = m+n-1
        
        var t1 = m-1
        var t2 = n-1
        
        while(t1 > -1 && t2 > -1){
            val e1 = nums1(t1)
            val e2 = nums2(t2)
            
            if(e1 > e2){
                nums1(trail) = e1
                t1 -= 1
                trail -= 1
            }else{
                nums1(trail) = e2
                t2 -= 1
                trail -= 1
            }
        }
        
        if(t1 == -1){
            while(t2 > -1){
                nums1(trail) = nums2(t2)
                t2 -= 1
                trail -= 1
            }
        }else{
            while(t1 > -1){
                nums1(trail) = nums1(t1)
                t1 -= 1
                trail -= 1
            }
        }
        
    }
}

```

###  3.81. <a name='89.'></a> 89. æ ¼é›·ç¼–ç 

```py
class Solution:
    def grayCode(self, n):
        # æ˜“é”™ç‚¹ï¼šé€’å½’éƒ¨åˆ†å¿…é¡»æ˜¯å­—ç¬¦ä¸²éƒ¨åˆ†
        def recur(i):
            if i==1:
                return ['0','1']
            else:
                lastList = recur(i-1)
                return ['0'+ x for x in lastList]+['1'+ x for x in lastList[::-1]]
            
        res = recur(n)
        return [int(x,2) for x in res] 
        # int(a,2)æŠŠäºŒè¿›åˆ¶è½¬åŒ–æˆ10è¿›åˆ¶

class Solution:
    def grayCode(self, n: int) -> List[int]:
        res, head = [0], 1
        for i in range(n):
            for subres in res[::-1]: # é€†åºï¼ŒèƒŒä¸€èƒŒ
                res.append(head + subres)
            head <<= 1 # headå°±æ˜¯2**i
        return res

class Solution:
    def grayCode(self, n):
        res, head = [0], 1
        for i in range(n):
            for j in range(len(res) - 1, -1, -1): # é€†åºï¼ŒèƒŒä¸€èƒŒ
                res.append(head + res[j])
            head <<= 1 # headå°±æ˜¯2**i
        return res
```

###  3.82. <a name='II'></a>90-å­é›† II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV11z4y1Q7Hd?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

```py
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        n = len(nums)
        path = []
        nums.sort()
        def backtrack(startIndex):
            if startIndex == n:
                return
            else:
                for i in range(startIndex,n):
                    if i > startIndex and nums[i] == nums[i-1]: 
                        # æ˜“é”™ç‚¹ï¼šä¸æ˜¯nums[i] == nums[startIndex]
                        continue
                    path.append(nums[i])
                    res.append(path[:]) # æ˜“é”™ç‚¹ï¼šä¸€å®šè¦æ˜¯path[:]
                    backtrack(i+1)
                    path.pop()
        backtrack(0)
        return res
```

```py
class Solution:
    def subsetsWithDup(self, nums):
        res = [[]]
        nums.sort()
        for i in range(len(nums)):
            for j in range(len(res)):
                if res[j] + [nums[i]] not in res:
                    res.append(res[j] + [nums[i]]) 
        return res

# å¦ä¸€ç§å†™æ³•
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        nums.sort()
        for num in nums:
            for subres in res[:]: # æ³¨æ„ï¼šè¦å†™æˆ res[:]
                if subres + [num] not in res:
                    res.append(subres + [num]) 
        return res
```

###  3.83. <a name='DecodeWays'></a>91. Decode Ways

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Lb411y7ec?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Pf4y1G7M5?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        
        @cache
        def dp(i):
            if i == 0: 
                if '1' <= s[i] <= '9':
                    return 1
                else:
                    return 0
            if i == -1: 
                return 1 
                # æ˜“é”™ç‚¹ï¼šreturn 1ï¼Œè€Œä¸æ˜¯return 0ï¼Œæ¯”å¦‚â€˜12â€™ï¼Œdp(i-2)åº”è¯¥è¦æ˜¯1çš„
            if i >= 1:
                res = 0
                if '1' <= s[i] <= '9':
                    res = dp(i-1)
                if '10' <= s[i-1:i+1] <= '26':
                    res += dp(i-2)
                return res
        
        return dp(len(s) - 1)
```

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp0 = 1 # è¿™é‡Œdp=0æˆ–è€…æ˜¯dp=1éƒ½å¯ä»¥ï¼Œå› ä¸ºåœ¨ç¬¬ä¸€è½®çš„å¾ªç¯è¿‡åä¼šæ›´æ–°
        dp1 = 1
        for i in range(n):
            res = 0
            if '1' <= s[i] <= '9':
                res = dp1
            if i > 0 and '10' <= s[i-1:i+1] <= '26':
                res += dp0
            dp1, dp0 = res, dp1
        return dp1
```

```scala


/**
* my first commitment dynamic programming
* memo:
* 1.subproblem dp(i) represents the decode ways of the sub-string which length is i 
* 2. dp(i) could be sum from dp(i-1) or dp(i-2) if s(i -1, i) or s(i-2, i) are valid coding
*  idx:   0 1 2 3 4 5 6 7
*  length 1 2 3 4 5 6 7 8
&  value  1 2 1 3 2 5 8 3
*   
*   dp(1) => "1"
*   dp(2) => "12" :
*            valid("12") + dp(0)
*            valid("2") + dp(1)
*   dp(3) => "121" :
*           valid("21") + dp(1)
*           valid("1) + dp(2)
*
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def numDecodings(s: String): Int = {
      if(s == null || s.length == 0) return 0 
      val dp = Array.ofDim[Int](s.length + 1)
      dp(0) = 1
      dp(1) = if (s(0) == '0') 0 else 1
      (2 to s.length).foreach { idx =>
        val single = s.slice(idx-1, idx).toInt
        val tens = s.slice(idx-2, idx).toInt
        if (0 < single && single <= 9)
          dp(idx) += dp(idx-1)
        if (10 <= tens && tens <= 26)
          dp(idx) += dp(idx-2)
      
      }
      dp.last
    }
}
/**
* instead of using slice, handle single and tens by hands
* memo
*  1. char as digit
*/

object Solution1-1 {
    def numDecodings(s: String): Int = {
      if(s == null || s.length == 0) return 0 
      val dp = Array.ofDim[Int](s.length + 1)
      dp(0) = 1
      dp(1) = if (s(0) == '0') 0 else 1
      (2 to s.length).foreach { idx =>
        val single = s(idx-1).asDigit
        val tens = s(idx-2).asDigit * 10 + single
        if (0 < single && single <= 9)
          dp(idx) += dp(idx-1)
        if (10 <= tens && tens <= 26)
          dp(idx) += dp(idx-2)
      }
      
      dp.last
      
    }
}

/**
*  dp - only keep dp(i-1) and dp(i-2)
* time complexity: O(2N)
* space complexity: O(1)
*/

object Solution1-3 {
    def numDecodings(s: String): Int = {
      if (s == null && s.isEmpty) return 0
      (2 to s.length).foldLeft((1, if(s(0) == '0') 0 else 1)) {
      /**
      * pre = dp(i-1)
      * prepre = dp(i-2) 
      */
        case ((prepre, pre), idx) =>
          val decodeOne = if(decodeSingle(s, idx)) pre else 0
          val decodeTwo = if(decodeTens(s, idx)) prepre else 0
          (pre, decodeOne + decodeTwo)
      }._2
    }
  
    def decodeSingle(s: String, idx: Int): Boolean = s(idx - 1) != '0'
  
    def decodeTens(s: String, idx: Int): Boolean = (s(idx - 2) == '1' ) || (s(idx - 2) == '2' && s(idx-1) <= '6' )
    
}



```

###  3.84. <a name='ReverseLinkedListII'></a>92-Reverse Linked List II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1n7411G7N4?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV19c411h7UE?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        dummy = ListNode(0,head)
        pre = dummy
        for _ in range(left-1):
            pre = pre.next

        cur = pre.next
        for _ in range(right-left):
            # æ˜“é”™ç‚¹ï¼šé¡ºåºä¸èƒ½é”™ï¼Œä¸­ï¼Œåï¼Œå‰
            aft = cur.next
            cur.next = aft.next
            aft.next = pre.next
            pre.next = aft
        
        return dummy.next
```

###  3.85. <a name='93.IP'></a> 93. å¤åŸ IP åœ°å€

```py
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        def backtrack(s,path):
            if len(path) == 4 and len(s) == 0:
                res.append('.'.join(path))
                return # æ³¨æ„ç‚¹ï¼šä¸€å®šè¦è¿”å›
            for i in range(len(s)):
                left,right = s[:i+1],s[i+1:]
                if 0 <= int(left) <= 255 and str(int(left)) ==  left:
                    backtrack(right,path + [left])  
        backtrack(s,[])    
        return res

ä¼˜åŒ–ä¸€ä¸‹ï¼š

class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        def backtrack(s,path):
            if len(path) == 4 and len(s) == 0:
                res.append('.'.join(path))
                return 
            if len(path) < 4: # ä¼˜åŒ–ï¼šåªæœ‰åœ¨pathå°äº4çš„æ—¶å€™ï¼Œæ‰æœ‰å¿…è¦ç»§ç»­backtrack
                for i in range(min(3,len(s))): # ä¼˜åŒ–ï¼šsä¸éœ€è¦éå†å®Œï¼Œåªè¦å–å‡ºå‰ä¸‰ä¸ªçœ‹çœ‹æ˜¯å¦ç¬¦åˆ
                    left,right = s[:i+1],s[i+1:]
                    if 0 <= int(left) <= 255 and str(int(left)) ==  left:
                        backtrack(right,path + [left])  
        backtrack(s,[])    
        return res
```

###  3.86. <a name='Inorderwihstack'></a>94-Inorder wih stack

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1uV411o78x?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1o54y1B7Z8?spm_id_from=333.999.0.0)



###  3.87. <a name='BinaryTreeInorderTraversal'></a>94-Binary Tree Inorder Traversal

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1n7411D7g5?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1mV411Y7T1?spm_id_from=333.999.0.0)

```py
# é€’å½’
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        @cache
        def dfs(root):
            if root: # ä¸è¦æ¼äº†æ¡ä»¶åˆ¤æ–­
                dfs(root.left)
                res.append(root.val)
                dfs(root.right)
        dfs(root)
        return res
```

```py
# stack
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []

        while stack or root: # ä»£è¡¨resè¿˜æ²¡æœ‰å¡«æ»¡
            while root:
                stack.append(root)
                root = root.left
            
            if stack:
                cur = stack.pop()
                res.append(cur.val)
                if cur.right:
                    root = cur.right
        
        return res

# å†™å•°å—¦äº†ï¼Œç®€åŒ–ä¸€ä¸‹
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []

        while stack or root: # ä»£è¡¨resè¿˜æ²¡æœ‰å¡«æ»¡
            while root:
                stack.append(root)
                root = root.left
            
            cur = stack.pop()
            res.append(cur.val)
            root = cur.right
        
        return res

# å…¶ä»–æ›´å¥½ç†è§£çš„å†™æ³•
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def addAllLeft(node):
            while node:
                stack.append(node)
                node = node.left

        stack, res = [], []
        addAllLeft(root)

        while stack:
            cur = stack.pop()
            res.append(cur.val)
            addAllLeft(cur.right)

        return res

# å…¶ä»–æ›´å¥½ç†è§£çš„å†™æ³•
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]: 
        stack, res = [], []
        cur = root
        while stack or cur:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                res.append(cur.val)
                cur = cur.right
        return res
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */

/**
* chosen solution
* iterative version
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution0 {
    def inorderTraversal(root: TreeNode): List[Int] = {
      var node = root
      val stack = new collection.mutable.Stack[TreeNode]()
      val result = new collection.mutable.ListBuffer[Int]()

      while(node != null || stack.nonEmpty) {
        while(node != null){
          stack.push(node)
          node = node.left
        }

        node = stack.pop()
        result += node.value
        node = node.right

      }
      result.toList
    }
}


/**
* iterative version
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution1 {
    def inorderTraversal(root: TreeNode): List[Int] = {
      var node = root
      val stack = new collection.mutable.Stack[TreeNode]()
      val result = new collection.mutable.ListBuffer[Int]()

      while(node != null || stack.nonEmpty) {
        while(node != null){
          stack.push(node)
          node = node.left
        }

        node = stack.pop()
        result += node.value
        node = node.right

      }
      result.toList
    }
}

/**
* recursive version
* time complexity: O(N)
* space complexity: O(logN), worst: O(N)
*/
object Solution2 {
    def inorderTraversal(root: TreeNode): List[Int] = {
        _inorderTraversal(root)
    }
    
    def _inorderTraversal(node: TreeNode): List[Int] = {
        if (node == null) Nil
        else
            _inorderTraversal(node.left) ::: List(node.value) ::: _inorderTraversal(node.right)
        
    }
}
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def inorderTraversal(root: TreeNode): List[Int] = {
        if(root == null){
            List.empty[Int]
        }
        else if(root.left == null && root.right == null){
            List(root.value)
        }else if(root.left == null){
            List(root.value) ++ inorderTraversal(root.right)
        }else if(root.right == null){
            inorderTraversal(root.left) ++ List(root.value)
        }else{
            inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)
        }
    }
}

```

###  3.88. <a name='II-1'></a>95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II

```py
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:

        def backtrack(start,end) -> List[TreeNode]:
            if start > end:
                return [None]

            res = [] # resä¸€å®šè¦å†™åœ¨backtracké‡Œé¢
            
            for i in range(start,end+1):
                
                leftTrees = backtrack(start,i-1)
                rightTrees = backtrack(i+1,end)
                
                for left in leftTrees:
                    for right in rightTrees:
                        root = TreeNode(i) # rootä¸€å®šè¦å†™åœ¨forå¾ªç¯é‡Œé¢
                        root.left = left
                        root.right = right
                        res.append(root)
            return res
                    
        return backtrack(1,n)
```

###  3.89. <a name='UniqueBinarySearchTrees'></a>96. Unique Binary Search Trees

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1xV411Y731?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1e5411W72t?spm_id_from=333.999.0.0)

```py
# åŸºäºä¸Šä¸€é—®ä¿®æ”¹
class Solution:
    def numTrees(self, n: int) -> int:

        @cache
        def backtrack(n):
            if n <= 1:
                return 1
            else:
                res = 0 # resä¸€å®šè¦å†™åœ¨backtracké‡Œé¢
                for i in range(n):
                    leftTrees = backtrack(i)
                    rightTrees = backtrack(n-i-1)
                    res += leftTrees*rightTrees # æ˜“é”™ç‚¹ï¼šä¸€å®šæ˜¯åŠ å·
                return res
                    
        return backtrack(n)

class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0]*(n+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2,n+1):
            for subi in range(i):
                dp[i] += dp[subi]*dp[i-subi-1]
        return dp[-1]
```





###  3.90. <a name='ValidateBinarySearchTree98-'></a>98. Validate Binary Search Tree 98-éªŒè¯äºŒå‰æœç´¢æ ‘

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV12t411Y7TP?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Wz4y1R7dF?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7FV?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Hv411478d?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Fi4y147Ng?spm_id_from=333.999.0.0)

```py
æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š

èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

è¿™æ ·å†™æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºä¸ä»…ä»…å·¦å°äºå³å°±å¤Ÿäº†
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        if not root.left:
            validleft = True
        elif root.left and root.left.val < root.val and self.isValidBST(root.left):
            validleft = True
        else:
            validleft = False

        if not root.right:
            validright = True
        elif root.right and root.right.val > root.val and self.isValidBST(root.right):
            validright = True
        else:    
            validright = False
        return validleft and validright
```

ä¸­åºéå†ä¸€ä¸‹å°±è¡Œäº†

```py
# stack
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack, res = [], float('-inf')
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if root.val <= res:
                return False
            res = root.val
            root = root.right
        return True

# æœ‰å¾ˆå¤šæ˜“é”™ç‚¹ï¼š
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        res = [float('-inf')] # æ˜“é”™ç‚¹ï¼šè¦æœ‰ä¸€ä¸ªfloat('-inf')
        valid = True

        @cache
        def dfs(root):
            nonlocal valid # æ˜“é”™ç‚¹ï¼švalid ä»å¤–éƒ¨ä¼ å…¥å†…éƒ¨ï¼Œå†ä¼ åˆ°å¤–éƒ¨
            if root: # ä¸è¦æ¼äº†æ¡ä»¶åˆ¤æ–­
                dfs(root.left)
                if root.val <= res[-1]: valid = False
                res.append(root.val)
                dfs(root.right)
        dfs(root)

        return valid
```

å®šä¹‰ä¸Šä¸‹ç•Œï¼š

```py
class Solution:
    def isValidBST(self, root):
        def BFS(node, lower, upper):
            if not node:
                return True
            return lower < node.val < upper and BFS(node.left, lower, node.val) and BFS(node.right, node.val, upper)

        return fun(root, float('-inf'), float('inf'))
```

```scala
/**
* chosen solution
* inorder iterative version only keep pre node
* this is also the inorder-iterative-template
* 
* time complexity: O(N)
*/

object Solution0 {
   def isValidBST(root: TreeNode): Boolean = {
    val stack = new collection.mutable.Stack[TreeNode]()
    var node = root
    var pre: TreeNode = null
    var result = true
    while ((node != null || stack.nonEmpty) && result) {
      while (node != null) {
        stack push node
        node = node.left
      }

      node = stack.pop
      if (pre != null && node.value <= pre.value) result = false
      pre = node
      node = node.right

    }
    result
  }
}

/**
* inorder recursive traversal
* memo:
*    1. recursive version with all element storing
* Time complexity O(NlogN)  there are a distinct and sorted operation
* space complexity O(N)
*/
object Solution1 {
  def isValidBST(root: TreeNode): Boolean = {
    val inorder = traversal(root)
    inorder equals inorder.distinct.sorted // why distinct here? [1, 1] is not a BST because left tree should be smaller than root. 
  }
  def traversal(node: TreeNode): List[Int] = {
    if(node == null){
      List.empty[Int]
    }else {
      // (traversal(node.left) :+ node.value) ::: traversal(node.right) 
      traversal(node.left) ::: List(node.value) ::: traversal(node.right)
    }
  }
}



/**
* inorder recursive version only keep pre node
* time complexity: O(N)
*  ! Not recommend
*/

object Solution2 {
    def isValidBST(root: TreeNode): Boolean = {

    var prev: TreeNode = null
    def _isValidBST(node: TreeNode): Boolean = {
      if (node == null) return true
      if (!_isValidBST(node.left)) return false
      if (prev != null && node.value <= prev.value) {
        return false
      }
      prev = node
      _isValidBST(node.right)
    }
    _isValidBST(root)
  }
}

/**
* inorder iterative version only keep pre node
*   inorder iterative template
* time complexity: O(N)
*/

object Solution3 {
   def isValidBST(root: TreeNode): Boolean = {
    val stack = new collection.mutable.Stack[TreeNode]()
    var node = root
    var pre: TreeNode = null
    var result = true
    while ((node != null || stack.nonEmpty) && result) {
      while (node != null) {
        stack push node
        node = node.left
      }

      node = stack.pop
      if (pre != null && node.value <= pre.value) result = false
      pre = node
      node = node.right

    }
    result
  }
}

/**
* giving min max range when recursive
* time complexity: O(N)
*/

object Solution4 {
  def isValidBST(root: TreeNode): Boolean = {

    def _isValidBST(node: TreeNode, min: TreeNode, max: TreeNode): Boolean = {

      if(node == null) true
      else {
        if((min != null && node.value <= min.value) || (max != null  && node.value >= max.value)) false
        else {
          _isValidBST(node.lefmt, min, node) && _isValidBST(node.right, node, max)
        }
      }
    }
    _isValidBST(root, null, null)
  }

}
```