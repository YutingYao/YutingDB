<!-- vscode-markdown-toc -->
* 1. [é¢˜ç›®500+](#500)
	* 1.1. [500. Keyboard Row](#KeyboardRow)
	* 1.2. [503 ã€æ ˆã€‘Next Greater Element II](#NextGreaterElementII)
	* 1.3. [504-Base 7](#Base7)
	* 1.4. [509. ã€åŠ¨æ€ğŸš€è§„åˆ’ + é€’å½’ã€‘Fibonacci Number](#FibonacciNumber)
	* 1.5. [516. ã€å›æ–‡ã€‘ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Longest Palindromic Subsequence](#LongestPalindromicSubsequence)
		* 1.5.1. [ç±»ä¼¼é¢˜ç›®ï¼š1143. æœ€é•¿å…¬å…±å­åºåˆ—](#1143.)
	* 1.6. [518 Coin Change 2](#CoinChange2)
	* 1.7. [520. Detect Capital](#DetectCapital)
	* 1.8. [525. ã€å‰ç¼€å’ŒğŸ¨ã€‘Contiguous Array](#ContiguousArray)
	* 1.9. [526 Beautiful Arrangement](#BeautifulArrangement)
	* 1.10. [528 Random Pick with Weight](#RandomPickwithWeight)
	* 1.11. [530. Minimum Absolute Difference in BST](#MinimumAbsoluteDifferenceinBST)
	* 1.12. [532 K-diff Pairs in an Array](#K-diffPairsinanArray)
	* 1.13. [535. Encode and Decode TinyURL](#EncodeandDecodeTinyURL)
	* 1.14. [537 Complex Number Multiplicatin](#ComplexNumberMultiplicatin)
	* 1.15. [538 Convert BST to Greater Tree](#ConvertBSTtoGreaterTree)
	* 1.16. [540. Single Element in a Sorted Array 540-æœ‰åºæ•°ç»„ä¸­çš„å•ä¸€å…ƒç´ ](#SingleElementinaSortedArray540-)
	* 1.17. [542. 01 çŸ©é˜µ 01 Matrix](#Matrix)
	* 1.18. [543 Diameter of Binary Tree](#DiameterofBinaryTree)
	* 1.19. [546 Remove Boxes](#RemoveBoxes)
	* 1.20. [547 ã€ğŸ’å¹¶æŸ¥é›†ã€‘æœ‹å‹åœˆ](#)
	* 1.21. [554 Brick Wall](#BrickWall)
	* 1.22. [556 Next Greater Element III](#NextGreaterElementIII)
	* 1.23. [560. Subarray Sum Equals K å’Œä¸ºKçš„å­æ•°ç»„](#SubarraySumEqualsKK)
	* 1.24. [563 Binary Tree Tilt](#BinaryTreeTilt)
	* 1.25. [565 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Array Nesting](#ArrayNesting)
	* 1.26. [567. ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘Permutation in String 567-å­—ç¬¦ä¸²çš„æ’åˆ—](#PermutationinString567-)
	* 1.27. [572-å¦ä¸€ä¸ªæ ‘çš„å­æ ‘](#-1)
	* 1.28. [575 Distribute Candies](#DistributeCandies)
	* 1.29. [576. Out of Boundary Paths](#OutofBoundaryPaths)
	* 1.30. [581 Shortest Unsorted Continuous Suba](#ShortestUnsortedContinuousSuba)
	* 1.31. [589 N-ary Tree Preorder Traversal](#N-aryTreePreorderTraversal)
	* 1.32. [593 Valid Square](#ValidSquare)
	* 1.33. [594 Longest Harmonious Subsequence](#LongestHarmoniousSubsequence)
	* 1.34. [605 Can Place Flowers](#CanPlaceFlowers)
	* 1.35. [611](#-1)
	* 1.36. [621. Task Scheduler](#TaskScheduler)
	* 1.37. [622 Design Circular Queue](#DesignCircularQueue)
	* 1.38. [623 Add One Row to Tree](#AddOneRowtoTree)
	* 1.39. [633-Sum of Square Numbers](#SumofSquareNumbers)
	* 1.40. [636. Exclusive Time of Functions](#ExclusiveTimeofFunctions)
	* 1.41. [637 Average of Levels in Binary Tree](#AverageofLevelsinBinaryTree)
	* 1.42. [639. Decode Ways II](#DecodeWaysII)
	* 1.43. [643. Maximum Average Subarray I](#MaximumAverageSubarrayI)
	* 1.44. [645-é”™è¯¯çš„é›†åˆ](#-1)
	* 1.45. [646-ã€åŠ¨æ€ğŸš€è§„åˆ’ + è´ªå¿ƒğŸ§¡ã€‘æœ€é•¿æ•°å¯¹é“¾](#-1)
	* 1.46. [647 ã€åŠ¨æ€ğŸš€è§„åˆ’ + ä¸­å¿ƒæ‹“å±•ã€‘Palindromic Substrings](#PalindromicSubstrings)
	* 1.47. [650-åªæœ‰ä¸¤ä¸ªé”®çš„é”®ç›˜](#-1)
	* 1.48. [652. Find Duplicate Subtrees](#FindDuplicateSubtrees)
	* 1.49. [653. Two Sum IV](#TwoSumIV)
	* 1.50. [662. Maximum Width of Binary Tree](#MaximumWidthofBinaryTree)
	* 1.51. [667 Beautiful Arrangement II](#BeautifulArrangementII)
	* 1.52. [668. Kth Smallest Number in Multiplication Table](#KthSmallestNumberinMultiplicationTable)
	* 1.53. [669 Trim a Binary Search Tree](#TrimaBinarySearchTree)
	* 1.54. [673 Number of Longest Increasing Subse](#NumberofLongestIncreasingSubse)
	* 1.55. [678 Valid Parenthesis String](#ValidParenthesisString)
	* 1.56. [680-Valid Palindrome II](#ValidPalindromeII)
	* 1.57. [683. K Empty Slots](#KEmptySlots)
	* 1.58. [684. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Redundant Connection 684-å†—ä½™è¿æ¥](#RedundantConnection684-)
	* 1.59. [685. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Redundant Connection II](#RedundantConnectionII)
	* 1.60. [687. Longest Univalue Path](#LongestUnivaluePath)
	* 1.61. [688. Knight Probability in Chessboard](#KnightProbabilityinChessboard)
	* 1.62. [690. Employee Importance](#EmployeeImportance)
	* 1.63. [692. Top K Frequent Words](#TopKFrequentWords)
	* 1.64. [693](#-1)
	* 1.65. [695-å²›å±¿çš„æœ€å¤§é¢ç§¯](#-1)
	* 1.66. [696 Count Binary Substrings](#CountBinarySubstrings)
	* 1.67. [699. Falling Squares](#FallingSquares)
	* 1.68. [700 Search in a Binary Search Tree](#SearchinaBinarySearchTree)
	* 1.69. [701 Insert into a Binary Search Tree](#InsertintoaBinarySearchTree)
	* 1.70. [703. ã€æ„é€ ğŸ° + æœ€å°å †ğŸŒµã€‘Kth Largest Element in a Streamæ•°æ®æµä¸­çš„ç¬¬Kå¤§å…ƒç´ ](#KthLargestElementinaStreamK)
	* 1.71. [704.Binary SearchäºŒåˆ†æŸ¥æ‰¾](#BinarySearch)
	* 1.72. [705 Design HashSet](#DesignHashSet)
	* 1.73. [706. Design HashMapè®¾è®¡å“ˆå¸Œæ˜ å°„](#DesignHashMap)
	* 1.74. [707. Design Linked List](#DesignLinkedList)
	* 1.75. [712. Minimum ASCII Delete Sum for Two Strings](#MinimumASCIIDeleteSumforTwoStrings)
	* 1.76. [713 Subarray Product Less Than K](#SubarrayProductLessThanK)
	* 1.77. [714 ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹](#-1)
	* 1.78. [715. Range Module](#RangeModule)
	* 1.79. [719. Find K-th Smallest Pair Distance](#FindK-thSmallestPairDistance)
	* 1.80. [720. Longest Word in Dictionary](#LongestWordinDictionary)
	* 1.81. [721 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Accounts Merge](#AccountsMerge)
	* 1.82. [724. Find Pivot Index](#FindPivotIndex)
	* 1.83. [725. Split Linked List in Parts](#SplitLinkedListinParts)
	* 1.84. [726. Number of Atoms](#NumberofAtoms)
	* 1.85. [730. Count Different Palindromic Subsequences](#CountDifferentPalindromicSubsequences)
	* 1.86. [732. My Calendar III](#MyCalendarIII)
	* 1.87. [733. å›¾åƒæ¸²æŸ“ Flood Fill](#FloodFill)
	* 1.88. [735 Asteroid Collision](#AsteroidCollision)
	* 1.89. [737. Sentence Similarity II](#SentenceSimilarityII)
	* 1.90. [739-Daily Temperatures](#DailyTemperatures)
	* 1.91. [740. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ Delete and Earn](#DeleteandEarn)
	* 1.92. [741. Cherry Pickup](#CherryPickup)
	* 1.93. [743. ã€DijkstrağŸš—ã€‘Network Delay Time](#DijkstraNetworkDelayTime)
	* 1.94. [745. Prefix and Suffix Search](#PrefixandSuffixSearch)
	* 1.95. [746. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Min Cost Climbing Stairs](#MinCostClimbingStairs)
	* 1.96. [748. Shortest Completing Word](#ShortestCompletingWord)
	* 1.97. [752. Open the Lock](#OpentheLock)
	* 1.98. [763 Partition Labels](#PartitionLabels)
	* 1.99. [765. ã€ğŸ’å¹¶æŸ¥é›†ã€‘æƒ…ä¾£ç‰µæ‰‹ Couples Holding Hands](#CouplesHoldingHands)
	* 1.100. [769. Max Chunks To Make Sorted](#MaxChunksToMakeSorted)
	* 1.101. [771 Jewels and Stones](#JewelsandStones)
	* 1.102. [773. Sliding Puzzle](#SlidingPuzzle)
	* 1.103. [775. Global and Local Inversions](#GlobalandLocalInversions)
	* 1.104. [777](#-1)
	* 1.105. [778. ã€DijkstrağŸš— + ğŸ’å¹¶æŸ¥é›†ã€‘Swim in Rising Water](#DijkstraSwiminRisingWater)
	* 1.106. [784. Letter Case Permutation](#LetterCasePermutation)
	* 1.107. [785-åˆ¤æ–­äºŒåˆ†å›¾](#-1)
	* 1.108. [786. K-th Smallest Prime Fraction](#K-thSmallestPrimeFraction)
	* 1.109. [787. ã€DijkstrağŸš— + åŠ¨æ€ğŸš€è§„åˆ’ + æœ€å°å †ğŸŒµã€‘Cheapest Flights Within K Stops](#DijkstraCheapestFlightsWithinKStops)
	* 1.110. [790. Domino and Tromino Tiling](#DominoandTrominoTiling)
	* 1.111. [792. Number of Matching Subsequences](#NumberofMatchingSubsequences)
	* 1.112. [797 All Paths From Source to Target](#AllPathsFromSourcetoTarget)
	* 1.113. [799 Champagne Tower](#ChampagneTower)
	* 1.114. [801. Minimum Swaps To Make Sequences Increasing](#MinimumSwapsToMakeSequencesIncreasing)
	* 1.115. [803. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Bricks Falling When Hit](#BricksFallingWhenHit)
	* 1.116. [804 Unique Morse Code Words](#UniqueMorseCodeWords)
	* 1.117. [813. Largest Sum of Averages](#LargestSumofAverages)
	* 1.118. [815. Bus Routes](#BusRoutes)
	* 1.119. [817. Linked List Components](#LinkedListComponents)
	* 1.120. [818. Race Car (ä¸Š)](#RaceCar)
	* 1.121. [821 Shortest Distance to a Character](#ShortestDistancetoaCharacter)
	* 1.122. [823. Binary Trees With Factors](#BinaryTreesWithFactors)
	* 1.123. [824 Goat Latin](#GoatLatin)
	* 1.124. [827. Making A Large Island](#MakingALargeIsland)
	* 1.125. [832 Flipping an Image](#FlippinganImage)
	* 1.126. [835 Image Overlap](#ImageOverlap)
	* 1.127. [837. æ–° 21 ç‚¹ New 21 Game](#New21Game)
	* 1.128. [839 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Similar String Groups](#SimilarStringGroups)
	* 1.129. [841 Keys and Rooms](#KeysandRooms)
	* 1.130. [842. Split Array into Fibonacci Sequence](#SplitArrayintoFibonacciSequence)
	* 1.131. [844 Backspace String Compare](#BackspaceStringCompare)
	* 1.132. [845 Longest Mountain in Array](#LongestMountaininArray)
	* 1.133. [847 Shortest Path Visiting All Nodes](#ShortestPathVisitingAllNodes)
	* 1.134. [849 Maximize Distance to Closest Person](#MaximizeDistancetoClosestPerson)
	* 1.135. [856. Score of Parentheses](#ScoreofParentheses)
	* 1.136. [858 Mirror Reflection](#MirrorReflection)
	* 1.137. [859 Buddy Strings](#BuddyStrings)
	* 1.138. [863. All Nodes Distance K in Binary Tree](#AllNodesDistanceKinBinaryTree)
	* 1.139. [864. Shortest Path to Get All Keys](#ShortestPathtoGetAllKeys)
	* 1.140. [869 Reordered Power of 2](#ReorderedPowerof2)
	* 1.141. [865. Smallest Subtree with all the Deepest Nodes](#SmallestSubtreewithalltheDeepestNodes)
	* 1.142. [871. Minimum Number of Refueling Stops](#MinimumNumberofRefuelingStops)
	* 1.143. [873. Length of Longest Fibonacci Subsequence](#LengthofLongestFibonacciSubsequence)
	* 1.144. [875.Koko Eating Bananasç§‘ç§‘åƒé¦™è•‰](#KokoEatingBananas)
	* 1.145. [876.Middle of the Linked List é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](#MiddleoftheLinkedList)
	* 1.146. [877 ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ã€‘Stone Game](#StoneGame)
	* 1.147. [879. Profitable Schemes](#ProfitableSchemes)
	* 1.148. [880 Decoded String at Index](#DecodedStringatIndex)
	* 1.149. [881 Boats to Save People](#BoatstoSavePeople)
	* 1.150. [882. Reachable Nodes In Subdivided Graph](#ReachableNodesInSubdividedGraph)
	* 1.151. [886. Possible Bipartition](#PossibleBipartition)
	* 1.152. [887. Super Egg Drop](#SuperEggDrop)
	* 1.153. [889. Construct Binary Tree from Preorder and Postorder](#ConstructBinaryTreefromPreorderandPostorder)
	* 1.154. [891. Sum of Subsequence Widths](#SumofSubsequenceWidths)
	* 1.155. [894. All Possible Full Binary Trees](#AllPossibleFullBinaryTrees)
	* 1.156. [895. Maximum Frequency Stack](#MaximumFrequencyStack)
	* 1.157. [898. Bitwise ORs of Subarrays](#BitwiseORsofSubarrays)
	* 1.158. [901. ã€æ„é€ ğŸ°ã€‘Online Stock Span](#OnlineStockSpan)
	* 1.159. [902 Numbers At Most N Given Digit Set](#NumbersAtMostNGivenDigitSet)
	* 1.160. [904-æ°´æœæˆç¯®](#-1)
	* 1.161. [905 Sort Array By Parity](#SortArrayByParity)
	* 1.162. [906 Super Palindromes](#SuperPalindromes)
	* 1.163. [909. Snakes and Ladders](#SnakesandLadders)
	* 1.164. [910 Smallest Range II](#SmallestRangeII)
	* 1.165. [916 Word Subsetse](#WordSubsetse)
	* 1.166. [918 Maximum Sum Circular Sub](#MaximumSumCircularSub)
	* 1.167. [923. 3Sum With Multiplicity](#SumWithMultiplicity)
	* 1.168. [926. Flip String to Monotone Increasing](#FlipStringtoMonotoneIncreasing)
	* 1.169. [930-ã€æ»‘åŠ¨çª—å£ğŸ”¹ + å‰ç¼€å’ŒğŸ¨ã€‘å’Œç›¸åŒçš„äºŒå…ƒå­æ•°ç»„](#-1)
	* 1.170. [933 Number of Recent Calls](#NumberofRecentCalls)
	* 1.171. [934. Shortest Bridge](#ShortestBridge)
	* 1.172. [936 Stamping The Sequence](#StampingTheSequence)
	* 1.173. [938 Range Sum of BST](#RangeSumofBST)
	* 1.174. [941 Valid Mountain Array](#ValidMountainArray)
	* 1.175. [943. Find the Shortest Superstring](#FindtheShortestSuperstring)
	* 1.176. [946-Python-æ ˆçš„å‹å…¥ã€å¼¹å‡ºåºåˆ—](#Python-)
	* 1.177. [946 Validate Stack Sequences](#ValidateStackSequences)
	* 1.178. [947. ã€ğŸ’å¹¶æŸ¥é›†ã€‘ç§»é™¤æœ€å¤šçš„åŒè¡Œæˆ–åŒåˆ—çŸ³å¤´ Most Stones Removed with Same](#MostStonesRemovedwithSame)
	* 1.179. [948 Bag of Tokens](#BagofTokens)
	* 1.180. [949 Largest Time for Given Digits](#LargestTimeforGivenDigits)
	* 1.181. [952 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Largest Component Size by Commo](#LargestComponentSizebyCommo)
	* 1.182. [953 Verifying an Alien Dictionary](#VerifyinganAlienDictionary)
	* 1.183. [954 Array of Doubled Pairs](#ArrayofDoubledPairs)
	* 1.184. [959. ã€ğŸ’å¹¶æŸ¥é›†ã€‘ç”±æ–œæ åˆ’åˆ†åŒºåŸŸ Regions Cut By Slashes](#RegionsCutBySlashes)
	* 1.185. [964. ã€DijkstrağŸš—ã€‘Least Operators to Express Number](#DijkstraLeastOperatorstoExpressNumber)
	* 1.186. [966 Vowel Spellchecker](#VowelSpellchecker)
	* 1.187. [967. Numbers With Same Consecutive Differences](#NumbersWithSameConsecutiveDifferences)
	* 1.188. [968 Binary Tree Cameras](#BinaryTreeCameras)
	* 1.189. [969 Pancake Sorting](#PancakeSorting)
	* 1.190. [971 Flip Binary Tree To Match Preorder](#FlipBinaryTreeToMatchPreorder)
	* 1.191. [973 K Closest Points to Origin](#KClosestPointstoOrigin)
	* 1.192. [974. å’Œå¯è¢« K æ•´é™¤çš„å­æ•°ç»„ Subarray Sums Divisible by K](#KSubarraySumsDivisiblebyK)
	* 1.193. [975. Odd Even Jump](#OddEvenJump)
	* 1.194. [976 Middle of the Linked List](#MiddleoftheLinkedList-1)
	* 1.195. [977 Squares of a Sorted Array](#SquaresofaSortedArray)
	* 1.196. [978. æœ€é•¿æ¹æµå­æ•°ç»„ Longest Turbulent Subarray](#LongestTurbulentSubarray)
	* 1.197. [980. Unique Paths III](#UniquePathsIII)
	* 1.198. [983 ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + é€’å½’ã€‘Minimum Cost For Tickets](#MinimumCostForTickets)
	* 1.199. [986 Interval List Intersections](#IntervalListIntersections)
	* 1.200. [987 Vertical Order Traversal of a Binary](#VerticalOrderTraversalofaBinary)
	* 1.201. [990. ã€ğŸ’å¹¶æŸ¥é›†ã€‘ç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§ Satisfiability of Equality Equations](#SatisfiabilityofEqualityEquations)
	* 1.202. [992 ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘K ä¸ªä¸åŒæ•´æ•°çš„å­æ•°ç»„](#K)
	* 1.203. [993. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹](#-1)
	* 1.204. [994-è…çƒ‚çš„æ©˜å­](#-1)
	* 1.205. [993, 994, 995, 996](#-1)
	* 1.206. [997 Find the Town Judge](#FindtheTownJudge)
	* 1.207. [1000. Minimum Cost to Merge Stones](#MinimumCosttoMergeStones)
	* 1.208. [1001 Grid Illumination](#GridIllumination)
	* 1.209. [1004-æœ€å¤§è¿ç»­1çš„ä¸ªæ•° III](#III)
	* 1.210. [1007 Minimum Domino Rotations For Eq](#MinimumDominoRotationsForEq)
	* 1.211. [1008 Construct Binary Search Tree from](#ConstructBinarySearchTreefrom)
	* 1.212. [1009 Complement of Base 10 Integer](#ComplementofBase10Integer)
	* 1.213. [1010 Pairs of Songs With Total Durations](#PairsofSongsWithTotalDurations)
	* 1.214. [1013. å°†æ•°ç»„åˆ†æˆå’Œç›¸ç­‰çš„ä¸‰ä¸ªéƒ¨åˆ† Partition Array Into Three Parts With Equ](#PartitionArrayIntoThreePartsWithEqu)
	* 1.215. [1015 Smallest Integer Divisible by K](#SmallestIntegerDivisiblebyK)
	* 1.216. [1019. Next Greater Node In Linked List](#NextGreaterNodeInLinkedList)
	* 1.217. [1022 Sum of Root To Leaf Binary Numbers](#SumofRootToLeafBinaryNumbers)
	* 1.218. [1025,1026,1027,1028](#-1)
	* 1.219. [1024. Video Stitching](#VideoStitching)
	* 1.220. [1026 Maximum Difference Between Nod](#MaximumDifferenceBetweenNod)
	* 1.221. [1029 Two City Scheduling](#TwoCityScheduling)
	* 1.222. [1032 Stream of Characters](#StreamofCharacters)
	* 1.223. [1035 Uncrossed Lines](#UncrossedLines)
	* 1.224. [1041 Robot Bounded In Circle](#RobotBoundedInCircle)
	* 1.225. [1043. Partition Array for Maximum Sum](#PartitionArrayforMaximumSum)
	* 1.226. [1044 Longest Duplicate Substring](#LongestDuplicateSubstring)
	* 1.227. [1046 Last Stone Weight](#LastStoneWeight)
	* 1.228. [1048 Longest String Chain](#LongestStringChain)
	* 1.229. [1055.Shortest Way to Form String å½¢æˆå­—ç¬¦ä¸²çš„æœ€çŸ­è·¯å¾„](#ShortestWaytoFormString)
	* 1.230. [1091-äºŒè¿›åˆ¶çŸ©é˜µä¸­çš„æœ€çŸ­è·¯å¾„](#-1)
	* 1.231. [1094 Car Pooling](#CarPooling)
	* 1.232. [1095. Find in Mountain Array](#FindinMountainArray)
	* 1.233. [1105. Filling Bookcase Shelves](#FillingBookcaseShelves)
	* 1.234. [1106. Parsing A Boolean Expression](#ParsingABooleanExpression)
	* 1.235. [1110. Delete Nodes And Return Forest](#DeleteNodesAndReturnForest)
	* 1.236. [1111. æœ‰æ•ˆæ‹¬å·çš„åµŒå¥—æ·±åº¦ Maximum Nesting Depth of Two Valid Parentheses](#MaximumNestingDepthofTwoValidParentheses)
	* 1.237. [1114 - 1115 - 1116 - å¤šçº¿ç¨‹ threading](#threading)
	* 1.238. [1123.Lowest Common Ancestor of Deepest Leavesæœ€æ·±å¶èŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–](#LowestCommonAncestorofDeepestLeaves)
	* 1.239. [1124. Longest Well-Performing Interval](#LongestWell-PerformingInterval)
	* 1.240. [1125. Smallest Sufficient Team](#SmallestSufficientTeam)
	* 1.241. [1128. ç­‰ä»·å¤šç±³è¯ºéª¨ç‰Œå¯¹çš„æ•°é‡ Number of Equivalent Domino Pairs](#NumberofEquivalentDominoPairs)
	* 1.242. [1129. Shortest Path with Alternating Colors](#ShortestPathwithAlternatingColors)
	* 1.243. [1137. N-th Tribonacci Number](#N-thTribonacciNumber)
	* 1.244. [1140. Stone Game II](#StoneGameII)
	* 1.245. [1143 ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ã€‘Longest Common Subsequence](#LongestCommonSubsequence)
		* 1.245.1. [ç±»ä¼¼é¢˜ç›®ï¼š516æœ€é•¿å›æ–‡å­åºåˆ—](#516)
	* 1.246. [1145. Binary Tree Coloring Game](#BinaryTreeColoringGame)
	* 1.247. [1155. Number of Dice Rolls With Target Sum](#NumberofDiceRollsWithTargetSum)
	* 1.248. [1160. æ‹¼å†™å•è¯ Find Words That Can Be Formed by Characters](#FindWordsThatCanBeFormedbyCharacters)
	* 1.249. [1172. Dinner Plate Stacks](#DinnerPlateStacks)
	* 1.250. [1178. Number of Valid Words for Each Puzzle](#NumberofValidWordsforEachPuzzle)
	* 1.251. [1187. Make Array Strictly Increasing](#MakeArrayStrictlyIncreasing)
	* 1.252. [1191. K-Concatenation Maximum Sum](#K-ConcatenationMaximumSum)
	* 1.253. [1201. Ugly Number III](#UglyNumberIII)
	* 1.254. [1202. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Smallest String With Swaps](#SmallestStringWithSwaps)
	* 1.255. [1203. é¡¹ç›®ç®¡ç† Sort Items by Groups Respecting Dependencies](#SortItemsbyGroupsRespectingDependencies)
	* 1.256. [1206. Design Skiplist](#DesignSkiplist)
	* 1.257. [1209 Remove All Adjacent Duplicates in](#RemoveAllAdjacentDuplicatesin)
	* 1.258. [1217 Minimum Cost to Move Chips](#MinimumCosttoMoveChips)
	* 1.259. [1218. Longest Arithmetic Subsequence of Given Difference](#LongestArithmeticSubsequenceofGivenDifference)
	* 1.260. [1220. Count Vowels Permutation](#CountVowelsPermutation)
	* 1.261. [1223 Dice Roll Simulation](#DiceRollSimulation)
	* 1.262. [1240 Tiling a Rectangle with the Fewest Squares](#TilingaRectanglewiththeFewestSquares)
	* 1.263. [1248-ç»Ÿè®¡ã€Œä¼˜ç¾å­æ•°ç»„ã€](#-1)
	* 1.264. [1249 Minimum Remove to Make Valid Pare](#MinimumRemovetoMakeValidPare)
	* 1.265. [1252 1253 1254 1255](#-1)
	* 1.266. [1263. Minimum Moves to Move a Box to Their Target](#MinimumMovestoMoveaBoxtoTheirTarget)
	* 1.267. [1277. ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ã€‘ç»Ÿè®¡å…¨ä¸º1çš„æ­£æ–¹å½¢å­çŸ©é˜µ](#-1)
	* 1.268. [1278. Palindrome Partitioning III](#PalindromePartitioningIII)
	* 1.269. [1283 Find the Smallest Divisor Given a](#FindtheSmallestDivisorGivena)
	* 1.270. [1284. Minimum Number of Flips to Convert Binary Matrix](#MinimumNumberofFlipstoConvertBinaryMatrix)
	* 1.271. [1290. äºŒè¿›åˆ¶é“¾è¡¨è½¬æ•´æ•° (Convert Binary Number in a Linked List](#ConvertBinaryNumberinaLinkedList)
	* 1.272. [1291 Sequential Digits](#SequentialDigits)
	* 1.273. [1293. Shortest Path in a Grid with Obstacles Elimination](#ShortestPathinaGridwithObstaclesElimination)
	* 1.274. [1296. Divide Array in Sets of K Consecutive Numbers](#DivideArrayinSetsofKConsecutiveNumbers)
	* 1.275. [1301. Number of Paths with Max Score](#NumberofPathswithMaxScore)
	* 1.276. [1302 Deepest Leaves Sum](#DeepestLeavesSum)
	* 1.277. [1305 All Elements in Two Binary Search](#AllElementsinTwoBinarySearch)
	* 1.278. [1306 Jump Game III](#JumpGameIII)
	* 1.279. [1310. XOR Queries of a Subarray](#XORQueriesofaSubarray)
	* 1.280. [1312. Minimum Insertion Steps to Make a String Palindrom](#MinimumInsertionStepstoMakeaStringPalindrom)
	* 1.281. [1319. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Number of Operations to Make Network Connected](#NumberofOperationstoMakeNetworkConnected)
	* 1.282. [1320. Minimum Distance to Type a Word Using Two Finger](#MinimumDistancetoTypeaWordUsingTwoFinger)
	* 1.283. [1329 Sort the Matrix Diagonally](#SorttheMatrixDiagonally)
	* 1.284. [1332 Remove Palindromic Subsequences](#RemovePalindromicSubsequences)
	* 1.285. [1334. ã€DijkstrağŸš—ã€‘Find the City With Smallest Number of Neighbors](#DijkstraFindtheCityWithSmallestNumberofNeighbors)
	* 1.286. [1335. Minimum Difficulty of a Job Schedule](#MinimumDifficultyofaJobSchedule)
	* 1.287. [1337 The K Weakest Rows in a Matrix](#TheKWeakestRowsinaMatrix)
	* 1.288. [1339 Maximum Product of Splitt](#MaximumProductofSplitt)
	* 1.289. [1340. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Jump Game V](#JumpGameV)
	* 1.290. [1349. Maximum Students Taking Exam](#MaximumStudentsTakingExam)
	* 1.291. [1353. Maximum Number of Events That Can Be Attended](#MaximumNumberofEventsThatCanBeAttended)
	* 1.292. [1354. Construct Target Array With Multiple Sums](#ConstructTargetArrayWithMultipleSums)
	* 1.293. [1368. ã€DijkstrağŸš—ã€‘Minimum Cost to Make at Least One Valid Path](#DijkstraMinimumCosttoMakeatLeastOneValidPath)
	* 1.294. [1371. Find the Longest Substring Containing Vowels in Eve](#FindtheLongestSubstringContainingVowelsinEve)
	* 1.295. [1373. Maximum Sum BST in Binary Tree](#MaximumSumBSTinBinaryTree)
	* 1.296. [1377. Frog Position After T Seconds](#FrogPositionAfterTSeconds)
	* 1.297. [1379 Find Corresponding Node of Binary Tree in a Clone](#FindCorrespondingNodeofBinaryTreeinaClone)
	* 1.298. [1382. Balance a Binary Search Tree](#BalanceaBinarySearchTree)
	* 1.299. [1395. Count Number of Teams](#CountNumberofTeams)
	* 1.300. [1396 Design Underground System](#DesignUndergroundSystem)
	* 1.301. [1406. Stone Game III](#StoneGameIII)
	* 1.302. [1409. Queries on a Permutation With Key](#QueriesonaPermutationWithKey)
	* 1.303. [1416. Restore The Array](#RestoreTheArray)
	* 1.304. [1424. Diagonal Traverse II](#DiagonalTraverseII)
	* 1.305. [1425. Constrained Subset Sum](#ConstrainedSubsetSum)
	* 1.306. [1426  Counting Elements](#CountingElements)
	* 1.307. [1431. æ‹¥æœ‰æœ€å¤šç³–æœçš„å­©å­ Kids With the Greatest Number of Candie](#KidsWiththeGreatestNumberofCandie)
	* 1.308. [1437 Check If All 1's Are at Least Length](#CheckIfAll1sAreatLeastLength)
	* 1.309. [1438. Longest Continuous Subarray With Absolute](#LongestContinuousSubarrayWithAbsolute)
	* 1.310. [1441 Build an Array With Stack Operations](#BuildanArrayWithStackOperations)
	* 1.311. [1442. Count Triplets That Can Form Two Arrays of Equal](#CountTripletsThatCanFormTwoArraysofEqual)
	* 1.312. [1443. Minimum Time to Collect All Apples in a Tree](#MinimumTimetoCollectAllApplesinaTree)
	* 1.313. [1444. ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ + å‰ç¼€å’ŒğŸ¨ + é€’å½’ã€‘Number of Ways of Cutting a Pizza](#NumberofWaysofCuttingaPizza)
	* 1.314. [1446 Consecutive Characters](#ConsecutiveCharacters)
	* 1.315. [1448 Count Good Nodes in Binary Tree](#CountGoodNodesinBinaryTree)
	* 1.316. [1449. ã€èƒŒåŒ… + åŠ¨æ€ğŸš€è§„åˆ’ã€‘Form Largest Integer With Digits That Add](#FormLargestIntegerWithDigitsThatAdd)
	* 1.317. [1451 Rearrange Words in a Sentence](#RearrangeWordsinaSentence)
	* 1.318. [1453 Maximum Number of Darts Inside of a Circular Dartb](#MaximumNumberofDartsInsideofaCircularDartb)
	* 1.319. [1457 Pseudo-Palindromic Paths in a Bin](#Pseudo-PalindromicPathsinaBin)
	* 1.320. [1461 Check If a String Contains All Binar](#CheckIfaStringContainsAllBinar)
	* 1.321. [1463 Cherry Pickup II](#CherryPickupII)
	* 1.322. [1473. Paint House III](#PaintHouseIII)
	* 1.323. [1475. Final Prices With a Special Discount in a Sho](#FinalPricesWithaSpecialDiscountinaSho)
	* 1.324. [1483. Kth Ancestor of a Tree Node](#KthAncestorofaTreeNode)
	* 1.325. [1488. Avoid Flood in The City](#AvoidFloodinTheCity)
	* 1.326. [1489. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Find Critical and Pseudo-Critical Edges in](#FindCriticalandPseudo-CriticalEdgesin)
	* 1.327. [1492 The kth Factor of n](#ThekthFactorofn)
	* 1.328. [1493. Longest Subarray of 1's After Deleting One](#LongestSubarrayof1sAfterDeletingOne)
	* 1.329. [1499. Max Value of Equation](#MaxValueofEquation)
	* 1.330. [1502 Can Make Arithmetic Progression From Sequence](#CanMakeArithmeticProgressionFromSequence)
	* 1.331. [1503 Last Moment Before All Ants Fall Out of a Plank](#LastMomentBeforeAllAntsFallOutofaPlank)
	* 1.332. [1505. Minimum Possible Integer After at Most K Adjacent](#MinimumPossibleIntegerAfteratMostKAdjacent)
	* 1.333. [1508. Range Sum of Sorted Subarray Sums](#RangeSumofSortedSubarraySums)
	* 1.334. [1510 Stone Game IV](#StoneGameIV)
	* 1.335. [1514 ã€DijkstrağŸš—ã€‘Path with Maximum Probability](#DijkstraPathwithMaximumProbability)
	* 1.336. [1515 Best Position for a Service Centre](#BestPositionforaServiceCentre)
	* 1.337. [1520. Maximum Number of Non-Overlapping Substrings](#MaximumNumberofNon-OverlappingSubstrings)
	* 1.338. [1530. Number of Good Leaf Nodes Pairs](#NumberofGoodLeafNodesPairs)
	* 1.339. [1531. String Compression II](#StringCompressionII)
	* 1.340. [1534 Count Good Triplets](#CountGoodTriplets)
	* 1.341. [1535 Find the Winner of an Array Game](#FindtheWinnerofanArrayGame)
	* 1.342. [1537. Get the Maximum Score](#GettheMaximumScore)
	* 1.343. [1539. Kth Missing Positive Number](#KthMissingPositiveNumber)
	* 1.344. [1542. Find Longest Awesome Substring](#FindLongestAwesomeSubstring)
	* 1.345. [1546. Maximum Number of Non-Overlapping Subarrays With Sum](#MaximumNumberofNon-OverlappingSubarraysWithSum)
	* 1.346. [1550. Three Consecutive Odds](#ThreeConsecutiveOdds)
	* 1.347. [1551 Minimum Operations to Make Array](#MinimumOperationstoMakeArray)
	* 1.348. [1553. Minimum Number of Days to Eat N Oranges](#MinimumNumberofDaystoEatNOranges)
	* 1.349. [1556. Thousand Separator](#ThousandSeparator)
	* 1.350. [1558. Minimum Numbers of Function Calls to Make Target](#MinimumNumbersofFunctionCallstoMakeTarget)
	* 1.351. [1563. Stone Game V](#StoneGameV)
	* 1.352. [1569. Number of Ways to Reorder Array to Get Sa](#NumberofWaystoReorderArraytoGetSa)
	* 1.353. [1573. Number of Ways to Split a String](#NumberofWaystoSplitaString)
	* 1.354. [1585. Check If String Is Transformable With](#CheckIfStringIsTransformableWith)
	* 1.355. [1593. Split a String Into the Max Number of Unique Substri](#SplitaStringIntotheMaxNumberofUniqueSubstri)
	* 1.356. [1595. Minimum Cost to Connect Two Groups of Points](#MinimumCosttoConnectTwoGroupsofPoints)
	* 1.357. [1621. Number of Sets of K Non-Overlapping Line](#NumberofSetsofKNon-OverlappingLine)
	* 1.358. [1631. ã€DijkstrağŸš— + æœ€å°å †ğŸŒµã€‘Path With Minimum Effort](#DijkstraPathWithMinimumEffort)
	* 1.359. [1632 Rank Transform of a Matrix](#RankTransformofaMatrix)
	* 1.360. [1640 Check Array Formation Through](#CheckArrayFormationThrough)
	* 1.361. [1641 Count Sorted Vowel Strings](#CountSortedVowelStrings)
	* 1.362. [1642. Furthest Building You Can Reach](#FurthestBuildingYouCanReach)
	* 1.363. [1646 Get Maximum in Generated Array](#GetMaximuminGeneratedArray)
	* 1.364. [1648. Sell Diminishing-Valued Colored Balls](#SellDiminishing-ValuedColoredBalls)
	* 1.365. [1649 Create Sorted Array through Instru](#CreateSortedArraythroughInstru)
	* 1.366. [1655. Distribute Repeating Integers](#DistributeRepeatingIntegers)
	* 1.367. [1657 Determine if Two Strings Are Close](#DetermineifTwoStringsAreClose)
	* 1.368. [1658 Minimum Operations to Reduce X](#MinimumOperationstoReduceX)
	* 1.369. [1659. Maximize Grid Happiness](#MaximizeGridHappiness)
	* 1.370. [1662 Check If Two String Arrays are Equi](#CheckIfTwoStringArraysareEqui)
	* 1.371. [1663 Smallest String With A Given Numer](#SmallestStringWithAGivenNumer)
	* 1.372. [1673 Find the Most Competitive Subseq](#FindtheMostCompetitiveSubseq)
	* 1.373. [1674. Minimum Moves to Make Array Complement](#MinimumMovestoMakeArrayComplement)
	* 1.374. [1675. Minimize Deviation in Array](#MinimizeDeviationinArray)
	* 1.375. [1679 Max Number of K-Sum Pairsã€‘](#MaxNumberofK-SumPairs)
	* 1.376. [1680 Concatenation of Consecutive Bina](#ConcatenationofConsecutiveBina)
	* 1.377. [1681. Minimum Incompatibility](#MinimumIncompatibility)
	* 1.378. [1690. Stone Game VII](#StoneGameVII)
	* 1.379. [1696. ã€åŠ¨æ€ğŸš€è§„åˆ’ O(n-k) * ä¼˜å…ˆé˜Ÿåˆ— O(1) + æœ€å°å †ğŸŒµã€‘ Jump Game VI](#On-kO1JumpGameVI)
	* 1.380. [1704 Determine if String Halves Are Alike](#DetermineifStringHalvesAreAlike)
	* 1.381. [1707. Maximum XOR With an Element From Array](#MaximumXORWithanElementFromArray)
	* 1.382. [1713. Minimum Operations to Make a Subsequence](#MinimumOperationstoMakeaSubsequence)
	* 1.383. [1721 Swapping Nodes in a Linked List](#SwappingNodesinaLinkedList)
	* 1.384. [1727. Largest Submatrix With Rearrangements](#LargestSubmatrixWithRearrangements)
	* 1.385. [1745. Palindrome Partitioning IV](#PalindromePartitioningIV)
	* 1.386. [1760. Minimum Limit of Balls in a Bag](#MinimumLimitofBallsinaBag)
	* 1.387. [1770. Maximum Score from Performing Multiplication](#MaximumScorefromPerformingMultiplication)
	* 1.388. [1771. Maximize Palindrome Length From Subsequences](#MaximizePalindromeLengthFromSubsequences)
	* 1.389. [1775. Equal Sum Arrays With Minimum Number of Operatio](#EqualSumArraysWithMinimumNumberofOperatio)
	* 1.390. [1786. ã€DijkstrağŸš—ã€‘ Number of Restricted Paths From First to Last Node](#DijkstraNumberofRestrictedPathsFromFirsttoLastNode)
	* 1.391. [1792. Maximum Average Pass Ratio](#MaximumAveragePassRatio)
	* 1.392. [1799. Maximize Score After N Operations](#MaximizeScoreAfterNOperations)
	* 1.393. [1815. Maximum Number of Groups Getting Fresh Donuts](#MaximumNumberofGroupsGettingFreshDonuts)
	* 1.394. [1838. Frequency of the Most Frequent Element](#FrequencyoftheMostFrequentElement)
	* 1.395. [1847. Closest Room](#ClosestRoom)
	* 1.396. [1872. Stone Game VIII](#StoneGameVIII)
	* 1.397. [ 1976. ã€DijkstrağŸš—ã€‘åˆ°è¾¾ç›®çš„åœ°çš„æ–¹æ¡ˆæ•°](#1976.Dijkstra)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
##  1. <a name='500'></a>é¢˜ç›®500+

###  1.1. <a name='KeyboardRow'></a>500. Keyboard Row

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1vJ411X7BR?spm_id_from=333.999.0.0)

###  1.2. <a name='NextGreaterElementII'></a>503 ã€æ ˆã€‘Next Greater Element II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV197411L77N?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1k5411t7Pa?spm_id_from=333.999.0.0)


```py
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = nums[:]
        stack = []
        for idx, cur in sorted(enumerate(nums),key = lambda x: x[1]):
            while stack and nums[stack[-1]] < cur:
                res[stack[-1]] = cur
                stack.pop()
            stack.append(idx)
        
        while stack:
            res[stack[-1]] = -1
            stack.pop()
        
        return res
        
# å“­ï¼Œæˆ‘åˆç†è§£é”™é¢˜ç›®äº†
# è¾“å…¥ï¼š
# [5,4,3,2,1]
# è¾“å‡ºï¼š
# [-1,5,4,3,2]
# é¢„æœŸç»“æœï¼š
# [-1,5,5,5,5]
```

```py
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = nums[:]
        stack = []
        # åŒå€numså¤§æ³•å¥½
        for idx, cur in enumerate(nums + nums):
            while stack and nums[stack[-1]] < cur:
                res[stack[-1]] = cur
                stack.pop()
            if idx < len(nums): # æ˜“é”™ç‚¹ï¼šappend(idx)æ˜¯æœ‰æ¡ä»¶çš„
                stack.append(idx)
        
        while stack:
            res[stack[-1]] = -1
            stack.pop()
        
        return res

æ›´ç®€å•çš„å†™æ³•:

class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = [-1] * len(nums)
        stack = []
        # åŒå€numså¤§æ³•å¥½
        for idx, cur in enumerate(nums + nums):
            while stack and nums[stack[-1]] < cur:
                res[stack[-1]] = cur
                stack.pop()
            if idx < len(nums): # æ˜“é”™ç‚¹ï¼šappend(idx)æ˜¯æœ‰æ¡ä»¶çš„
                stack.append(idx)
        return res


```



###  1.3. <a name='Base7'></a>504-Base 7

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1pj411f7o5?spm_id_from=333.999.0.0)

###  1.4. <a name='FibonacciNumber'></a>509. ã€åŠ¨æ€ğŸš€è§„åˆ’ + é€’å½’ã€‘Fibonacci Number

[1:30 èŠ±èŠ±é…± DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV15y4y147Re?spm_id_from=333.999.0.0)

```py
class Solution:
    def fib(self, n: int) -> int:
        a, b = 0, 1
        for i in range(n): 
            a, b = b, a + b # pyçš„å•è¡Œæ›´æ–°å€¼
    	return a


# é€’å½’å®ç°
class Solution:
    @lru_cache
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)

    
class Solution:
    @cache
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)

# è®°å¿†åŒ–é€’å½’
class Solution:
    def fib(self, n: int) -> int:
        dic = {}
        dic[0] = 0
        dic[1] = 1

        def helper(n):
            # è¿™ä¸ªå†™æ³•æ˜¯é”™è¯¯çš„ï¼šif n == 0 or 1:
            if n <= 1:
                return n
            elif n in dic:
                return dic[n]
            else:
                dic[n] = helper(n - 1) + helper(n - 2)
                return dic[n]
        return helper(n)
```

```scala
/**
* chosen solution
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution0 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* iterative - bottom up with memorization
* time complexity O(N)
* space complexity O(N)
*/

object Solution1 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1
        (2 to N).foreach(n => cache(n) = cache(n -1) + cache(n -2))
        cache(N)
    }
}

/**
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution1-2 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* recursive - top-down with memorization
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution2 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1

        def _fib(n: Int):Int = {
            if(n <= 1) return n
            
            if(cache(n) != 0) cache(n)
            else {
                cache(n) = _fib(n-1) + _fib(n-2)
                cache(n)
            }
        }
        _fib(N)
        
    }
}



/**
* recursive version - top-down
* time complexity: O(2^Nï¼‰
* space complexity: O(N)
*/

object Solution3 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
           fib(N - 1) + fib(N - 2)
        }
    }
}


```

###  1.5. <a name='LongestPalindromicSubsequence'></a>516. ã€å›æ–‡ã€‘ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Longest Palindromic Subsequence

####  1.5.1. <a name='1143.'></a>ç±»ä¼¼é¢˜ç›®ï¼š1143. æœ€é•¿å…¬å…±å­åºåˆ—

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV18W411d7k2?spm_id_from=333.999.0.0)

```py
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        #dp æœ€é•¿å›æ–‡ä¸²ä¸ªæ•°
        n = len(s)
        #if not s or n < 2: return n

        dp = [[0] * n for _ in range(n)]
        for i in range(n):  # ä»å·¦ å³ å·¦ä¸‹ è®¡ç®—ï¼š
            dp[i][i] = 1
        
        for stt in range(n-1,-1,-1):  # ä¸åŒçš„çŠ¶æ€è½¬ç§»å¯¹åº”ä¸åŒçš„loop
            for end in range(stt + 1, n): #[i,j]
                if s[stt] == s[end]:
                    dp[stt][end] = dp[stt+1][end-1] + 2
                else:
                    dp[stt][end] = max(dp[stt+1][end], dp[stt][end-1])
                    # å› ä¸ºå¯ä»¥åˆ é™¤å­—ç¬¦,æ‰€ä»¥å¯ä»¥åƒè¿™æ ·ç›´æ¥ä¼ é€’
        
        #print(dp)
        return dp[0][-1]
```

###  1.6. <a name='CoinChange2'></a>518 Coin Change 2

[å°æ˜](https://www.bilibili.com/video/BV1jC4y1a7YT?spm_id_from=333.999.0.0)

###  1.7. <a name='DetectCapital'></a>520. Detect Capital

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1NJ41197da?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1xT4y1j7G4?spm_id_from=333.999.0.0)

```py
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        # è‹¥ç¬¬ 1 ä¸ªå­—æ¯ä¸ºå°å†™ï¼Œåˆ™éœ€é¢å¤–åˆ¤æ–­ç¬¬ 2 ä¸ªå­—æ¯æ˜¯å¦ä¸ºå°å†™
        if len(word) >= 2 and word[0].islower() and word[1].isupper():
            return False
        
        # æ— è®ºç¬¬ 1 ä¸ªå­—æ¯æ˜¯å¦å¤§å†™ï¼Œå…¶ä»–å­—æ¯å¿…é¡»ä¸ç¬¬ 2 ä¸ªå­—æ¯çš„å¤§å°å†™ç›¸åŒ
        return all(word[i].islower() == word[1].islower() for i in range(2, len(word)))

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/detect-capital/solution/jian-ce-da-xie-zi-mu-by-leetcode-solutio-449z/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

python3: å¦‚æœåªæœ‰ä¸€ä¸ªå­—æ¯ï¼Œè¿”å›trueï¼›å¦‚æœå…¨æ˜¯å¤§å†™ï¼Œè¿”å›trueï¼Œå¦åˆ™è¿”å›é™¤äº†é¦–å­—æ¯å¤–çš„å­—æ¯æ˜¯ä¸æ˜¯å…¨æ˜¯å°å†™ã€‚

class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if len(word) == 1:
            return True
        if word.isupper():
            return True
        else:
            return word[1:].islower()
```

```py
å˜»å˜»ï¼Œè¿™åº”è¯¥æ˜¯ç›®å‰ä¸ºæ­¢æœ€ç®€å•çš„ä¸€é¢˜äº†

class Solution(object):
    def detectCapitalUse(self, word):
        """
        :type word: str
        :rtype: bool
        """
        if word == word.upper() or word == word.lower() or word == word.title():
            return True
        else:
            return False


class Solution:
    def detectCapitalUse(self, word: str) -> bool:
            return word.islower() or word.isupper() or word.istitle()
```

###  1.8. <a name='ContiguousArray'></a>525. ã€å‰ç¼€å’ŒğŸ¨ã€‘Contiguous Array

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14W411d7SD?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV185411t7tu?spm_id_from=333.999.0.0)

```py
0å˜-1æ˜¯ç²¾é«“ï¼Œsum_dct = {0:-1}æ˜¯ç»†èŠ‚ã€‚

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        sum_dct = {0:-1}
        temp,res = 0,0
        for i in range(len(nums)):
            if nums[i] == 0:
                temp += -1
            else:
                temp += 1
            if temp not in sum_dct:
                sum_dct[temp] = i
            else:
                res = max(res,i-sum_dct[temp])
        return res
```

```py
è¯´ä¸€ä¸‹å¿ƒè·¯å†ç¨‹ã€‚

é”™è¯¯æ€è·¯1ï¼šå¼€å§‹æˆ‘ä»¥ä¸ºæ˜¯ä¸€ä¸ªæ ˆçš„æ€è·¯ï¼Œé‡åˆ°0å°±pushï¼Œ1å°±popï¼Œ

ç„¶åä»€ä¹ˆæ—¶å€™stackç©ºäº†å°±è¡Œäº†ã€‚ åæ¥å‘ç°è¿™ä¸ªæ€è·¯æ˜¯é”™çš„ï¼Œå› ä¸º1ï¼‰

å¦‚æœ1æ¯”0å¤šä¹…popä¸å‡ºå»äº†ï¼Œ2ï¼‰è¿™ç§æ€è·¯åªè€ƒè™‘åˆ°ä»ç¬¬0ä½å¼€å§‹çš„å­æ•°ç»„

é”™è¯¯æ€è·¯2ï¼šå› æ­¤æˆ‘æƒ³åˆ°æ„å»ºä¸¤ä¸ªlistï¼Œåˆ†åˆ«å­˜1å’Œ0ï¼Œæ¯”è¾ƒä»€ä¹ˆæ—¶å€™ä¸Šä¸‹ä¸¤ä¸ªæ•°ç»„lenä¸€æ ·ï¼Œ

ç„¶åè¿”å›ä¸¤ä¸ªlisté•¿åº¦æ€»å’Œï¼Œçš„è¿™ç§æ–¹æ³•åªèƒ½è§£å†³ä¸Šé¢æåˆ°çš„1ï¼‰é—®é¢˜

æ­£ç¡®æ€è·¯ï¼š è½¬è€Œæˆ‘æƒ³åˆ°ï¼Œç«Ÿç„¶æ˜¯æ ˆçš„æ€ç»´ï¼Œä½•å¿…ç”¨ä¸€ä¸ªçœŸçš„æ ˆï¼Œ

åªè¦è®°å½•æ ˆé‡Œé¢çš„å…ƒç´ æ•°é‡å³å¯ï¼ˆ0pushï¼Œ1popï¼‰ 

å› æ­¤æˆ‘æ„å»ºäº†ä¸€ä¸ªè®°å½•æ ˆé•¿åº¦æ•°é‡çš„listï¼Œç„¶åå‘ç°è¿™ç©æ„ä¸è¯´å°±æ˜¯å‰ç¼€å’Œçš„æ€è·¯å˜›ã€‚ 

ç„¶åæˆ‘å€Ÿé‰´é”™è¯¯æ€è·¯2çš„ç‚¹ï¼Œéœ€è¦è®°å½•é•¿åº¦çš„è¯ï¼Œ

å°±æ˜¯å½“æ ˆé‡Œå…ƒç´ æ•°é‡ç›¸ç­‰çš„æ—¶å€™ï¼Œä¿ç•™ä¸Šä¸‹æ ‡ï¼ˆæˆ–è€…ä¿ç•™æœ€å¤§é•¿åº¦ï¼‰ï¼Œ æœ€åæ‰¾ä¸€ä¸‹æœ€å¤§é•¿åº¦å³å¯

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:        
        preSum = [0]
        presum_index = {0:[-1,-1]}
        for i in range(len(nums)):
            preSum.append(preSum[i]+1 if nums[i] == 1 else preSum[i]-1)
            presum_index[preSum[-1]] = presum_index.get(preSum[-1],[i,i])
            presum_index[preSum[-1]][1] = i
        res = 0
        for v in presum_index.values():
            res = max(v[1] - v[0],res)
        return res

ç„¶åï¼Œæˆ‘å»çœ‹äº†ä¸€ä¸‹æˆ‘çš„å†å²æäº¤è®°å½•ï¼Œå‘ç°è¿™é¢˜æˆ‘ä¸€å¹´å‰è§£è¿‡ï¼Œè€Œä¸”è§£æ³•ç«Ÿç„¶æ¯”ç°åœ¨å¥½ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚è¿™ä¸€å¹´å®Œå…¨æ²¡æœ‰è¿›æ­¥

ä¸€å¹´å‰çš„ä»£ç :

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        front_hash = {}
        front_hash[0] = -1
        res = 0
        s = 0
        for i in range(len(nums)):
            s += 1 if nums[i] == 1 else -1
            if s in front_hash:
                res = max(res, i - front_hash[s])
            else:
                front_hash[s] = i
        return res

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        res = 0
        hmap = {0: -1}
        prefix = 0
        for index, num in enumerate(nums):
            if num == 0:
                prefix -= 1
            else:
                prefix += 1
            hmap[prefix] = hmap.get(prefix, index)
            res = max(res, index - hmap[prefix])
        return res
```


###  1.9. <a name='BeautifulArrangement'></a>526 Beautiful Arrangement

[å°æ˜](https://www.bilibili.com/video/BV1DK411M7QR?spm_id_from=333.999.0.0)

###  1.10. <a name='RandomPickwithWeight'></a>528 Random Pick with Weight

[å°æ˜](https://www.bilibili.com/video/BV1UV411r7MK?spm_id_from=333.999.0.0)

###  1.11. <a name='MinimumAbsoluteDifferenceinBST'></a>530. Minimum Absolute Difference in BST

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1fW411k7eT?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1FJ41147BB?spm_id_from=333.999.0.0)

```py
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        inorder = []
        def dfs(root):
            nonlocal inorder
            if not root:
                return 
            dfs(root.left)
            inorder.append(root.val)
            dfs(root.right) 
        dfs(root)
        return min([inorder[i]-inorder[i-1] for i in range(1,len(inorder))])

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        
        def inorder(node):
            if node:
                yield from inorder(node.left)
                yield node.val
                yield from inorder(node.right)

        pre, cur = tee(inorder(root))
        next(cur, None)
        return min(b-a for a, b in zip(pre, cur))
```

```py
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        self.res = float('inf')
        self.tmp = -1
        def dfs(root):
            if not root:
                return
            dfs(root.left)
            if self.tmp == -1:
                self.tmp = root.val
            else:
                self.res = min(self.res, abs(root.val - self.tmp))
                self.tmp = root.val
            dfs(root.right)
        dfs(root)
        return self.res

é€’å½’

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        ret = inf
        pre = None
        def dfs(node):
            nonlocal ret, pre
            if not node: return   
            dfs(node.left)
            if pre != None: ret = min(node.val - pre, ret)             
            pre = node.val
            dfs(node.right)                
        dfs(root)       
        return ret

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        """è§£é¢˜æ€è·¯ï¼šäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†æ˜¯ä¸€ä¸ªé€’å¢ä¸”æ— é‡å¤å…ƒç´ çš„åºåˆ—"""
        path = []
        min_ = float('INF')  

        def traval(root):  # ä¸­åºéå†
            nonlocal path
            if not root: return

            traval(root.left)
            path.append(root.val)
            traval(root.right)

        
        traval(root)
        result = list(zip(path, path[1:]))   # çª—å£å¤§å°ä¸º2ï¼Œæ­¥é•¿ä¸º1
        for i, j in result:
            if abs(j - i) < min_:
                min_ = abs(j - i)
        
        return min_
```

###  1.12. <a name='K-diffPairsinanArray'></a>532 K-diff Pairs in an Array

[å°æ˜](https://www.bilibili.com/video/BV1MV41127o1?spm_id_from=333.999.0.0)

###  1.13. <a name='EncodeandDecodeTinyURL'></a>535. Encode and Decode TinyURL

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411e7zp?spm_id_from=333.999.0.0)

###  1.14. <a name='ComplexNumberMultiplicatin'></a>537 Complex Number Multiplicatin

[å°æ˜](https://www.bilibili.com/video/BV1sP4y1p7Px?spm_id_from=333.999.0.0)

###  1.15. <a name='ConvertBSTtoGreaterTree'></a>538 Convert BST to Greater Tree

[å°æ˜](https://www.bilibili.com/video/BV1k541177bt?spm_id_from=333.999.0.0)

###  1.16. <a name='SingleElementinaSortedArray540-'></a>540. Single Element in a Sorted Array 540-æœ‰åºæ•°ç»„ä¸­çš„å•ä¸€å…ƒç´ 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gW411y7N3?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1P64y1F7cd?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Tg4y1B7Va?spm_id_from=333.999.0.0)

```py
def singleNonDuplicate(self, nums: List[int]) -> int:
    for i in range(0, len(nums) - 2, 2):
        if nums[i] != nums[i + 1]:
            return nums[i]
    return nums[-1]

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

def singleNonDuplicate(self, nums: List[int]) -> int:
    lo = 0
    hi = len(nums) - 1   
    while lo < hi:
        mid = lo + (hi - lo) // 2
        halves_are_even = (hi - mid) % 2 == 0
        if nums[mid + 1] == nums[mid]:
            if halves_are_even:
                lo = mid + 2
            else:
                hi = mid - 1
        elif nums[mid - 1] == nums[mid]:
            if halves_are_even:
                hi = mid - 2
            else:
                lo = mid + 1
        else:
            return nums[mid]
    return nums[lo]

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

def singleNonDuplicate(self, nums: List[int]) -> int:
    lo = 0
    hi = len(nums) - 1
    while lo < hi:
        mid = lo + (hi - lo) // 2
        if mid % 2 == 1:
            mid -= 1
        if nums[mid] == nums[mid + 1]:
            lo = mid + 2
        else:
            hi = mid
    return nums[lo]

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

è¿™é¢˜ä¸€çœ‹å°±æ˜¯è€ƒå¼‚æˆ–å˜›ï¼Œæ•°ç»„ç›´æ¥å…¨éƒ¨å–å¼‚æˆ–å°±è¡Œäº†

class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        t = nums[0]
        for i in range(1,len(nums)):
            t ^= nums[i]
        return t

å¼‚æˆ–çš„æ—¶é—´å¤æ‚åº¦ä¸ç¬¦åˆè¦æ±‚å•Š
```

```py
äºŒåˆ†æ³•

class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l, r = 0, len(nums)-1
        while l < r:
            m = l+((r-l) >> 1)
            if m % 2 == 1:
                m -= 1
            if nums[m] == nums[m+1]:
                l = m+2
            else:
                r = m-1
        return nums[l]
```

###  1.17. <a name='Matrix'></a>542. 01 çŸ©é˜µ 01 Matrix 

[å®˜æ–¹](https://www.bilibili.com/video/BV1cZ4y1s727?spm_id_from=333.999.0.0)

###  1.18. <a name='DiameterofBinaryTree'></a>543 Diameter of Binary Tree

[å°æ˜](https://www.bilibili.com/video/BV12K4y1r78T?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1qA411t7LR?spm_id_from=333.999.0.0)

```py
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.ans = 1
        def depth(node):
            # è®¿é—®åˆ°ç©ºèŠ‚ç‚¹äº†ï¼Œè¿”å›0
            if not node:
                return 0
            # å·¦å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦
            L = depth(node.left)
            # å³å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦
            R = depth(node.right)
            # è®¡ç®—d_nodeå³L+R+1 å¹¶æ›´æ–°ans
            self.ans = max(self.ans, L + R + 1)
            # è¿”å›è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦
            return max(L, R) + 1

        depth(root)
        return self.ans - 1

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_len = 0
        def recur_func(root):
            nonlocal max_len
            if not root: return 0
            l_len = recur_func(root.left)
            r_len = recur_func(root.right)
            max_len = max(max_len, l_len + r_len)
            return max(l_len, r_len) + 1  # æ¯æ¬¡è¿”å›å·¦å­æ ‘å’Œå³å­æ ‘ä¸­é•¿åº¦æœ€é•¿çš„è·¯å¾„é•¿åº¦
            # æ— è®ºä»å·¦å­©å­è¿”å›è¿˜æ˜¯å³å­©å­è¿”å›ï¼Œé•¿åº¦éƒ½è¦åŠ 1

        recur_func(root)
        return max_len

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        self.res=0 #å­˜å‚¨æœ€é•¿ç›´å¾„
        def dfs(root:TreeNode):# è®°å½•æ¯ä¸€ä¸ªå­æ ‘çš„æ·±åº¦
            if not root:
                return 0
            l= dfs(root.left)
            r= dfs(root.right)
            self.res=max(self.res,l+r)#å­˜å‚¨å½“å‰èŠ‚ç‚¹ä¸ä¹‹å‰éå†èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„
            return max(l,r)+1 #è¿”å›å½“å‰å­æ ‘çš„æœ€é•¿æ·±åº¦
        dfs(root)
        return self.res
```

```py
æµ‹è¯•ç”¨ä¾‹æ„Ÿè§‰æœ‰ç‚¹é—®é¢˜,ç©ºæ ‘çš„è·¯å¾„å®šä¹‰ä¸º-1æ¯”è¾ƒå¥½

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
            def dfs(root):
                if not root:
                    return -1
                l,r=dfs(root.left),dfs(root.right)
                self.ans=max(self.ans,l+r+2)
                return max(l,r)+1
            self.ans=0
            dfs(root)
            return self.ans

ç±»å±æ€§å˜é‡ç”¨çš„å¦™ï¼
```

###  1.19. <a name='RemoveBoxes'></a>546 Remove Boxes

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11W411Z7jG?spm_id_from=333.999.0.0)

###  1.20. <a name=''></a>547 ã€ğŸ’å¹¶æŸ¥é›† + dfs + é˜Ÿåˆ—ã€‘æœ‹å‹åœˆ

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Ta411F7rk?spm_id_from=333.999.0.0)

[éƒ­éƒ­](https://www.bilibili.com/video/BV1eX4y157jr?from=search&seid=13286624680279107242&spm_id_from=333.337.0.0)

ğŸ’å¹¶æŸ¥é›†

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def find(i: int) -> int:
            if parent[i] != i:
                parent[i] = find(parent[i])
            return parent[i]
        
        def union(i: int, j: int):
            parent[find(i)] = find(j)
        
        proN = len(isConnected)
        parent = list(range(proN))
        
        for i in range(proN):
            for j in range(i + 1, proN):
                if isConnected[i][j] == 1:
                    union(i, j)
        
        res = sum(parent[i] == i for i in range(proN))
        # æ±‚å‡º i å°±æ˜¯ parent çš„æ€»å’Œ
        return res
```

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def dfs(i: int):
            for j in range(proN):
                if isConnected[i][j] == 1 and j not in visited:
                    visited.add(j)
                    dfs(j)
        
        proN = len(isConnected)
        visited = set()
        res = 0

        for i in range(proN):
            if i not in visited:
                dfs(i)
                res += 1
        
        return res
```

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        proN = len(isConnected)
        visited = set()
        res = 0
        
        for i in range(proN):
            if i not in visited:
                peopleQ = collections.deque([i])
                while peopleQ:
                    peo = peopleQ.popleft()
                    visited.add(peo)
                    for fri in range(proN):
                        if isConnected[peo][fri] == 1 and fri not in visited:
                            peopleQ.append(fri)
                res += 1
        
        return res

ä¸ç”¨é€’å½’ï¼Œå¯ä»¥å®ç°åŒ100%ï¼š

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        candidates = set(range(1, len(isConnected)))
        # candidateså°±æ˜¯not visited
        if not candidates:
            return 1
        res = 0
        peopleQ = [0]
        while candidates:
            while peopleQ:
                peo = peopleQ.pop()
                friends = [fri for fri in candidates if isConnected[peo][fri]]
                for i in friends:
                    peopleQ.append(i)
                    candidates.remove(i)
            res += 1
            if candidates:
                peopleQ = [list(candidates)[0]]
        return res
```

```scala


/**
* union & find: implement both union by rank and path compression
* time complexity : 
*   in union & find each op:
*           find: very very close to O(1) amortized
*           union: very very close to O(1) amortized
*   the entire ï¼š
*       O(n + M), n is node size, M is the times we call Union operation which cause O(1) 
*       n (constructor) + M (call union times)
*/

object Solution1 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    unionFind.counter

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)
  var counter = M

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
    counter -= 1
  }
}

/**
* union & find: without counter in union&find to record current cluster
*       O(n + M + n), n is node size, M is the times we call Union operation which cause O(1) 
*       n (construct union & find ) + M (call union times)  + n (n time call findRoot)
*/
object Solution1-2 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    M.indices.map(unionFind.findRoot).distinct.size

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
  }
}


```

###  1.21. <a name='BrickWall'></a>554 Brick Wall

[å°æ˜](https://www.bilibili.com/video/BV1mo4y1f7wc?spm_id_from=333.999.0.0)

###  1.22. <a name='NextGreaterElementIII'></a>556 Next Greater Element III

[å°æ˜](https://www.bilibili.com/video/BV19t4y167yb?spm_id_from=333.999.0.0)

###  1.23. <a name='SubarraySumEqualsKK'></a>560. Subarray Sum Equals K å’Œä¸ºKçš„å­æ•°ç»„

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1XW411d71i?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1d54y127ri?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1vK4y1k7ku?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV13t4y1y7ya?spm_id_from=333.999.0.0)

```py
æ–¹æ³•2 çš„ hashmap åˆå§‹åŒ–ä¸€å¼€å§‹æ²¡æƒ³é€šä¸ºå•¥æ˜¯ {0: 1}ï¼Œå†™æˆä¸‹é¢çš„å½¢å¼æ„Ÿè§‰å°±å¥½ç†è§£äº†

å…¶å®å°±æ˜¯è€ƒè™‘ pre[i] == k çš„è¿™ç§æƒ…å†µ

class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        counter = dict()
        pre, ans = 0, 0
        for num in nums:
            pre += num
            if pre == k:
                ans += 1
            ans += counter.get(pre - k, 0)
            counter[pre] = counter.get(pre, 0) + 1
        return ans
```

```py
å‰åºå’Œä¹Ÿè¶…æ—¶äº†

class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        prefixsum=[0]*(len(nums)+1)
        for i in range(len(nums)):
            prefixsum[i+1] = prefixsum[i] + nums[i]
        count = 0
        for i in range(len(nums)):
            for j in range(i,len(nums)):
                if prefixsum[j+1] - prefixsum[i] == k:
                    count +=1
        return count 

class Solution:
    def subarraySum(self, nums: 'List[int]', k: 'int') -> 'int':
        sum, res, cul = 0, 0, {}
        cul[0] = 1
        for i in range(len(nums)):
            sum += nums[i]
            if sum - k in cul:
                res += cul[sum - k]
            if sum not in cul:
                cul[sum] = 0
            cul[sum] += 1
        return res
```

###  1.24. <a name='BinaryTreeTilt'></a>563 Binary Tree Tilt

[å°æ˜](https://www.bilibili.com/video/BV1KV41117ho?spm_id_from=333.999.0.0)

###  1.25. <a name='ArrayNesting'></a>565 ã€ä¸ºä»€ä¹ˆä¸ç”¨ğŸ’å¹¶æŸ¥é›†ï¼Ÿæˆç¯çš„ğŸŒˆã€‘Array Nesting

[éƒ­éƒ­](https://www.bilibili.com/video/BV11V411e7fv?from=search&seid=16576806175247069118&spm_id_from=333.337.0.0)

```py
class Solution(object):
	def arrayNesting(self, nums):
		r = 0
		for i in xrange(0, len(nums)):
			if nums[i] == -1:
				continue
			usedlist = set({})
			while i not in usedlist:
				usedlist.add(i)
				i = nums[i]
			r = max(r, len(usedlist))
			for i in usedlist:
				nums[i] = -1
		return r
```
é¢˜ç›®ç±»ä¼¼äºæ‰¾æœ€å¤§ç¯çš„é•¿åº¦

å› ä¸ºæ²¡æœ‰é‡å¤å…ƒç´ ï¼Œæ‰€ä»¥æ¯ä¸ªå…ƒç´ éƒ½å±äºä¸€ä¸ªç¯ï¼Œ

æ¯ä¸ªç¯åªè®¡ç®—ä¸€æ¬¡ï¼Œæ¯ä¸ªèµ°è¿‡çš„å…ƒç´ ç½®ä¸º-1ï¼ˆä¹Ÿå¯ä»¥ç½®ä¸ºè´Ÿæ•°ï¼‰ã€‚

ä»å¼€å¤´éå†æ•°ç»„ï¼Œå¦‚æœè¯¥å…ƒç´ ä¸º-1åˆ™è·³è¿‡

æ—¶é—´å¤æ‚åº¦Oï¼ˆnï¼‰ï¼Œç©ºé—´å¤æ‚åº¦Oï¼ˆ1ï¼‰

```py
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums)):
            if nums[i] == -1:
                continue
            temp = 1
            path_index = i
            while nums[path_index] != i:
                nums[path_index], path_index = -1, nums[path_index]
                temp += 1
            nums[path_index] = -1
            res = max(temp, res)
        return res
```

```py
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        # æœ€å¤§ç¯é—®é¢˜
        # ç¯é—®é¢˜ å¿«æŒ‡é’ˆèµ°2æ­¥, æ…¢æŒ‡é’ˆèµ°1æ­¥

        visited = [False]*len(nums) # è®°å½•æ˜¯å¦éå†è¿‡
        def measure_len(i):
            fast = slow = i
            ans = 0
            while True:
                fast = nums[nums[fast]]
                slow = nums[slow]
                visited[fast] = True
                visited[slow] = True
                ans += 1
                if fast == slow:
                    break
            
            return ans

        ans = 0
        for i in nums:
            if not visited[i]: # å¦‚æœæ²¡éå†è¿‡åˆ™è¿›è¡ŒæŸ¥çœ‹ æœ‰ i å…ƒç´ çš„ç¯æœ€å¤§é•¿åº¦
                ans = max(ans, measure_len(i))

        return ans
```


###  1.26. <a name='PermutationinString567-'></a>567. ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘Permutation in String 567-å­—ç¬¦ä¸²çš„æ’åˆ—

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14W411d7g6?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1z54y1C7qB?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV175411E761?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1154y1X7qB?spm_id_from=333.999.0.0)

```py
è§‰å¾—å†™çš„ä¸é”™ï¼ŒPythonçš„èƒ¸å¼Ÿä»¬ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ï¼Œè¿‡äº†å¹´å°±ä¼šæœ‰å¯¹è±¡çš„~

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        '''
        æ€è·¯ï¼šæ€ä¹ˆåˆ¤æ–­s2çš„å­—ä¸²å’Œs1çš„æ’åˆ—ä¹‹ä¸€ç›¸ç­‰ï¼Œå‡å¦‚æ’åºçš„è¯ï¼Œéå†s2çš„åŒæ—¶ï¼Œæ¯æ¬¡éƒ½æ’åºï¼Œæ€»çš„æ—¶é—´å¤æ‚åº¦å¤ªé«˜äº†ã€‚
        å› æ­¤ï¼Œæˆ‘ä»¬é‡‡ç”¨ä¸€ä¸ªæœ‰åºå­—å…¸æ¥æ¯”è¾ƒï¼Œç”±äºåªåŒ…å«å°å†™å­—æ¯ï¼Œæˆ‘ä»¬é‡‡ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿæœ‰åºå­—å…¸ï¼Œ
        è¿™æ ·åˆ¤æ–­s2çš„å­ä¸²å’Œs1çš„æ’åˆ—ä¹‹ä¸€ç›¸ç­‰å°±å¾ˆå®¹æ˜“äº†ã€‚æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n),nä¸ºs2çš„é•¿åº¦ã€‚
        ç©ºé—´å¤æ‚åº¦ä¸º:O(26)*2 == O(1) 

        '''
        m1 = len(s1)
        m2 = len(s2)
        if m1 > m2:
            return False
        dic1 = [0]*26
        dic2 = [0]*26
        for i in range(m1):
            dic1[ord(s1[i])-ord('a')] += 1
            dic2[ord(s2[i])-ord('a')] += 1
        if dic1 == dic2:
            return True

        for i in range(m1,m2):
            dic2[ord(s2[i-m1])-ord('a')] -= 1
            dic2[ord(s2[i])-ord('a')] += 1
            if dic1 == dic2:
                return True
        return False
æ–¹æ³•1ï¼šå…¶å®å°±æ˜¯æ»‘åŠ¨çª—å£å“ˆå¸Œè¡¨ï¼ˆæ›´æ–°è¾¹ç•Œæ³•ï¼‰ï¼Œå¯¹åº”ä¸Šé¢çš„æ–¹æ³•äº”
class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        l1, l2 = len(s1), len(s2)
        c1 = collections.Counter(s1) #s1çš„å“ˆå¸Œè¡¨ï¼Œå®è´¨æ˜¯å­—å…¸
        c2 = collections.Counter() #å®ä¾‹åŒ–ä¸€ä¸ªcounterç±»
        p = q = 0  #è®¾å®šä¸‹æ ‡åˆå§‹åŒ–ä¸º0ï¼Œæ»‘åŠ¨çª—å£å°±æ˜¯[p,q]
        #ä¸‹é¢å°±æ˜¯ä¸æ–­åœ¨s2ä¸Šé¢è¿›è¡Œæ»‘åŠ¨çª—å£ï¼Œä¸æ–­æ›´æ–°å“ˆå¸Œè¡¨è¿›è¡Œæ¯”è¾ƒï¼Œè¿™æ˜¯é‡‡ç”¨çš„è¾¹ç•Œæ›´æ–°æ³•å“¦ï¼Œå› æ­¤æ˜¯æ–¹æ³•äº”ï¼Œè€Œä¸æ˜¯æ–¹æ³•ä¸‰
        #è¿™é‡Œè¡¥å……ä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆæ»‘åŠ¨çª—å£ç”¨whileæ²¡ç”¨forï¼Œå…¶å®éƒ½æ˜¯ä¸€æ ·çš„ï¼Œä½ ä¹Ÿå¯ä»¥æ”¹æˆfor
        #ä½†æ˜¯å¯¹äºæœ‰äº›æƒ…å†µï¼Œå°±åªèƒ½ç”¨whileï¼Œæ¯”å¦‚åœ¨å›æº¯ç®—æ³•é‡Œé¢ï¼Œå³å¾ªç¯å˜é‡éœ€è¦é¢‘ç¹çš„åŠ å‡ï¼Œæ˜¾ç„¶æ­¤é¢˜å¹¶ä¸æ˜¯
        #å› æ­¤å¯¹äºæ­¤é¢˜ï¼Œç”¨forä¹Ÿå¯ä»¥ï¼Œæ•´ä½“æ¥è¯´whileçš„åº”ç”¨åœºåˆæ›´åŠ å¹¿æ³›
        while q < l2:
            c2[s2[q]] += 1   #ç»Ÿè®¡å­—å…¸å“ˆå¸Œè¡¨
            if c1 == c2:
                return True  #æ³¨æ„ï¼Œè¿™ç§ç»“æœæ€§æ¡ä»¶åˆ¤æ–­ä¸€å®šæ˜¯å†™åœ¨å‰é¢
            q += 1           #s2æ»‘åŠ¨çª—å£ï¼Œä¸‹æ ‡åç§»
            if q - p + 1 > l1:   #ä¸ºä»€ä¹ˆæœ‰è¿™ä¸ªå‘¢ï¼Ÿå› ä¸ºç¬¬ä¸€ä¸ªæ»‘åŠ¨çª—å£æ¯”è¾ƒç‰¹æ®Šï¼Œè¦å…ˆæ„é€ ç¬¬ä¸€ä¸ªå®Œæ•´çš„æ»‘åŠ¨çª—å£ï¼Œåé¢æ‰æ˜¯æ›´æ–°è¾¹ç•Œ
                c2[s2[p]] -= 1   #å­—å…¸å“ˆå¸Œè¡¨ç§»é™¤æœ€å‰é¢çš„å­—ç¬¦
                if c2[s2[p]] == 0:  #ç”±äºcounterç‰¹æ€§ï¼Œå¦‚æœvalueä¸º0ï¼Œå°±åˆ é™¤å®ƒ
                #å¦åˆ™ä¼šå‡ºç°s1çš„mapæ²¡æœ‰aï¼Œä½†æ˜¯s2çš„mapçš„aä¸º0ï¼Œæ­¤æ—¶æ˜¯æˆç«‹çš„ï¼Œä½†æ˜¯å¯¼è‡´äº†è¿™ä¸¤ä¸ªmapä¸ç›¸ç­‰ï¼Œç»“æœå‡ºé”™
                    del c2[s2[p]]
                p += 1     #æœ€å‰é¢çš„ä¸‹æ ‡å³ç§»åŠ¨
        return False  #éå†æ‰€æœ‰æ»‘åŠ¨çª—å£è¿‡åï¼Œä»ç„¶æ²¡è¿”å›trueï¼Œé‚£å°±æ˜¯ä¸åˆé¢˜æ„
        
æ–¹æ³•2ï¼šä¼˜åŒ–çš„æ»‘åŠ¨çª—å£ï¼ˆå˜é‡ç»Ÿè®¡æ³•ï¼‰ï¼Œå…¶å®å°±æ˜¯ä¸Šé¢çš„æ–¹æ³•å…­
class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        l1, l2 = len(s1), len(s2)
        c1 = collections.Counter(s1)
        c2 = collections.Counter()
        cnt = 0 #ç»Ÿè®¡å˜é‡ï¼Œå…¨éƒ¨26ä¸ªå­—ç¬¦ï¼Œé¢‘ç‡ç›¸åŒçš„ä¸ªæ•°ï¼Œå½“cnt==s1å­—æ¯çš„ä¸ªæ•°çš„æ—¶å€™ï¼Œå°±æ˜¯å…¨éƒ¨ç¬¦åˆé¢˜æ„ï¼Œè¿”å›çœŸ
        p = q = 0 #æ»‘åŠ¨çª—å£[p,q]
        while q < l2:
            c2[s2[q]] += 1
            if c1[s2[q]] == c2[s2[q]]: #å¯¹äºéå†åˆ°çš„å­—æ¯ï¼Œå¦‚æœå‡ºç°æ¬¡æ•°ç›¸åŒ
                cnt += 1               #ç»Ÿè®¡å˜é‡+1
            if cnt == len(c1):         #åˆ¤æ–­ç»“æœå†™åœ¨å‰é¢ï¼Œæ­¤æ—¶è¯æ˜s2æ»‘åŠ¨çª—å£å’Œs1å…¨éƒ¨å­—ç¬¦ç›¸åŒï¼Œè¿”å›çœŸ
                return True
            q += 1                     #æ»‘åŠ¨çª—å£å³ç§»
            if q - p + 1 > l1:         #è¿™æ˜¯æ„é€ ç¬¬ä¸€ä¸ªæ»‘åŠ¨çª—å£çš„ç‰¹æ®Šåˆ¤æ–­ï¼Œé‡Œé¢å†…å®¹æ˜¯ç»´æŠ¤è¾¹ç•Œæ»‘åŠ¨çª—å£
                if c1[s2[p]] == c2[s2[p]]:    #åˆ¤æ–­æ€§çš„ifå†™åœ¨å‰é¢ï¼Œå› ä¸ºä¸€æ—¦é¢‘ç‡å˜åŒ–ï¼Œè¿™ä¸ªç»Ÿè®¡å˜é‡å°±å‡1
                    cnt -= 1
                c2[s2[p]] -= 1                #å­—å…¸å“ˆå¸Œè¡¨ç§»é™¤æœ€å‰é¢çš„å­—ç¬¦
                if c2[s2[p]] == 0:            #ç”±äºcounterç‰¹æ€§ï¼Œå¦‚æœvalueä¸º0ï¼Œå¿…é¡»åˆ é™¤å®ƒ
                    del c2[s2[p]]
                p += 1                        #æœ€å‰é¢çš„ä¸‹æ ‡å³ç§»åŠ¨
        return False

class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        l1, l2 = len(s1), len(s2)
        c1 = collections.Counter(s1)
        c2 = collections.Counter()
        cnt = 0 #ç»Ÿè®¡å˜é‡ï¼Œå…¨éƒ¨26ä¸ªå­—ç¬¦ï¼Œé¢‘ç‡ç›¸åŒçš„ä¸ªæ•°ï¼Œå½“cnt==s1å­—æ¯çš„ä¸ªæ•°çš„æ—¶å€™ï¼Œå°±æ˜¯å…¨éƒ¨ç¬¦åˆé¢˜æ„ï¼Œè¿”å›çœŸ
        p = q = 0 #æ»‘åŠ¨çª—å£[p,q]
        while q < l2:
            c2[s2[q]] += 1
            if c1[s2[q]] == c2[s2[q]]: #å¯¹äºéå†åˆ°çš„å­—æ¯ï¼Œå¦‚æœå‡ºç°æ¬¡æ•°ç›¸åŒ
                cnt += 1               #ç»Ÿè®¡å˜é‡+1
            if cnt == len(c1):         #åˆ¤æ–­ç»“æœå†™åœ¨å‰é¢ï¼Œæ­¤æ—¶è¯æ˜s2æ»‘åŠ¨çª—å£å’Œs1å…¨éƒ¨å­—ç¬¦ç›¸åŒï¼Œè¿”å›çœŸ
                return True
            q += 1                     #æ»‘åŠ¨çª—å£å³ç§»
            if q - p + 1 > l1:         #è¿™æ˜¯æ„é€ ç¬¬ä¸€ä¸ªæ»‘åŠ¨çª—å£çš„ç‰¹æ®Šåˆ¤æ–­ï¼Œé‡Œé¢å†…å®¹æ˜¯ç»´æŠ¤è¾¹ç•Œæ»‘åŠ¨çª—å£
                if c1[s2[p]] == c2[s2[p]]:    #åˆ¤æ–­æ€§çš„ifå†™åœ¨å‰é¢ï¼Œå› ä¸ºä¸€æ—¦é¢‘ç‡å˜åŒ–ï¼Œè¿™ä¸ªç»Ÿè®¡å˜é‡å°±å‡1
                    cnt -= 1
                c2[s2[p]] -= 1                #å­—å…¸å“ˆå¸Œè¡¨ç§»é™¤æœ€å‰é¢çš„å­—ç¬¦
                if c2[s2[p]] == 0:            #ç”±äºcounterç‰¹æ€§ï¼Œå¦‚æœvalueä¸º0ï¼Œå¿…é¡»åˆ é™¤å®ƒ
                    del c2[s2[p]]
                p += 1                        #æœ€å‰é¢çš„ä¸‹æ ‡å³ç§»åŠ¨
        return False


```

```py

Python 92% é…æ³¨é‡Šã€‚

æ€è·¯ä¸ºç»´æŠ¤ä¸€ä¸ªçª—å£ï¼Œç”¨mp2å­˜æ”¾çª—å£å†…å…ƒç´ å‡ºç°çš„æ¬¡æ•°ã€‚å½“mp2 == mp1ï¼Œè¿”å›Trueï¼›å¦åˆ™ï¼Œè¿”å›Falseã€‚

æ—¶é—´å¤æ‚åº¦ï¼šO(n)

ç©ºé—´å¤æ‚åº¦ï¼šO(2 * 26)æ¸è¿›ä¸ºO(1)ï¼Œ2 * æ˜¯å› ä¸ºä¸¤ä¸ªå­—å…¸ã€‚26æ˜¯å› ä¸ºæœ€å¤š26ä¸ªå­—æ¯ã€‚

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        n = len(s2)
        mp1 = collections.Counter(s1)
        mp2 = collections.defaultdict(int)
        l = 0 # å·¦çª—
        for r in range(n):
            ele = s2[r]
            if ele not in mp1: # å½“ræŒ‡å‘å…ƒç´ ä¸åœ¨mp1é‡Œæ—¶ï¼Œå°†mp2æ¸…ç©ºï¼Œé‡æ–°ä¸‹ä¸€è½®è®°æ•°ã€‚
                l = r + 1
                mp2 = collections.defaultdict(int) 
            else: # å¦‚æœræŒ‡å‘å…ƒç´ åœ¨mp1é‡Œï¼Œæ£€æŸ¥æŒ‡å‘å…ƒç´ é¢‘ç‡æ˜¯å¦å¤§äºmp1å†…å¯¹åº”å…ƒç´ ã€‚å¦‚æœæ˜¯ï¼Œä¸€ç›´ç§»åŠ¨çª—å£å·¦ä¾§ã€‚
                mp2[ele] += 1
                while mp2[ele] > mp1[ele]:
                    mp2[s2[l]] -= 1
                    l += 1
                if mp2 == mp1: return True
        return False
```

```scala


/**
* my first commitment: sliding window: hashcode with build-in sliding method
*/
object Solution1 {
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1Length = s1.length
      val s1Hash = s1.groupBy(identity).mapValues(_.length).toMap.hashCode

      s2.sliding(s1Length).exists(seq => seq.groupBy(identity).mapValues(_.length).toMap.hashCode == s1Hash)
    }
}


/**
* optimize from 1-1 : maintain sliding window and hashmap by my self
* time complexity: O(s1.length + s2.length)
* space complexity: O(s1.distinct.length)
*/
object Solution1-2 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1HashCode = s1.groupBy(identity).mapValues(_.length).toMap.hashCode
      val s2Map = mutable.Map.empty[Char, Int]
      
      (0 until s2.length).exists {
        case idx if idx < s1.length =>
          val char = s2(idx)
          mapIncrement(s2Map, char)
          s2Map.hashCode == s1HashCode
        case idx => 
          val rightChar = s2(idx)
          val leftChar = s2(idx - s1.length)
          mapIncrement(s2Map, rightChar)
          mapDecrement(s2Map, leftChar) 
          s2Map.hashCode == s1HashCode
      }
    }
    def mapIncrement(map: mutable.Map[Char, Int], char: Char): Unit = {
      map.get(char) match {
            case Some(v) => map.update(char, v + 1)
            case None => map.update(char, 1)
      }
    }
    def mapDecrement(map: mutable.Map[Char, Int], char: Char) = map.get(char) match {
      case Some(v) if v == 1 => map.remove(char)
      case Some(v) => map.update(char, v - 1)
      case None =>
    }
}

/**
* sliding windows: using only 1 map to record differential
* 1. if diff map is empty, s2 contains the permutation of s1
* 2. initial map with foreach instead of groupBy witch is time consuming
* time complexity (l1 + l2)
*/
object Solution1-3 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val diffMap = mutable.Map.empty[Char, Int]
      s1.foreach(mapUpdate(diffMap, _, 1))
      
      (0 until s2.length).exists {case idx =>
        if (idx >= s1.length) {
          val leftChar = s2(idx - s1.length)
          mapUpdate(diffMap, leftChar, 1)
        }
        val rightChar = s2(idx)
        mapUpdate(diffMap, rightChar, -1)
        diffMap.isEmpty
      }
    }
    def mapUpdate(map: mutable.Map[Char, Int], char: Char, value: Int): Unit = {
      map.get(char) match {
            case Some(v) if v + value == 0 => map.remove(char)
            case Some(v) => map.update(char, v + value)
            case None => map.update(char, value)
      }
    }
}
```

###  1.27. <a name='-1'></a>572-å¦ä¸€ä¸ªæ ‘çš„å­æ ‘

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1cA411t7zD?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1wt4y197aB?spm_id_from=333.999.0.0)

```py
è¿™é¢˜ä¸å¯èƒ½æ˜¯ç®€å•é¢˜

class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        def dfs(A,B): # å‡½æ•°çš„åŠŸèƒ½è¦æ˜ç¡®ï¼Œç”¨æ¥åˆ¤æ–­å½“å‰å­æ ‘æ˜¯å¦ä¸€è‡´
            if not B and not A: # å¦‚æœåŒæ—¶ä¸ºç©ºï¼Œåˆ™å­æ ‘ä¸€è‡´
                return True
            if not A and B: # ä¸€ä¸ªä¸ºç©ºï¼Œå¦ä¸€ä¸ªä¸ä¸ºç©ºï¼Œåˆ™å­æ ‘ä¸ä¸€è‡´
                return False
            if not B and A:
                return False
            if A.val != B.val: # å¦‚æœå½“å‰èŠ‚ç‚¹çš„å€¼ä¸ç›¸ç­‰ï¼Œæ˜¾ç„¶ä¸ä¸€è‡´
                return False
            return dfs(A.left, B.left) and dfs(A.right, B.right) # é€’å½’å»å¯¹ç…§ä¸¤ä¸ªå­æ ‘çš„å·¦å­æ ‘å’Œå³å­æ ‘
        
        if not root or not subRoot:
            return False
        if root.val == subRoot.val:
            if dfs(root, subRoot):
                return True
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
```

```py
python

class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        if not root or not subRoot: return False
        l = self.isSubtree(root.left, subRoot)
        r = self.isSubtree(root.right, subRoot)    
        def equal(root1, root2):
            if not root1 and not root2: return True
            elif not root1 or not root2: return False
            elif root1.val != root2.val: return False
            else: return equal(root1.left, root2.left) and equal(root1.right, root2.right)
        return equal(root, subRoot) or l or r
å­¦ä¹ ä¸€ä¸‹é€Ÿåº¦æœ€å¿«é‚£å‡ ç§æ–¹æ³•ä¹‹ä¸€:åºåˆ—åŒ–ï¼ˆå…ƒç»„åŒ–ï¼‰+å­—ç¬¦ä¸²æ¯”è¾ƒ-----æ‰“è´¥96%

class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        def toTup(t):#è¿™ä¸ªå‡½æ•°æŠŠæ ‘åºåˆ—åŒ–ä¸ºä¸€ä¸ªå…ƒç»„
            return (t.val,toTup(t.left),toTup(t.right)) if t else None
        return str(toTup(t)) in str(toTup(s))#æŠŠå…ƒç»„è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ä»¥æ–¹ä¾¿æ¯”è¾ƒ
```

###  1.28. <a name='DistributeCandies'></a>575 Distribute Candies

[å°æ˜](https://www.bilibili.com/video/BV11i4y1T7Pr?spm_id_from=333.999.0.0)

###  1.29. <a name='OutofBoundaryPaths'></a>576. Out of Boundary Paths

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV18W411d7Cf?spm_id_from=333.999.0.0)

###  1.30. <a name='ShortestUnsortedContinuousSuba'></a>581 Shortest Unsorted Continuous Suba

[å°æ˜](https://www.bilibili.com/video/BV1Y54y1h7Xa?spm_id_from=333.999.0.0)

###  1.31. <a name='N-aryTreePreorderTraversal'></a>589 N-ary Tree Preorder Traversal

[å°æ˜](https://www.bilibili.com/video/BV1io4y1f7qT?spm_id_from=333.999.0.0)

###  1.32. <a name='ValidSquare'></a>593 Valid Square

[å°æ˜](https://www.bilibili.com/video/BV1j5411V73U?spm_id_from=333.999.0.0)

###  1.33. <a name='LongestHarmoniousSubsequence'></a>594 Longest Harmonious Subsequence

[å°æ˜](https://www.bilibili.com/video/BV1Pp4y1p7ss?spm_id_from=333.999.0.0)

###  1.34. <a name='CanPlaceFlowers'></a>605 Can Place Flowers

[å°æ˜](https://www.bilibili.com/video/BV1Uz4y1k7xU?spm_id_from=333.999.0.0)

###  1.35. <a name='-1'></a>611

```py
# åŒæŒ‡é’ˆ

class Solution:
    # åŒæŒ‡é’ˆ
    def triangleNumber(self, nums):
        nums.sort()
        n = len(nums)
        count = 0
        for c in range(2, n):
            a, b = 0, c-1
            while a < b:
                if nums[a] + nums[b] <= nums[c]:
                    a += 1
                else:
                    count += b - a 
                    b -= 1
        return count

class Solution(object):
    def triangleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)[::-1]
        res = 0
        for i in range(len(nums)-2):
            j, k = i + 1, len(nums) - 1
            while j < k:
                if nums[k] + nums[j] > nums[i]:
                    res += k - j
                    j += 1                
                else:
                    k -= 1
        return res

class Solution:
    def triangleNumber(self, nums):
        nums.sort()
        res = 0
        # ä»å¤§åˆ°å°éå†
        for i in range(len(nums) - 1, 1, -1):
            l, r = 0, i -1
            while l < r:
                # åªè¦è¾ƒå°çš„ä¸¤ä¸ªå€¼ä¹‹å’Œå¤§äºæœ€å¤§çš„å€¼ï¼Œåˆ™ä¸€å®šå¯ç»„æˆä¸‰è§’å½¢
                if nums[l] + nums[r] > nums[i]:
                    #i, r å’Œä»låˆ°r-1éƒ½å¯ç»„æˆä¸‰è§’å½¢ï¼Œä¸ªæ•°ä¸º (r-1) - l + 1 = r - l
                    res += (r-1) - l + 1
                    r -= 1
                else: l += 1
        return res

class Solution:
    def triangleNumber(self, nums):
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n):
            k = i
            for j in range(i + 1, n):
                while k + 1 < n and nums[k + 1] < nums[i] + nums[j]:
                    k += 1
                ans += max(k - j, 0)
        return ans

class Solution:
    def triangleNumber(self, nums):
        nums.sort()
        res = 0
        for k in range(len(nums)):
            i, j = 0, k - 1
            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    res += j - i
                    j -= 1
                else:
                    i += 1
        return res
```

###  1.36. <a name='TaskScheduler'></a>621. Task Scheduler

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Wt411Y7Y9?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1LZ4y1M7Bg?spm_id_from=333.999.0.0)

```py
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = collections.Counter(tasks)

        # ä»»åŠ¡æ€»æ•°
        m = len(freq)
        nextValid = [1] * m
        rest = list(freq.values())

        time = 0
        for i in range(len(tasks)):
            time += 1
            minNextValid = min(nextValid[j] for j in range(m) if rest[j] > 0)
            time = max(time, minNextValid)
            
            best = -1
            for j in range(m):
                if rest[j] and nextValid[j] <= time:
                    if best == -1 or rest[j] > rest[best]:
                        best = j
            
            nextValid[best] = time + n + 1
            rest[best] -= 1

        return time

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = collections.Counter(tasks)

        # æœ€å¤šçš„æ‰§è¡Œæ¬¡æ•°
        maxExec = max(freq.values())
        # å…·æœ‰æœ€å¤šæ‰§è¡Œæ¬¡æ•°çš„ä»»åŠ¡æ•°é‡
        maxCount = sum(1 for v in freq.values() if v == maxExec)

        return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

æœ€å®¹æ˜“æƒ³æ˜ç™½çš„æ–¹æ³•ï¼Œæ¯æ¬¡éƒ½ç»Ÿè®¡æ‰€æœ‰ä»»åŠ¡çš„æ•°é‡ç„¶åé™åºæ’åºï¼Œæ¯æ¬¡å¾ªç¯åˆ·n+1ä¸ªä»»åŠ¡ï¼Œå³ç›¸åº”æ•°ç»„ä½ç½®-1ã€‚å†æ’åºï¼Œå†åˆ·ã€‚ç›´åˆ°ç¬¬ä¸€ä¸ªä½ç½®å˜æˆ1å°±ä¸è¿™ä¹ˆæ“ä½œã€‚åŠ ä¸Šå‰©ä¸‹ä¸º1çš„ä½ç½®æ•°ç›®å°±å¤§åŠŸå‘Šæˆ

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        if n==0:
            return(len(tasks))
        timee = 0
        appearence = sorted(collections.Counter(tasks).values(), reverse=True)
        while appearence[0]>1:
            for i in range(n+1):
                if i < len(appearence):
                    appearence[i] = appearence[i]-1
            appearence = sorted(appearence,reverse = True)
            timee = timee+n+1
        print(appearence)
        last = collections.Counter(appearence)[1]
        return(timee+last)
        
å¦™ï¼è™½ç„¶æ¡¶æ€æƒ³å®¹æ˜“ç†è§£ä¸”ä»£ç å¾ˆç®€æ´ï¼Œä½†äº‹å…ˆä¸å®¹æ˜“æƒ³åˆ°ï¼Œ

è¿™ç§æ’åºæ€æƒ³æ˜¯å¾ˆå®¹æ˜“æƒ³åˆ°çš„ï¼Œä½†æ˜¯æ’åºæ€æƒ³ç¼–ç ä¸å¤ªå®¹æ˜“ï¼Œæ¥¼ä¸»ä»£ç å†™çš„å¾ˆç²¾å¦™ç®€æ´ï¼Œ

å„ç§æƒ…å†µéƒ½åŒ…å«åœ¨ä»£ç é‡Œäº†ï¼Œç‰›é€¼ï¼æ‰¾ä¸åˆ°ä¸€å¥åºŸè¯ï¼Œ

å”¯ä¸€å¯ä»¥ä¿®æ”¹çš„åœ°æ–¹æ˜¯last= appearence.count(1)ğŸ˜
```

```py
è¿˜æ˜¯ç¦»ä¸å¼€Counterã€‚ç®€å•è§£é‡Šä¸€ä¸‹ï¼šå–æ¬¡æ•°æœ€å¤šçš„å­—æ¯ï¼Œä¸¤ä¸¤ä¹‹é—´åŠ ä¸Šnä¸ªé—´éš”ã€‚

ä½†æ˜¯ï¼Œå¦‚æœæœ‰æ¬¡æ•°ä¸€æ ·å¤šçš„ï¼Œè¿˜éœ€è¦åŠ 1ï¼ŒåŠ 1ä¸è¶…è¿‡næ¬¡ã€‚å†è·Ÿä»»åŠ¡çš„æ€»é•¿åº¦æ¯”è¾ƒï¼Œå–å¤§çš„å€¼å°±å¯ä»¥äº†ã€‚

from collections import Counter
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        l = len(tasks)
        if n == 0:
            return l
        c = Counter(tasks)
        m = c.most_common()
        ret = m[0][1] * (n + 1) - n
        for i in range(1, min(len(m), n)):
            if m[i][1] < m[0][1]:
                break
            ret += 1
        return max(ret, l)
```

###  1.37. <a name='DesignCircularQueue'></a>622 Design Circular Queue

[å°æ˜](https://www.bilibili.com/video/BV1kV411n7Uk?spm_id_from=333.999.0.0)

###  1.38. <a name='AddOneRowtoTree'></a>623 Add One Row to Tree

[å°æ˜](https://www.bilibili.com/video/BV1AK4y1U7ud?spm_id_from=333.999.0.0)

###  1.39. <a name='SumofSquareNumbers'></a>633-Sum of Square Numbers

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1a7411h7on?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Qh411i7Yh?spm_id_from=333.999.0.0)

```py
åˆæ˜¯Pythonä¸æ‹¥æœ‰å§“åçš„ä¸€å¤©

class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        if not c:
            return True
        # (a - b) ^ 2 + (a + b) ^ 2 = 2 (a ^ 2 + b ^ 2) = 2 * c
        while c % 2 == 0:
            c //= 2
        # è´¹é©¬å¹³æ–¹å’Œå®šç†
        if c % 4 == 3:
            return False
        sqrt = int(math.sqrt(c))
        for i in range(3, sqrt + 1, 4):
            count = 0
            while c % i == 0:
                c //= i
                count += 1
            if count % 2 != 0:
                return False
        return True
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        # åŒæŒ‡é’ˆè§£æ³•
        i, j = 0, int(math.sqrt(c))
        while i <= j:
            res = i * i + j * j
            if res == c:
                return True
            elif res < c:
                i += 1
            else:
                j -= 1
        return False
```

```py
åŒæŒ‡é’ˆ

i ä» 0 å¼€å§‹
j ä»å¯å–çš„æœ€å¤§æ•° int(math.sqrt(c)) å¼€å§‹
total = i * i + j * j
total > c: j = j - 1ï¼Œå°† total å€¼å‡å°
total < c: i = i + 1ï¼Œå°† total å€¼å¢å¤§
total == cï¼šè¿”å› True
import math

class Solution(object):
    def judgeSquareSum(self, c):
        """
        :type c: int
        :rtype: bool
        """
        j = int(math.sqrt(c))
        i = 0
        while i <= j:
            total = i * i + j * j
            if total > c:
                j = j - 1
            elif total < c:
                i = i + 1
            else:
                return True
        return False
æœ€å¤§å€¼åº”è¯¥æ˜¯Math.sqrt(c/2)
æœ€å¤§å€¼å°±æ˜¯Math.sqrt(c)ï¼Œc = a^2 + b^2ï¼Œåœ¨b=0çš„æ—¶å€™ï¼Œaå°±æ˜¯Math.sqrt(c)ï¼Œå–Math.sqrt(c/2)ä¼šå‡ºé”™ã€‚
```

###  1.40. <a name='ExclusiveTimeofFunctions'></a>636. Exclusive Time of Functions

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1PW411o7Bh?spm_id_from=333.999.0.0)

###  1.41. <a name='AverageofLevelsinBinaryTree'></a>637 Average of Levels in Binary Tree

[å°æ˜](https://www.bilibili.com/video/BV1eb4y1976M?spm_id_from=333.999.0.0)

###  1.42. <a name='DecodeWaysII'></a>639. Decode Ways II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1YW411r75q?spm_id_from=333.999.0.0)

###  1.43. <a name='MaximumAverageSubarrayI'></a>643. Maximum Average Subarray I

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1dV411k7i6?spm_id_from=333.999.0.0)

###  1.44. <a name='-1'></a>645-é”™è¯¯çš„é›†åˆ

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1az411e7zU?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Pf4y1479j?spm_id_from=333.999.0.0)

```py
æ•°å­¦è§£é¢˜

class Solution:
    def findErrorNums(self, nums):
        ln, total = len(nums), sum(set(nums))
        return [sum(nums) - total, (1 + ln) * ln // 2 - total]
å¾ªç¯æ•°ç»„è§£é¢˜

class Solution:
    def findErrorNums(self, nums):
        ln = len(nums)
        repeat = lose = -1
        nums.sort()
        if nums[0] != 1:
            lose = 1
        elif nums[-1] != ln:
            lose = ln
        for i in range(1, ln):
            if nums[i] == nums[i - 1]:
                repeat = nums[i]
            if nums[i] - nums[i - 1] == 2:
                lose = nums[i] - 1
        return [repeat, lose]
å“ˆå¸Œè¡¨è§£é¢˜

from collections import Counter

class Solution:
    def findErrorNums(self, nums):
        ln = len(nums)
        dic = Counter(nums)
        repeat = lose = -1
        for i in range(1, ln + 1):
            tmp = dic.get(i, 0)
            if tmp == 0:
                lose = i
            elif tmp == 2:
                repeat = i
        return [repeat, lose]
```

```py
åœ¨è‹±æ–‡ç«™æŠ„çš„ï¼Œå¾ˆæœ‰æ„æ€

å°†1ï¼Œnçš„boolåˆå§‹ä¸ºNone

å‡ºç°ä¸€æ¬¡ï¼Œå˜åŒ–ä¸ºTrue

å‡ºç°ä¸¤æ¬¡ï¼Œå˜åŒ–ä¸ºFalse

å‡ºç°é›¶æ¬¡ï¼Œä»ä¸ºNone

ç¬¬ä¸€ä¸ª['']æ˜¯å«äº†ä¸€ä¸ªï¼Œå› ä¸ºä¸æ˜¯ä»é›¶å¼€å§‹çš„

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        flag = [''] + [None] * len(nums)
        for each in nums:
            flag[each] = not flag[each]
        return [flag.index(False),flag.index(None)]



æ•°å­¦æ–¹æ³•ï¼Œæ±‚1+2...+Nçš„å’Œï¼Œnumså”¯ä¸€set()çš„å’Œï¼Œå’Œnumsçš„å’Œå¯¹åº”åšå‡æ³•ç›´æ¥å¾—åˆ°ç»“æœ

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        S = sum(set(nums))
        return [sum(nums)-S ,len(nums)*(len(nums)+1)//2-S]
        # len(nums)*(len(nums)+1)//2è¡¨ç¤º1+2+...+n = n*(n+1)/2, å‡å» é™¤äº†ä¸¢å¤±æ•°çš„å’Œå°±æ˜¯ç¬¬äºŒä¸ªç»“æœ
è¿™é¢˜ç»™æˆ‘æ•´æŠ‘éƒäº†ã€‚ã€‚ã€‚ã€‚æ­»ç£•éå†çš„æ–¹æ³•ä¸å¤ªè¡Œã€‚ã€‚ã€‚

é‚£å°±ç›´æ¥æ— è„‘ç®—å§ï¼š

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        dup = sum(nums) - sum(set(nums))
        err = abs(sum(range(len(nums)+1)) - (sum(nums) - dup))
        return [dup, err]
```

###  1.45. <a name='-1'></a>646-ã€åŠ¨æ€ğŸš€è§„åˆ’ + è´ªå¿ƒğŸ§¡ã€‘æœ€é•¿æ•°å¯¹é“¾

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1rz411q7pZ?spm_id_from=333.999.0.0)

python3 è´ªå¿ƒï¼ˆæŒ‰ç…§å³ç«¯ç‚¹æ’åºï¼‰ï¼ˆé€Ÿåº¦betterï¼‰

```py
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs.sort(key=lambda x: x[1])
        count = 0
        end = -float('inf')
        for i, p in enumerate(pairs):
            # print(p[0],end)
            # æ˜“é”™ç‚¹ï¼šé¢˜ç›®å®¹æ˜“ç†è§£é”™è¯¯
            # å½“ä¸”ä»…å½“ b < c æ—¶ï¼Œæ•°å¯¹(c, d) æ‰å¯ä»¥è·Ÿåœ¨ (a, b) åé¢ã€‚
            if p[0] > end:
                count += 1
                end = p[1]
                # print('new end:',end)
        return count 
```

åŠ¨æ€è§„åˆ’ï¼ˆæŒ‰ç…§å·¦ç«¯ç‚¹æ’åºï¼‰

```py
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs = sorted(pairs, key=lambda x:x[0])
        dp = [1] * len(pairs)
        for cur in range(1, len(pairs)):
            for pre in range(cur):
                dp[cur] = max(dp[cur], dp[pre] + 1 if pairs[cur][0] > pairs[pre][1] else dp[pre])
        return dp[-1]

class Solution:
    def findLongestChain(self, pairs):
        pairs.sort(key=lambda x:x[0])
        dp = []
        for cur in range(len(pairs)):
            dp.append(1)
            for pre in range(cur):
                if pairs[cur][0] > pairs[pre][1]:
                    dp[cur] = max(dp[cur], dp[pre] + 1)
        return dp[-1]
```



###  1.46. <a name='PalindromicSubstrings'></a>647 ã€åŠ¨æ€ğŸš€è§„åˆ’ + ä¸­å¿ƒæ‹“å±•ã€‘Palindromic Substrings

[å°æ˜](https://www.bilibili.com/video/BV1g54y1h7uv?spm_id_from=333.999.0.0)

```py
class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        res = 0
        # è¿™ä¸ªéƒ¨åˆ†å…¶å®å¯ä»¥ä¸å†™ï¼š
        # for i in range(n):
        #     dp[i][i]=1
        for i in range(n):
            for j in range(i, -1, -1):
                if s[i] == s[j] and (i - j <= 1 or dp[i - 1][j + 1]):
                    dp[i][j] = 1
                    res += 1
        return res



class Solution(object):
    def countSubstrings(self, s):
        '''
        åŒæŒ‡é’ˆå¤ªæš´åŠ›äº†å§
        '''
        cnt = 0
        for i in range(0,len(s)):
            for j in range(i+1,len(s)+1):
                if s[i:j] == s[i:j][::-1]:
                    cnt += 1
        return cnt
```

```py
# Python3ä¸­å¿ƒæ‰©å±•æ³•éå¸¸ç®€æ´ä»£ç 
# ç›´æ¥åˆ©ç”¨ä¸­å¿ƒæ‰©å±•æ³•, ä¾æ¬¡è®¡æ•°æ‰¾åˆ°çš„æ‰€æœ‰çš„å›æ–‡å­ä¸²å³å¯ï¼›
# æ— éœ€åœ¨å­—ç¬¦ä¸²ä¸­æ’å…¥ç‰¹æ®Šå­—ç¬¦, centerä¸­å¿ƒä½ç½®ä»0åˆ°æœ€åä¸€ä¸ªå…ƒç´ ç§»åŠ¨,
# æ¯æ¬¡ç§»åŠ¨0.5, è¡¨ç¤ºç§»åŠ¨åˆ°å½“å‰å…ƒç´ ä¸ä¸‹ä¸€ä¸ªå…ƒç´ ä¸­é—´ä½œä¸ºä¸­å¿ƒã€‚
### ä»£ç 
from math import floor,ceil
class Solution:
    def countSubstrings(self, s: str) -> int:
        center = ans = 0
        while center < len(s):
            low, high = floor(center), ceil(center)
            while low >=0 and high < len(s) and s[low] == s[high]:
                low, high, ans = low-1, high+1, ans+1
            center += 0.5
        return ans
```

###  1.47. <a name='-1'></a>650-åªæœ‰ä¸¤ä¸ªé”®çš„é”®ç›˜

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1254y1z7ze?spm_id_from=333.999.0.0)

###  1.48. <a name='FindDuplicateSubtrees'></a>652. Find Duplicate Subtrees

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cW411y7d1?spm_id_from=333.999.0.0)

###  1.49. <a name='TwoSumIV'></a>653. Two Sum IV

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qz4y197h1?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1AQ4y117mc?spm_id_from=333.999.0.0)

```py
çœ‹äº†å®˜æ–¹é¢˜è§£ï¼Œå†™çš„å¾ˆå¥½ï¼Œæˆ‘è¡¥å……python 3 ä¸­åºéå†ä¸­ï¼Œç›´æ¥å‘å¤–ä¼ å€¼çš„ä¸€ä¸ªè§£æ³•ã€‚

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        a=set()
        find=0
        def dfs(r):
            nonlocal find
            if r:
                dfs(r.left)
                if k-r.val in a:find=1
                a.add(r.val)
                dfs(r.right)
        dfs(root)
        return True if find else False

ä¼˜åŒ–ï¼ŒåŠæ—¶åœæ­¢é€’å½’ï¼Œ

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        a=set()
        def dfs(r):
            if r is None:return False
            
            if k-r.val in a:
                return True
            a.add(r.val)
            return dfs(r.left) or dfs(r.right)

        return dfs(root)
å±‚å±‚é€’å½’è¿”å›å€¼ä¸ ç›´æ¥è¿”å›å€¼ï¼Œå†æ¬¡æœäº†å¤§ç¥çš„ä»£ç 

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        if not root: return False
        bfs, s = [root], set()
        for i in bfs:
            v=i.val
            l=i.left
            r=i.right
            if k - v in s: return True
            s.add(v)
            if l: bfs.append(l)
            if r: bfs.append(r)
        return False
```

```py
DFS

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        def dfs(root, k):
            nonlocal ans
            if not root:
                return False
            if k - root.val in ans:
                return True
            ans.add(root.val)
            return dfs(root.left, k) or dfs(root.right, k)
        
        ans = set()
        return dfs(root, k) 
BFS

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        ans = set()
        if not root:
            return False
        queue = [root]
        while queue:
            temp = queue.pop(0)
            if k - temp.val in ans:
                return True
            ans.add(temp.val)
            if temp.left:
                queue.append(temp.left)
            if temp.right:
                queue.append(temp.right)
        return False
```

###  1.50. <a name='MaximumWidthofBinaryTree'></a>662. Maximum Width of Binary Tree

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cv411q7pb?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV16a4y1h7fG?spm_id_from=333.999.0.0)

```py
def widthOfBinaryTree(self, root):
    queue = [(root, 0, 0)]
    cur_depth = left = ans = 0
    for node, depth, pos in queue:
        if node:
            queue.append((node.left, depth+1, pos*2))
            queue.append((node.right, depth+1, pos*2 + 1))
            if cur_depth != depth:
                cur_depth = depth
                left = pos
            ans = max(pos - left + 1, ans)

    return ans

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

å¯¹ç¬¬ä¸€ç§æ–¹æ³•çš„æ”¹è¿›ï¼šqueueä¸­æ— é¡»è®°å½•å±‚æ•°ä¿¡æ¯

class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        queue = [(root,0)]
        res = 0
        while queue:
            arr = []
            for _ in range(len(queue)):
                node,pos = queue.pop(0)
                arr.append(pos)
                if node.left:
                    queue.append((node.left,pos*2))
                if node.right:
                    queue.append((node.right,pos*2+1))
            
            res = max(res,1+arr[-1]-arr[0])
        
        return res

ä¸å®Œå–„ï¼Œæ²¡å¿…è¦ç”¨arrè£…å…¥èŠ‚ç‚¹åºå·ã€‚BFS å»ºè®®ç”¨åŒç«¯é˜Ÿåˆ—ã€‚

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        from collections import deque
        if not root: return 0  # å­¤å„¿æ ‘
        q = deque([(root, 1)])
        res = 0
        while q:
            res = max(res, q[-1][-1] - q[0][-1] + 1)  # åªèƒ½å†™åœ¨è¿™é‡Œï¼å¦åˆ™ä¸å­˜åœ¨
            for _ in range(len(q)):
                node, val = q.popleft()
                if node.left:
                    q.append((node.left, val * 2))
                if node.right:
                    q.append((node.right, val * 2 + 1))
        return res

class Solution(object):
    def widthOfBinaryTree(self, root):
        self.ans = 0
        left = {}
        def dfs(node, depth = 0, pos = 0):
            if node:
                left.setdefault(depth, pos)
                self.ans = max(self.ans, pos - left[depth] + 1)
                dfs(node.left, depth + 1, pos * 2)
                dfs(node.right, depth + 1, pos * 2 + 1)

        dfs(root)
        return self.ans

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        max_width = 0
        queue = collections.deque([(root, 1)])
        while queue:
            max_width = max(max_width, queue[-1][1] - queue[0][1] + 1)
            for _ in range(len(queue)):
                node, idx = queue.popleft()

                if node.left:  queue.append((node.left,  idx * 2))
                if node.right: queue.append((node.right, idx * 2 + 1))

        return max_width
```

###  1.51. <a name='BeautifulArrangementII'></a>667 Beautiful Arrangement II

[å°æ˜](https://www.bilibili.com/video/BV1j54y1b7Br?spm_id_from=333.999.0.0)

###  1.52. <a name='KthSmallestNumberinMultiplicationTable'></a>668. Kth Smallest Number in Multiplication Table

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV17W411C7ai?spm_id_from=333.999.0.0)

###  1.53. <a name='TrimaBinarySearchTree'></a>669 Trim a Binary Search Tree

[å°æ˜](https://www.bilibili.com/video/BV19y4y1J7fu?spm_id_from=333.999.0.0)

###  1.54. <a name='NumberofLongestIncreasingSubse'></a>673 Number of Longest Increasing Subse

[å°æ˜](https://www.bilibili.com/video/BV1gT4y1F7y3?spm_id_from=333.999.0.0)

###  1.55. <a name='ValidParenthesisString'></a>678 Valid Parenthesis String

[å°æ˜](https://www.bilibili.com/video/BV1ap4y1X7nu?spm_id_from=333.999.0.0)

###  1.56. <a name='ValidPalindromeII'></a>680-Valid Palindrome II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV167411h7x1?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV17i4y147xn?spm_id_from=333.999.0.0)

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def checkPalindrome(low, high):
            i, j = low, high
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        low, high = 0, len(s) - 1
        while low < high:
            if s[low] == s[high]: 
                low += 1
                high -= 1
            else:
                return checkPalindrome(low + 1, high) or checkPalindrome(low, high - 1)
        return True

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/valid-palindrome-ii/solution/yan-zheng-hui-wen-zi-fu-chuan-ii-by-leetcode-solut/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def validPalindrome(self, s: str, flag=False) -> bool:
        if s == s[::-1]:
            return True 
        start, end = 0, len(s) - 1
        while start < end:
            if s[start] == s[end]:
                start, end = start+1, end-1
            elif not flag:
                return self.validPalindrome(s[start+1:end+1], True) or self.validPalindrome(s[start:end], True)
            else:
                return False
        return True

class Solution:
    def validPalindrome(self, s):
        if s == s[::-1]:
            return True
        l, r = 0, len(s) - 1
        while l < r:
            if s[l] == s[r]:
                l, r = l + 1, r - 1
            else:
                a = s[l + 1 : r + 1]
                b = s[l:r]
                return a == a[::-1] or b==b[::-1]
```

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        n = len(s)
        i = next((i for i in range(n>>1) if s[i] != s[~i]), -1)
        return i == -1 or s[i+1:n-i] == s[i+1:n-i][::-1] or s[i:n-i-1] == s[i:n-i-1][::-1]
```

###  1.57. <a name='KEmptySlots'></a>683. K Empty Slots

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Jb411k7Yu?spm_id_from=333.999.0.0)

###  1.58. <a name='RedundantConnection684-'></a>684. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Redundant Connection 684-å†—ä½™è¿æ¥

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1mt411J79j?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1oe411p7qF?spm_id_from=333.999.0.0)

[éƒ­éƒ­](https://www.bilibili.com/video/BV1oQ4y1U7dH?from=search&seid=13286624680279107242&spm_id_from=333.337.0.0)

```py
        # ğŸ’å¹¶æŸ¥é›†å…ƒç´ åˆå§‹åŒ–çš„ä¸‰ç§å†™æ³•
        p = list(range(len(edges) + 1))
        p = [i for i in range(len(edges) + 1)]
        p = [*range(len(edges) + 1)]     
```

```py
å†™æ³•ä¸€ï¼š
class Solution:

    def __init__(self):
        self.size = 1005
        self.parent = list(range(self.size))

    def find(self, u):
        # while u != self.parent[u]:
        #     u = self.parent[u]
        # return u
        # ä¸‹é¢ï¼Œè¿™ä¸ªæ›´å¿«ä¸€ç‚¹
        if u != self.parent[u]: 
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        self.parent[self.find(u)] = self.find(v)


    def isConnected(self, u, v ):
        return self.find(u) == self.find(v)

    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        for x, y in edges:
            if self.isConnected(x, y) :
                return [x, y]
            else :
                self.union(x, y)
        return []
        # for i in range(len(edges)):
        #     if self.isConnected(edges[i][0], edges[i][1]) :
        #         return edges[i]
        #     else :
        #         self.union(edges[i][0], edges[i][1])
        # return []

å†™æ³•äºŒï¼šç”¨dic
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = {}
        
        def find(x):
            # è¿™ä¸€è¡Œå¾ˆå…³é”®ï¼Œå¦‚æœé”®ä¸å­˜åœ¨äºå­—å…¸ä¸­ï¼Œå°†ä¼šæ·»åŠ xå¹¶å°†å€¼è®¾ä¸ºé»˜è®¤å€¼ã€‚
            parent.setdefault(x,x)
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
    
        def union(x,y):
            if find(x) != find(y):
                parent[find(y)] = find(x)

        # å¦‚æœéå†è¾¹çš„è¿‡ç¨‹ä¸­ï¼Œå‘ç°ä¸¤ä¸ªç‚¹å·²ç»æˆç¯äº†ï¼Œè¿™æ—¶å°±å¯ä»¥è¾“å‡ºäº†ã€‚
        for x, y in edges:
            if find(x) == find(y):
                return [x, y]
            else:
                union(x,y)  #æ£€æŸ¥é›†åˆï¼Œé¢†å¯¼èŠ‚ç‚¹æ˜¯å¦ç›¸åŒï¼Œå¦‚æœé›†åˆä¸åŒå°±åˆå¹¶     

å†™æ³•ä¸‰ï¼šç”¨list

class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        parent = list(range(n + 1))

        def find(x: int) -> int:
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x: int, y: int):
            parent[find(x)] = find(y)

        for node1, node2 in edges:
            if find(node1) != find(node2):
                union(node1, node2)
            else:
                return [node1, node2]
        
        return []

å†™æ³•å››ï¼šä¸æ¨è

åˆ©ç”¨pyé›†åˆç‰¹æ€§ä¹Ÿå¯ä»¥åšğŸ’å¹¶æŸ¥é›†ï¼Œæœ¬è´¨ä¸Šæ²¡æœ‰åŒºåˆ«ï¼Œä¸è¿‡ä¸ç”¨é€’å½’äº†ï¼Œå…¶å®å°±æ˜¯é å­—å…¸å®ç°çš„ğŸ’å¹¶æŸ¥é›†

parent[x] |= parent[y]ï¼š

{1} {2}
{1, 2} {2}
--------------------
{1, 2} {3}
{1, 2, 3} {3}
--------------------

class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = {i: {i} for i in range(1, len(edges) + 1)}  
        #ğŸ’å¹¶æŸ¥é›†åˆå§‹åŒ–ï¼Œ{1: {1}, 2: {2}, 3: {3}, 4: {4}}
        for x, y in edges:
            if parent[x] is not parent[y]:    #å¦‚æœä¸¤ä¸ªé›†åˆåœ°å€ä¸ä¸€æ ·
                parent[x] |= parent[y]        #åˆå¹¶é›†åˆ
                for z in parent[y]:
                    parent[z] = parent[x]     #ä¿®æ”¹å…ƒç´ é›†åˆæ ‡è®°çš„æŒ‡é’ˆåœ°å€
            else:
                return [x, y]
```

###  1.59. <a name='RedundantConnectionII'></a>685. ã€ğŸ’å¹¶æŸ¥é›† + hardã€‘Redundant Connection II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1St411J7Ur?spm_id_from=333.999.0.0)

```py
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
    
    def union(self, x: int, y: int):
        self.parent[self.find(x)] = self.find(y)
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        uf = UnionFind(n + 1)
        parent = list(range(n + 1))
        error = -1
        cycle = -1
        for i, (x, y) in enumerate(edges):
            if parent[y] != y:
                error = i
            else:
                parent[y] = x
                if uf.find(x) == uf.find(y):
                    cycle = i
                else:
                    uf.union(x, y)

        if error < 0:
            return [edges[cycle][0], edges[cycle][1]]
        else:
            errorEdge = edges[error]
            if cycle >= 0:
                return [parent[errorEdge[1]], errorEdge[1]]
            else:
                return [errorEdge[0], errorEdge[1]]



class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        def find(f,x):
            f.setdefault(x,x)
            if f[x] != x:
                f[x] = find(f,f[x])
            return f[x]
        def cycle(graph):
            f = {}
            for x,y in graph:
                if find(f,x) == find(f,y):
                    return True
                else:
                    f[find(f,y)] = find(f,x)
        indegree = {i:0 for i in range(1,len(edges)+1)}
        tmp = 0
        for i,j in edges:
            indegree[j] += 1
            if indegree[j] == 2:
                tmp = j
                break
        if tmp == 0:
            f = {}
            for x,y in edges:
                if find(f,x) == find(f,y):
                    return [x,y]
                else:
                    f[find(f,y)] = find(f,x)
        else:
            for x,y in edges[::-1]:
                if y == tmp:
                    if not cycle(edges[:edges.index([x,y])]+edges[edges.index([x,y])+1:]) :
                        return [x,y]
```

###  1.60. <a name='LongestUnivaluePath'></a>687. Longest Univalue Path

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1wt411r7Pr?spm_id_from=333.999.0.0)

###  1.61. <a name='KnightProbabilityinChessboard'></a>688. Knight Probability in Chessboard

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Hb411c7mu?spm_id_from=333.999.0.0)

###  1.62. <a name='EmployeeImportance'></a>690. Employee Importance

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Ut411J7uC?spm_id_from=333.999.0.0)

###  1.63. <a name='TopKFrequentWords'></a>692. Top K Frequent Words

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Mt41137eL?spm_id_from=333.999.0.0)

###  1.64. <a name='-1'></a>693

```py
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while n:
            prenum = (n//2) & 1 # èƒŒä¸€èƒŒï¼Œå’Œ16è¿›åˆ¶å·®ä¸å¤š
            nownum = n%2
            if prenum == nownum:
                return False
            n>>=1
        return True

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while n:
            x = n & 1 # å¦‚æœä¸¤ä¸ªç›¸åº”ä½éƒ½ä¸º1,åˆ™è¯¥ä½çš„ç»“æœä¸º1
            n>>=1 # æŠŠ">>"å·¦è¾¹çš„è¿ç®—æ•°çš„å„äºŒè¿›ä½å…¨éƒ¨å³ç§»1ä½
            y = n & 1
            if x==y:
                return False
        return True

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        tmp = str(bin(n))[2:]
        res = [tmp[i] != tmp[i-1] for i in range(1, len(tmp))]
        return all(res)

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        return not ('11' in str(bin(n)) or '00' in str(bin(n)))

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        return not('11' in bin(n) or '00' in bin(n))

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        n = str(bin(n))[2:]
        for i in range(0, len(n)-1):
            if n[i] == n[i+1]:
                return False
        return True

# bin()æœ¬èº«è¿”å›çš„å°±æ˜¯å­—ç¬¦ä¸²

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        b = n >> 1
        res = bin(b^n)[2:]
        if '0' in res:
            return False
        else:
            return True
```

###  1.65. <a name='-1'></a>695-å²›å±¿çš„æœ€å¤§é¢ç§¯

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1s54y1B77k?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1wz4y1R7e6?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1k64y1c798?spm_id_from=333.999.0.0)

```py
class Solution:
    def dfs(self, grid, cur_i, cur_j) -> int:
        if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
            return 0
        grid[cur_i][cur_j] = 0
        ans = 1
        for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
            next_i, next_j = cur_i + di, cur_j + dj
            ans += self.dfs(grid, next_i, next_j)
        return ans

    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                ans = max(self.dfs(grid, i, j), ans)
        return ans


ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                cur = 0
                stack = [(i, j)]
                while stack:
                    cur_i, cur_j = stack.pop()
                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
                        continue
                    cur += 1
                    grid[cur_i][cur_j] = 0
                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        next_i, next_j = cur_i + di, cur_j + dj
                        stack.append((next_i, next_j))
                ans = max(ans, cur)
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                cur = 0
                q = collections.deque([(i, j)])
                while q:
                    cur_i, cur_j = q.popleft()
                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
                        continue
                    cur += 1
                    grid[cur_i][cur_j] = 0
                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        next_i, next_j = cur_i + di, cur_j + dj
                        q.append((next_i, next_j))
                ans = max(ans, cur)
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

python dfs å’Œ union find dfs

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        
        def dfs(i, j):
            grid[i][j] = 0
            ans = 1
            for r, c in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= r < m and 0 <= c < n and grid[r][c] == 1:
                    ans += dfs(r, c)
            return ans
        
        res = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    res = max(res, dfs(i, j))
        return res
union find é¦–å…ˆå°†gridä¸­çš„æ¯ä¸€ä¸ªç‚¹éƒ½å½“ä½œä¸€ä¸ªsetï¼Œ å¦‚æœè¿™ä¸ªç‚¹çš„å…ƒç´ ä¸º1ï¼Œ åˆ™setçš„å¤§å°ä¸º1ï¼Œ å¦‚æœè¿™ä¸ªç‚¹çš„å…ƒç´ ä¸º0ï¼Œ åˆ™setçš„å¤§å°ä¸º0ï¼› éå†gridä¸­çš„æ¯ä¸€ä¸ªç‚¹vï¼Œå¦‚æœvçš„å…ƒç´ ä¸º1ï¼Œ åˆ™åˆ¤æ–­vå³è¾¹çš„ç‚¹v_rå’Œä¸‹é¢çš„v_dç‚¹æ˜¯å¦ä¸º1ï¼Œ å¦‚æœæ˜¯ï¼Œ åˆ™å°†v_r/v_dç‚¹æ”¾è¿›ç‚¹vçš„setä¸­ï¼Œ åŒæ—¶ç”¨numæ¥æ›´æ–°è¿™ä¸ªsetçš„å¤§å°ã€‚

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        
        def find(v):
            if parent[v] != v:
                return find(parent[v])
            return parent[v]
        
        def union(v1, v2):
            r1 = find(v1)
            r2 = find(v2)
            if r1 != r2:
                parent[r2] = r1
                num[r1] += num[r2]
        
        m, n = len(grid), len(grid[0])
        parent = [i*n+j for i in range(m) for j in range(n)]
        num = [0] * (m * n)
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    v = i*n+j
                    num[v] = 1
                    if 0 <= i + 1 < m and grid[i + 1][j]:
                        num[v+n] = 1
                        union(v, v+n)
                    if 0 <= j + 1 < n and grid[i][j + 1]:
                        num[v+1] = 1
                        union(v, v+1)
        return max(num)
```

```py
æœ€å¼€å§‹ç”¨ä¸¤å±‚é€’å½’ï¼Œä¸€å±‚æ‰¾å²›å±¿ï¼Œä¸€å±‚è®¡ç®—é¢ç§¯ï¼Œæ—¶é—´ç›´æ¥çˆ†ç‚¸ åæ¥ç›´æ¥ç”¨ä¸¤ä¸ªforå¾ªç¯éå†åˆ—è¡¨æ¥æ‰¾å²›å±¿ï¼Œå†ç”¨é€’å½’è®¡ç®—é¢ç§¯ï¼Œé€Ÿåº¦éå¸¸å¿«

æ‰§è¡Œç”¨æ—¶ï¼š56 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†94.56%çš„ç”¨æˆ·
å†…å­˜æ¶ˆè€—ï¼š16.7 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†67.66%çš„ç”¨æˆ·
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        self.grid = grid
        self.ans = 0
        self.ans2 = 0
        self.height = len(grid)
        self.width  = len(grid[0])

        for i in range(self.height):  #ç›´æ¥forå¾ªç¯éå†å³å¯ï¼Œä¸ç”¨é€’å½’
            for j in range(self.width):
                if self.grid[i][j] == 1:
                    self.grid[i][j] = 0
                    self.dfs(i, j)
                    self.ans = max(self.ans, self.ans2)
                    self.ans2 = 0    
                    
        return self.ans        


    def dfs(self, i, j):  #ä»ä¸€ä¸ªç‚¹å¼€å§‹æ‰¾é™„è¿‘çš„æ‰€æœ‰å²›å±¿ï¼Œå¹¶ä¸”æŠŠæ‰¾åˆ°çš„å²›å±¿æ ‡è®°ä¸ºæµ·æ°´
        self.grid[i][j] = 0
        self.ans2 += 1
        if j+1 < self.width and self.grid[i][j+1] == 1: #å¾€å³
            self.dfs(i, j+1)
        if j-1 >= 0 and self.grid[i][j-1] == 1:   #å¾€å·¦
            self.dfs(i, j-1)
        if i+1 < self.height and self.grid[i+1][j] == 1:   #å¾€ä¸Š
            self.dfs(i+1, j)
        if i-1 >= 0 and self.grid[i-1][j] == 1:   #å¾€ä¸‹
            self.dfs(i-1, j)
```

###  1.66. <a name='CountBinarySubstrings'></a>696 Count Binary Substrings

[å°æ˜](https://www.bilibili.com/video/BV14p4y1b7nV?spm_id_from=333.999.0.0)

###  1.67. <a name='FallingSquares'></a>699. Falling Squares

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Lt41137EM?spm_id_from=333.999.0.0)

###  1.68. <a name='SearchinaBinarySearchTree'></a>700 Search in a Binary Search Tree

[å°æ˜](https://www.bilibili.com/video/BV14z411e76U?spm_id_from=333.999.0.0)

###  1.69. <a name='InsertintoaBinarySearchTree'></a>701 Insert into a Binary Search Tree

[å°æ˜](https://www.bilibili.com/video/BV1q54y1k76s?spm_id_from=333.999.0.0)

###  1.70. <a name='KthLargestElementinaStreamK'></a>703. ã€æ„é€ ğŸ° + æœ€å°å †ğŸŒµã€‘Kth Largest Element in a Streamæ•°æ®æµä¸­çš„ç¬¬Kå¤§å…ƒç´ 

[å›¾çµ](https://www.bilibili.com/video/BV1g5411w7o8?spm_id_from=333.999.0.0)

```py
æ–¹æ³•ä¸€ï¼šç›´æ¥é™åºæ’åºï¼Œç„¶åå–ç¬¬kä¸ªå…ƒç´ è¿”å›ï¼Œaddæ—¶æ¯æ¬¡éƒ½å†æ’åºä¸€æ¬¡ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦ä¸ºO(k*logk)

# 1.ç›´æ¥æ’åº
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.nums = nums
        self.k = k
        self.nums.sort(reverse = True)
        while len(self.nums) > k:
            self.nums.pop()

    def add(self, val: int) -> int:
        self.nums.append(val)
        self.nums.sort(reverse = True)
        if len(self.nums) > self.k:
            self.nums.pop()
        return self.nums[-1]
æ–¹æ³•äºŒï¼šä½¿ç”¨å°é¡¶å †å®ç°çš„ä¼˜å…ˆé˜Ÿåˆ—ï¼ŒPython ä¸­æ ‡å‡†åº“ heapq å°±æ˜¯å°é¡¶å †ï¼Œæ—¶é—´å¤æ‚åº¦é™ä½ä¸ºO(k)

# 2.å°é¡¶å †
import heapq
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.pool = nums
        heapq.heapify(self.pool)
        self.k = k
        while len(self.pool) > k:
            heapq.heappop(self.pool)

    def add(self, val: int) -> int:
        if len(self.pool) < self.k:
            heapq.heappush(self.pool, val)
        elif val > self.pool[0]:
            heapq.heapreplace(self.pool, val)
        return self.pool[0]
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.queue = []
        for n in nums: self.add(n)

    def add(self, val: int) -> int:
        if len(self.queue) < self.k:
            heapq.heappush(self.queue, val)
        elif val > self.queue[0]:
            heapq.heapreplace(self.queue, val)
        return self.queue[0]



python 3
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.nums = nums
        heapq.heapify(self.nums)
        self.k = k


    def add(self, val: int) -> int:
        heapq.heappush(self.nums, val)
        while len(self.nums) > self.k:
            heapq.heappop(self.nums)
        return self.nums[0]
```

```py
ä¸€é¡¿æ“ä½œçŒ›å¦‚è™ï¼Œä¸€çœ‹å‡»è´¥ç™¾åˆ†äº”

class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k = k
        t = sorted(nums)
        t = t[::-1]
        self.arr = t[:k]

    def add(self, val: int) -> int:
        for i in range(min(self.k, len(self.arr))):
            if self.arr[i] < val:
                self.arr.insert(i, val)
                break
        else:
            self.arr.append(val)
        return self.arr[self.k - 1]
```

```scala
/**
* using min heap
*/
class KthLargest(_k: Int, _nums: Array[Int]) {
    private val pq = scala.collection.mutable.PriorityQueue.empty[Int](Ordering[Int].reverse)
    val k = _k
    _nums.foreach(add)


    def add(`val`: Int): Int = {
        if (pq.size < k)
            /* if only add one element at once, += is more effective than enqueue op */
            pq += `val`
            // pq.enqueue(`val`)
        else if(pq.head < `val`){
            pq.dequeue
            pq += `val`
            // pq.enqueue(`val`)
        }
        // println(pq.clone.dequeueAll)
        pq.head
               
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * var obj = new KthLargest(k, nums)
 * var param_1 = obj.add(`val`)
 */
```

###  1.71. <a name='BinarySearch'></a>704.Binary SearchäºŒåˆ†æŸ¥æ‰¾

[å›¾çµ](https://www.bilibili.com/video/BV1Dh411v7yT?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1qa4y157E4?spm_id_from=333.999.0.0)

```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        low, high = 0, len(nums) - 1
        while low <= high:
            mid = (high - low) // 2 + low
            num = nums[mid]
            if num == target:
                return mid
            elif num > target:
                high = mid - 1
            else:
                low = mid + 1
        return -1

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
å¯¹ä¸èµ·æ²¡å¿ä½

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target in nums :
            return nums.index(target)
        else:
            return -1
ï¼ˆç‰ˆæœ¬ä¸€ï¼‰å·¦é—­å³é—­åŒºé—´

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            middle = (left + right) // 2

            if nums[middle] < target:
                left = middle + 1
            elif nums[middle] > target:
                right = middle - 1
            else:
                return middle
        return -1
ï¼ˆç‰ˆæœ¬äºŒï¼‰å·¦é—­å³å¼€åŒºé—´

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left,right  =0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid+1
            elif nums[mid] > target:
                right = mid
            else:
                return mid
        return -1
```

```scala
object Solution {
    def search(nums: Array[Int], target: Int): Int = {
        nums.lastIndexOf(target)
    }
}

/**
* my first commitment:
* time complexity: O(logn)
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        println(left, right)
        val mid: Int = left  + (right - left) / 2
        if(nums(mid) == target){
          ans = mid
        } else if(target > nums(mid)) {
          left = mid + 1
        } else {
          right = mid - 1
        }
 
      }
      ans
    }
}

/**
* recursive version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
        search(nums, target, 0, nums.length - 1)
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      
      val mid = left + (right - left) / 2
      if (nums(mid) == target) 
        mid
      else if (target > nums(mid))
        search(nums, target, mid + 1, right)
      else 
        search(nums, target, left, right - 1)
      
    }
}
```

###  1.72. <a name='DesignHashSet'></a>705 Design HashSet

[å°æ˜](https://www.bilibili.com/video/BV1hV411z73p?spm_id_from=333.999.0.0)

###  1.73. <a name='DesignHashMap'></a>706. Design HashMapè®¾è®¡å“ˆå¸Œæ˜ å°„

[å›¾çµ](https://www.bilibili.com/video/BV1Ho4y1Q7cr?spm_id_from=333.999.0.0)

###  1.74. <a name='DesignLinkedList'></a>707. Design Linked List

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yW411Z7dV?spm_id_from=333.999.0.0)

###  1.75. <a name='MinimumASCIIDeleteSumforTwoStrings'></a>712. Minimum ASCII Delete Sum for Two Strings

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV17W411d7m2?spm_id_from=333.999.0.0)

###  1.76. <a name='SubarrayProductLessThanK'></a>713 Subarray Product Less Than K

[å°æ˜](https://www.bilibili.com/video/BV1T5411j7tC?spm_id_from=333.999.0.0)

###  1.77. <a name='-1'></a>714 ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1WK4y1E7mP?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1t54y187Qy?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        buy = prices[0]
        profit = 0
        for i in range(1,n):
            buy = min(buy, prices[i]-profit)
            profit = max(profit, prices[i] - buy - fee)
        return profit
```

```scala
/**
* dynamic programming: only create an array keeping holding and un-holding
* time complexity: O(N)
* space complexity:  O(1)
*/
object Solution1-1 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        if(prices == null || prices.isEmpty) return 0
        val dp = Array.ofDim[Int](2)
        dp(0) = 0
        dp(1) = -prices(0)
        // 0 un-holding, 1 holding
        for(i <- 1 until prices.length){
        /*
        * it may causes a problem here, because we overwrite the previous dp(0) by new state i value and dp(1) would utilizes dp(0) which was overwritten 
        */
            dp(0) = dp(0) max (dp(1) + prices(i) - fee)
            dp(1) = dp(1) max (dp(0) - prices(i))
        }
        dp(0)
    }
}
```

###  1.78. <a name='RangeModule'></a>715. Range Module

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1jt411379W?spm_id_from=333.999.0.0)

###  1.79. <a name='FindK-thSmallestPairDistance'></a>719. Find K-th Smallest Pair Distance

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1zb411u7iP?spm_id_from=333.999.0.0)

###  1.80. <a name='LongestWordinDictionary'></a>720. Longest Word in Dictionary

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1vW411r75D?spm_id_from=333.999.0.0)

###  1.81. <a name='AccountsMerge'></a>721 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Accounts Merge

[edo](https://www.bilibili.com/video/BV1wK4y1p7f1?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

```py
import heapq
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        def find(x):
            f.setdefault(x,x)
            while x != f[x]:
                f[x] = f[f[x]]
                x = f[x]
            return x
            
        def union(i, j):
            rooti = find(i)
            rootj = find(j)
            if rootj != rooti:
                f[rootj] = rooti
        f = {}
        for i in range(len(accounts)):
            for mail in accounts[i][1:]:
                union(i, mail)

        res = defaultdict(list)
        for mail, name in f.items():
            if type(mail) == str:
                heappush(res[find(name)], mail)
        ans = [[] for _ in range(len(res))]
        index = 0
        for name, mail in res.items():
            ans[index].append(accounts[name][0])
            while mail:
                ans[index].append(heappop(mail))
            index += 1
        return ans
```

```py
class Solution:
    """å¹¶æŸ¥é›†"""
    '''
    root å­˜æ”¾accountsé‡Œé¢æ¯ä¸ªèŠ‚ç‚¹çš„parent
    mail å­˜æ”¾æ¯ä¸ªé‚®ç®±åœ°å€çš„ç¬¬ä¸€æ¬¡å‡ºç°parent
    '''
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        root = [i for i in range(len(accounts))]
        mail = {}
        
        # å¹¶æŸ¥é›†find
        def find(i):
            if root[i] != i:
                return find(root[i])
            return root[i]
        
        
        for i in range(len(accounts)):
            for email in accounts[i][1:]:
                if email not in mail:
                    mail[email] = i
                else:
                    # é€šè¿‡findæ‰¾åˆ°içš„æœ€ç»ˆparentï¼Œç„¶åå°†parentçš„parentæ”¹å†™ä¸ºmailé€šè¿‡findæ‰¾åˆ°çš„parent
                    # ç”±äºmailé‡Œå­˜æ”¾çš„èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¹Ÿå¯èƒ½è¢«æ›´æ–°æ‰€ä»¥è¦é€šè¿‡findæ‰¾åˆ°æœ€ç»ˆparent
                    
                    root[find(i)] = find(mail[email])
        
        # å­˜æ”¾å­è´¦æˆ·
        delt = set()
        for i in range(len(root)):
            if root[i] != i:
                # é€šè¿‡findæ‰¾åˆ°içš„æœ€ç»ˆparentï¼Œç„¶åæŠŠiæ·»åŠ è¿›æœ€ç»ˆparent
                accounts[find(root[i])].extend(accounts[i][1:])
                delt.add(i)
        # ç­›é€‰å‡ºä¸å«å­è´¦æˆ·çš„æœ€ç»ˆè´¦æˆ·å­˜å…¥result
        result = []
        for i in range(len(accounts)):
            if i not in delt:
                result.append(accounts[i][:1]+sorted(list(set(accounts[i][1:]))))
        return result
```

```py
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))

    def union(self, index1: int, index2: int):
        self.parent[self.find(index2)] = self.find(index1)

    def find(self, index: int) -> int:
        if self.parent[index] != index:
            self.parent[index] = self.find(self.parent[index])
        return self.parent[index]

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        emailToIndex = dict()
        emailToName = dict()

        for account in accounts:
            name = account[0]
            for email in account[1:]:
                if email not in emailToIndex:
                    emailToIndex[email] = len(emailToIndex)
                    emailToName[email] = name
        
        uf = UnionFind(len(emailToIndex))
        for account in accounts:
            firstIndex = emailToIndex[account[1]]
            for email in account[2:]:
                uf.union(firstIndex, emailToIndex[email])
        
        indexToEmails = collections.defaultdict(list)
        for email, index in emailToIndex.items():
            index = uf.find(index)
            indexToEmails[index].append(email)
        
        ans = list()
        for emails in indexToEmails.values():
            ans.append([emailToName[emails[0]]] + sorted(emails))
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/accounts-merge/solution/zhang-hu-he-bing-by-leetcode-solution-3dyq/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        belongs = collections.defaultdict(list)
        for i, j in enumerate(accounts):
            for email in j[1:]:
                belongs[email].append(i)
        emial_visited = set()
        id_visited = set()
        def dfs(id):
            if id in id_visited:
                return
            id_visited.add(id)
            for email in accounts[id][1:]:
                if email in emial_visited:
                    continue
                emial_visited.add(email)
                ans[-1].append(email)
                for i in belongs[email]:
                    dfs(i)
        ans = []
        for i in range(len(accounts)):
            if i not in id_visited:
                ans.append(accounts[i][:1])
                dfs(i)
        for i in range(len(ans)):
            ans[i] = ans[i][:1] + sorted(ans[i][1:])
        return ans
```

```py
Pythonå¹¶æŸ¥é›†è§£æ³•

from collections import defaultdict
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        dic = {}
        email2name = {}
        def find(x):
            if x != dic.setdefault(x, x):
                dic[x] = find(dic[x])
            return dic[x]
        for it in accounts:
            email2name[it[1]] = it[0] # è®°å½•ä¸€ä¸‹ç¬¬ä¸€ä¸ªé‚®ä»¶åœ°å€å¯¹åº”çš„ç”¨æˆ·å
            root = find(it[1]) # find(it[1])è¿™æ­¥ä¸èƒ½å°‘ï¼Œå› ä¸ºæœ‰å¯èƒ½å‡ºç°æ²¡æœ‰it[2]çš„æƒ…å†µ
            for mail in it[2:]:
                dic[find(mail)] = root # å°†æ‰€æœ‰çš„é‚®ä»¶åœ°å€å½’å¹¶åˆ°ç¬¬ä¸€ä¸ªé‚®ä»¶åœ°å€ä¸Š
        # è¿”å›å¤„ç†
        ret = defaultdict(list)
        for key in dic: # è¿™ç‚¹æˆ‘ä¹‹å‰ä¸æ˜¯å¾ˆç†Ÿæ‚‰ï¼Œå¯ä»¥é€šè¿‡éå†dicçš„æ–¹æ³•æŸ¥çœ‹æ‰€æœ‰åœ¨å¹¶æŸ¥é›†ä¸­æ³¨å†Œçš„å…ƒç´ ï¼
            ret[find(key)].append(key) # è¿™é‡Œä¸èƒ½å†™æˆret[dic[key]]ï¼Œå› ä¸ºfind()çš„è¿‡ç¨‹ä¹Ÿæ˜¯æ›´æ–°dicå­—å…¸çš„è¿‡ç¨‹
        return [[email2name[k]] + sorted(v) for k, v in ret.items()]
é™„ä¸ŠPythonçš„DFSè§£æ³•

from collections import defaultdict
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        # å…ˆæ„å»ºç½‘ç«™ä¹‹é—´çš„å…³ç³»å›¾
        dic = defaultdict(set)
        for it in accounts:
            for i in range(1, len(it)):
                dic[it[i]] |= set(it[1:i] + it[i+1:])
        # DFSç®—æ³•ï¼Œç›®æ ‡æ˜¯é€šè¿‡DFSä»¥åŠå…³ç³»å›¾dicå°†ä¸mailç›¸å…³è”çš„æ‰€æœ‰ç½‘ç«™éƒ½æ±‡æ€»èµ·æ¥
        seen = set()
        def dfs(mail):
            if mail in seen:
                return set()
            ret = {mail}
            seen.add(mail)
            for t in dic[mail]:
                ret |= dfs(t)
            return ret
        # ä¸»å‡½æ•°
        ret = []
        for it in accounts:
            if it[1] not in seen:
                ret.append([it[0]] + sorted(dfs(it[1])))
        return ret
```

###  1.82. <a name='FindPivotIndex'></a>724. Find Pivot Index

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1KW411S7nG?spm_id_from=333.999.0.0)

###  1.83. <a name='SplitLinkedListinParts'></a>725. Split Linked List in Parts

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1KW411S7ti?spm_id_from=333.999.0.0)

###  1.84. <a name='NumberofAtoms'></a>726. Number of Atoms

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11W411U7KT?spm_id_from=333.999.0.0)

###  1.85. <a name='CountDifferentPalindromicSubsequences'></a>730. Count Different Palindromic Subsequences

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV12W41167vQ?spm_id_from=333.999.0.0)

###  1.86. <a name='MyCalendarIII'></a>732. My Calendar III

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1fW411k75b?spm_id_from=333.999.0.0)

###  1.87. <a name='FloodFill'></a>733. å›¾åƒæ¸²æŸ“ Flood Fill

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yW41167S4?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1fp4y1v7Pn?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1HZ4y1p7vH?spm_id_from=333.999.0.0)

```py
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        currColor = image[sr][sc]
        if currColor == newColor:
            return image
        
        n, m = len(image), len(image[0])
        que = collections.deque([(sr, sc)])
        image[sr][sc] = newColor
        while que:
            x, y = que.popleft()
            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                if 0 <= mx < n and 0 <= my < m and image[mx][my] == currColor:
                    que.append((mx, my))
                    image[mx][my] = newColor
        
        return image

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        n, m = len(image), len(image[0])
        currColor = image[sr][sc]

        def dfs(x: int, y: int):
            if image[x][y] == currColor:
                image[x][y] = newColor
                for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                    if 0 <= mx < n and 0 <= my < m and image[mx][my] == currColor:
                        dfs(mx, my)

        if currColor != newColor:
            dfs(sr, sc)
        return image

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
python :æ·±åº¦ä¼˜å…ˆæœç´¢+é€’å½’ï¼›æ³¨æ„æµ‹è¯•é‡Œé¢æœ‰ä¸€ç»„æ¯”è¾ƒæ¶å¿ƒï¼Œå°±æ˜¯åˆå§‹ä½ç½®çš„é¢œè‰²å¦‚æœå’Œnewcolor ä¸€æ ·ï¼Œå°±ä¸å¯¹imageè¿›è¡Œæ“ä½œï¼Œç›´æ¥åå›image

class Solution(object):
    def floodFill(self, image, sr, sc, newColor):
        """
        :type image: List[List[int]]
        :type sr: int
        :type sc: int
        :type newColor: int
        :rtype: List[List[int]]
        """
        #up\down\left\right = u\p\l\r
        color = image[sr][sc]
        row = len(image) #è¡Œæ•°
        col = len(image[0]) #åˆ—æ•°
        if color == newColor:
            #æµ‹è¯•è¯•ä¾‹æ¯”è¾ƒæ¶å¿ƒï¼šimage = [[0,0,0],[0,1,1]]; sr=1;sc=1;newColor=1
            return image 

        def DFS(r,c):#æ·±åº¦ä¼˜å…ˆæœç´¢å‡½æ•°ï¼Œç”¨äºé€’å½’
            if image[r][c] == color:
                image[r][c] = newColor
                if r-1>=0 :
                    DFS(r-1,c)
                if r+1<row:
                    DFS(r+1,c)
                if c-1>=0:
                    DFS(r,c-1)
                if c+1<col:
                    DFS(r,c+1)
        
        DFS(sr,sc)
        return image
```

###  1.88. <a name='AsteroidCollision'></a>735 Asteroid Collision

[å°æ˜](https://www.bilibili.com/video/BV1jT4y1F76n?spm_id_from=333.999.0.0)

###  1.89. <a name='SentenceSimilarityII'></a>737. Sentence Similarity II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1qW41167iB?spm_id_from=333.999.0.0)

###  1.90. <a name='DailyTemperatures'></a>739-Daily Temperatures

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Q7411L7w8?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ov411z7rM?spm_id_from=333.999.0.0)

```py
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        ans, nxt, big = [0] * n, dict(), 10**9
        for i in range(n - 1, -1, -1):
            warmer_index = min(nxt.get(t, big) for t in range(temperatures[i] + 1, 102))
            if warmer_index != big:
                ans[i] = warmer_index - i
            nxt[temperatures[i]] = i
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        length = len(temperatures)
        ans = [0] * length
        stack = []
        for i in range(length):
            temperature = temperatures[i]
            while stack and temperature > temperatures[stack[-1]]:
                prev_index = stack.pop()
                ans[prev_index] = i - prev_index
            stack.append(i)
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

è¿™ç§é¢˜æˆ‘å§‹ç»ˆæ›´å–œæ¬¢KMPï¼Œç©ºé—´å¤æ‚åº¦æ›´ä½å“Ÿ

æ—¶é—´å¤æ‚åº¦O(n)

ç©ºé—´å¤æ‚åº¦O(1)

è¯¥æ€è·¯ç”±KMPä¸­å¤±é…æ•°ç»„çš„æ„é€ æ¼”å˜è€Œæ¥ã€‚å‡è®¾ans[i]è®°å½•äº†iä½ç½®ä¸Šçš„ç­”æ¡ˆï¼ˆå‘å³æ‰¾å¤šå°‘ä¸ªæ¯”è‡ªå·±å¤§ï¼‰ï¼Œåˆ™æ±‚ans[i]æ—¶ï¼Œæˆ‘å…ˆçœ‹ä¸€çœ¼i+1ä½ç½®ï¼Œå¦‚æœT[i+1]æ¯”æˆ‘å¤§ï¼Œé‚£å¾—äº†ï¼Œç­”æ¡ˆå°±æ˜¯å®ƒäº†ã€‚

å¦åˆ™æˆ‘è¦æ‰¾çš„ä½ç½®è‡³å°‘æ˜¯æ¯”T[i+1]å¤§ï¼Œé‚£ä¹ˆå½“ç„¶æˆ‘å°±çœ‹ä¸€çœ‹ans[i+1]

class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        n=len(T)
        ans=[0]*n
        for i in range(n-2,-1,-1):
            now=i+1
            while T[now]<=T[i]:
                if ans[now]:
                    now+=ans[now]
                else:
                    break
            else:
                ans[i]=now-i
        return ans
```

```py
ç»´æŠ¤é€’å‡æ ˆï¼Œåå…¥æ ˆçš„å…ƒç´ æ€»æ¯”æ ˆé¡¶å…ƒç´ å°ã€‚

æ¯”å¯¹å½“å‰å…ƒç´ ä¸æ ˆé¡¶å…ƒç´ çš„å¤§å°
è‹¥å½“å‰å…ƒç´  < æ ˆé¡¶å…ƒç´ ï¼šå…¥æ ˆ
è‹¥å½“å‰å…ƒç´  > æ ˆé¡¶å…ƒç´ ï¼šå¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œè®°å½•ä¸¤è€…ä¸‹æ ‡å·®å€¼å³ä¸ºæ‰€æ±‚å¤©æ•°
è¿™é‡Œç”¨æ ˆè®°å½•çš„æ˜¯ T çš„ä¸‹æ ‡ã€‚

class Solution(object):
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        stack = list()
        t_length = len(T)
        res_list = [0 for _ in range(t_length)]
        
        for key, value in enumerate(T):     
            if stack:
                while stack and T[stack[-1]] < value:
                    res_list[stack[-1]] = key - stack[-1]
                    stack.pop()
            stack.append(key)
        return res_list

Pythonï¼š

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        answer = [0]*len(temperatures)
        stack = [0]
        for i in range(1,len(temperatures)):
            # æƒ…å†µä¸€å’Œæƒ…å†µäºŒ
            if temperatures[i]<=temperatures[stack[-1]]:
                stack.append(i)
            # æƒ…å†µä¸‰
            else:
                while len(stack) != 0 and temperatures[i]>temperatures[stack[-1]]:
                    answer[stack[-1]]=i-stack[-1]
                    stack.pop()
                stack.append(i)
            
        return answer
```

###  1.91. <a name='DeleteandEarn'></a>740. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ Delete and Earn

[24:45 èŠ±èŠ±é…± DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1xW41167b5?spm_id_from=333.999.0.0)

```py
åˆ«äººçš„å†™æ³•ï¼š
class Solution(object):
    def deleteAndEarn(self, nums):
        dp = [0] * 10001
        for num in nums:
            dp[num] += num
        for i in range(2, 10001):
            dp[i] = max(dp[i]+dp[i-2], dp[i-1])
        return dp[-1]

æˆ‘çš„ä¿®æ”¹ï¼š
class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        n = max(nums)
        dp = [0] * (n + 1)

        for num in nums:
            dp[num] += num 
        
        start = max(2, min(nums))
        for i in range(start, n + 1):
            # æ˜“é”™ç‚¹ï¼šä¸æ˜¯è¿™ä¸ªdp[i] += max(dp[i-2], dp[i-1])
            dp[i] = max(dp[i-2] + dp[i], dp[i-1])
        return dp[-1]

ä½¿ç”¨è®¡æ•°å™¨ï¼š
from collections import Counter
class Solution:
    def deleteAndEarn(self, nums):
        count = Counter(nums)
        # print(count): Counter({3: 1, 4: 1, 2: 1})
        key = sorted(count)
        # print(key): [2, 3, 4]
        n = len(key)
        dp = [0]*(1+n) # dp[i] è¡¨ç¤ºçš„æ˜¯åœ¨[tmp[0],...tmp[i-1]]èƒ½è·å¾—çš„æœ€å¤§ç‚¹æ•°
        dp[1] = key[0] * count[key[0]]

        for i in range(2, 1+n):
            if key[i-1] - key[i-2] == 1:
                dp[i] = max(dp[i-1], dp[i-2] + key[i-1] * count[key[i-1]])
            if key[i-1] - key[i-2] > 1:
                dp[i] = dp[i-1] + key[i-1] * count[key[i-1]]
        return dp[-1]
```

###  1.92. <a name='CherryPickup'></a>741. Cherry Pickup

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1tW41167jy?spm_id_from=333.999.0.0)

###  1.93. <a name='DijkstraNetworkDelayTime'></a>743. ã€DijkstrağŸš—ã€‘Network Delay Time

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1UW411r7S8?spm_id_from=333.999.0.0)

[ç†Šç¾Šä¸€é”…é²œ](https://www.bilibili.com/video/BV1E341187W6?from=search&seid=4056121790831106424&spm_id_from=333.337.0.0)

###  1.94. <a name='PrefixandSuffixSearch'></a>745. Prefix and Suffix Search

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1TW411k7PY?spm_id_from=333.999.0.0)

###  1.95. <a name='MinCostClimbingStairs'></a>746. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Min Cost Climbing Stairs

[7:45 èŠ±èŠ±é…± DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1VW411y7Dq?spm_id_from=333.999.0.0)

```py
# [10,15,20,10]
# dp(0) dp(1) dp(2)              dp(3)                              dp(4)
# 0       0     10
#                    20 + 10       | 15 + 0           10 + ?          | 20 + ï¼Ÿ
#                    cost(2)+dp(2) | cost(1)+dp(1)    cost(3) + dp(3) | cost(2) + dp(2)
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        dp = [0] * (n+1)
        for i in range(2,n+1):
            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
        return dp[-1]

ç©ºé—´ä¼˜åŒ–ï¼š
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        dp1 = dp0 = 0
        for i in range(2,n+1):
            dp = min(dp1 + cost[i-1], dp0 + cost[i-2])
            dp1, dp0 = dp, dp1
        return dp

æˆ–è€…è¿”å›åˆ°è¾¾ cost[-1], cost[-2] çš„è¾ƒå°å€¼

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        for i in range(2, len(cost)):
            cost[i] += min(cost[i-1], cost[i-2])
        return min(cost[-1], cost[-2])

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp = [0] * (len(cost))
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2, len(cost)):
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
        return min(dp[len(cost) - 1], dp[len(cost) - 2])
```

###  1.96. <a name='ShortestCompletingWord'></a>748. Shortest Completing Word

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV15W411y7sJ?spm_id_from=333.999.0.0)

###  1.97. <a name='OpentheLock'></a>752. Open the Lock

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1NW411y74z?spm_id_from=333.999.0.0)

###  1.98. <a name='PartitionLabels'></a>763 Partition Labels

[å°æ˜](https://www.bilibili.com/video/BV1Ca4y177LW?spm_id_from=333.999.0.0)

###  1.99. <a name='CouplesHoldingHands'></a>765. ã€ğŸ’å¹¶æŸ¥é›† + å›°éš¾ã€‘æƒ…ä¾£ç‰µæ‰‹ Couples Holding Hands

[å®˜æ–¹](https://www.bilibili.com/video/BV1pv411Y7wX?spm_id_from=333.999.0.0)

```py
æ‰’æ‰ä½ çš„å¹¶æŸ¥é›†çš®ï¼Œå“ˆå¸Œè¡¨çœŸé¦™ã€‚

class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        # ä½¿ç”¨å“ˆå¸Œè¡¨ç»´æŠ¤å­—ç¬¦ç´¢å¼•ï¼Œæ¯æ¬¡éå†ä¸€å¯¹äº¤æ¢
        d = {num: idx for idx, num in enumerate(row)}
        cnt = 0
        for i in range(0, len(row), 2):
            flag = -1 if row[i] & 1 else 1
            if row[i+1] != row[i] + flag:  # å½“å‰æ˜¯å¥‡æ•°/å¶æ•°
                row[i+1], row[d[row[i]+flag]] = row[d[row[i]+flag]], row[i+1]
                x, y = row[i+1], row[d[row[i]+flag]]
                d[x], d[y] = d[y], d[x]
                cnt += 1
        return cnt
```

```py
æœ¬æ¥æƒ³éšä¾¿å†™ä¸‹å…ˆè¯•é”™çš„ï¼Œç»“æœå±…ç„¶ç›´æ¥è¿‡äº†è¿˜æ˜¯100%ã€‚ã€‚ã€‚è™½ç„¶100%ä½†è¿˜æ˜¯è¦çƒ§äº†ä½ ä»¬ã€‚ã€‚

class Solution(object):
    def minSwapsCouples(self, row):
        """
        æ¯ä¸¤ä¸ªåº§ä½æˆä¸€å¯¹ï¼Œå‡å®šå·¦è¾¹çš„äººéƒ½æ˜¯åˆæ³•çš„ä¸å˜ï¼Œå¦‚æœTAå³è¾¹çš„äººä¸TAåŒ¹é…åˆ™
        è·³è¿‡ï¼Œä¸åŒ¹é…åˆ™æ‰¾åˆ°TAçš„åŒ¹é…å¯¹è±¡çš„ä¸TAå³è¾¹çš„äººäº¤æ¢ã€‚
        """
        def find_another(n):
            if n % 2 == 0:
                return n + 1
            else:
                return n - 1

        c = 0
        for i in range(0, len(row), 2):
            p1 = row[i]
            p2 = find_another(p1)
            if row[i+1] != p2:
                j = row.index(p2)
                row[i+1], row[j] = row[j], row[i+1]
                c += 1

        return c
```

###  1.100. <a name='MaxChunksToMakeSorted'></a>769. Max Chunks To Make Sorted

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1LW411C7nD?spm_id_from=333.999.0.0)

###  1.101. <a name='JewelsandStones'></a>771 Jewels and Stones

[å°æ˜](https://www.bilibili.com/video/BV1RC4y1W7yH?spm_id_from=333.999.0.0)

###  1.102. <a name='SlidingPuzzle'></a>773. Sliding Puzzle

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1PW411o7g4?spm_id_from=333.999.0.0)

###  1.103. <a name='GlobalandLocalInversions'></a>775. Global and Local Inversions

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1JW411d75t?spm_id_from=333.999.0.0)

###  1.104. <a name='-1'></a>777

```py
# LRä¸èƒ½äº’ç›¸ç©¿è¿‡
# Råªèƒ½å³ç§»
# Låªèƒ½å·¦ç§»
class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        # -----------å»æ‰X,ä¸¤ä¸ªå­—ç¬¦ä¸²åº”è¯¥ç›¸ç­‰-----------
        s = start.replace('X','')
        if s != end.replace('X',''):
            return False
        # -----------å»æ‰X,ä¸¤ä¸ªå­—ç¬¦ä¸²åº”è¯¥ç›¸ç­‰-----------

        # startä¸­Rçš„ç´¢å¼•è¦å°äºç­‰äºendçš„
        # startä¸­Lçš„ç´¢å¼•è¦å¤§äºç­‰äºendçš„
        d1 = [index for index,char in enumerate(start) if char !='X']
        d2 = [index for index,char in enumerate(end) if char !='X']


        for index,char in enumerate(s):
            # R åˆ™startå¤§äºendçš„éƒ½æ˜¯False
            if char == 'R' and d1[index] > d2[index]:
                return False
            if char == 'L' and d1[index] < d2[index]:
                return False

        return True

class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        start = [(index, char) for index, char in enumerate(start) if char in ["L", "R"]]
        end = [(index, char) for index, char in enumerate(end) if char in ["L", "R"]]
        return len(start) == len(end) and all(c1 == c2 == "L" and i1 >= i2 or c1 == c2 == "R" and i1 <= i2 for (i1, c1), (i2, c2) in zip(start, end))

class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        start_id = []
        print("enumerate: ", list(enumerate(start)))
        for i, c in enumerate(start):
            if c in ['L', 'R']:
                start_id.append((i, c))
                
        end_id = []
        for i, c in enumerate(end):
            if c in ['L', 'R']:
                end_id.append((i, c))
                
        if len(start_id) != len(end_id):
            return False
        
        for (i1, c1), (i2, c2) in zip(start_id, end_id):
            print("list(zipped): ",list(zip(start_id, end_id)))
            if c1 != c2:
                return False
            if c1 == c2 == 'L' and i1 < i2:
                return False
            if c1 == c2 == 'R' and i1 > i2:
                return False
        return True

class Solution:
    def canTransform(self, start, end):
        judge = lambda idxStart,idxEnd,f : len(idxStart)==len(idxEnd) and all(f(x,y) for x,y in zip(idxStart,idxEnd)) # f(x,y)æ˜¯ lambda x,y
        # startå’Œend é•¿åº¦ç›¸ç­‰ï¼Œä¸”ä¸èƒ½æœ‰ false
        # å¦‚æœæ»¡è¶³ifæ¡ä»¶ï¼Œåˆ™è¿”å›i
        gen = lambda string,char : [i for i in string if i in char] # charæ˜¯'LR'
        # å¦‚æœæ»¡è¶³ifæ¡ä»¶ï¼Œåˆ™è¿”å›i
        genIdx = lambda string,char : [i for i in range(len(string)) if string[i] in char] # charæ˜¯'L'æˆ–è€… 'R'
        return len(start)==len(end) and\
               gen(start,'LR')==gen(end,'LR') and \
               judge(genIdx(start,'L'),genIdx(end,'L'),lambda x,y:x>=y) and\
               judge(genIdx(start,'R'),genIdx(end,'R'),lambda x,y:x<=y)
```

###  1.105. <a name='DijkstraSwiminRisingWater'></a>778. ã€DijkstrağŸš— + ğŸ’å¹¶æŸ¥é›† + å›°éš¾ã€‘Swim in Rising Water

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ab411k7TH?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1kv4y1f7to?spm_id_from=333.999.0.0)

[ä¸€ä¿©ä¸‰å››äº”](https://www.bilibili.com/video/BV1MJ411g7LM?from=search&seid=4056121790831106424&spm_id_from=333.337.0.0)

```py
# å¯ä»¥èƒŒä¸€èƒŒ
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        #ä¸¤ç‚¹çš„è¾¹é•¿ä¸ºä¸¤ç‚¹ä¸­æœ€å¤§çš„é«˜åº¦ã€‚å»ºç«‹ä¸€ä¸ªè¾¹é•¿é›†åˆï¼Œå‡åºæ’åºã€‚
        n = len(grid)
        edges = []
        for i in range(n):
            for j in range(n):
                ID = i * n + j
                if i < n-1:
                    edges.append([max(grid[i][j],grid[i+1][j]),ID,ID+n])
                if j < n-1:
                    edges.append([max(grid[i][j],grid[i][j+1]),ID,ID+1])
        edges.sort()
        
        #ğŸ’å¹¶æŸ¥é›†åˆå§‹åŒ–
        parent={i:i for i in range(n*n)}
        def find(x):
            if x != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x,y):
            parent[find(x)] = find(y)
        
        #ä»å°åˆ°å¤§éå†åŠ å…¥æ¯ä¸€æ¡è¾¹ï¼Œå¦‚æœåŠ å…¥ä¸€æ¡è¾¹åï¼Œé¦–å°¾è”é€šï¼Œé‚£ä¹ˆè¿”å›åŠ å…¥çš„è¾¹é•¿
        for level, start, end in edges:
            union(start, end)
            if find(0) == find((n*n)-1):
                return level
        return 0
```

###  1.106. <a name='LetterCasePermutation'></a>784. Letter Case Permutation

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1wW411o7WK?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Sv411a7Gx?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def letterCasePermutation(self, S):
        ans = [[]]

        for char in S:
            n = len(ans)
            if char.isalpha():
                for i in xrange(n):
                    ans.append(ans[i][:])
                    ans[i].append(char.lower())
                    ans[n+i].append(char.upper())
            else:
                for i in xrange(n):
                    ans[i].append(char)

        return map("".join, ans)

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution(object):
    def letterCasePermutation(self, S):
        B = sum(letter.isalpha() for letter in S)
        ans = []

        for bits in xrange(1 << B):
            b = 0
            word = []
            for letter in S:
                if letter.isalpha():
                    if (bits >> b) & 1:
                        word.append(letter.lower())
                    else:
                        word.append(letter.upper())

                    b += 1
                else:
                    word.append(letter)

            ans.append("".join(word))
        return ans

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

from typing import List
from itertools import product

# S çš„é•¿åº¦ä¸è¶…è¿‡12ã€‚


class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        available = [set([char.lower(), char.upper()]) for char in s]
        return [''.join(t) for t in product(*available)]
class Solution(object):
    def letterCasePermutation(self, S):
        f = lambda x: (x.lower(), x.upper()) if x.isalpha() else x
        return map("".join, itertools.product(*map(f, S)))

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

BitMap Bitmapæ³•ï¼Œå­—ç¬¦ä¸²Sçš„é•¿åº¦ä¸ºlï¼Œ åˆ™æ€»å…±ä¼šæœ‰ 2** lç§ç»“æœï¼Œæ¢æˆäºŒè¿›åˆ¶å°±æ˜¯0 ~ 2 **l - 1ä¸ªæ•°ï¼Œ
å¯¹äºæ¯ä¸ªæ•°ï¼Œå¦‚æœæŸä¸ªä½ä¸Šæ˜¯0ï¼Œ å°±æ”¾å°å†™ï¼›æ˜¯1ï¼Œ å°±æ”¾å¤§å†™ã€‚

class Solution(object):
    def letterCasePermutation(self, S):
        l = len(S)
        n = 2 ** l
        res = list()
        if l == 0:
            res.append("")
        for i in range(0, n): #å¾—åˆ°0 ~ 2 ** l çš„æ¯ä¸ªæ•°
            temp = ""

            for j in range(0, l):
                if ((2 ** j) &i) == 0:#å½“å‰ä½æ˜¯0ï¼Œ æ”¾å°å†™
                    temp += S[j].lower()
                else: #æ”¾å¤§å†™
                    temp += S[j].upper()
            if temp not in res:
                res.append(temp)
        return res

ä»¥å‰ç«Ÿç„¶è¿˜æ²¡å†™å‡ºæ¥ï¼Œä»Šå¤©éšæœºåˆ°è¿™ä¸€é¢˜ï¼ŒæŠ¥ä»‡é›ªæ¨äº†ï¼Œå…¶å®å¾ˆç®€å•å•Šï¼Œä¸ä¿¡ä½ çœ‹ï¼Œå‡»è´¥98%

class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        res = ['']
        for c in s:
            if c in 'abcdefghijkmlnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
                res = [r+c.lower() for r in res] + [r+c.upper() for r in res]
            else:
                res = [r+c for r in res]
        return res

è¿™ä¸æ¯”å®˜æ–¹çš„å¥½æ‡‚

def letterCasePermutation(s):
    result = [s]
    for i in range(len(s)):
        if s[i]>='a' and s[i]<='z':  
            length = len(result)  # éå†åˆ°lengthï¼Œå°±æ˜¯ä¸Šä¸€ä¸ªå­—ç¬¦ä¸²å¯¹åº”çš„é•¿åº¦
            for j in range(length):
                result.append(result[j][0:i]+s[i].upper()+result[j][i+1:])
        elif s[i]>='A' and s[i]<='Z':
            length = len(result)
            for j in range(length):
                result.append(result[j][0:i]+s[i].lower()+result[j][i+1:])
    return result
```

```py

```

###  1.107. <a name='-1'></a>785-åˆ¤æ–­äºŒåˆ†å›¾

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1KQ4y1N72Z?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV11r4y1P7Wr?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1254y1i7Ut?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        UNCOLORED, RED, GREEN = 0, 1, 2
        color = [UNCOLORED] * n
        valid = True

        def dfs(node: int, c: int):
            nonlocal valid
            color[node] = c
            cNei = (GREEN if c == RED else RED)
            for neighbor in graph[node]:
                if color[neighbor] == UNCOLORED:
                    dfs(neighbor, cNei)
                    if not valid:
                        return
                elif color[neighbor] != cNei:
                    valid = False
                    return

        for i in range(n):
            if color[i] == UNCOLORED:
                dfs(i, RED)
                if not valid:
                    break
        
        return valid


ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        UNCOLORED, RED, GREEN = 0, 1, 2
        color = [UNCOLORED] * n
        
        for i in range(n):
            if color[i] == UNCOLORED:
                q = collections.deque([i])
                color[i] = RED
                while q:
                    node = q.popleft()
                    cNei = (GREEN if color[node] == RED else RED)
                    for neighbor in graph[node]:
                        if color[neighbor] == UNCOLORED:
                            q.append(neighbor)
                            color[neighbor] = cNei
                        elif color[neighbor] != cNei:
                            return False

        return True

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
visited -1æ²¡è®¿é—®è¿‡ 0 1ä»£è¡¨color

DFSç‰ˆæœ¬

class Solution(object):
    def isBipartite(self, graph):
        """
        :type graph: List[List[int]]
        :rtype: bool
        """
        n = len(graph)
        visited = [-1] * n
        for i in range(n):
            if visited[i] == -1:
                if not self.dfs(graph, i, 0, visited):
                    return False
        return True

    def dfs(self, graph, v, color, visited):
        visited[v] = color
        for i in graph[v]:
            if visited[i] == -1:
                if not self.dfs(graph, i, 1 - color, visited):
                    return False
            elif visited[i] == color:
                return False
        return True
BFSç‰ˆæœ¬

class Solution(object):
    def isBipartite(self, graph):
        n = len(graph)
        visited = [-1] * n
        for i in range(n):
            if visited[i] == -1:
                if not self.bfs(graph, i, 0, visited):
                    return False
        return True

    def bfs(self, graph, v, color, visited):
        visited[v], queue = color, [v]
        while queue:
            node = queue.pop(0)
            for i in graph[node]:
                if visited[i] == -1:
                    visited[i] = 1 - visited[node]
                    queue.append(i)
                elif visited[i] == visited[node]:
                    return False
        return True
```

###  1.108. <a name='K-thSmallestPrimeFraction'></a>786. K-th Smallest Prime Fraction

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1AW411o7oi?spm_id_from=333.999.0.0)

###  1.109. <a name='DijkstraCheapestFlightsWithinKStops'></a>787. ã€DijkstrağŸš— + åŠ¨æ€ğŸš€è§„åˆ’ + æœ€å°å †ğŸŒµã€‘Cheapest Flights Within K Stops

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV13W411o7wc?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1DZ4y1H7oH?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5kql1xc5ggs0.webp)

```py
class Solution:
    # DijkstrağŸš—+å‰ªæ
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        if src == dst:
            return 0
        graph = collections.defaultdict(list)
        for start, t, p in flights:
            graph[start].append((t, p))
        dist = {src: 0}
        queue = [(0, src, 0)]
        while queue:
            price, start, interval = queue.pop(0)
            if interval > k:
                break
            for end, p in graph[start]:
                if price + p < dist.get(end, float("inf")):
                    dist[end] = price + p
                    queue.append((price + p, end, interval + 1))
        return -1 if dist.get(dst, float("inf")) == float("inf") else dist[dst]

# from xiaoming

import heapq
class Solution:
    # DijkstrağŸš—+å‰ªæ
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        if src == dst:
            return 0
        graph = collections.defaultdict(list)
        for f, t, p in flights:
            graph[f].append((t, p))
        dist = {}
        queue = [(0, src, 0)]
        while queue:
            price, start, interval = heapq.heappop(queue)
            # è¿™ä¸ªéƒ¨åˆ†å¾ˆé‡è¦ï¼Œä¸€å®šè¦k+1
            if interval > k+1:
                continue
            if start == dst:
                return price
            for end, p in graph[start]:
                # è¿™ä¸€æ­¥å‰ªæå¾ˆé‡è¦
                if price + p < dist.get((end,interval+1), float("inf")):
                    heapq.heappush(queue, (price + p, end, interval + 1))
                    dist[(end,interval+1)] = price + p
                # print(dist)
                # {(1, 1): 100}
                # {(1, 1): 100, (2, 1): 500}
                # {(1, 1): 100, (2, 1): 500, (2, 2): 200}
        return -1 
```

py åŠ¨æ€ğŸš€è§„åˆ’

```py
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        dp = [float('inf') for _ in range(n)]
        dp[src] = 0
        for _ in range(K+1):
            tmp = dp[:]
            for start, end, cost in flights:
                dp[end] = min(dp[end],tmp[start] + cost)
                # print(dp)
                # [0, 100, inf]
                # [0, 100, inf]
                # [0, 100, 500]
                # [0, 100, 500]
                # [0, 100, 200]
                # [0, 100, 200]
        return dp[dst] if dp[dst] != float('inf') else -1

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        dp = [[float("inf")] * n for _ in range(k + 2)]
        dp[0][src] = 0
        for t in range(1, k + 2):
            for start, end, cost in flights:
                dp[t][end] = min(dp[t][end], dp[t - 1][start] + cost)
        
        res = min(dp[t][dst] for t in range(1, k + 2))
        return -1 if res == float("inf") else res

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        tmp = [float("inf")] * n
        tmp[src] = 0
        res = float("inf")
        for _ in range(1, k + 2):
            dp = [float("inf")] * n
            for j, i, cost in flights:
                dp[i] = min(dp[i], tmp[j] + cost)
            tmp = dp
            res = min(res, tmp[dst])
        
        return -1 if res == float("inf") else res

```



###  1.110. <a name='DominoandTrominoTiling'></a>790. Domino and Tromino Tiling

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV13W411o7AW?spm_id_from=333.999.0.0)

###  1.111. <a name='NumberofMatchingSubsequences'></a>792. Number of Matching Subsequences

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV13W411o7Af?spm_id_from=333.999.0.0)

###  1.112. <a name='AllPathsFromSourcetoTarget'></a>797 All Paths From Source to Target

[å°æ˜](https://www.bilibili.com/video/BV1qa4y1E7sg?spm_id_from=333.999.0.0)

###  1.113. <a name='ChampagneTower'></a>799 Champagne Tower

[å°æ˜](https://www.bilibili.com/video/BV1Da411A7u5?spm_id_from=333.999.0.0)

###  1.114. <a name='MinimumSwapsToMakeSequencesIncreasing'></a>801. Minimum Swaps To Make Sequences Increasing

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1FW411o7tL?spm_id_from=333.999.0.0) 

###  1.115. <a name='BricksFallingWhenHit'></a>803. ã€ğŸ’å¹¶æŸ¥é›† + å›°éš¾ã€‘Bricks Falling When Hit 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV13W411o7kA?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Xv411W74B?spm_id_from=333.999.0.0)

```py
class Solution:
    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:
        def getSit2Idx(n, x, y):
            return x * n + y

        m, n = len(grid), len(grid[0])
        size = m * n
        u = self.UnionFind(size + 1)
        tmp = copy.deepcopy(grid)

        for x, y in hits:
            tmp[x][y] = 0

        for column in range(n):
            if tmp[0][column] == 1:
                u.union(column, size)
        
        for row in range(1, m):
            for column in range(n):
                if tmp[row][column] == 1:
                    if row - 1 >= 0 and tmp[row - 1][column] == 1:
                        u.union(getSit2Idx(n, row - 1, column), getSit2Idx(n, row, column))
                    if column - 1 >= 0 and tmp[row][column - 1] == 1:
                        u.union(getSit2Idx(n, row, column - 1), getSit2Idx(n, row, column))

        dx, dy, ans = [0, 0, -1, 1], [-1, 1, 0, 0], []
        for x, y in hits[::-1]:
            if grid[x][y] == 0: 
                ans.insert(0, 0)
                continue
            original = u.getSize(size)
            if x == 0: u.union(y, size)
            for i in range(4):
                offsetX, offsetY = x + dx[i], y + dy[i]
                if 0 <= offsetX < m and 0 <= offsetY < n and tmp[offsetX][offsetY]:
                    a, b = getSit2Idx(n, x, y), getSit2Idx(n, offsetX, offsetY)
                    u.union(a, b)
            current = u.getSize(size)
            ans.insert(0, max(0, current - original - 1))
            tmp[x][y] = 1
        return ans

    class UnionFind:
        def __init__(self, n):
            self.parents = {}
            self.total = [1 for _ in range(n)]
            for i in range(n):
                self.parents[i] = i

        
        def find(self, x):
            original = self.parents[x]
            if original != x:
                original = self.find(original)
                self.parents[x] = original
            return original


        def union(self, x, y):
            rootX, rootY = self.find(x), self.find(y)
            if rootX != rootY:
                self.parents[rootX] = self.parents[rootY]
                self.total[rootY] += self.total[rootX]

        
        def getSize(self, idx):
            return self.total[self.find(idx)]
```

```py

```

###  1.116. <a name='UniqueMorseCodeWords'></a>804 Unique Morse Code Words

[å°æ˜](https://www.bilibili.com/video/BV1RD4y1Q7AM?spm_id_from=333.999.0.0)

###  1.117. <a name='LargestSumofAverages'></a>813. Largest Sum of Averages

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1XW411d7RB?spm_id_from=333.999.0.0)

###  1.118. <a name='BusRoutes'></a>815. Bus Routes

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1QW411d794?spm_id_from=333.999.0.0)

###  1.119. <a name='LinkedListComponents'></a>817. Linked List Components

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cW411o7Eu?spm_id_from=333.999.0.0)

###  1.120. <a name='RaceCar'></a>818. Race Car (ä¸Š)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cW411o7Tb?spm_id_from=333.999.0.0)

###  1.121. <a name='ShortestDistancetoaCharacter'></a>821 Shortest Distance to a Character

[å°æ˜](https://www.bilibili.com/video/BV1gy4y1Y784?spm_id_from=333.999.0.0)

###  1.122. <a name='BinaryTreesWithFactors'></a>823. Binary Trees With Factors

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1CW411d7RX?spm_id_from=333.999.0.0)

###  1.123. <a name='GoatLatin'></a>824 Goat Latin

[å°æ˜](https://www.bilibili.com/video/BV1Th411o782?spm_id_from=333.999.0.0)

###  1.124. <a name='MakingALargeIsland'></a>827. Making A Large Island

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1mW411d7rc?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Cg4117727?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def largestIsland(self, grid):
        N = len(grid)

        def check(r, c):
            seen = {(r, c)}
            stack = [(r, c)]
            while stack:
                r, c = stack.pop()
                for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):
                    if (nr, nc) not in seen and 0 <= nr < N and 0 <= nc < N and grid[nr][nc]:
                        stack.append((nr, nc))
                        seen.add((nr, nc))
            return len(seen)

        ans = 0
        has_zero = False
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == 0:
                    has_zero = True
                    grid[r][c] = 1
                    ans = max(ans, check(r, c))
                    grid[r][c] = 0

        return ans if has_zero else N*N

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/making-a-large-island/solution/zui-da-ren-gong-dao-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution(object):
    def largestIsland(self, grid):
        N = len(grid)

        def neighbors(r, c):
            for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if 0 <= nr < N and 0 <= nc < N:
                    yield nr, nc

        def dfs(r, c, index):
            ans = 1
            grid[r][c] = index
            for nr, nc in neighbors(r, c):
                if grid[nr][nc] == 1:
                    ans += dfs(nr, nc, index)
            return ans

        area = {}
        index = 2
        for r in xrange(N):
            for c in xrange(N):
                if grid[r][c] == 1:
                    area[index] = dfs(r, c, index)
                    index += 1

        ans = max(area.values() or [0])
        for r in xrange(N):
            for c in xrange(N):
                if grid[r][c] == 0:
                    seen = {grid[nr][nc] for nr, nc in neighbors(r, c) if grid[nr][nc] > 1}
                    ans = max(ans, 1 + sum(area[i] for i in seen))
        return ans

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/making-a-large-island/solution/zui-da-ren-gong-dao-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py

```

###  1.125. <a name='FlippinganImage'></a>832 Flipping an Image

[å°æ˜](https://www.bilibili.com/video/BV1q54y1r7f3?spm_id_from=333.999.0.0)

###  1.126. <a name='ImageOverlap'></a>835 Image Overlap

[å°æ˜](https://www.bilibili.com/video/BV1NK4y1a7Yf?spm_id_from=333.999.0.0)

###  1.127. <a name='New21Game'></a>837. æ–° 21 ç‚¹ New 21 Game

[å®˜æ–¹](https://www.bilibili.com/video/BV1Sz4y197cA?spm_id_from=333.999.0.0)

###  1.128. <a name='SimilarStringGroups'></a>839 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Similar String Groups

[edo](https://www.bilibili.com/video/BV1jA411L7BY?from=search&seid=13338604369462419980&spm_id_from=333.337.0.0)

[éƒ­éƒ­](https://www.bilibili.com/video/BV1E64y1b7xd?from=search&seid=13286624680279107242&spm_id_from=333.337.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6owto1xqj040.webp)

```py
class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        def similarity(s, t):
            ans = 0
            for i in range(len(s)):
                if s[i] != t[i]:
                    ans += 1
                if ans > 2: return False
            return ans == 2 or ans == 0
        def dfs(graph, i, visit):
            visit.add(i)
            for v in graph[i]:
                if v not in visit:
                    dfs(graph, v, visit)
        n = len(strs)
        graph = defaultdict(set)
        for i in range(n):
            for j in range(i + 1, n):
                if similarity(strs[i], strs[j]):
                    graph[i].add(j)
                    graph[j].add(i)
        ans = 0
        visit = set()
        for i in range(n):
            if i not in visit:
                ans += 1
                dfs(graph, i, visit)
        return ans
```

```py
class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        n=len(strs)
        parent=list(range(n))
        size=[1]*n
        nSet=n

        def find(a):
            if parent[a]!=a:
                parent[a]=find(parent[a])
            return parent[a]

        def union(a,b):
            a,b=find(a),find(b)
            if a==b: return False
            if size[a]<size[b]:
                a,b=b,a
            parent[b]=a
            size[a]+=size[b]
            nonlocal nSet
            nSet-=1
            return True

        l=len(strs[0])
        for i in range(n-1):
            for j in range(i+1,n):
                diff=None
                for k in range(l):
                    c1,c2=strs[i][k],strs[j][k]
                    if c1!=c2:
                        if diff is None:
                            diff=(c1,c2)
                        elif diff==(c2,c1):
                            diff=0
                        else: break
                else:
                    union(i,j)
        return nSet
```

```py
class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        n, m = len(strs), len(strs[0])
        uf = UnionFind(n)
        for i in range(n):
            for j in range(i + 1, n):
                count = 0
                for k in range(m):
                    if strs[i][k] != strs[j][k]:
                        count += 1
                        if count > 2:
                            break
                if count in {0, 2}:
                    uf.union(i, j)
        return uf.count


class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.count = n

    def find(self, x):
        if self.parent[x] == x:
            return x
        self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        x, y = self.find(x), self.find(y)
        if x != y:
            self.parent[x] = y
            self.count -= 1

ä½œè€…ï¼šT-RexInTheBronx
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/similar-string-groups/solution/python3-shi-yong-bing-cha-ji-ji-lu-lian-clfgm/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        n = len(strs)
        f = list(range(n))

        def find(x: int) -> int:
            if f[x] == x:
                return x
            f[x] = find(f[x])
            return f[x]
        
        def check(a: str, b: str) -> bool:
            num = 0
            for ac, bc in zip(a, b):
                if ac != bc:
                    num += 1
                    if num > 2:
                        return False
            return True
        
        for i in range(n):
            for j in range(i + 1, n):
                fi, fj = find(i), find(j)
                if fi == fj:
                    continue
                if check(strs[i], strs[j]):
                    f[fi] = fj
        
        ret = sum(1 for i in range(n) if f[i] == i)
        return ret

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/similar-string-groups/solution/xiang-si-zi-fu-chuan-zu-by-leetcode-solu-8jt9/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

###  1.129. <a name='KeysandRooms'></a>841 Keys and Rooms

[å°æ˜](https://www.bilibili.com/video/BV1Wb4y1Q7hE?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1HK411F7JQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        def dfs(x: int):
            vis.add(x)
            nonlocal num
            num += 1
            for it in rooms[x]:
                if it not in vis:
                    dfs(it)
        
        n = len(rooms)
        num = 0
        vis = set()
        dfs(0)
        return num == n

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        num = 0
        vis = {0}
        que = collections.deque([0])

        while que:
            x = que.popleft()
            num += 1
            for it in rooms[x]:
                if it not in vis:
                    vis.add(it)
                    que.append(it)
        
        return num == n

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

DFSå¯ä»¥ç”¨æ ˆå®ç°ã€‚

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        cnt = len(rooms)
        seen = [False] * cnt
        stack = [0, ]
        while stack:
            nxt = stack.pop()
            if not seen[nxt]:
                seen[nxt] = True
                cnt -= 1
                stack.extend(rooms[nxt])
        return cnt == 0
```

```py
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        vis = [False] * n
        def dfs(st):
            vis[st] = True
            for ano in rooms[st]:
                if not vis[ano]:
                    dfs(ano)
        dfs(0)
        return all(vis)
dfs

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        vst = set()
        def f(key):
            vst.add(key)
            [f(k) for k in rooms[key] if k not in vst]
        return f(0) or len(vst) == len(rooms)
bfs

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        que, vst = [0], {0}
        for key in que:
            for k in filter(lambda k: k not in vst, rooms[key]):
                que += [k]
                vst |= {k}
        return len(vst) == len(rooms)
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        keys = [0]*len(rooms)
        def dfs(i):
            keys[i] = 1
            [dfs(key) for key in rooms[i] if keys[key]==0]
        dfs(0)
        return all(i==1 for i in keys)


class Solution:

    def dfs(self, key: int, rooms: List[List[int]]  , visited : List[bool] ) :
        if visited[key] :
            return

        visited[key] = True
        keys = rooms[key]
        for i in range(len(keys)) :
            # æ·±åº¦ä¼˜å…ˆæœç´¢éå†
            self.dfs(keys[i], rooms, visited)

    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = [False for i in range(len(rooms))]

        self.dfs(0, rooms, visited)

        # æ£€æŸ¥æ˜¯å¦éƒ½è®¿é—®åˆ°äº†
        for i in range(len(visited)):
            if not visited[i] :
                return False
        return True

dfs ä¸éœ€è¦é‚£ä¸ª è®¡æ•°å‘€

class Solution:
    def canVisitAllRooms(self, rooms):
        def dfs(x: int):
            vis.add(x)
            for it in rooms[x]:
                if it not in vis:
                    dfs(it)
        
        n = len(rooms)
        vis = set()
        dfs(0)
        return len(vis) == n
```

###  1.130. <a name='SplitArrayintoFibonacciSequence'></a>842. Split Array into Fibonacci Sequence

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ZJ411H7t4?spm_id_from=333.999.0.0)

###  1.131. <a name='BackspaceStringCompare'></a>844 Backspace String Compare

[å°æ˜](https://www.bilibili.com/video/BV1aC4y1s7LK?spm_id_from=333.999.0.0)

###  1.132. <a name='LongestMountaininArray'></a>845 Longest Mountain in Array

[å°æ˜](https://www.bilibili.com/video/BV1zi4y1L7yV?spm_id_from=333.999.0.0)

###  1.133. <a name='ShortestPathVisitingAllNodes'></a>847 Shortest Path Visiting All Nodes

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1hW411d7MU?spm_id_from=333.999.0.0)

###  1.134. <a name='MaximizeDistancetoClosestPerson'></a>849 Maximize Distance to Closest Person

[å°æ˜](https://www.bilibili.com/video/BV1ZZ4y1G7iT?spm_id_from=333.999.0.0)

###  1.135. <a name='ScoreofParentheses'></a>856. Score of Parentheses

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1bW411d7gp?spm_id_from=333.999.0.0)

###  1.136. <a name='MirrorReflection'></a>858 Mirror Reflection

[å°æ˜](https://www.bilibili.com/video/BV1av411r7MW?spm_id_from=333.999.0.0)

###  1.137. <a name='BuddyStrings'></a>859 Buddy Strings

[å°æ˜](https://www.bilibili.com/video/BV1nz4y1o7Wo?spm_id_from=333.999.0.0)

###  1.138. <a name='AllNodesDistanceKinBinaryTree'></a>863. All Nodes Distance K in Binary Tree

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14W411d7mz?spm_id_from=333.999.0.0)

###  1.139. <a name='ShortestPathtoGetAllKeys'></a>864. Shortest Path to Get All Keys

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1LW411d7th?spm_id_from=333.999.0.0)

###  1.140. <a name='ReorderedPowerof2'></a>869 Reordered Power of 2

[å°æ˜](https://www.bilibili.com/video/BV1M64y1D78v?spm_id_from=333.999.0.0)

###  1.141. <a name='SmallestSubtreewithalltheDeepestNodes'></a>865. Smallest Subtree with all the Deepest Nodes

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14W411d7ZR?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1CV41187ZA?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def subtreeWithAllDeepest(self, root):
        # Tag each node with it's depth.
        depth = {None: -1}
        def dfs(node, parent = None):
            if node:
                depth[node] = depth[parent] + 1
                dfs(node.left, node)
                dfs(node.right, node)
        dfs(root)

        max_depth = max(depth.itervalues())

        def answer(node):
            # Return the answer for the subtree at node.
            if not node or depth.get(node, None) == max_depth:
                return node
            L, R = answer(node.left), answer(node.right)
            return node if L and R else L or R

        return answer(root)

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/solution/ju-you-suo-you-zui-shen-jie-dian-de-zui-xiao-zi-sh/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution(object):
    def subtreeWithAllDeepest(self, root):
        # The result of a subtree is:
        # Result.node: the largest depth node that is equal to or
        #              an ancestor of all the deepest nodes of this subtree.
        # Result.dist: the number of nodes in the path from the root
        #              of this subtree, to the deepest node in this subtree.
        Result = collections.namedtuple("Result", ("node", "dist"))
        def dfs(node):
            # Return the result of the subtree at this node.
            if not node: return Result(None, 0)
            L, R = dfs(node.left), dfs(node.right)
            if L.dist > R.dist: return Result(L.node, L.dist + 1)
            if L.dist < R.dist: return Result(R.node, R.dist + 1)
            return Result(node, L.dist + 1)

        return dfs(root).node

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/solution/ju-you-suo-you-zui-shen-jie-dian-de-zui-xiao-zi-sh/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
ä¸€è¶Ÿdfs

class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        def f(t):
            if not t:
                return t, 0
            else:
                x, m = f(t.left)
                y, n = f(t.right)
                if m > n:
                    return x, m + 1
                elif m < n:
                    return y, n + 1
                else:
                    return t, n + 1
        return f(root)[0]
å•æ¬¡dfs

class Solution:
    def dfs(self, root, level):
        if not root: return None, level
        left, llevel = self.dfs(root.left, level+1)
        right, rlevel = self.dfs(root.right, level+1)
        if llevel == rlevel:
            return root, llevel
        if llevel > rlevel:
            return left, llevel
        if llevel < rlevel:
            return right, rlevel


    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        if not root: return None
        ret, level = self.dfs(root, 0)
        return ret
python æ¯”è¾ƒç›´è§‚çš„å®ç°æ–¹æ³•ï¼Œåˆ¤æ–­èŠ‚ç‚¹çš„å·¦å³å­æ ‘æ·±åº¦æ˜¯å¦ç›¸åŒï¼Œç›¸åŒçš„åˆ™ä¸ºæ‰€æ±‚çš„å­—æ•°ï¼š

class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        if not root: return root
        def dfs(root):
            if not root: return root
            l = self.max_depth(root.left)
            r = self.max_depth(root.right)
            if l == r: return root
            elif l > r: return dfs(root.left)
            else: return dfs(root.right)
        return dfs(root)
    def max_depth(self, root, layer=1):
        if not root: return layer-1
        return max(self.max_depth(root.left,layer+1), self.max_depth(root.right, layer+1))
```

###  1.142. <a name='MinimumNumberofRefuelingStops'></a>871. Minimum Number of Refueling Stops

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1JW411d7VK?spm_id_from=333.999.0.0)

###  1.143. <a name='LengthofLongestFibonacciSubsequence'></a>873. Length of Longest Fibonacci Subsequence

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1jW411d79H?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1ab411i7wx?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def lenLongestFibSubseq(self, A):
        S = set(A)
        ans = 0
        for i in xrange(len(A)):
            for j in xrange(i+1, len(A)):
                """
                With the starting pair (A[i], A[j]),
                y represents the future expected value in
                the fibonacci subsequence, and x represents
                the most current value found.
                """
                x, y = A[j], A[i] + A[j]
                length = 2
                while y in S:
                    x, y = y, x + y
                    length += 1
                ans = max(ans, length)
        return ans if ans >= 3 else 0

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/solution/zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-chang-du-by/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution(object):
    def lenLongestFibSubseq(self, A):
        index = {x: i for i, x in enumerate(A)}
        longest = collections.defaultdict(lambda: 2)

        ans = 0
        for k, z in enumerate(A):
            for j in xrange(k):
                i = index.get(z - A[j], None)
                if i is not None and i < j:
                    cand = longest[j, k] = longest[i, j] + 1
                    ans = max(ans, cand)

        return ans if ans >= 3 else 0

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/solution/zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-chang-du-by/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
def lenLongestFibSubseq(self, A):
    """
    :type A: List[int]
    :rtype: int
    """
    dic = {num:[] for num in A}
    head = [(2,num) for num in A]
    size = len(A)
    cnt = 0
    for i,num in enumerate(A):
        cur = dic[num]
        for l,last in head[:i]+cur:
            if l+size-i+1 <= cnt:
                continue
            new = last+num
            if new in dic:
                dic[new].append((l+1,num))
                cnt = max(cnt,l+1)
    return cnt if cnt > 2 else 0
æ€è·¯ï¼ša[i][j]ç”¨äºè®°å½•A[?]+A[i]æ˜¯å¦èƒ½å¾—åˆ°A[j]ï¼Œå¦‚æœä»æ¥éƒ½ä¸è¡Œï¼Œç„¶åç¬¬ä¸€æ¬¡å¯ä»¥ï¼Œå°±ä¸º3ï¼›å¦åˆ™åˆ™ä¸ºa[i][j]+1

class Solution:
    def lenLongestFibSubseq(self, A: List[int]) -> int:
        n, res = len(A), 0
        a = [[0] * n for i in range(n)]
        for i in range(n):
            lo, hi, v = 0, i - 1, A[i]
            while lo < hi:
                if A[lo] + A[hi] < v:
                    lo += 1
                elif A[lo] + A[hi] > v:
                    hi -= 1
                else:
                    if a[lo][hi]:
                        a[hi][i] = a[lo][hi] + 1
                    else:
                        a[hi][i] = 3
                    res = max(a[hi][i], res)
                    lo += 1
                    hi -= 1
        return res
```

###  1.144. <a name='KokoEatingBananas'></a>875.Koko Eating Bananasç§‘ç§‘åƒé¦™è•‰

[å›¾çµ](https://www.bilibili.com/video/BV1iV411s7eU?spm_id_from=333.999.0.0)

###  1.145. <a name='MiddleoftheLinkedList'></a>876.Middle of the Linked List é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹

[å›¾çµ](https://www.bilibili.com/video/BV1Kv411p7vf?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1Pz41187WS?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1aK411T74X?spm_id_from=333.999.0.0)

```py
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        A = [head]
        while A[-1].next:
            A.append(A[-1].next)
        return A[len(A) // 2]

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        n, cur = 0, head
        while cur:
            n += 1
            cur = cur.next
        k, cur = 0, head
        while k < n // 2:
            k += 1
            cur = cur.next
        return cur

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

python å¿«æ…¢åŒæŒ‡é’ˆ

class Solution(object):
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow


```

```py
ç¬¬ä¸€ç§å…ˆè®¡æ•°å†æ‰¾ä¸­ç‚¹ï¼Œç¬¬äºŒç§å¿«æ…¢æŒ‡é’ˆ

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        first = head
        count = 0
        while first != None:
            first = first.next
            count += 1
        second = head
        count = count//2
        while count > 0:
            second = second.next
            count -= 1
        return second
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        first = second = head
        while first != None and first.next != None:
            first = first.next.next
            second = second.next
        return second
```

###  1.146. <a name='StoneGame'></a>877 ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ã€‘Stone Game

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1mW411Z7Hr?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1xq4y1Q7uL?spm_id_from=333.999.0.0)

ä¸€å…±æœ‰å¶æ•°å †çŸ³å­ï¼Œå¿…ç„¶å­˜åœ¨å¥‡æ•°å †å¤§ï¼Œorå¶æ•°å †å¤§ï¼Œåªè¦æ‰¾åˆ°å…¶ä¸­çš„è¾ƒå¤§ä¸€åŠå°±è¡Œ

```py
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        return True
```

é€’å½’ï¼ŒO(2^n)

è®°å¿†åŒ–é€’å½’(min-Max) O(n^2)

ç¼ºç‚¹æ˜¯ï¼š
- æ·±åº¦ä¸èƒ½å¤ªæ·±
- ä¸èƒ½é™ç»´

```py
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        @cache
        def helper(i, j):
            if i==j: return piles[i]
            return max(piles[i]-helper(i+1, j),
                       piles[j]-helper(i, j-1))
        return helper(0, len(piles)-1)>=0
```

åŠ¨æ€ğŸš€è§„åˆ’ O(n^2)

å¯ä»¥é™ç»´

```py

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        length = len(piles)
        dp = [[0] * length for _ in range(length)]
        for i, pile in enumerate(piles):
            dp[i][i] = pile
        for i in range(length - 2, -1, -1):
            for j in range(i + 1, length):
                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])
        return dp[0][length - 1] > 0

é™ç»´ä»¥å

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        length = len(piles)
        dp = [0] * length
        for i, pile in enumerate(piles):
            dp[i] = pile
        for i in range(length - 2, -1, -1):
            for j in range(i + 1, length):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[length - 1] > 0

åŒºé—´DPï¼Œå’Œä¸Šé¢æ›´æ–°çš„æ¬¡åºä¸åŒ

æŠŠdpæ‰“å°å‡ºæ¥çœ‹çœ‹å°±æ‡‚äº†ã€‚

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        N = len(piles)
        dp = [[0]*(N+1) for _ in range(N+1)] # é˜²æ­¢å‡ºç•Œ
        for gap in range(N):
            for i in range(N-gap):
                j = i+gap
                dp[i][j] = max(piles[i]-dp[i+1][j],
                              piles[j]-dp[i][j-1])
        return dp[0][N-1]>0
```



###  1.147. <a name='ProfitableSchemes'></a>879. Profitable Schemes

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1mW411Z7Jt?spm_id_from=333.999.0.0)

###  1.148. <a name='DecodedStringatIndex'></a>880 Decoded String at Index

[å°æ˜](https://www.bilibili.com/video/BV1Tt4y1k7GJ?spm_id_from=333.999.0.0)

###  1.149. <a name='BoatstoSavePeople'></a>881 Boats to Save People

[å°æ˜](https://www.bilibili.com/video/BV1MT4y1K7yq?spm_id_from=333.999.0.0)

###  1.150. <a name='ReachableNodesInSubdividedGraph'></a>882. Reachable Nodes In Subdivided Graph

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11W411Z71N?spm_id_from=333.999.0.0)

###  1.151. <a name='PossibleBipartition'></a>886. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Possible Bipartition

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1DW411Z7G6?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1FT4y1g77u?spm_id_from=333.999.0.0)

```py
ğŸ’å¹¶æŸ¥é›†

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        teams = [0] * (n + 1)
        graph = collections.defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
        # print(graph):
        # defaultdict(<class 'list'>, {1: [2, 3], 2: [1, 4], 3: [1], 4: [2]})

        parent = list(range(n+1))
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            parent[find(x)] = parent[find(y)]

        for AA in range(1, n+1):
            for BB in graph[AA]: # AA ä¸èƒ½å’Œ BB åœ¨ä¸€èµ·
                if find(AA) == find(BB): return False
                union(BB, graph[AA][0])
        return True
```

```py
class Solution(object):
    def possibleBipartition(self, N, dislikes):
        graph = collections.defaultdict(list)
        for u, v in dislikes:
            graph[u].append(v)
            graph[v].append(u)

        color = {}
        def dfs(node, c = 0):
            if node in color:
                return color[node] == c
            color[node] = c
            return all(dfs(nei, c ^ 1) for nei in graph[node])

        return all(dfs(node)
                   for node in range(1, N+1)
                   if node not in color)

python, äºŒåˆ·, å›¾+dfsæœç´¢, ç¼“å­˜æœç´¢ä¸­çš„åˆ†ç»„å·, é™ä½æ—¶é—´å¤æ‚åº¦

class Solution:
    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:
        graph = collections.defaultdict(list)   # åˆ»ç”»a, bä¸¤äººçš„å…³ç³»å›¾, æ— å‘å›¾
        for s, e in dislikes:
            graph[s].append(e)
            graph[e].append(s)
        
        group = dict()

        @functools.lru_cache(None)               # ç¼“å­˜dfsæœç´¢ä¸­é—´ç»“æœ, ä¸‹æ¬¡iç›¸åŒå°±ç›¸å½“äºè¡¨æŸ¥è¯¢, æ—¶é—´å¤æ‚åº¦ä¸ºO(n)
        def dfs(i, g=1):
            if i in group:
                return group[i] == g            # içš„ç»„åˆ’åˆ†,å·²ç»åˆ¤å®šåœ¨äº†groupå½“ä¸­, æ‰€ä»¥åˆ¤æ–­æ˜¯å¦çŸ›ç›¾
            group[i] = g                        # ä¸çŸ›ç›¾çš„è¯, åˆ¤å®šç»™ç»„g
            for con in graph[i]:                # å¦‚æœiçš„é‚»æ¥èŠ‚ç‚¹,éƒ½èƒ½ä¸çŸ›ç›¾åœ°"å®‰æ’", è¿”å›true
                if not dfs(con, -1 * g):
                    return False
            return True
        
        for i in range(1, N + 1):
            if i not in group and not dfs(i):   # æ­¤å¤„å¿…é¡»å¼ºè°ƒiä¸åœ¨group, å› ä¸ºå‰é¢æœç´¢ä¸­å¯èƒ½å°†
                return False                    # iåˆ¤å®šç»™äº†-1, ä½†æ˜¯æ­¤æ—¶å¦‚æœå†æ¬¡dfsæœç´¢, å°†å…¶é»˜è®¤ä¸º1,ä¼šçŸ›ç›¾
        return True

DFS

class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        color = [0] * n
        
        def dfs(node, c):
            if color[node] == -c: return False
            if color[node] == c: return True
            color[node] = c
            for neighbor in graph[node]:
                if not dfs(neighbor, -c):
                    return False
            return True
        
        for i in range(n):
            if color[i] == 0 and not dfs(i, 1):
                return False
        return True
BFS

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        teams = [0] * (n + 1)
        graph = collections.defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)

        for i in range(1, n+1):
            if teams[i] == 0:
                teams[i] = 1
                Q = collections.deque([i])
                while Q:
                    p = Q.popleft()
                    for neighbor in graph[p]:
                        if teams[neighbor] == teams[p]: return False
                        elif teams[neighbor] == 0:
                            teams[neighbor] = -teams[p]
                            Q.append(neighbor)
        return True


```

###  1.152. <a name='SuperEggDrop'></a>887. Super Egg Drop

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Tv411i7cP?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ri4y1t78d?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3ld2gccb6ey0.webp" width="30%">

```py
dp[k][m] çš„å«ä¹‰æ˜¯kä¸ªé¸¡è›‹ ç§»åŠ¨mæ¬¡æœ€å¤šèƒ½å¤Ÿç¡®å®šå¤šå°‘æ¥¼å±‚
è¿™ä¸ªè§’åº¦æ€è€ƒ
dp[k][m] æœ€å¤šèƒ½å¤Ÿç¡®å®šçš„æ¥¼å±‚æ•°ä¸ºL

é‚£ä¹ˆæˆ‘é€‰å®šç¬¬ä¸€ä¸ªæ‰”çš„æ¥¼å±‚ä¹‹åï¼Œæˆ‘è¦ä¹ˆç¢ï¼Œè¦ä¹ˆä¸ç¢

è¿™å°±æ˜¯æŠŠLåˆ†æˆ3æ®µ:
å·¦è¾¹æ˜¯ç¢çš„é‚£æ®µ é•¿åº¦æ˜¯ dp[k][m - 1]
å³è¾¹æ˜¯æ²¡ç¢çš„é‚£æ®µ é•¿åº¦æ˜¯ dp[k-1][m - 1] å› ä¸ºå·²ç»ç¢äº†ä¸€ä¸ªäº†
ä¸­é—´æ˜¯æˆ‘é€‰å®šæ‰”çš„æ¥¼å±‚ æ˜¯1

æ‰€ä»¥é€’æ¨å…¬å¼æ˜¯:
dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1

æ ¹æ®é€’æ¨å…¬å¼ å¦‚æœé‡‡ç”¨kå€’ç€ä»å¤§åˆ°å°è®¡ç®— å°±å¯ä»¥åªå­˜ä¸€è¡Œçš„dp[k] ç›´æ¥åŸåœ°æ›´æ–°dp[k] ä¸å½±å“åç»­è®¡ç®— 

åªéœ€è¦O(K)ç©ºé—´å¤æ‚åº¦ O(KlogN) é¸¡è›‹å®Œå…¨å¤Ÿç”¨çš„æ—¶å€™ å°±æ˜¯èµ°LogNæ­¥ æœ€å·®æƒ…å†µæ˜¯1ä¸ªé¸¡è›‹èµ°Næ­¥ O(KN)

class Solution:
    def superEggDrop(self, eggs: int, level: int) -> int:
            dp = [0] * (eggs + 1)
            m = 0
            while dp[eggs] < level:
                m += 1
                for gg in range(eggs, 0, -1):
                    # é¸¡è›‹ç¢äº†ï¼Œå‰©ä¸‹çš„é¸¡è›‹å¯ä»¥éå†å¤šå°‘æ¥¼å±‚ï¼Œé¸¡è›‹æ²¡ç¢ï¼Œå¯ä»¥éå†çš„æ¥¼å±‚æ•°ç›®
                    dp[gg] = dp[gg - 1] + dp[gg] + 1
            return m

if __name__ == "__main__":      
	s = Solution()
	print(s.superEggDrop(3,14))
    # print('ç§»åŠ¨æ¬¡æ•°:',m,'é¸¡è›‹:', k)
# ç§»åŠ¨æ¬¡æ•°: 1 é¸¡è›‹0-3å¯¹åº”æ¥¼å±‚: [0, 1, 1, 1]
# ç§»åŠ¨æ¬¡æ•°: 2 é¸¡è›‹0-3å¯¹åº”æ¥¼å±‚: [0, 2, 3, 3]
# ç§»åŠ¨æ¬¡æ•°: 3 é¸¡è›‹0-3å¯¹åº”æ¥¼å±‚: [0, 3, 6, 7]
# ç§»åŠ¨æ¬¡æ•°: 4 é¸¡è›‹0-3å¯¹åº”æ¥¼å±‚: [0, 4, 10, 14]
```

```py
class Solution:
    def superEggDrop(self, eggs: int, levels: int) -> int:
        dp = list(range(levels + 1))
        dp2 = [0] * (levels + 1)
        for eggs in range(2, eggs + 1):
            x = 1
            for m in range(1, levels + 1):
                # max(dp[x-1], dp2[m-x]) > max(dp[x], dp2[m-x-1])
                # max(T1(x-1), T2(x-1)) > max(T1(x), T2(x)).
                while x < m and max(dp[x - 1], dp2[m - x]) >= max(dp[x], dp2[m - x - 1]):
                    x += 1
                # The final answer happens at this x.
                dp2[m] = 1 + max(dp[x - 1], dp2[m - x])

            dp = dp2[:]

        return dp[-1]


class Solution:
    def superEggDrop(self, eggs: int, level: int) -> int:
        if level == 1:
            return 1
        f = [[0] * (eggs + 1) for _ in range(level + 1)]
        for i in range(1, eggs + 1):
            f[1][i] = 1
        res = -1
        for i in range(2, level + 1):
            for j in range(1, eggs + 1):
                f[i][j] = 1 + f[i - 1][j - 1] + f[i - 1][j]
            if f[i][eggs] >= level:
                res = i
                break
        return res
```

###  1.153. <a name='ConstructBinaryTreefromPreorderandPostorder'></a>889. Construct Binary Tree from Preorder and Postorder

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1DW411Z7Qi?spm_id_from=333.999.0.0)

###  1.154. <a name='SumofSubsequenceWidths'></a>891. Sum of Subsequence Widths

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1DW411Z7Yv?spm_id_from=333.999.0.0)

###  1.155. <a name='AllPossibleFullBinaryTrees'></a>894. All Possible Full Binary Trees

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1rW411Z7Sb?spm_id_from=333.999.0.0)

###  1.156. <a name='MaximumFrequencyStack'></a>895. Maximum Frequency Stack

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1rW411Z7Hp?spm_id_from=333.999.0.0)

###  1.157. <a name='BitwiseORsofSubarrays'></a>898. Bitwise ORs of Subarrays

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1kW411Z7HV?spm_id_from=333.999.0.0)

###  1.158. <a name='OnlineStockSpan'></a>901. ã€æ„é€ ğŸ°ã€‘Online Stock Span

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1kW411k77K?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Jg4y1B74H?spm_id_from=333.999.0.0)

```py
class StockSpanner(object):
    def __init__(self):
        self.stack = []

    def next(self, price):
        weight = 1
        while self.stack and self.stack[-1][0] <= price:
            weight += self.stack.pop()[1]
        self.stack.append((price, weight))
        return weight

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/online-stock-span/solution/gu-piao-jie-ge-kua-du-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class StockSpanner:

    def __init__(self):
        self.stack = [] # (price, span)

    def next(self, price: int) -> int:
        span = 1
        while self.stack and self.stack[-1][0] <= price:
            span += self.stack.pop()[1]
        self.stack.append((price, span))
        return span
```

```py
class StockSpanner:
    """
    ç”¨ä¸€ä¸ªæ ˆæ¥å­˜å‚¨è¿‡å»è‚¡ç¥¨çš„ä»·æ ¼å’Œå¯¹åº”çš„è·¨åº¦ï¼Œ
    å¦‚æœå½“å¤©çš„è‚¡ç¥¨ä»·æ ¼å¤§äºæ ˆé¡¶çš„è‚¡ç¥¨ä»·æ ¼ï¼Œåˆ™å‡ºæ ˆï¼Œ
    å°†å¯¹åº”çš„è·¨åº¦åŠ åˆ°ä»Šæ—¥è‚¡ç¥¨ä»·æ ¼çš„è·¨åº¦ä¸Šï¼
    ç›´åˆ°æ ˆé¡¶çš„è‚¡ç¥¨ä»·æ ¼å¤§äºå½“æ—¥è‚¡ç¥¨ä»·æ ¼ï¼Œç„¶åå°†å½“æ—¥è‚¡ç¥¨ä»·æ ¼å’Œå¯¹åº”çš„è·¨åº¦å…¥æ ˆ
    """
    def __init__(self):
        self.his_prices = [(-999, 0)]

    def next(self, price: int) -> int:
        span = 1
        while self.his_prices:
            if self.his_prices[-1][0] <= price:
                span += self.his_prices.pop()[1]
            else:
                break
        self.his_prices.append((price, span))
        return span
```

###  1.159. <a name='NumbersAtMostNGivenDigitSet'></a>902 Numbers At Most N Given Digit Set

[å°æ˜](https://www.bilibili.com/video/BV19A411j7Wf?spm_id_from=333.999.0.0)

###  1.160. <a name='-1'></a>904-æ°´æœæˆç¯®

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV19i4y1M7Xn?spm_id_from=333.999.0.0)

###  1.161. <a name='SortArrayByParity'></a>905 Sort Array By Parity

[å°æ˜](https://www.bilibili.com/video/BV1Xk4y117rK?spm_id_from=333.999.0.0)

###  1.162. <a name='SuperPalindromes'></a>906 Super Palindromes

[å°æ˜](https://www.bilibili.com/video/BV1LA41157Wf?spm_id_from=333.999.0.0)

###  1.163. <a name='SnakesandLadders'></a>909. Snakes and Ladders

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1cy4y1W7u9?spm_id_from=333.999.0.0)

###  1.164. <a name='SmallestRangeII'></a>910 Smallest Range II

[å°æ˜](https://www.bilibili.com/video/BV1p5411H7mS?spm_id_from=333.999.0.0)

###  1.165. <a name='WordSubsetse'></a>916 Word Subsetse

[å°æ˜](https://www.bilibili.com/video/BV1vh411S7r3?spm_id_from=333.999.0.0)

###  1.166. <a name='MaximumSumCircularSub'></a>918 Maximum Sum Circular Sub

[å°æ˜](https://www.bilibili.com/video/BV1c5411s7jZ?spm_id_from=333.999.0.0)

###  1.167. <a name='SumWithMultiplicity'></a>923. 3Sum With Multiplicity 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14t411o7QT?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Pv41187sq?spm_id_from=333.999.0.0)

```py
def solve(A, target):
    # Assume A already sorted
    i, j = 0, len(A) - 1
    ans = 0
    while i < j:
        if A[i] + A[j] < target:
            i += 1
        elif A[i] + A[j] > target:
            j -= 1
        else:
            ans += 1
            i += 1
            j -= 1
    return ans

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        ans = 0
        A.sort()

        for i, x in enumerate(A):
            # We'll try to find the number of i < j < k
            # with A[j] + A[k] == T, where T = target - A[i].

            # The below is a "two sum with multiplicity".
            T = target - A[i]
            j, k = i+1, len(A) - 1

            while j < k:
                # These steps proceed as in a typical two-sum.
                if A[j] + A[k] < T:
                    j += 1
                elif A[j] + A[k] > T:
                    k -= 1
                # These steps differ:
                elif A[j] != A[k]: # We have A[j] + A[k] == T.
                    # Let's count "left": the number of A[j] == A[j+1] == A[j+2] == ...
                    # And similarly for "right".
                    left = right = 1
                    while j + 1 < k and A[j] == A[j+1]:
                        left += 1
                        j += 1
                    while k - 1 > j and A[k] == A[k-1]:
                        right += 1
                        k -= 1

                    # We contributed left * right many pairs.
                    ans += left * right
                    ans %= MOD
                    j += 1
                    k -= 1

                else:
                    # M = k - j + 1
                    # We contributed M * (M-1) / 2 pairs.
                    ans += (k-j+1) * (k-j) / 2
                    ans %= MOD
                    break

        return ans

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        count = [0] * 101
        for x in A:
            count[x] += 1

        ans = 0

        # All different
        for x in xrange(101):
            for y in xrange(x+1, 101):
                z = target - x - y
                if y < z <= 100:
                    ans += count[x] * count[y] * count[z]
                    ans %= MOD

        # x == y
        for x in xrange(101):
            z = target - 2*x
            if x < z <= 100:
                ans += count[x] * (count[x] - 1) / 2 * count[z]
                ans %= MOD

        # y == z
        for x in xrange(101):
            if (target - x) % 2 == 0:
                y = (target - x) / 2
                if x < y <= 100:
                    ans += count[x] * count[y] * (count[y] - 1) / 2
                    ans %= MOD

        # x == y == z
        if target % 3 == 0:
            x = target / 3
            if 0 <= x <= 100:
                ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6
                ans %= MOD

        return ans

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

å—¯â€¦â€¦æ•°å­¦å¤§æ³•å¥½

from collections import defaultdict
class Solution(object):
    def threeSumMulti(self, A, target):
        """
        :type A: List[int]
        :type target: int
        :rtype: int
        """
        mod = 1000000007
        
        counter = defaultdict(int)
        for n in A:
            counter[n] += 1
        
        ans = 0
        # x != y != z
        for x in xrange(101):
            for y in xrange(x+1, 101):
                z = target - x - y
                if z <= y:
                    continue
                ans += counter[x] * counter[y] * counter[z]
                ans %= mod 
                        
        # x == y != z
        for x in xrange(101):
            z = target - 2*x
            if z == x:
                continue
            ans += counter[x] * (counter[x]-1) * counter[z] / 2
            ans %= mod
            
        if target % 3 == 0:
            x = target / 3
            ans += counter[x] * (counter[x]-1) * (counter[x]-2) / 6
            ans %= mod
            
        return ans
pythonï¼Œæ•°å­¦æ–¹æ³•ï¼Œå…ˆæŠŠæ•°ç»„å‚¨å­˜æˆå­—å…¸ï¼Œå¦‚æœ3ä¸ªæ•°ç›¸åŒï¼Œé‚£ä¹ˆå°±æ˜¯Cm3ï¼ˆmæ˜¯è¯¥å€¼çš„ä¸ªæ•°ï¼Œæ•°å­¦é‡Œé¢çš„æ’åˆ—ï¼Œä¸çŸ¥é“æ€ä¹ˆè°ƒæ ¼å¼ï¼‰ï¼Œå¦‚æœæœ‰ä¸¤ä¸ªæ•°ä¸€æ ·ï¼Œé‚£ä¹ˆå°±æ˜¯Cm2*Cn1ï¼Œå¦‚æœä¸‰ä¸ªæ•°å‡ä¸åŒï¼Œé‚£ä¹ˆå°±æ˜¯Cm1*Cn1*Ck1


class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        count = collections.Counter(A)
        keys = sorted(count)

        ans = 0

        # Now, let's do a 3sum on "keys", for i <= j <= k.
        # We will use count to add the correct contribution to ans.
        for i, x in enumerate(keys):
            T = target - x
            j, k = i, len(keys) - 1
            while j <= k:
                y, z = keys[j], keys[k]
                if y + z < T:
                    j += 1
                elif y + z > T:
                    k -= 1
                else: # x+y+z == T, now calculate the size of the contribution
                    if i < j < k:
                        ans += count[x] * count[y] * count[z]
                    elif i == j < k:
                        ans += count[x] * (count[x] - 1) / 2 * count[z]
                    elif i < j == k:
                        ans += count[x] * count[y] * (count[y] - 1) / 2
                    else:  # i == j == k
                        ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6

                    j += 1
                    k -= 1

        return ans % MOD

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
class Solution:
    def threeSumMulti(self, A: List[int], target: int) -> int:
        ans = dict()  #æ•°ç»„è½¬æ¢æˆå­—å…¸
        for i,num in enumerate(A):
            ans[num] = ans.get(num,0) + 1
        res = []  #targetçš„å¯èƒ½åˆ†è§£ç»“æœ
        for i in range(0,target//3+1):
            for j in range(i,target//2+1):
                k = target - i - j
                if k >= j:
                    res.append([i,j,k]) 
        total = 0
        for i,j,k in res:
            if i in ans and j in ans and k in ans:
                if i == j==k:
                    total += ans[i]*(ans[i]-1)*(ans[i]-2)//6
                elif i == j:
                    total += ans[i]*(ans[i]-1)*(ans[k])//2
                elif j == k:
                    total += ans[i]*(ans[j]-1)*ans[j]//2
                else:
                    total += ans[i]*ans[j]*ans[k]
        return total % (10**9+7)
```

###  1.168. <a name='FlipStringtoMonotoneIncreasing'></a>926. Flip String to Monotone Increasing

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ft411R7qv?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Vh411i7Wg?spm_id_from=333.999.0.0)

```py
æš´åŠ›æ±‚è§£ï¼šä¸€è¡Œä»£ç ï¼Œä½†æ˜¯ä¼šè¶…æ—¶ï¼Œå­˜åœ¨å¤§é‡é‡å¤è®¡ç®—
class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        return min([s[:i].count('1') + s[i+1:].count('0') for i in range(len(s))])

ä¸€å®šè¦æ‹¿è‰ç¨¿çº¸å†™ä¸‹æ¥

class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        # æœ€åä¸€ä½1è‚¯å®šä¸éœ€è¦åè½¬
        dp1 = [0] * n
        for i in range(n-1): 
            dp1[i+1] = dp1[i]
            if s[i] == '1':
                dp1[i+1] += 1
        # ç¬¬ä¸€ä½0è‚¯å®šä¸éœ€è¦åè½¬
        dp0 = [0] * n
        for i in range(n-1,0,-1): 
            dp0[i-1] = dp0[i]
            if s[i] == '0':
                dp0[i-1] += 1
        return min(x[0]+x[1] for x in zip(dp0,dp1))


class Solution(object):
    def minFlipsMonoIncr(self, S):
        m = S.count('0')   #åˆ†ç•Œç‚¹ä¸º0ä¹‹å‰ï¼Œç»Ÿè®¡ä¹‹åçš„0
        res = [m]
        for x in S:
            if x == '1':   #å¦‚æœæ˜¯1ï¼Œåˆ†ç•Œç‚¹ä¹‹å‰1çš„ä¸ªæ•°+1ï¼Œåˆ†ç•Œç‚¹ä¹‹å0çš„ä¸ªæ•°ä¸å˜
                m += 1
            else:       #å¦‚æœæ˜¯0ï¼Œåˆ†ç•Œç‚¹ä¹‹å‰1çš„ä¸ªæ•°ä¸å˜ï¼Œåˆ†ç•Œç‚¹ä¹‹å0çš„ä¸ªæ•°å‡1
                m -= 1
            res.append(m)        
        return min(res)
```

###  1.169. <a name='-1'></a>930-ã€æ»‘åŠ¨çª—å£ğŸ”¹ + å‰ç¼€å’ŒğŸ¨ã€‘å’Œç›¸åŒçš„äºŒå…ƒå­æ•°ç»„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1iy4y1T7M3?spm_id_from=333.999.0.0)

###  1.170. <a name='NumberofRecentCalls'></a>933 Number of Recent Calls

[å°æ˜](https://www.bilibili.com/video/BV1gA41177jm?spm_id_from=333.999.0.0)

###  1.171. <a name='ShortestBridge'></a>934. Shortest Bridge

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV19t411y7rL?spm_id_from=333.999.0.0)

###  1.172. <a name='StampingTheSequence'></a>936 Stamping The Sequence

[å°æ˜](https://www.bilibili.com/video/BV1d64y1D7fq?spm_id_from=333.999.0.0)

###  1.173. <a name='RangeSumofBST'></a>938 Range Sum of BST

[å°æ˜](https://www.bilibili.com/video/BV1WV411a7VR?spm_id_from=333.999.0.0)

###  1.174. <a name='ValidMountainArray'></a>941 Valid Mountain Array

[å°æ˜](https://www.bilibili.com/video/BV1n5411G7qs?spm_id_from=333.999.0.0)

###  1.175. <a name='FindtheShortestSuperstring'></a>943. Find the Shortest Superstring

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yt411171k?spm_id_from=333.999.0.0)

###  1.176. <a name='Python-'></a>946-Python-æ ˆçš„å‹å…¥ã€å¼¹å‡ºåºåˆ—

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1JD4y1o7ZD?spm_id_from=333.999.0.0)

###  1.177. <a name='ValidateStackSequences'></a>946 Validate Stack Sequences

[å°æ˜](https://www.bilibili.com/video/BV1fz4y1y7rS?spm_id_from=333.999.0.0)

###  1.178. <a name='MostStonesRemovedwithSame'></a>947. ã€ğŸ’å¹¶æŸ¥é›†ã€‘ç§»é™¤æœ€å¤šçš„åŒè¡Œæˆ–åŒåˆ—çŸ³å¤´ Most Stones Removed with Same

[å®˜æ–¹](https://www.bilibili.com/video/BV1Nr4y1K7Gj?spm_id_from=333.999.0.0)

[éƒ­éƒ­](https://www.bilibili.com/video/BV1Tq4y157i8?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

```py
å¹¶æŸ¥é›†ï¼ŒçœŸå¥½ç”¨ï¼Œ

ä¸€æ¬¡ACä¸æ˜¯æ¢¦ï¼

æˆ‘ä»¬å…¨å®¶éƒ½ç”¨å®ƒï¼Œ

æ•ˆæœçœŸæ˜¯é¡¶å‘±å‘±.

åˆå¥½å†™æ¥åˆå¥½æ‡‚ï¼Œ

è„‘å£³å†ä¹Ÿä¸ä¼šç—›.

class UFS():
    def __init__(self, N):
        self.p = range(N)

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]
    
    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr

class Solution(object):
    def removeStones(self, stones):
        ufs = UFS(20000)
        for x,y in stones:
            ufs.union(x,y+10000)
        return len(stones)-len({ufs.find(x) for x,y in stones})
```

```py
class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        def union(x: int, y: int):
            parent[find(x)] = find(parent[y])

        def find(idx: int) -> int:
            if parent[idx] != idx:
                parent[idx] = find(parent[idx])
            return parent[idx]

        n = len(stones)
        parent = list(range(n))
        row_map, col_map = {}, {}
        for i in range(n):
            if stones[i][0] not in row_map:
                row_map[stones[i][0]] = i
            else:
                union(i, row_map[stones[i][0]])
            if stones[i][1] not in col_map:
                col_map[stones[i][1]] = i
            else:
                union(i, col_map[stones[i][1]])
        graph = set()
        for i in range(n):
            graph.add(find(i))
        return n - len(graph)
```

```py
å¹¶æŸ¥é›†èƒ½æƒ³åˆ°ï¼Œéš¾çš„æ˜¯æƒ³äº†åŠå¤©æ€ä¹ˆæŠŠæ¯ä¸ªç‚¹ä¹‹é—´çš„è¿é€šçš„å…³ç³»è¡¨ç¤ºå‡ºæ¥ï¼Œä¸€çœ‹é¢˜è§£å¥½å®¶ä¼™+10000ï¼Œå¤ªå¦™äº†

class DSU:
    def __init__(self,nodecount):
        self.node_relation_list=[-1]*nodecount
    def find(self,node):
        temp=node
        while self.node_relation_list[node]!=-1:
            node=self.node_relation_list[node]
        if temp!=node:
            self.node_relation_list[temp]=node
        return node
    def merge(self,node1,node2):
        node1boss=self.find(node1)
        node2boss=self.find(node2)
        if node1boss!=node2boss:
            self.node_relation_list[node1boss]=node2boss
        return 
class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        ufs = DSU(20000)
        for x,y in stones:
            ufs.merge(x,y+10000)#æ‰€æœ‰ç‚¹æŒ‰æ¨ªåæ ‡è¿é€š
        return len(stones)-len({ufs.find(x) for x,y in stones})#åè€…æ˜¯ç®—æœ‰å‡ ä¸ªé›†åˆ

ä½¿ç”¨å¹¶æŸ¥é›†ã€‚å…¶å®ä¸éœ€è¦åƒå®˜æ–¹é¢˜è§£é‚£æ · +10000ã€‚ 

ç”±äºé¢˜ç›®æ²¡æœ‰ç›´æ¥ç»™å‡ºçŸ³å¤´çš„è¿æ¥å…³ç³»ï¼Œå¯ä»¥è®°å½•ä¸¤ä¸ªdictã€‚ 

dictçš„keyä¸ºçŸ³å¤´çš„æ¨ª/çºµåæ ‡ï¼Œvalueæ˜¯ä¸Šä¸€ä¸ªç›¸åŒæ¨ª/çºµåæ ‡çš„çŸ³å¤´çš„ç¼–å·ã€‚ 

è¿™æ ·éå†æ‰€æœ‰çŸ³å¤´ï¼Œæ¯æ¬¡ä»ä¸¤ä¸ªdictä¸­å–å‡ºä¸Šä¸€ä¸ªä¸è¯¥çŸ³å¤´æœ‰ç›¸åŒæ¨ª/çºµåæ ‡çš„çŸ³å¤´ï¼Œ

æŠŠå®ƒä»¬åœ¨å¹¶æŸ¥é›†ä¸­è¿é€šå³å¯ã€‚

    def removeStones(self, stones):
        father = range(len(stones))
        def find(x):
            if father[x] != x:
                father[x] = find(father[x])
            return father[x]
        
        def union(x, y):
            if y is not None:
                father[find(x)] = find(y)
        
        c_dict, r_dict = {}, {}
        for i in range(len(stones)):
            union(i, c_dict.get(stones[i][0]))
            c_dict[stones[i][0]] = i
            union(i, r_dict.get(stones[i][1]))
            r_dict[stones[i][1]] = i
        return len(stones) - len({find(x) for x in father})
```

```py
class DSU:
    def __init__(self,n: int):
        self.p = [i for i in range(n)]
    
    def find(self,x: int) -> int:
        if x != self.p[x]: self.p[x] = self.find(self.p[x])
        return self.p[x]
    
    def merge(self,x: int,y: int):
        rx , ry = self.find(x) , self.find(y)
        if rx == ry: return 
        self.p[rx] = ry
        return

class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        n = len(stones)
        dsu = DSU(n)
        for i in range(len(stones)):
            for j in range(i+1,len(stones)):
                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:
                    dsu.merge(i,j)
        cnt = 0
        for i in range(len(dsu.p)):
            if dsu.p[i] == i:
                cnt += 1
        return n - cnt
```

```py
è´¡çŒ®ä¸€ä¸ªpython3 80ms 97%

class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        dict_X = collections.defaultdict(list)
        dict_Y = collections.defaultdict(list)
        for x, y in stones:
            dict_X[x].append((x, y))
            dict_Y[y].append((x, y))
        visited = set()

        def dfs(node):
            if node in visited:
                return
            visited.add(node)
            x, y = node
            for i in dict_X[x]:
                dfs(i)
            for i in dict_Y[y]:
                dfs(i)
        
        ans = 0
        for i in stones:
            i = tuple(i)
            if i not in visited:
                ans += 1
                dfs(i)
        
        return len(stones) - ans
```

```py
è´¡çŒ®ä¸€ä¸ªå¹¶æŸ¥é›† Python3 76ms 96%çš„ä»£ç ã€‚ã€‚ã€‚

class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        uf = UnionFindSet()
        for s in stones:
            x, y = s[0], s[1] + 10000
            # print('add:', x, y)
            uf.add(x)
            uf.add(y)
            uf.union(x, y)
        return len(stones) - uf.count()


class UnionFindSet:

    def __init__(self):
        self.dic_set = {}
        self.sets = set()

    def add(self, x):
        if x not in self.dic_set:
            s = {x}
            self.dic_set[x] = s
            self.sets.add(id(s))
    
    def find(self, x):
        if x not in self.dic_set:
            return None
        return self.dic_set[x]
    
    def union(self, x, y):
        x_set, y_set = self.find(x), self.find(y)
        if x_set is y_set:
            return
        
        if len(x_set) < len(y_set):
            x_set, y_set = y_set, x_set

        x_set |= y_set
        for item in y_set:
            self.dic_set[item] = x_set

        self.sets.remove(id(y_set))

    def is_connected(self, x, y):
        return self.find(x) is self.find(y)

    def count(self):
        return len(self.sets)

æˆ‘åŸæ¥å°è¯•è¿‡åœ¨å¹¶æŸ¥é›†é‡ŒåŠ ä¸Š add() æ–¹æ³•ï¼Œ

åœ¨ add() æ–¹æ³•é‡Œåˆ¤æ–­æŸä¸ªé‡Œåœ¨å¹¶æŸ¥é›†é‡Œæ˜¯ä¸æ˜¯å­˜åœ¨ã€‚

åæ¥æ„Ÿè§‰å¼„ä¸ª add() æ–¹æ³•è®©å¤–éƒ¨è°ƒç”¨å¯èƒ½ä¸å¤ªå¥½ã€‚

ä½†æ˜¯æ¯æ¬¡åœ¨ find() æ–¹æ³•é‡Œé¢åˆ¤æ–­å…¶å®æ˜¯æ¯”è¾ƒä¸åˆ’ç®—çš„ã€‚é€‰æ‹©å›°éš¾å•Šã€‚

---------------------------------------

çš„ç¡®å¦‚æ­¤ï¼Œæˆ‘æ¯”è¾ƒå€¾å‘äºä¸ç»™å‡º add()æ–¹æ³•ï¼Œ

æ ¹æ®å…·ä½“é¢˜ç›®ç¼–å†™åˆå§‹åŒ–å‡½æ•°æˆ–è€… add()æ–¹æ³• ï¼›

æœ€åˆçœ‹ä½ ç¼–å†™çš„å¹¶æŸ¥é›†æ•™ç¨‹é‡Œå¤´ï¼Œå°±æ˜¯ç–‘æƒ‘å¦‚æœå…ƒç´ ä¸å­˜åœ¨äºå¹¶æŸ¥é›†é‡Œæ€ä¹ˆåŠï¼Œ

dict[x]å¦‚æœxä¸å­˜åœ¨éš¾é“ä¸å¼‚å¸¸ä¹ˆã€‚ã€‚ã€‚ç»“æœæ¸…ä¸€è‰²çš„ï¼Œå…¨æ˜¯ç”¨æ•°ç»„åˆå§‹åŒ–ã€æˆ–è€…å­—å…¸åˆå§‹åŒ–ï¼Œ

ä¿è¯äº†xå…ƒç´ å¿…ç„¶å­˜åœ¨ï¼ˆåŒæ—¶self.parent[x]ä¹Ÿå¿…ç„¶å­˜åœ¨ï¼‰ï¼ŒçœŸæ˜¯ä¸ªå¤§å¤§çš„æ€ç»´ç›²åŒºã€‚ 

ä¸è¿‡æ ¹æ®ä»Šå¤©çš„é¢˜ç›®ï¼Œæˆ‘æ€»ç»“äº†ä¸€ä¸‹é€‚åˆæˆ‘ç†è§£çš„å¹¶æŸ¥é›†æ¨¡å‹ï¼Œ

ç»™å‡ºaddæ–¹æ³•è™½ç„¶åˆå§‹åŒ–æ•ˆç‡ä¼šä½ä¸€äº›ï¼Œä½†æ˜¯ä»£ç é€»è¾‘æ¯”è¾ƒç»Ÿä¸€ï¼Œ

é›†æˆäº†å¹¶æŸ¥é›†+è·¯å¾„å‹ç¼©+æƒé‡ä¼˜åŒ–+ç»“æœé›†ï¼Œæ‰§è¡Œæ•ˆç‡ä¼šé«˜ä¸€äº›ï¼Œç»¼åˆæ¥çœ‹è¿˜æ˜¯æ¯”è¾ƒåˆé€‚çš„ã€‚
```

###  1.179. <a name='BagofTokens'></a>948 Bag of Tokens

[å°æ˜](https://www.bilibili.com/video/BV1MK411P7K6?spm_id_from=333.999.0.0)

###  1.180. <a name='LargestTimeforGivenDigits'></a>949 Largest Time for Given Digits

[å°æ˜](https://www.bilibili.com/video/BV13v41117QS?spm_id_from=333.999.0.0)

###  1.181. <a name='LargestComponentSizebyCommo'></a>952 ã€ğŸ’å¹¶æŸ¥é›†ã€‘Largest Component Size by Commo

[å°æ˜](https://www.bilibili.com/video/BV1oK4y1h7Jt?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1at411D7gp?from=search&seid=1135814820928819139&spm_id_from=333.337.0.0)

###  1.182. <a name='VerifyinganAlienDictionary'></a>953 Verifying an Alien Dictionary

[å°æ˜](https://www.bilibili.com/video/BV1C64y1S7tT?spm_id_from=333.999.0.0)

###  1.183. <a name='ArrayofDoubledPairs'></a>954 Array of Doubled Pairs

[å°æ˜](https://www.bilibili.com/video/BV1Hq4y1S7xR?spm_id_from=333.999.0.0)

###  1.184. <a name='RegionsCutBySlashes'></a>959. ã€ğŸ’å¹¶æŸ¥é›†ã€‘ç”±æ–œæ åˆ’åˆ†åŒºåŸŸ Regions Cut By Slashes

[å®˜æ–¹](https://www.bilibili.com/video/BV1Ry4y117HD?spm_id_from=333.999.0.0)

[edo](https://www.bilibili.com/video/BV1fp4y1W7eR?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14t411v7VX?from=search&seid=1135814820928819139&spm_id_from=333.337.0.0)

###  1.185. <a name='DijkstraLeastOperatorstoExpressNumber'></a>964. ã€DijkstrağŸš—ã€‘Least Operators to Express Number

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Pt411k7qn?spm_id_from=333.999.0.0)

###  1.186. <a name='VowelSpellchecker'></a>966 Vowel Spellchecker

[å°æ˜](https://www.bilibili.com/video/BV1oK4y1T7kR?spm_id_from=333.999.0.0)

###  1.187. <a name='NumbersWithSameConsecutiveDifferences'></a>967. Numbers With Same Consecutive Differences

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gt411B7oG?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def numsSameConsecDiff(self, N, K):
        ans = {x for x in range(1, 10)}
        for _ in xrange(N-1):
            ans2 = set()
            for x in ans:
                d = x % 10
                if d - K >= 0:
                    ans2.add(10*x + d-K)
                if d + K <= 9:
                    ans2.add(10*x + d+K)
            ans = ans2

        if N == 1:
            ans.add(0)

        return list(ans)

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/numbers-with-same-consecutive-differences/solution/lian-xu-chai-xiang-tong-de-shu-zi-by-leetcode-2/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def numsSameConsecDiff(self, n: int, k: int):
        def temp_class(ret,N,K):
            temp = []
            #è¿”å›æ¡ä»¶
            if N == 0:
                return [ret]
            #
            if ret%10 + K < 10:
                temp += temp_class(ret*10+ret%10+k,N-1,K)
            if ret%10 - K > -1 and K != 0:
                temp += temp_class(ret*10+ret%10-k,N-1,K)
            return temp
        #
        ret = []
        for i in range(1,10,1):
            if i + k < 10 or k - i < 10:
                ret += temp_class(i,n-1,k)
        return ret

def numsSameConsecDiff(self, N, K):
        """
        :type N: int
        :type K: int
        :rtype: List[int]
        """
        dp = set(range(10))
        for i in range(1, N):
            prev_dp = dp
            dp = set()
            for num in prev_dp:
                if num == 0:
                    continue
                left = num % 10
                if left >= K:
                    dp.add(num*10+left-K)
                if left + K <= 9:
                    dp.add(num*10+left+K)
        return sorted(list(dp))
```

```py

```

###  1.188. <a name='BinaryTreeCameras'></a>968 Binary Tree Cameras

[å°æ˜](https://www.bilibili.com/video/BV1Q5411u72B?spm_id_from=333.999.0.0)

###  1.189. <a name='PancakeSorting'></a>969 Pancake Sorting

[å°æ˜](https://www.bilibili.com/video/BV1hk4y127yJ?spm_id_from=333.999.0.0)

###  1.190. <a name='FlipBinaryTreeToMatchPreorder'></a>971 Flip Binary Tree To Match Preorder

[å°æ˜](https://www.bilibili.com/video/BV1NB4y1P7qL?spm_id_from=333.999.0.0)

###  1.191. <a name='KClosestPointstoOrigin'></a>973 K Closest Points to Origin

[å°æ˜](https://www.bilibili.com/video/BV1Vf4y1278J?spm_id_from=333.999.0.0)

###  1.192. <a name='KSubarraySumsDivisiblebyK'></a>974. å’Œå¯è¢« K æ•´é™¤çš„å­æ•°ç»„ Subarray Sums Divisible by K 

[å®˜æ–¹](https://www.bilibili.com/video/BV19z4y1X79a?spm_id_from=333.999.0.0)

###  1.193. <a name='OddEvenJump'></a>975. Odd Even Jump

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1pt411p7M4?spm_id_from=333.999.0.0)

###  1.194. <a name='MiddleoftheLinkedList-1'></a>976 Middle of the Linked List

[å°æ˜](https://www.bilibili.com/video/BV1N5411t7Xm?spm_id_from=333.999.0.0)

###  1.195. <a name='SquaresofaSortedArray'></a>977 Squares of a Sorted Array

[å°æ˜](https://www.bilibili.com/video/BV1EX4y1u7Mb?spm_id_from=333.999.0.0)

###  1.196. <a name='LongestTurbulentSubarray'></a>978. æœ€é•¿æ¹æµå­æ•°ç»„ Longest Turbulent Subarray 

[å®˜æ–¹](https://www.bilibili.com/video/BV1PV411i73Y?spm_id_from=333.999.0.0)

###  1.197. <a name='UniquePathsIII'></a>980. Unique Paths III 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yt41187Si?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1oK4y1a7Qp?spm_id_from=333.999.0.0)

```py
class Solution:
    def uniquePathsIII(self, grid):
        R, C = len(grid), len(grid[0])

        def nei***ors(r, c):
            for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):
                if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] % 2 == 0:
                    yield nr, nc

        todo = 0
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val != -1: todo += 1
                if val == 1: sr, sc = r, c
                if val == 2: tr, tc = r, c

        self.ans = 0
        def dfs(r, c, todo):
            todo -= 1
            if todo < 0: return
            if r == tr and c == tc:
                if todo == 0:
                    self.ans += 1
                return

            grid[r][c] = -1
            for nr, nc in nei***ors(r, c):
                dfs(nr, nc, todo)
            grid[r][c] = 0

        dfs(sr, sc, todo)
        return self.ans

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/unique-paths-iii/solution/bu-tong-lu-jing-iii-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

from functools import lru_cache
class Solution:
    def uniquePathsIII(self, grid):
        R, C = len(grid), len(grid[0])

        def code(r, c):
            return 1 << (r * C + c)

        def nei***ors(r, c):
            for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):
                if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] % 2 == 0:
                    yield nr, nc

        target = 0
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val % 2 == 0:
                    target |= code(r, c)

                if val == 1:
                    sr, sc = r, c
                if val == 2:
                    tr, tc = r, c

        @lru_cache(None)
        def dp(r, c, todo):
            if r == tr and c == tc:
                return +(todo == 0)

            ans = 0
            for nr, nc in nei***ors(r, c):
                if todo & code(nr, nc):
                    ans += dp(nr, nc, todo ^ code(nr, nc))
            return ans

        return dp(sr, sc, target)

ä½œè€…ï¼šLeetCode
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/unique-paths-iii/solution/bu-tong-lu-jing-iii-by-leetcode/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution:
æ­£å¸¸backtrackingåŠ ä¸Šç´¯è®¡0åˆ¤æ–­å³å¯

    def uniquePathsIII(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        # å›æº¯æ–¹å¼
        m, n = len(grid), len(grid[0])
        # æ‰€æœ‰0çš„ä¸ªæ•°
        cnt_0 = 0
        sx, sy = 0, 0
        self.ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    cnt_0 += 1
                elif grid[i][j] == 1:
                    sx, sy = i, j
        def backtracking(x, y, cum):
            # ç»ˆæ­¢æ¡ä»¶ï¼Œè¾¹ç•Œåˆ¤æ–­
            if x < 0 or x >= m or y < 0 or y >= n:
                return
            if grid[x][y] == -1 or grid[x][y] == 3:
                return
            # ç»ˆæ­¢æ¡ä»¶
            # æ‰€æœ‰0èµ°è¿‡ä¸”åˆ°äº†2çš„ä½ç½®
            if cum - 1 == cnt_0 and grid[x][y] == 2:
                self.ans += 1
                return

            # æ‰€æœ‰å¯è¡Œçš„é€‰æ‹©
            for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                nx, ny = x + dx, y + dy
                t = grid[x][y]
                # è®¿é—®è¿‡çš„æ ¼å­ä¿®æ”¹ä¸º3
                grid[x][y] = 3
                backtracking(nx, ny, cum+1)
                grid[x][y] = t

        backtracking(sx, sy, 0)
        return self.ans

class Solution:
    def uniquePathsIII(self, grid: 'm * n grid') -> int:

        self.grid, self.paths = grid, 0
        self.reset()
        self.walk(1, self.start, grid)
        return self.paths

    def reset(self):

        self.m, self.n = len(self.grid), len(self.grid[0])
        self.spaces = 0
        for i in range(self.m):
            for j in range(self.n):
                if self.grid[i][j] == 1:
                    self.start = (i, j)
                elif self.grid[i][j] == 2:
                    self.end = (i, j)
                elif not self.grid[i][j]:
                    self.spaces += 1

    def walk(self, cur_filled: int, start: '(i, j)', cur_grid: 'grid'):

        if cur_filled < self.spaces:
            for i_next, j_next in self.neighbor(start, cur_grid):
                next_start = (i_next, j_next)
                next_grid = [line[:] for line in cur_grid]
                next_grid[i_next][j_next] = 1
                if self.neighbor(self.end, next_grid) and (
                    self.neighbor(next_start, next_grid)):
                    self.walk(cur_filled + 1, next_start, next_grid)
        elif cur_filled == self.spaces:
            self.paths += 1
        else:
            self.paths = int(self.start in self.neighbor(self.end))

    def neighbor(self, center: '(i, j)', cur_grid = None) -> 'list[(i, j)]':
        '''è¿”å›(i, j)çš„ç›¸é‚»ä¸º0çš„åˆæ³•åæ ‡'''
        i, j = center
        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]
        if not i:
            neighbors.remove((i - 1, j))
        if i == self.m - 1:
            neighbors.remove((i + 1, j))
        if not j :
            neighbors.remove((i, j - 1))
        if j == self.n - 1:
            neighbors.remove((i, j + 1))

        if cur_grid:
        	neighbors = [(i, j) for i, j in neighbors if not cur_grid[i][j]]
        return neighbors
```

###  1.198. <a name='MinimumCostForTickets'></a>983 ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + é€’å½’ã€‘Minimum Cost For Tickets

[å°æ˜](https://www.bilibili.com/video/BV1Wz4y1f7hG?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1WK4y1t7pP?spm_id_from=333.999.0.0)

```py
æ‹…å¿ƒè¶Šç•Œï¼Œå¯ä»¥è¿™æ ·å†™ï¼š

class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        max_day = days[-1]
        dp = [0 for _ in range(max_day + 1)]

        for i in range(max_day + 1):
            if i not in days:
                dp[i] = dp[i - 1]
            else:
                dp[i] = min(
                    dp[max(0, i - 1)] + costs[0],
                    dp[max(0, i - 7)] + costs[1],
                    dp[max(0, i - 30)] + costs[2],
                )
        return dp[-1]

è™½ç„¶ï¼Œi - 30 å¯èƒ½è¶Šç•Œï¼Œä½†æ˜¯æ²¡å…³ç³»ï¼š

class Solution(object):
    def mincostTickets(self, days, costs):

        ans = [0]*(days[-1]+31)
        dayset = set(days)
       
        for i in range(1,len(ans)):
            if i not in dayset:
                ans[i] += ans[i-1]
            else:
                ans[i] = ans[i] = min(ans[i-1]+costs[0], ans[i-30]+costs[2],ans[i-7]+costs[1])
        return ans[-1]
```

é€’å½’æ³•

```py
class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        dayset = set(days)
        N = max(days)
        durations = [1, 7, 30]

        @lru_cache(None)
        def dp(i):
            if i > N:
                return 0
            elif i in dayset:
                return min(dp(i + d) + c for c, d in zip(costs, durations))
            else:
                return dp(i + 1)

        return dp(1)

```


###  1.199. <a name='IntervalListIntersections'></a>986 Interval List Intersections

[å°æ˜](https://www.bilibili.com/video/BV1wg4y1z7Xz?spm_id_from=333.999.0.0)

###  1.200. <a name='VerticalOrderTraversalofaBinary'></a>987 Vertical Order Traversal of a Binary

[å°æ˜](https://www.bilibili.com/video/BV1yZ4y1M7CL?spm_id_from=333.999.0.0)

###  1.201. <a name='SatisfiabilityofEqualityEquations'></a>990. ã€ğŸ’å¹¶æŸ¥é›†ã€‘ç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§ Satisfiability of Equality Equations 

[å®˜æ–¹](https://www.bilibili.com/video/BV1gz411i7kD?spm_id_from=333.999.0.0)

###  1.202. <a name='K'></a>992 ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘K ä¸ªä¸åŒæ•´æ•°çš„å­æ•°ç»„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1t44y1q7th?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1xy4y1Y7GL?spm_id_from=333.999.0.0)

```py
 ä¸€æ ·çš„æ€è·¯ã€‚hhhã€‚ å‹‰å¼ºèƒ½è¿‡ã€‚æ—¶é—´5%

class Solution:

def subarraysWithKDistinct(self, A: List[int], K: int) -> int:
    if len(set(A)) < K:
        return 0
    ret = 0
    for i in range(len(A) - K + 1):
        s = set(A[i:i+K])
        for j in range(i + K - 1, len(A)):
            if len(s) == K:
                ret += 1
            if j+1 < len(A):
                s.add(A[j+1])
            if len(s) > K:
                break
    return ret
æœ€å¥½ç†è§£çš„æ€è·¯äº†ï¼Œå¯æƒœ45/55ï¼Œä¸€æ—¶åŠä¼šä¼˜åŒ–ä¸å¥½

class Solution:
    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:
        cnt=0
        for i in range(len(A)):
            a=set()
            a.add(A[i])
            for j in range(i,len(A)):
                a.add(A[j])
                if len(a) == K:
                    cnt+=1
                elif len(a)>K:
                    break
        return(cnt)
```

```py
ä¸‰æŒ‡é’ˆ(?) éå†Aä»¥å„ä¸ªindexä½œä¸ºå·¦è¾¹ç•Œ æ¯æ¬¡è´ªå©ª+å…‹åˆ¶åœ°å¯»æ‰¾Kä¸ªä¸åŒçš„æ•°å­— O(3n)->O(n)

#python3
from collections import defaultdict
class Solution:
	def subarraysWithKDistinct(self,A,K):
		size=len(A)
		cnt1,cnt2=[defaultdict(int) for _ in range(2)]
		n1=n2=ri1=ri2=ans=0 #n1è¡¨ç¤º[le,ri1)æœ‰å¤šå°‘ä¸ªä¸åŒçš„æ•°å­— n2è¡¨ç¤º[le,ri2)æœ‰å¤šå°‘ä¸ªä¸åŒçš„æ•°å­—
		for le in A: #éå†Aä½œä¸ºå·¦è¾¹ç•Œ
			while ri1<size and n1<K: #å…‹åˆ¶ æ‰¾åˆ°Kä¸ªä¸åŒçš„æ•°å­—å°±ç«‹åˆ»åœä¸‹æ¥
				v=A[ri1]
				cnt1[v]+=1
				if cnt1[v]==1:
					n1+=1
				ri1+=1
			while ri2<size and n2<=K: #è´ªå©ª ç›´åˆ°å‡ºç°ç¬¬K+1ä¸ªä¸åŒçš„æ•°å­—æ‰åœä¸‹
				v=A[ri2]
				if not cnt2[v]:
					if n2==K:
						break
					n2+=1
				cnt2[v]+=1
				ri2+=1
			ans+=(n1==K and ri2-ri1+1)
			cnt1[le]-=1 #ä¸‹é¢å°±æ˜¯è°ƒæ•´äº†
			cnt2[le]-=1
			n1-=cnt1[le]==0
			n2-=cnt2[le]==0
		return ans
è†œæ‹œæœ€é«˜èµçš„slice111å¤§ä½¬ï¼è¿™ä¸ªå‡æ³•æˆ‘è‡ªå·±æ˜¯ç»é€¼æƒ³ä¸åˆ°çš„ã€‚

class Solution:
    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:
        return self.f(A, K)-self.f(A, K-1)
    def f(self, n, k):
        l, r, res, c = 0, 0, 0, Counter()
        while r<len(n):
            c[n[r]] += 1
            r += 1
            while len(c)>k:
                c[n[l]] -= 1
                if c[n[l]] == 0: c.pop(n[l])
                l += 1
            res += r-l+1
        return res
å‚ç…§é¢˜è§£å†™çš„pythonç‰ˆæœ¬ï¼ŒåŠ äº†ä¸€äº›è‡ªå·±çš„æ³¨é‡Š

class Solution:
	# 1. å…ˆå›ºå®šleftï¼ŒrightæŒ‡é’ˆå‘å³è¯•æ¢
	# 2. æ»¡è¶³çª—å£æ—¶ï¼Œè®°å½•ç»“æœï¼ŒåŒæ—¶ç”¨tempæŒ‡é’ˆä»leftå‘å³è¯•æ¢ï¼Œæ˜¯å¦ä»æœ‰æ»¡è¶³æ¡ä»¶çš„æƒ…å†µ
	# 3. å¤§äºçª—å£æ—¶ï¼ŒleftæŒ‡é’ˆå³ç§»ï¼Œç„¶åé‡å¤1
	
	def subarraysWithKDistinct(self, A, K: int) -> int:
		left, right = 0, 0
		res = 0
		l = len(A)

		from collections import defaultdict
		hash = defaultdict(int)  # ç”¨äºä¿ç•™Kä¸ªä¸é‡å¤æ•°å­—çš„çª—å£
		while right < l:
			hash[A[right]] += 1
			right += 1

			# 1.å½“çª—å£å¤§äºKä¸ªä¸é‡å¤æ•°å­—æ—¶ï¼ŒleftæŒ‡é’ˆå³ç§»ï¼Œhashè¡¨æ›´æ–°
			while len(hash) > K:
				if hash[A[left]] > 1:
					hash[A[left]] -= 1
				else:
					hash.pop(A[left])
				left += 1

			temp = left
			# 2.æ­£å¥½æœ‰Kä¸ªä¸é‡å¤æ•°å­—æ—¶ï¼Œè®°å½•ç»“æœ
			#   åŒæ—¶ç”¨tempæŒ‡é’ˆä»leftå‘å³ç§»åŠ¨ï¼Œçœ‹æ˜¯å¦ä¾æ—§æ»¡è¶³ï¼Œæ»¡è¶³åˆ™res+1
			while len(hash) == K:
				res += 1
				if hash[A[temp]] > 1:
					hash[A[temp]] -= 1
				else:
					hash.pop(A[temp])
				temp += 1

			# 3.å°†hashè¡¨æ¢å¤æˆåŸæ ·ï¼Œä»¥è¿›ä¸€æ­¥å‘å³ç§»åŠ¨rightåšå‡†å¤‡
			while temp > left:
				hash[A[temp - 1]] += 1
				temp -= 1
		return res
å‚è€ƒ @Linder

class Solution:
    def subarraysWithKDistinct(self, A, K: int) -> int:
        left, right = 0, 0
        res = 0
        N = len(A)

        window = collections.defaultdict(int)  # ç”¨äºä¿ç•™Kä¸ªä¸é‡å¤æ•°å­—çš„çª—å£
        count = 0   # ç”¨äºè¡¨ç¤ºå½“å‰[left, right]æœ‰å¤šå°‘ä¸ªä¸é‡å¤æ•°å­— 

        while right < N:
            if window[A[right]] == 0:
                count += 1
            window[A[right]] += 1
            # 1.å½“çª—å£å¤§äºKä¸ªä¸é‡å¤æ•°å­—æ—¶ï¼ŒleftæŒ‡é’ˆå³ç§»
            while count > K:
                window[A[left]] -= 1
                if window[A[left]] == 0:
                    count -= 1
                left += 1

            temp = left # ä¸´æ—¶æŒ‡é’ˆï¼Œè¿™ä¸ªè®°å½•ä¸€ä¸‹å¯¹äºåŒä¸€ä¸ªrightï¼Œæœ‰å¤šå°‘ä¸ªå€™é€‰çš„leftä¹Ÿæ»¡è¶³æ¡ä»¶
            # 2.æ­£å¥½æœ‰Kä¸ªä¸é‡å¤æ•°å­—æ—¶ï¼Œè®°å½•ç»“æœ
            #   åŒæ—¶ç”¨tempæŒ‡é’ˆä»leftå‘å³ç§»åŠ¨ï¼Œçœ‹æ˜¯å¦ä¾æ—§æ»¡è¶³ï¼Œæ»¡è¶³åˆ™res+1
            while count == K:
                res += 1
                window[A[temp]] -= 1
                if window[A[temp]] == 0:
                    count -= 1
                temp += 1

            # 3.å°†æŒ‡é’ˆå’Œwindowä»¥åŠcountæ¢å¤æˆåŸæ ·ï¼Œä»¥è¿›ä¸€æ­¥å‘å³ç§»åŠ¨rightåšå‡†å¤‡
            while temp > left:
                if window[A[temp - 1]] == 0:
                    count += 1
                window[A[temp - 1]] += 1
                temp -= 1
            
            right += 1

        return res
```

###  1.203. <a name='-1'></a>993. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹

[å°æ˜](https://www.bilibili.com/video/BV17t4y11725?spm_id_from=333.999.0.0)

###  1.204. <a name='-1'></a>994-è…çƒ‚çš„æ©˜å­

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Yp4y1D7Kg?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1bB4y1A7tG?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Qk4y1m7fz?spm_id_from=333.999.0.0)

```py
Python3:ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå…ˆæŠŠè…çƒ‚çš„æ©˜å­ï¼ˆçš„åæ ‡ï¼‰ä¾æ¬¡å…¥é˜Ÿï¼Œç„¶åä»é˜Ÿå¤´å¼€å§‹ï¼Œå¼¹å‡ºä¸€ä¸ªè…çƒ‚çš„æ©˜å­ï¼ŒåŒæ—¶å°†å…¶å››å‘¨çš„å¥½æ©˜å­è…èš€å¹¶å…¥é˜Ÿï¼Œæ—¶é—´time+1ï¼Œä¾æ¬¡è¿›è¡Œç›´åˆ°é˜Ÿç©ºï¼Œæœ€åå¦‚æœgridä¸­å¥½æœ‰å¥½æ©˜å­åˆ™è¿”å›-1ï¼Œå¦åˆ™è¿”å›time

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        x,y,time = len(grid),len(grid[0]),0
        D,queue = [[-1,0],[0,-1],[0,1],[1,0]],[]  #å››ä¸ªæ–¹å‘çš„åæ ‡å’Œé˜Ÿåˆ—
        for i in range(x):
            for j in range(y):
                if grid[i][j] == 2:
                    queue.append((i,j,0))
        while queue:  
            i,j,time = queue.pop(0)
            for d in D:
                loc_i,loc_j = i+d[0],j+d[1]
                if 0 <=loc_i<x and 0<=loc_j<y and grid[loc_i][loc_j]==1:
                    grid[loc_i][loc_j] = 2
                    queue.append((loc_i,loc_j,time+1))
        for g in grid:  
            if 1 in g:
                return -1
        return time
æ€è·¯ï¼š è¿™ç§éœ€è¦ä¸€åœˆä¸€åœˆå¾€å¤–ä¼ æ’­çš„ä¸€èˆ¬ç”¨BFSè§£ï¼Œ å…ˆæ‰¾åˆ°èµ·å§‹æ‰€æœ‰è…çƒ‚çš„æ©˜å­ï¼Œç„¶åå¾ªç¯å¤„ç†ï¼ŒæŠŠæ–°è…çƒ‚çš„æ©˜å­åŠ å…¥ä¸‹ä¸€æ¬¡å¾ªç¯çš„é˜Ÿåˆ—ä¸­ï¼Œ å½“ä¸‹ä¸€æ¬¡å¾ªç¯çš„é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œè¯´æ˜ä¸èƒ½ç»§ç»­è…çƒ‚äº†ï¼Œ åˆ¤æ–­ä¸€ä¸‹è¿˜æœ‰æ²¡æœ‰æ–°é²œçš„æ©˜å­ï¼Œå¦‚æœæœ‰ï¼Œå°±è¿”å›-1ï¼Œå¦åˆ™è¿”å›åˆ†é’Ÿæ•°

class Solution(object):
    def orangesRotting(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        dx = [1, -1, 0, 0]
        dy = [0, 0, 1, -1]
        rotlist = list()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 2:
                    rotlist.append([i, j])
        minute = 0
        while(rotlist): #BFSå¾ªç¯
            newrotlist = list()
            for rotnode in rotlist:
                x0 = rotnode[0]
                y0 = rotnode[1]
                
                for k in range(4):
                    x = x0 + dx[k]
                    y = y0 + dy[k]
                    
                    if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1:
                        grid[x][y] = 2
                        newrotlist.append([x,y])
            if not newrotlist:
                break
                
            rotlist = newrotlist[:]
            minute += 1
            
        for row in grid:
            for i in row:
                if i == 1:#è¿˜æœ‰æ–°é²œçš„
                    return -1
        return minute
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])

        # queue - all starting cells with rotting oranges
        queue = collections.deque()
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == 2:
                    queue.append((r, c, 0))

        def neighbors(r, c) -> (int, int):
            for nr, nc in ((r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1)):
                if 0 <= nr < R and 0 <= nc < C:
                    yield nr, nc

        d = 0
        while queue:
            r, c, d = queue.popleft()
            for nr, nc in neighbors(r, c):
                if grid[nr][nc] == 1:
                    grid[nr][nc] = 2
                    queue.append((nr, nc, d + 1))

        if any(1 in row for row in grid):
            return -1
        return d

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/rotting-oranges/solution/fu-lan-de-ju-zi-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
ç®€å•é¢˜

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])
        ones = sum([1 for i in range(n) for j in range(m) if grid[i][j] == 1])
        twos = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 2]
        queue = deque(twos)
        visited = set(twos)
        ans = count = 0
        while queue:
            flag = 0
            for _ in range(len(queue)):
                x, y = queue.popleft()
                for new_x, new_y in [(x+1, y), (x-1, y), (x, y-1), (x, y+1)]:
                    if 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] == 1 and (new_x, new_y) not in visited:
                        if flag == 0: # æ ‡è®°è¿™è½®æœ‰æ²¡æœ‰1å˜æˆ2ï¼Œå¦‚æœæœ‰ï¼Œans+1
                            ans += 1
                            flag = 1
                        visited.add((new_x, new_y))
                        count += 1
                        queue.append((new_x, new_y))
        if count != ones: return -1
        else: return ans
é¢˜è¦æœ‰æ€è·¯çœŸçš„å¾ˆå®¹æ˜“ é¦–å…ˆç»Ÿè®¡æ‰€æœ‰æ–°é²œçš„æ©˜å­åæ ‡ä¸ºfreshåˆ—è¡¨ï¼Œé¿å…åç»­åå¤éå†æ•´ä¸ªçŸ©é˜µã€‚ å¯¹freshåˆ—è¡¨è¿›è¡Œåˆ¤å®šæ˜¯å¦ç¬¦åˆè…çƒ‚æ¡ä»¶ï¼Œæ˜¯çš„è¯åŠ å…¥rotåˆ—è¡¨ï¼Œä¸æ˜¯åŠ å…¥freshnewåˆ—è¡¨ï¼Œå½“freshnewåˆ—è¡¨é•¿åº¦ç­‰äºfreshåˆ—è¡¨çš„é•¿åº¦æ—¶ï¼Œè®¤ä¸ºæ²¡ç”¨æ©˜å­è¿›ä¸€æ­¥è…çƒ‚è¿”å›-1ï¼Œå¦åˆ™freshnewä¸ºæ–°çš„freshåˆ—è¡¨

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        ischange = False
        fresh = []
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    fresh.append([i, j])
        loop = 0
        while len(fresh)>0:
            loop += 1
            fresh_new = []
            rot = []
            for i,j in fresh:
                if (i-1>=0 and grid[i-1][j] == 2) or (j-1>=0 and grid[i][j-1] == 2) or (j+1<len(grid[0]) and grid[i][j+1] == 2) or (i+1<len(grid) and grid[i+1][j] == 2):
                    rot.append([i, j])
                else:
                    fresh_new.append([i, j])
            if len(fresh_new) == len(fresh):
                return -1
            for i,j in rot:
                grid[i][j] = 2
            fresh = fresh_new
        return loop
```

###  1.205. <a name='-1'></a>993, 994, 995, 996

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1bb41117PB?spm_id_from=333.999.0.0)

###  1.206. <a name='FindtheTownJudge'></a>997 Find the Town Judge

[å°æ˜](https://www.bilibili.com/video/BV1Ka4y1i7Qt?spm_id_from=333.999.0.0)

###  1.207. <a name='MinimumCosttoMergeStones'></a>1000. Minimum Cost to Merge Stones

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1db411v7DG?spm_id_from=333.999.0.0)

###  1.208. <a name='GridIllumination'></a>1001 Grid Illumination

[å°æ˜](https://www.bilibili.com/video/BV1NT4y1V7Vk?spm_id_from=333.999.0.0)

###  1.209. <a name='III'></a>1004-æœ€å¤§è¿ç»­1çš„ä¸ªæ•° III

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Zg411L7Qu?spm_id_from=333.999.0.0)

###  1.210. <a name='MinimumDominoRotationsForEq'></a>1007 Minimum Domino Rotations For Eq

[å°æ˜](https://www.bilibili.com/video/BV1br4y1w7TM?spm_id_from=333.999.0.0)

###  1.211. <a name='ConstructBinarySearchTreefrom'></a>1008 Construct Binary Search Tree from

[å°æ˜](https://www.bilibili.com/video/BV1yk4y1R7oF?spm_id_from=333.999.0.0)

###  1.212. <a name='ComplementofBase10Integer'></a>1009 Complement of Base 10 Integer

[å°æ˜](https://www.bilibili.com/video/BV1oK4y187ZM?spm_id_from=333.999.0.0)

###  1.213. <a name='PairsofSongsWithTotalDurations'></a>1010 Pairs of Songs With Total Durations 

[å°æ˜](https://www.bilibili.com/video/BV1t64y1f7hc?spm_id_from=333.999.0.0)

###  1.214. <a name='PartitionArrayIntoThreePartsWithEqu'></a>1013. å°†æ•°ç»„åˆ†æˆå’Œç›¸ç­‰çš„ä¸‰ä¸ªéƒ¨åˆ† Partition Array Into Three Parts With Equ

[å®˜æ–¹](https://www.bilibili.com/video/BV1ZK4y1t7Sf?spm_id_from=333.999.0.0)

###  1.215. <a name='SmallestIntegerDivisiblebyK'></a>1015 Smallest Integer Divisible by K

[å°æ˜](https://www.bilibili.com/video/BV1PZ4y1G7iU?spm_id_from=333.999.0.0)

###  1.216. <a name='NextGreaterNodeInLinkedList'></a>1019. Next Greater Node In Linked List

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV12b411s77J?spm_id_from=333.999.0.0)

###  1.217. <a name='SumofRootToLeafBinaryNumbers'></a>1022 Sum of Root To Leaf Binary Numbers

[å°æ˜](https://www.bilibili.com/video/BV11A411E7AN?spm_id_from=333.999.0.0)

###  1.218. <a name='-1'></a>1025,1026,1027,1028

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Nb411j7qr?spm_id_from=333.999.0.0)

###  1.219. <a name='VideoStitching'></a>1024. Video Stitching

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1kb411u7Qk?spm_id_from=333.999.0.0)

###  1.220. <a name='MaximumDifferenceBetweenNod'></a>1026 Maximum Difference Between Nod

[å°æ˜](https://www.bilibili.com/video/BV1fi4y157ZS?spm_id_from=333.999.0.0)

###  1.221. <a name='TwoCityScheduling'></a>1029 Two City Scheduling

[å°æ˜](https://www.bilibili.com/video/BV1t54y1Q7G8?spm_id_from=333.999.0.0)

###  1.222. <a name='StreamofCharacters'></a>1032 Stream of Characters

[å°æ˜](https://www.bilibili.com/video/BV15T4y1L7RG?spm_id_from=333.999.0.0)

###  1.223. <a name='UncrossedLines'></a>1035 Uncrossed Lines

[å°æ˜](https://www.bilibili.com/video/BV1si4y1s79e?spm_id_from=333.999.0.0)

###  1.224. <a name='RobotBoundedInCircle'></a>1041 Robot Bounded In Circle

[å°æ˜](https://www.bilibili.com/video/BV1dk4y1y7RH?spm_id_from=333.999.0.0)

###  1.225. <a name='PartitionArrayforMaximumSum'></a>1043. Partition Array for Maximum Sum

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV154411J7so?spm_id_from=333.999.0.0)

###  1.226. <a name='LongestDuplicateSubstring'></a>1044 Longest Duplicate Substring

[å°æ˜](https://www.bilibili.com/video/BV1Kv411B7a3?spm_id_from=333.999.0.0)

###  1.227. <a name='LastStoneWeight'></a>1046 Last Stone Weight

[å°æ˜](https://www.bilibili.com/video/BV1w54y197Ln?spm_id_from=333.999.0.0)

###  1.228. <a name='LongestStringChain'></a>1048 Longest String Chain

[å°æ˜](https://www.bilibili.com/video/BV17K4y1G7et?spm_id_from=333.999.0.0)



###  1.229. <a name='ShortestWaytoFormString'></a>1055.Shortest Way to Form String å½¢æˆå­—ç¬¦ä¸²çš„æœ€çŸ­è·¯å¾„

[å›¾çµ](https://www.bilibili.com/video/BV1SZ4y1G7WX?spm_id_from=333.999.0.0)

###  1.230. <a name='-1'></a>1091-äºŒè¿›åˆ¶çŸ©é˜µä¸­çš„æœ€çŸ­è·¯å¾„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV17k4y1r7EP?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ro4y197kU?spm_id_from=333.999.0.0)

```py
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        l = len(grid)
        if grid[0][0] != 0 or grid[l-1][l-1] != 0:  #å¤„ç†ç‰¹æ®Šæƒ…å†µ
            return -1
        if l == 1:
            return 1

        visited = set((0,0)) #å­˜æ”¾å·²éå†çš„ä½ç½®çš„é›†åˆ
        Q  = collections.deque([(0,0)])  #å­˜æ”¾æ¥ä¸‹æ¥ä¸€è½®çš„åœ°å€
        Q2 = collections.deque([])       #åœ¨ä¸€è½®ä¸­æš‚å­˜æ‰€æœ‰çš„ä½ç½®
        ans = 0

        while Q:
            ans += 1
            while Q:  #é¦–å…ˆæŠŠæ­¤è½®ä¸­Qå†…æ‰€æœ‰ç‚¹çš„å‘¨å›´éå†è¿‡å»ï¼Œä¸ºäº†æ–¹ä¾¿è®°å½•ansï¼Œæ¯æ¬¡éƒ½éå†å®Œåï¼Œæ‰æŠŠæ–°çš„ç‚¹é‡æ–°åŠ å…¥
                i, j = Q.popleft()
                if i == l-1 and j == l-1:   #å‘ç°å·²ç»æ‰¾åˆ°ç»ˆç‚¹ï¼Œé‚£å°±å¯ä»¥ç›´æ¥è¿”å›äº†
                    return ans
                for (x, y) in [(i-1,j),(i+1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    if (x,y) not in visited and l>x>=0 and l>y>=0:
                        if grid[x][y] == 0:
                            visited.add((x,y))
                            Q2.append((x,y))
            while Q2:   #æŠŠQ2ä¸­çš„ä¸‹ä¸€è½®éœ€è¦éå†çš„ç‚¹åŠ å›åˆ°Qä¸­
                Q.append(Q2.popleft())
        return -1   #éå†å®Œäº†è¿˜æ²¡åˆ°è¾¾ç»ˆç‚¹ï¼Œè¯´æ˜æ ¹æœ¬æ— æ³•è¿‡æ¥

ä½œè€…ï¼šbluegreenred
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/shortest-path-in-binary-matrix/solution/1091-er-jin-zhi-ju-zhen-zhong-de-zui-dua-vgdw/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

æ–¹æ³•äºŒï¼šDFS
å¤ªæ…¢äº†ï¼Œæ— æ³•AC


class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        l = len(grid)
        if grid[0][0] != 0 or grid[l-1][l-1]:
            return -1
        if len(grid) == 1 and len(grid[0]) == 1:
            return 1
        self.ans = len(grid) * len(grid)
        def dfs(i, j, visited, path):
            if i == len(grid) - 1 and j == len(grid) - 1:
                self.ans = min(self.ans, path)
            else:
                visited2 = deepcopy(visited)
                visited2.add((i,j))
                for (x, y) in [(i-1,j),(i+1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    if (x,y) not in visited and l>x>=0 and l>y>=0:
                        if grid[x][y] == 0:
                            dfs(x, y, visited2, path+1)

        v = set()
        dfs(0, 0, v, 1)
        return self.ans if self.ans != len(grid) * len(grid) else -1

ä½œè€…ï¼šbluegreenred
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/shortest-path-in-binary-matrix/solution/1091-er-jin-zhi-ju-zhen-zhong-de-zui-dua-vgdw/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
æ–¹æ³•ä¸€ï¼šBFS é¦–å…ˆå¤„ç†ä¸€ä¸‹ç‰¹æ®Šæƒ…å†µï¼šï¼ˆ1ï¼‰èµ·ç‚¹æˆ–ç»ˆç‚¹ä¸ä¸º0ï¼›ï¼ˆ2ï¼‰çŸ©é˜µåªæœ‰ä¸€ä¸ªæ•°

ç„¶åï¼Œç”¨ä¸€ä¸ªé˜Ÿåˆ—Qæ¥å­˜å‚¨å½“å‰æ­¥æ•°æ—¶æ‰€æœ‰çš„ç‚¹

ç„¶åéå†Qä¸­æ‰€æœ‰çš„ç‚¹ï¼Œç”¨Q2è®°å½•è¿™äº›ç‚¹é™„è¿‘çš„å¯ä»¥åˆ°è¾¾çš„ç‚¹

å½“Qéå†å®Œæ—¶æŠŠè¿™äº›Q2çš„ç‚¹é‡æ–°åŠ å…¥è¿›Qï¼ˆä¸ºäº†æ–¹ä¾¿è®°å½•ansï¼‰

å½“å‘ç°Qä¸­çš„ç‚¹å·²ç»æœ‰åˆ°è¾¾ç»ˆç‚¹çš„æ—¶å€™ï¼Œç›´æ¥è¿”å›ansï¼Œè¿™æ—¶çš„anså°±æ˜¯æœ€çŸ­è·¯å¾„

å¦‚æœéå†å®Œå‘ç°è¿˜æ²¡æœ‰ç‚¹åˆ°è¾¾ç»ˆç‚¹ï¼Œé‚£å°±è¯´æ˜ä¸å­˜åœ¨è¿™æ ·çš„è·¯å¾„ï¼Œè¿”å›-1

class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        l = len(grid)
        if grid[0][0] != 0 or grid[l-1][l-1] != 0:  #å¤„ç†ç‰¹æ®Šæƒ…å†µ
            return -1
        if l == 1:
            return 1

        visited = set((0,0)) #å­˜æ”¾å·²éå†çš„ä½ç½®çš„é›†åˆ
        Q  = collections.deque([(0,0)])  #å­˜æ”¾æ¥ä¸‹æ¥ä¸€è½®çš„åœ°å€
        Q2 = collections.deque([])       #åœ¨ä¸€è½®ä¸­æš‚å­˜æ‰€æœ‰çš„ä½ç½®
        ans = 0

        while Q:
            ans += 1
            while Q:  #é¦–å…ˆæŠŠæ­¤è½®ä¸­Qå†…æ‰€æœ‰ç‚¹çš„å‘¨å›´éå†è¿‡å»ï¼Œä¸ºäº†æ–¹ä¾¿è®°å½•ansï¼Œæ¯æ¬¡éƒ½éå†å®Œåï¼Œæ‰æŠŠæ–°çš„ç‚¹é‡æ–°åŠ å…¥
                i, j = Q.popleft()
                if i == l-1 and j == l-1:   #å‘ç°å·²ç»æ‰¾åˆ°ç»ˆç‚¹ï¼Œé‚£å°±å¯ä»¥ç›´æ¥è¿”å›äº†
                    return ans
                for (x, y) in [(i-1,j),(i+1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    if (x,y) not in visited and l>x>=0 and l>y>=0:
                        if grid[x][y] == 0:
                            visited.add((x,y))
                            Q2.append((x,y))
            while Q2:   #æŠŠQ2ä¸­çš„ä¸‹ä¸€è½®éœ€è¦éå†çš„ç‚¹åŠ å›åˆ°Qä¸­
                Q.append(Q2.popleft())
        return -1   #éå†å®Œäº†è¿˜æ²¡åˆ°è¾¾ç»ˆç‚¹ï¼Œè¯´æ˜æ ¹æœ¬æ— æ³•è¿‡æ¥
æ–¹æ³•äºŒï¼šDFS ä¹Ÿæ˜¯ä¸æ–­æ·±å…¥å»æ‰¾ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦å¾ˆé«˜ï¼Œæ— æ³•AC

class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        l = len(grid)
        if grid[0][0] != 0 or grid[l-1][l-1]:
            return -1
        if len(grid) == 1 and len(grid[0]) == 1:
            return 1
        self.ans = len(grid) * len(grid)
        def dfs(i, j, visited, path):
            if i == len(grid) - 1 and j == len(grid) - 1:
                self.ans = min(self.ans, path)
            else:
                visited2 = deepcopy(visited)
                visited2.add((i,j))
                for (x, y) in [(i-1,j),(i+1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    if (x,y) not in visited and l>x>=0 and l>y>=0:
                        if grid[x][y] == 0:
                            dfs(x, y, visited2, path+1)

        v = set()
        dfs(0, 0, v, 1)
        return self.ans if self.ans != len(grid) * len(grid) else -1

```

###  1.231. <a name='CarPooling'></a>1094 Car Pooling

[å°æ˜](https://www.bilibili.com/video/BV1Xk4y1k7UX?spm_id_from=333.999.0.0)

###  1.232. <a name='FindinMountainArray'></a>1095. Find in Mountain Array

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1m5411V7x7?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1GK4115778?spm_id_from=333.999.0.0)

```py
def binary_search(mountain, target, l, r, key=lambda x: x):
    target = key(target)
    while l <= r:
        mid = (l + r) // 2
        cur = key(mountain.get(mid))
        if cur == target:
            return mid
        elif cur < target:
            l = mid + 1
        else:
            r = mid - 1
    return -1

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        l, r = 0, mountain_arr.length() - 1
        while l < r:
            mid = (l + r) // 2
            if mountain_arr.get(mid) < mountain_arr.get(mid + 1):
                l = mid + 1
            else:
                r = mid
        peak = l
        index = binary_search(mountain_arr, target, 0, peak)
        if index != -1:
            return index
        index = binary_search(mountain_arr, target, peak + 1, mountain_arr.length() - 1, lambda x: -x)
        return index

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/find-in-mountain-array/solution/shan-mai-shu-zu-zhong-cha-zhao-mu-biao-zhi-by-leet/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
å¥½å­©å­ä¸è¦å­¦

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        try:
            return mountain_arr._MountainArray__secret.index(target)
        except:
            return -1

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        n = mountain_arr.length()
        l, r = 0, n - 1
        
        # äºŒåˆ†å¯»æ‰¾å±±é¡¶(162ï¼Œå¯»æ‰¾å³°å€¼)
        while(l < r):
            mid = (l + r + 1) >> 1
            # å·¦è¾¹æœ‰åºï¼Œ å¯ä»¥æ’é™¤ 0 ~ i -1
            if mountain_arr.get(mid) > mountain_arr.get(mid - 1):
                l = mid
            else:
                r = mid - 1

        top_idx = l

        # # åœ¨å·¦è¾¹å¯»æ‰¾ >= target çš„å·¦è¾¹ç•Œ
        l, r = 0, top_idx
        while(l < r):
            mid = (l + r) >> 1
            if mountain_arr.get(mid) >= target:
                r = mid
            else:
                l = mid + 1

        # åˆšå¥½ç­‰äº target, ç›´æ¥è¿”å›
        if (mountain_arr.get(l) == target):
            return l

        # å³è¾¹æ‰¾ <= target çš„å·¦è¾¹ç•Œ
        l, r = top_idx, n - 1
        while(l < r):
            mid = (l + r) >> 1 
            if mountain_arr.get(mid) <= target:
                r = mid
            else:
                l = mid + 1

        return l if mountain_arr.get(l) == target else -1
```

###  1.233. <a name='FillingBookcaseShelves'></a>1105. Filling Bookcase Shelves

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Mx411X7Ks?spm_id_from=333.999.0.0)

###  1.234. <a name='ParsingABooleanExpression'></a>1106. Parsing A Boolean Expression

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Cx411X7aF?spm_id_from=333.999.0.0)

###  1.235. <a name='DeleteNodesAndReturnForest'></a>1110. Delete Nodes And Return Forest

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1u4411977H?spm_id_from=333.999.0.0)

###  1.236. <a name='MaximumNestingDepthofTwoValidParentheses'></a>1111. æœ‰æ•ˆæ‹¬å·çš„åµŒå¥—æ·±åº¦ Maximum Nesting Depth of Two Valid Parentheses

[å®˜æ–¹](https://www.bilibili.com/video/BV11a4y1v7Bb?spm_id_from=333.999.0.0)

###  1.237. <a name='threading'></a>1114 - 1115 - 1116 - å¤šçº¿ç¨‹ threading

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV12t411P79a?spm_id_from=333.999.0.0)

###  1.238. <a name='LowestCommonAncestorofDeepestLeaves'></a>1123.Lowest Common Ancestor of Deepest Leavesæœ€æ·±å¶èŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–

[å°æ˜](https://www.bilibili.com/video/BV16f4y1q7eA?spm_id_from=333.999.0.0)

###  1.239. <a name='LongestWell-PerformingInterval'></a>1124. Longest Well-Performing Interval

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Et41157Jw?spm_id_from=333.999.0.0)

###  1.240. <a name='SmallestSufficientTeam'></a>1125. Smallest Sufficient Team

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14t411G7WL?spm_id_from=333.999.0.0)

###  1.241. <a name='NumberofEquivalentDominoPairs'></a>1128. ç­‰ä»·å¤šç±³è¯ºéª¨ç‰Œå¯¹çš„æ•°é‡ Number of Equivalent Domino Pairs

[å®˜æ–¹](https://www.bilibili.com/video/BV1fV411q7ZY?spm_id_from=333.999.0.0)

###  1.242. <a name='ShortestPathwithAlternatingColors'></a>1129. Shortest Path with Alternating Colors

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Et411J7Dh?spm_id_from=333.999.0.0)

###  1.243. <a name='N-thTribonacciNumber'></a>1137. N-th Tribonacci Number

[3:55 èŠ±èŠ±é…± DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

###  1.244. <a name='StoneGameII'></a>1140. Stone Game II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Gt411c7hM?spm_id_from=333.999.0.0)

###  1.245. <a name='LongestCommonSubsequence'></a>1143 ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ã€‘Longest Common Subsequence

####  1.245.1. <a name='516'></a>ç±»ä¼¼é¢˜ç›®ï¼š516æœ€é•¿å›æ–‡å­åºåˆ—

[å°æ˜](https://www.bilibili.com/video/BV19Z4y1W7Xi?spm_id_from=333.999.0.0)

```py
åšäº†å‡ ä¸ªdpçš„é¢˜ä¹‹åï¼Œæ€»ç»“äº†dpéœ€è¦æ³¨æ„çš„å‡ ä¸ªè¦ç´ ï¼š

1ã€ æ˜ç¡®dpäºŒç»´æ•°ç»„è¡¨ç¤ºçš„å«ä¹‰

2ã€ base case

3ã€ çŠ¶æ€çš„è½¬ç§»ï¼šå¯¹äº`å›æ–‡/LCS`ä¹‹ç±»çš„é—®é¢˜åˆ™æ˜¯è€ƒè™‘å½“å‰å­—ä¸²å’Œå·²ç»è®¡ç®—è¿‡çš„å­ä¸²ä¹‹é—´çš„å…³ç³»

4ã€ ç”±`çŠ¶æ€çš„è½¬ç§»`æ¥ç¡®å®š loopçš„è¾¹ç•Œ

5ã€ ç”±loopçš„è¾¹ç•Œ`æ‰“å‡ºè¡¨æ ¼` å¯å¾—å‡ºæœ€åä¸€ä¸ªdpçš„çŠ¶æ€å€¼ï¼Œå³ç»“æœã€‚


class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0] * (len(text2)+1) for _ in range(len(text1)+1)]
        for i in range(1, len(text1)+1): 
            for j in range(1, len(text2)+1): 
                if text1[i-1] == text2[j-1]: 
                    dp[i][j] = dp[i-1][j-1] + 1 
                else: 
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]

python ä¸€ç»´æ•°ç»„ï¼Œ æ±‚èµ

class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n1, n2 = len(text1), len(text2)
        pre = [0 for _ in range(n2 + 1)]
        dp = [0 for _ in range(n2 + 1)]
        for i in range(n1):
            for j in range(1, n2 + 1):
                if text1[i] == text2[j-1]:
                    dp[j] = pre[j-1] + 1
                else:
                    dp[j] = max(pre[j], dp[j-1])
                pre[j-1] = dp[j-1]
                # è¿™é‡Œä¸ºä»€ä¹ˆä¸æ˜¯ç›´æ¥pre[j] = dp[j]ï¼Œè€Œç”¨äº†pre[j-1] = dp[j-1] å‘¢ï¼Ÿè°¢è°¢
                # æ˜ç™½äº†ï¼Œå› ä¸ºæ±‚è§£dp[j]çš„æ—¶å€™éœ€è¦ç”¨åˆ°pre[j-1]æ‰€ä»¥è¦æ¨è¿Ÿæ›´æ–°ï¼Œæå‰æ›´æ–°å°±å‡ºé”™äº†ã€‚è°¢è°¢~
            pre[j] = dp[j]
        return dp[-1]
```



```scala


  object Solution {
    def longestCommonSubsequence(text1: String, text2: String): Int = {
      val m = text1.length
      val n = text2.length
      //val dp = Array.ofDim[Int](1001,1001)
      val dp = Array.fill(1001,1001)(0)
      for (i<- 1 to m) { // must have space?
        for (j<- 1 to n) {
          dp(i)(j) = if (text1(i-1)== text2(j-1)) dp(i-1)(j-1)+1 else Math.max(dp(i-1)(j),dp(i)(j-1))
        }
      }
      dp(m)(n)
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.longestCommonSubsequence("abcde", "ace") == 3)
    }
    val name = "1143 Longest common sequence"
  }

```

###  1.246. <a name='BinaryTreeColoringGame'></a>1145. Binary Tree Coloring Game

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ft411K7Gf?spm_id_from=333.999.0.0)

###  1.247. <a name='NumberofDiceRollsWithTargetSum'></a>1155. Number of Dice Rolls With Target Sum

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1t4411Q7JN?spm_id_from=333.999.0.0)

###  1.248. <a name='FindWordsThatCanBeFormedbyCharacters'></a>1160. æ‹¼å†™å•è¯ Find Words That Can Be Formed by Characters 

[å®˜æ–¹](https://www.bilibili.com/video/BV1Lt4y1Q7Yx?spm_id_from=333.999.0.0)

###  1.249. <a name='DinnerPlateStacks'></a>1172. Dinner Plate Stacks

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1E4411z7xb?spm_id_from=333.999.0.0)

###  1.250. <a name='NumberofValidWordsforEachPuzzle'></a>1178. Number of Valid Words for Each Puzzle

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1x441117vz?spm_id_from=333.999.0.0)

###  1.251. <a name='MakeArrayStrictlyIncreasing'></a>1187. Make Array Strictly Increasing

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1sJ411N7jD?spm_id_from=333.999.0.0)

###  1.252. <a name='K-ConcatenationMaximumSum'></a>1191. K-Concatenation Maximum Sum

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1AJ411w756?spm_id_from=333.999.0.0)

###  1.253. <a name='UglyNumberIII'></a>1201. Ugly Number III

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1QJ411M7Jx?spm_id_from=333.999.0.0)

###  1.254. <a name='SmallestStringWithSwaps'></a>1202. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Smallest String With Swaps

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1PJ411T7Wq?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Yh41127VH?spm_id_from=333.999.0.0)

```py
class UF:
    def __init__(self, n): self.p = list(range(n))
    def union(self, x, y): self.p[self.find(x)] = self.find(y)
    def find(self, x):
        if x != self.p[x]: self.p[x] = self.find(self.p[x])
        return self.p[x]
```

```py
æ¥ä¸ªpythonç‰ˆæœ¬çš„ï¼Œç¬¬ä¸‰æ­¥çš„åˆ†ç»„æ’åºä¸åŒï¼Œæˆ‘ç”¨çš„æ˜¯O(N)çš„åŸºæ•°æ’åº

def find(u, parents):
    if parents[u] == u:
        return u
    parents[u] = find(parents[u], parents) # è·¯å¾„å‹ç¼©
    return parents[u]
def union(u, v, ranks, parents):
    pu, pv = find(u, parents), find(v, parents)
    if pu == pv:
        return False
    ru, rv = ranks[pu], ranks[pv] # æŒ‰ç§©åˆå¹¶
    if ru > rv:
        parents[pv] = pu
    elif rv > ru:
        parents[pu] = pv
    else:
        parents[pv] = pu
        ranks[pu] += 1
    return True

class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        parents = [i for i in range(len(s))]
        ranks = [0] * len(s)

        for u, v in pairs:
            union(u, v, ranks, parents)  # åˆå¹¶

        groups = {}
        for i in range(len(s)):
            groups.setdefault(find(i, parents), [0]*26)[ord(s[i])-ord('a')] += 1    # åˆ†ç»„ï¼Œæ¯ä¸ªé›†åˆçš„ä»£è¡¨ä½œä¸ºå­—å…¸çš„keyï¼Œç»„å‘˜æ”¾åœ¨åˆ—è¡¨ä¸­ï¼Œç¬¬0ä¸ªä½ç½®ä»£è¡¨â€™a'ï¼Œå€¼ä¸º1è¡¨ç¤ºæœ‰ä¸€ä¸ª'a'ï¼Œä»¥æ­¤ç±»æ¨

        res = [None] * len(s)
        for index, boss in enumerate(parents):
            for i in range(26):
                if groups[boss][i] > 0:
                    tmp = chr(i+97)
                    res[index] = tmp
                    groups[boss][i] -= 1
                    break

        return "".join(res)
```

```py
è¯´æ˜ä¹‹å‰çš„åˆå¹¶å¯¼è‡´ç´¢å¼•1,2å•ç‹¬æˆä¸ºé›†åˆï¼Œåç»­å°†1ä¸å…¶ä»–åˆ†ç»„åˆå¹¶ï¼Œæ›´æ–°äº†1ï¼Œä½†æ˜¯æ²¡æœ‰å†é‡åˆ°ç´¢å¼•2çš„å€¼ï¼Œå› æ­¤2æ²¡æœ‰è¢«æ›´æ–°ï¼Œä¾æ—§æŒ‡å‘1


class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        n = len(s)
        ls = [i for i in range(n)]
        def find(x):
            if ls[x] == x:
                return x
            ls[x] = find(ls[x])
            return ls[x]
        def merge(a, b):
            a = find(a)
            b = find(b)
            if a != b:
                ls[b] = a
        for par in pairs:
            merge(par[0], par[1])
        dirs = {}
        for i in range(n):
            find(i)
            index = ls[i]
            qs = dirs.get(index, False)
            if qs:
                qs.append(s[i])
            else:
                qs = [s[i]]
            dirs[index] = qs
        for k in dirs.keys():
            dirs[k].sort()
        res = []
        for i in range(n):
            index = ls[i]
            res.append(dirs[index].pop(0))
        return "".join(res)
pythonğŸ’å¹¶æŸ¥é›†

class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: [int]) -> str:
        p = {i:i for i in range(len(s))}  
        def f(x):
            if x != p[x]:
                p[x] = f(p[x])
            return p[x]

        for i, j in pairs:
            p[f(j)] = f(i)   
        
        d = collections.defaultdict(list)
        for i, j in enumerate(map(f, p)):
            d[j].append(i)

        ans = list(s)
        for q in d.values():
            t = sorted(ans[i] for i in q)
            for i, c in zip(sorted(q), t):
                ans[i] = c
        return ''.join(ans)
```

###  1.255. <a name='SortItemsbyGroupsRespectingDependencies'></a>1203. é¡¹ç›®ç®¡ç† Sort Items by Groups Respecting Dependencies

[å®˜æ–¹](https://www.bilibili.com/video/BV1iy4y1m7ye?spm_id_from=333.999.0.0)

###  1.256. <a name='DesignSkiplist'></a>1206. Design Skiplist 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1kT4y1F7Nr?spm_id_from=333.999.0.0)

###  1.257. <a name='RemoveAllAdjacentDuplicatesin'></a>1209 Remove All Adjacent Duplicates in 

[å°æ˜](https://www.bilibili.com/video/BV1qA411L7z9?spm_id_from=333.999.0.0)

###  1.258. <a name='MinimumCosttoMoveChips'></a>1217 Minimum Cost to Move Chips

[å°æ˜](https://www.bilibili.com/video/BV1zt4y1e7fK?spm_id_from=333.999.0.0)

###  1.259. <a name='LongestArithmeticSubsequenceofGivenDifference'></a>1218. Longest Arithmetic Subsequence of Given Difference

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1tE411f73y?spm_id_from=333.999.0.0)

###  1.260. <a name='CountVowelsPermutation'></a>1220. Count Vowels Permutation

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1FJ411c7pT?spm_id_from=333.999.0.0)

###  1.261. <a name='DiceRollSimulation'></a>1223 Dice Roll Simulation

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV17E411k7PR?spm_id_from=333.999.0.0)

###  1.262. <a name='TilingaRectanglewiththeFewestSquares'></a>1240 Tiling a Rectangle with the Fewest Squares

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1UE411t7Gb?spm_id_from=333.999.0.0)

###  1.263. <a name='-1'></a>1248-ç»Ÿè®¡ã€Œä¼˜ç¾å­æ•°ç»„ã€

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1FU4y1H76T?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Wk4y1r7t7?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def numberOfSubarrays(self, nums, k):
        tmp = [] # å­˜è¿ç»­å¶æ•°ä¸ªæ•°çš„å­åºåˆ—
        n = 1 # ä»1å¼€å§‹è®¡æ•°ï¼Œå°†æ¥è®¡ç®—çš„æ—¶å€™å°±ä¸ç”¨åŠ 1äº†
        for i in nums:
            if i % 2 == 0:
                n += 1
            else: # å‘ç°ä¸€ä¸ªå¥‡æ•°å°±å­˜å…¥è¿ç»­å¶æ•°çš„ä¸ªæ•°
                tmp.append(n)
                n = 1
        tmp.append(n) # å¾ªç¯ç»“æŸåè¿˜è¦æŠŠæœ€åä¸€ä¸ªnåŠ è¿›æ¥
        if len(tmp) < k+1: # kä¸ªå¥‡æ•°ï¼Œtmpé‡Œè‡³å°‘è¦æœ‰k+1ä¸ªå…ƒç´ 
            return 0 # å‡‘ä¸å¤Ÿkä¸ªå¥‡æ•°è¿”å›0
        res = 0
        for i in range(k, len(tmp)): # å°†kä¸ªå¥‡æ•°ä¸¤ä¾§çš„å¶æ•°æ•°é‡ç›¸ä¹˜ï¼ŒåŠ åœ¨ä¸€èµ·
            res += tmp[i] * tmp[i-k]
        return res

Py3 å“ˆå¸Œ

class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        res, tmp, dic = 0, 0, {0: 1}
        for num in nums:
            if num & 1:
                tmp += 1
                dic[tmp] = 1
            else:
                dic[tmp] += 1
            res += dic.get(tmp-k, 0)
        return res
å…ˆæŠŠå¥‡æ•°çš„ç´¢å¼•åˆ—å‡ºæ¥æ”¾è¿›p âˆ‘(p[i]-p[i-1])*(p[i+k]-p[i+k-1])å°±æ˜¯ç»“æœ

class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        p=[-1]+[i for i,v in enumerate(nums) if v&1]+[len(nums)]
        return sum((p[i]-p[i-1])*(p[i+k]-p[i+k-1]) for i in range(1,len(p)-k))
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        cnt = [0] * (len(nums) + 1)
        cnt[0] = 1
        odd, ans = 0, 0
        for num in nums:
            if num % 2 == 1:
                odd += 1
            if odd >= k:
                ans += cnt[odd - k]
            cnt[odd] += 1
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/tong-ji-you-mei-zi-shu-zu-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        n = len(nums)
        odd = [-1]
        ans = 0
        for i in range(n):
            if nums[i] % 2 == 1:
                odd.append(i)
        odd.append(n)
        print(odd)
        for i in range(1, len(odd) - k):
            ans += (odd[i] - odd[i - 1]) * (odd[i + k] - odd[i + k - 1])
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/tong-ji-you-mei-zi-shu-zu-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
åˆ†äº«ä¸€ä¸ªç¬¨åŠæ³•ï¼ˆå¤§ä½¬å‹¿å–·ï¼‰ï¼Œåªä¼šæ±‚ k é•¿åº¦ä¸¤ä¸ªå¥‡æ•°ç«¯ç‚¹ï¼Œç„¶åä¹˜æ³•ã€‚ å…ˆæ±‚å‡ºæ‰€æœ‰å¥‡æ•°ä¸‹æ ‡ï¼Œç„¶åæ»‘åŠ¨çª—å£è¿›è¡Œè®¡ç®—ã€‚

~~~~start-----end~~~~

æ±‚å‡º start å·¦è¾¹å¶æ•°ä¸ªæ•°ï¼Œå¾—åˆ°å·¦ä¾§ left_rest
æ±‚å‡º end å³ä¾§å¶æ•°ä¸ªæ•°ï¼Œå¾—åˆ°å³ä¾§ right_rest
ä¸€ä¸ª K é•¿åº¦å°±æœ‰ç»„åˆï¼š
~~~~start-----endï¼šæœ‰ left_rest ä¸ª
start-----endï¼šæœ‰ 1 ä¸ª
~~~~start-----end~~~~ï¼šæœ‰ left_rest * right_rest ä¸ª
start-----end~~~~ï¼šæœ‰ right_rest ä¸ª
æ‰€ä»¥ä¸€ä¸ª ã€Kã€‘é•¿åº¦å°±æœ‰ left_rest + right_rest + left_rest * right_rest + 1 ä¸ªã€‚

é‚£ä¹ˆä¸€å…±æœ‰ å¤šå°‘ä¸ªé•¿åº¦ä¸º ã€Kã€‘çš„å¥‡æ•°åºåˆ—å‘¢ï¼Ÿå°±æ˜¯ len(odd) - k æ¡ã€‚

class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        size = len(nums)
        if size < k:
            return 0
        
        odd = [i for i in range(size) if nums[i] & 1]
        odd_size = len(odd)
        if odd_size < k:
            return 0
        res = 0
        for i in range(odd_size - k + 1):
            start, end = odd[i], odd[i+k-1]
            if i > 0:
                left_rest = start - odd[i-1] - 1  # ä¸¤ä¸ªå¥‡æ•°ä¹‹é—´çš„è·ç¦»ï¼ˆå¶æ•°ä¸ªæ•°ï¼‰
            else:
                left_rest = start  # ä¸¤ä¸ªå¥‡æ•°ä¹‹é—´çš„è·ç¦»ï¼ˆå¶æ•°ä¸ªæ•°ï¼‰
            if i+k-1 < odd_size - 1:  # éæœ€åä¸€ä¸ª
                right_rest = odd[i+k] - end - 1 # å³ä¾§ä¸¤ä¸ªå¥‡æ•°é—´è·ç¦»
            else:
                right_rest = size - 1 - end  # å³ä¾§å¯èƒ½æ²¡æœ‰ [1,2,1,2,2]
            res += left_rest + right_rest + left_rest * right_rest + 1
        return res
ç»†å“å®˜æ–¹çš„é¢˜è§£ä¸€ã€å‘ç°æ˜¯å¯¹è¾¹ç•Œçš„å¤„ç†ï¼Œæ€ä¹ˆè¯´å‘¢ï¼Ÿ å°†ä¸Šé¢çš„å¼å­åˆå¹¶åŒç±»é¡¹ï¼Œleft_rest + right_rest + left_rest * right_rest + 1å°±æ˜¯ (left_rest + 1) * (right_rest + 1)ï¼Œå¾ˆæ˜æ˜¾è¿™å°±æ˜¯å‰åä¸¤ä¸ªå¥‡æ•°çš„**ç´¢å¼•å·®**ç›¸ä¹˜ç»“æœã€‚

å”¯ä¸€å®˜æ–¹å·§å¦™çš„åœ°æ–¹å°±æ˜¯ï¼Œåœ¨å¤„ç†å·¦å³è¾¹ç•Œä¸åƒä¸Šé¢ä¸€æ · if-elseï¼Œè€Œæ˜¯åœ¨ odd[0]=-1 å’Œ odd[-1]=len(nums)ï¼Œç®€ç›´ç»äº†ï¼è¿™ä¸¤ä¸ªå¤„ç†å¾ˆå¦™ã€‚åŒæ—¶å®˜æ–¹çš„æ»‘åŠ¨çª—å£ä¸ªäººè®¤ä¸ºæ˜¯ k+2 æ›´å¥½ç†è§£ã€‚

nums=[1,1,2,1,1], k=2 å¥‡æ•°ç´¢å¼•ï¼š[0,1,3,4]ï¼Œç„¶åç°åœ¨é€šè¿‡ä¸Šé¢å¼å­çŸ¥é“ï¼Œå°±æ˜¯æ±‚ä¸¤ä¸ªå¥‡æ•°ç´¢å¼•å·®ï¼Œé¢„å¤„ç†å¤´åŠ ä¸Š -1 å’Œå°¾éƒ¨åŠ ä¸Š len(nums) å¾—åˆ° odd = [-1, 0, 1, 3, 4, 5]

ä»¥ k + 2 é•¿åº¦ä¸ºæ»‘åŠ¨çª—å£è¿›è¡Œæ±‚è§£ï¼Œé‚£ä¹ˆå…±è¿›è¡Œ len(odd) - (k + 2) æ¬¡ï¼ˆå³è¿™é‡Œå…±2æ¬¡ï¼‰ã€‚

ç¬¬ä¸€è½®ï¼š[-1, 0, 1, 3, 4] ï¼šå®é™…æ»‘åŠ¨çª—å£ [0, 1, 3]ã€‚

ç¬¬ä¸€ä¸ªå¥‡æ•°ç«¯ç‚¹ä¸º 0, å…¶å‡å»å·¦ä¾§å¥‡æ•°ç´¢å¼•å·®ä¸º 0 - (-1) = 1ï¼ˆleft_res + 1)

ç¬¬ k ä¸ªå¥‡æ•°ç«¯ç‚¹ä¸º 3, å…¶å³ä¾§å¥‡æ•°ç´¢å¼•(4)å‡å»è‡ªèº«ä¸º 4 - 3 = 1 ï¼ˆright_res + 1ï¼‰

--------------------------------------------------------------------------------------------------

ç¬¬äºŒè½®ï¼š[0, 1, 3, 4, 5] ï¼šå®é™…æ»‘åŠ¨çª—å£ [1, 3, 4]ã€‚

ç¬¬ä¸€ä¸ªå¥‡æ•°ç«¯ç‚¹ä¸º 1, å…¶å‡å»å·¦ä¾§å¥‡æ•°ç´¢å¼•å·®ä¸º 1 -0 = 1ï¼ˆleft_res + 1)

ç¬¬ k ä¸ªå¥‡æ•°ç«¯ç‚¹ä¸º 4, å…¶å³ä¾§å¥‡æ•°ç´¢å¼•(5)å‡å»è‡ªèº«ä¸º 5 - 4 = 1 ï¼ˆright_res + 1ï¼‰

è¿™æ˜¯æˆ‘å¯¹å…¬å¼çš„ç»“æœç†è§£ï¼Œä»£ç å°±æ˜¯å®˜æ–¹çš„é‚£æ ·
```

###  1.264. <a name='MinimumRemovetoMakeValidPare'></a>1249 Minimum Remove to Make Valid Pare

[å°æ˜](https://www.bilibili.com/video/BV1wK4y1X7G7?spm_id_from=333.999.0.0)

###  1.265. <a name='-1'></a>1252 1253 1254 1255

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1kE411Y7rg?spm_id_from=333.999.0.0)

###  1.266. <a name='MinimumMovestoMoveaBoxtoTheirTarget'></a>1263. Minimum Moves to Move a Box to Their Target

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1AJ411Q7B6?spm_id_from=333.999.0.0)

###  1.267. <a name='-1'></a>1277. ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ã€‘ç»Ÿè®¡å…¨ä¸º1çš„æ­£æ–¹å½¢å­çŸ©é˜µ

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1nk4y1k7vi?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Kp4y1X7n4?spm_id_from=333.999.0.0)

```py
class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        m,n = len(matrix), len(matrix[0])
        res = 0

        for i in range(m):
            for j in range(n):
                if i>0 and j>0 and matrix[i][j]:
                    a, b, c = matrix[i-1][j], matrix[i-1][j-1], matrix[i][j-1]
                    matrix[i][j] = min(a, b, c) + 1
                
                res += matrix[i][j]
        
        return res

class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        if len(matrix) == 0:
            return sum(matrix)
        rows, cols = len(matrix), len(matrix[0])
        dp = [[0]*cols for _ in range(rows)]
        ans = 0
        for i in range(rows):
            for j in range(cols):
                if matrix[i][j] == 0:
                    continue
                if i == 0 or j == 0:
                    dp[i][j] = matrix[i][j]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1
                ans += dp[i][j]
        return ans
```

###  1.268. <a name='PalindromePartitioningIII'></a>1278. Palindrome Partitioning III

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1HJ411q7nc?spm_id_from=333.999.0.0)

###  1.269. <a name='FindtheSmallestDivisorGivena'></a>1283 Find the Smallest Divisor Given a

[å°æ˜](https://www.bilibili.com/video/BV1Fv411r7Nw?spm_id_from=333.999.0.0)

###  1.270. <a name='MinimumNumberofFlipstoConvertBinaryMatrix'></a>1284. Minimum Number of Flips to Convert Binary Matrix

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1nJ411y7m1?spm_id_from=333.999.0.0)

###  1.271. <a name='ConvertBinaryNumberinaLinkedList'></a>1290. äºŒè¿›åˆ¶é“¾è¡¨è½¬æ•´æ•° (Convert Binary Number in a Linked List

[æ´›é˜³](https://www.bilibili.com/video/BV1kc411h7Rs?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1nD4y1R7QH?spm_id_from=333.999.0.0)

```py
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        cur = head
        ans = 0
        while cur:
            ans = ans * 2 + cur.val
            cur = cur.next
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution/er-jin-zhi-lian-biao-zhuan-zheng-shu-by-leetcode-s/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution(object):
    def getDecimalValue(self, head):
        """
        :type head: ListNode
        :rtype: int
        """
        res = 0
        while head:
            res = res * 2 + head.val
            head = head.next 
        return res
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        ret = ''
        while head:
            ret += str(head.val)
            head = head.next
        return int(ret,2)
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        ret = str(head)
        bei = ''
        for i in ret:
            if i.isdigit():
                bei += i
        return int(bei,2)
```

###  1.272. <a name='SequentialDigits'></a>1291 Sequential Digits

[å°æ˜](https://www.bilibili.com/video/BV11v411C7so?spm_id_from=333.999.0.0)

###  1.273. <a name='ShortestPathinaGridwithObstaclesElimination'></a>1293. Shortest Path in a Grid with Obstacles Elimination

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1VJ411k72A?spm_id_from=333.999.0.0)

###  1.274. <a name='DivideArrayinSetsofKConsecutiveNumbers'></a>1296. Divide Array in Sets of K Consecutive Numbers

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gJ411e7cS?spm_id_from=333.999.0.0)

###  1.275. <a name='NumberofPathswithMaxScore'></a>1301. Number of Paths with Max Score

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1pJ411a7ry?spm_id_from=333.999.0.0)

###  1.276. <a name='DeepestLeavesSum'></a>1302 Deepest Leaves Sum

[å°æ˜](https://www.bilibili.com/video/BV1Bb4y1D7Cp?spm_id_from=333.999.0.0)

###  1.277. <a name='AllElementsinTwoBinarySearch'></a>1305 All Elements in Two Binary Search

[å°æ˜](https://www.bilibili.com/video/BV1kK411N7az?spm_id_from=333.999.0.0)

###  1.278. <a name='JumpGameIII'></a>1306 Jump Game III

[å°æ˜](https://www.bilibili.com/video/BV13y4y1q7Gi?spm_id_from=333.999.0.0)

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start] == 0:
            return True

        n = len(arr)
        used = {start}
        q = collections.deque([start])

        while len(q) > 0:
            u = q.popleft()
            for v in [u + arr[u], u - arr[u]]:
                if 0 <= v < n and v not in used:
                    if arr[v] == 0:
                        return True
                    q.append(v)
                    used.add(v)
        
        return False

```

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(site, n):
            if flag[0]:
                return
            if arr[site] == 0:
                flag[0] = True
                return
            see[site] = True
            for next_site in (site+arr[site], site-arr[site]):
                if 0 <= next_site < n and see[next_site] == False:
                    dfs(next_site, n)
        n = len(arr)
        flag = [False]
        see = [False] * n
        dfs(start, n)
        return flag[0]
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()

        def dfs(index):
            if index in seen:
                return False

            seen.add(index)
            if index < 0 or index >= len(arr):
                return False

            if arr[index] == 0:
                return True

            return dfs(index + arr[index]) or dfs(index - arr[index])

        return dfs(start)
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()
        queue = [(start, 0)]

        while queue:
            index, step = queue.pop(0)

            if index in seen:
                continue

            seen.add(index)

            if index < 0 or index >= len(arr):
                continue

            if arr[index] == 0:
                return True

            queue.extend([(index + arr[index], step+1), (index - arr[index], step+1)])

        return False

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(index,d):
            if index<0 or index>=len(arr) or len(d)!=len(set(d)):return False
            if arr[index]==0:return True
            return dfs(index+arr[index],d+[index+arr[index]]) or  dfs(index-arr[index],d+[index-arr[index]])
        return dfs(start,[start])

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start]==0:return True
        q=collections.deque([start])
        visited={start}
        while q:
            node=q.popleft()
            for n in [node+arr[node],node-arr[node]]:
                if 0<=n<len(arr) and n not in visited:
                    if arr[n]==0:return True
                    q.append(n)
                    visited.add(n)
        return False

bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        q, v, n = [start], {start}, len(arr)
        while q:
            p = []
            for i in q:
                if not arr[i]:
                    return True
                for j in i - arr[i], i + arr[i]:
                    if 0 <= j < n and j not in v:
                        p.append(j)
                        v.add(j)
            q = p
        return False
dfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        n, v = len(arr), set()
        def f(i):
            if not arr[i]:
                return True
            elif i not in v:
                v.add(i)
                return 0 <= i - arr[i] < n and f(i - arr[i]) or 0 <= i + arr[i] < n and f(i + arr[i])
        return f(start)

python bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        l, mark, queue= len(arr), [1 for i in range(len(arr))], [start]
        while len(queue)!=0:
            n = len(queue)
            for i in range(n):
                tmp = queue.pop()
                if arr[tmp]==0:
                    return True
                mark[tmp] = 0
                for cur in tmp+arr[tmp], tmp-arr[tmp]:
                    if 0<=cur<l and mark[cur]:
                        queue.insert(0, cur)
        return False
```

###  1.279. <a name='XORQueriesofaSubarray'></a>1310. XOR Queries of a Subarray

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1oJ411L78Y?spm_id_from=333.999.0.0)

###  1.280. <a name='MinimumInsertionStepstoMakeaStringPalindrom'></a>1312. Minimum Insertion Steps to Make a String Palindrom

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1HJ411L7b2?spm_id_from=333.999.0.0)

###  1.281. <a name='NumberofOperationstoMakeNetworkConnected'></a>1319. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Number of Operations to Make Network Connected

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1jJ411n7dc?from=search&seid=16576806175247069118&spm_id_from=333.337.0.0)

```py

```

###  1.282. <a name='MinimumDistancetoTypeaWordUsingTwoFinger'></a>1320. Minimum Distance to Type a Word Using Two Finger

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11J411n7fN?spm_id_from=333.999.0.0)

###  1.283. <a name='SorttheMatrixDiagonally'></a>1329 Sort the Matrix Diagonally

[å°æ˜](https://www.bilibili.com/video/BV1hU4y147b1?spm_id_from=333.999.0.0)

###  1.284. <a name='RemovePalindromicSubsequences'></a>1332 Remove Palindromic Subsequences

[å°æ˜](https://www.bilibili.com/video/BV1tK4y1D7aV?spm_id_from=333.999.0.0)

###  1.285. <a name='DijkstraFindtheCityWithSmallestNumberofNeighbors'></a>1334. ã€DijkstrağŸš—ã€‘Find the City With Smallest Number of Neighbors

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1b7411z7Tb?spm_id_from=333.999.0.0)

###  1.286. <a name='MinimumDifficultyofaJobSchedule'></a>1335. Minimum Difficulty of a Job Schedule

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1K7411r7xj?spm_id_from=333.999.0.0)

###  1.287. <a name='TheKWeakestRowsinaMatrix'></a>1337 The K Weakest Rows in a Matrix

[å°æ˜](https://www.bilibili.com/video/BV1bX4y157ju?spm_id_from=333.999.0.0)

###  1.288. <a name='MaximumProductofSplitt'></a>1339 Maximum Product of Splitt

[å°æ˜](https://www.bilibili.com/video/BV1Ch411i7yS?spm_id_from=333.999.0.0)

###  1.289. <a name='JumpGameV'></a>1340. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘Jump Game V

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1h7411W7wS?spm_id_from=333.999.0.0)

```py
è®°å¿†åŒ– DFS + é€’å½’

class Solution:
    def maxJumps(self, arr: List[int], step: int) -> int:
        n = len(arr)
        
        @lru_cache(None)
        def dfs(i):
            res = 0
            for j in range(i + 1, i + step + 1):
                if j >= n or arr[j] >= arr[i]:
                    break
                res = max(res, dfs(j))
            for j in range(i - 1, i - step - 1, -1):
                if j < 0 or arr[j] >= arr[i]:
                    break
                res = max(res, dfs(j))
            return res + 1
        
        return max(dfs(i) for i in range(n))

ç­‰æ•ˆäºï¼š

class Solution:
    def maxJumps(self, arr: List[int], step: int) -> int:
        visited = {}
        l = len(arr)
        def dfs(n):
            
            if n in visited:
                return visited[n]
            
            t = 1
            
            for i in range(1, step + 1):
                if n + i >= l or arr[n] <= arr[n + i]:
                    break
                t = max(t, 1 + dfs(n + i))
                
            for i in range(1, step + 1):
                if n - i < 0 or arr[n] <= arr[n - i]:
                    break
                t = max(t, 1 + dfs(n - i))
                
            visited[n] = t
            return t
        
        return max(dfs(i) for i in range(l))

ç­‰æ•ˆäºï¼š

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        visited = dict()

        def dfs(pos):
            if pos in visited:
                return
            visited[pos] = 1

            i = pos - 1
            while i >= 0 and pos - i <= d and arr[pos] > arr[i]:
                dfs(i)
                visited[pos] = max(visited[pos], visited[i] + 1)
                i -= 1
            i = pos + 1
            while i < len(arr) and i - pos <= d and arr[pos] > arr[i]:
                dfs(i)
                visited[pos] = max(visited[pos], visited[i] + 1)
                i += 1

        for i in range(len(arr)):
            dfs(i)
        print(visited)
        return max(visited.values())
```

åŠ¨æ€ğŸš€è§„åˆ’

```py
æ’åºä¹‹åå¯¹å‘ä¸¤è¾¹è¿›è¡Œæ‹“å±•

class Solution:
    def maxJumps(self, arr: List[int], step: int) -> int:
        n = len(arr)
        # å…ˆæŒ‰ç…§é«˜åº¦æ’åº
        height = [(jump,i) for i, jump in enumerate(arr)]
        height = sorted(height, key=lambda x: x[0])
        dp = [1 for _ in range(n)]
        
        
        for jump, i in height:
            cur = 1
            for j in range(i-1, max(-1, i - step) - 1, -1): # å‘å·¦è·³
                if arr[j] >= jump: break
                cur = max(dp[j] + 1,cur)

            for j in range(i + 1, min(n, i + step + 1)):
                if arr[j] >= jump: break
                cur = max(dp[j] + 1, cur)
            # æ ¹æ® jump çš„å¤§å°ï¼ŒåŠ¨æ€ğŸš€è§„åˆ’ï¼Œæ±‚dp
            dp[i] = cur
        return max(dp)

```

###  1.290. <a name='MaximumStudentsTakingExam'></a>1349. Maximum Students Taking Exam

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1w7411V7eC?spm_id_from=333.999.0.0)

###  1.291. <a name='MaximumNumberofEventsThatCanBeAttended'></a>1353. Maximum Number of Events That Can Be Attended 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1C7411j7YJ?spm_id_from=333.999.0.0)

###  1.292. <a name='ConstructTargetArrayWithMultipleSums'></a>1354. Construct Target Array With Multiple Sums

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1g7411c793?spm_id_from=333.999.0.0)

###  1.293. <a name='DijkstraMinimumCosttoMakeatLeastOneValidPath'></a>1368. ã€DijkstrağŸš—ã€‘Minimum Cost to Make at Least One Valid Path

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1oE411E74t?spm_id_from=333.999.0.0)

###  1.294. <a name='FindtheLongestSubstringContainingVowelsinEve'></a>1371. Find the Longest Substring Containing Vowels in Eve

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1CE411K7hb?spm_id_from=333.999.0.0)

###  1.295. <a name='MaximumSumBSTinBinaryTree'></a>1373. Maximum Sum BST in Binary Tree

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV17E411u797?spm_id_from=333.999.0.0)

###  1.296. <a name='FrogPositionAfterTSeconds'></a>1377. Frog Position After T Seconds

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1mE411K7vc?spm_id_from=333.999.0.0)

###  1.297. <a name='FindCorrespondingNodeofBinaryTreeinaClone'></a>1379 Find Corresponding Node of Binary Tree in a Clone

[å°æ˜](https://www.bilibili.com/video/BV1A54y147HN?spm_id_from=333.999.0.0)

###  1.298. <a name='BalanceaBinarySearchTree'></a>1382. Balance a Binary Search Tree

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1y7411f7v2?spm_id_from=333.999.0.0)

###  1.299. <a name='CountNumberofTeams'></a>1395. Count Number of Teams

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cc411h73E?spm_id_from=333.999.0.0)

###  1.300. <a name='DesignUndergroundSystem'></a>1396 Design Underground System

[å°æ˜](https://www.bilibili.com/video/BV1uA411N7q6?spm_id_from=333.999.0.0)

###  1.301. <a name='StoneGameIII'></a>1406. Stone Game III

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1zT4y1G7Tb?spm_id_from=333.999.0.0)

###  1.302. <a name='QueriesonaPermutationWithKey'></a>1409. Queries on a Permutation With Key

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1mz411b7Uw?spm_id_from=333.999.0.0)

###  1.303. <a name='RestoreTheArray'></a>1416. Restore The Array

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gK4y1k7Rv?spm_id_from=333.999.0.0)

###  1.304. <a name='DiagonalTraverseII'></a>1424. Diagonal Traverse II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1r5411x7Tm?spm_id_from=333.999.0.0)

###  1.305. <a name='ConstrainedSubsetSum'></a>1425. Constrained Subset Sum

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV13t4y1m7fD?spm_id_from=333.999.0.0)

###  1.306. <a name='CountingElements'></a>1426  Counting Elements

[å°æ˜](https://www.bilibili.com/video/BV1Eg4y187vx?spm_id_from=333.999.0.0)

###  1.307. <a name='KidsWiththeGreatestNumberofCandie'></a>1431. æ‹¥æœ‰æœ€å¤šç³–æœçš„å­©å­ Kids With the Greatest Number of Candie

[å®˜æ–¹](https://www.bilibili.com/video/BV1vD4y1D7yo?spm_id_from=333.999.0.0)

###  1.308. <a name='CheckIfAll1sAreatLeastLength'></a>1437 Check If All 1's Are at Least Length

[å°æ˜](https://www.bilibili.com/video/BV1Yo4y1R78P?spm_id_from=333.999.0.0)

###  1.309. <a name='LongestContinuousSubarrayWithAbsolute'></a>1438. Longest Continuous Subarray With Absolute

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Cf4y1m7aN?spm_id_from=333.999.0.0)

###  1.310. <a name='BuildanArrayWithStackOperations'></a>1441 Build an Array With Stack Operations

[å°æ˜](https://www.bilibili.com/video/BV1Gg4y167ZD?spm_id_from=333.999.0.0)

###  1.311. <a name='CountTripletsThatCanFormTwoArraysofEqual'></a>1442. Count Triplets That Can Form Two Arrays of Equal

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV17g4y1B7yo?spm_id_from=333.999.0.0)

###  1.312. <a name='MinimumTimetoCollectAllApplesinaTree'></a>1443. Minimum Time to Collect All Apples in a Tree

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1e541147oZ?spm_id_from=333.999.0.0)

###  1.313. <a name='NumberofWaysofCuttingaPizza'></a>1444. ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ + å‰ç¼€å’ŒğŸ¨ + é€’å½’ã€‘Number of Ways of Cutting a Pizza

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1CK411W7nR?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1gg4y1B7zS?spm_id_from=333.999.0.0)

é€’å½’æ³•

```py
class Solution:

    def ways(self, pizza: List[str], k: int) -> int:
        dicDP = {}
        MOD = 10 **9 + 7
        
        @cache
        def dp(i, j, numK):
            # é€’å½’ç»“æŸï¼š
            if (i, j, numK) in dicDP:
                return dicDP[(i, j, numK)]
            if numK == 1:
                isCut = False
                for upRemove in range(i, len(pizza)):
                    for leftRemove in range(j, len(pizza[0])):
                        isCut = isCut or pizza[upRemove][leftRemove] == 'A'
                return 1 if isCut else 0
            
            # é€’å½’å¼€å§‹
            isCut = False
            res = 0
            for upRemove in range(i, len(pizza)):
                isCut = isCut or any([pizza[upRemove][c] == 'A' for c in range(j, len(pizza[0]))])
                if isCut:
                    res += dp(upRemove + 1, j, numK - 1)
                    
            isCut = False
            for leftRemove in range(j, len(pizza[0])):
                isCut = isCut or any([pizza[r][leftRemove] == 'A' for r in range(i, len(pizza))])
                if isCut:
                    res += dp(i, leftRemove + 1, numK - 1)
                    
            dicDP[(i, j, numK)] = res % MOD
            return res % MOD
        
        return dp(0, 0, k) % MOD

æš´åŠ›æ·±æœ+è®°å¿†åŒ–

class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        
        rows, cols = len(pizza), len(pizza[0])
        
        @functools.lru_cache(None)
        def dp(x,y,k):
            if not k:
                return any('A' in p[y:cols] for p in pizza[x:rows])
            res=0
            
            for upCut in range(x+1,rows):
                if any('A' in p[y:cols] for p in pizza[x:upCut]):
                    res += dp(upCut,y,k-1)
                    
            for leftCut in range(y+1,cols):
                if any('A' in p[y:leftCut] for p in pizza[x:rows]):
                    res += dp(x,leftCut,k-1)
                    
            return res
        
        return dp(0,0,k-1) % 1000000007

å‰ç¼€å’Œï¼š
class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        
        rows, cols = len(pizza), len(pizza[0])
        
        pref = [[0]* (cols+1) for _ in range(rows+1)]
        # å‰ç¼€å’Œï¼Œæœ‰å¤šå°‘ä¸ªè‹¹æœ
        for i in range(rows):
            for j in range(cols):
                pref[i+1][j+1] = pref[i][j+1] + pref[i+1][j] - pref[i][j] + (1 if pizza[i][j] == 'A' else 0)
                
        @lru_cache(None)
        def f(x, y, k):
            
            # ç»“æŸé€’å½’ï¼š
            if not k:
                return pref[rows][cols] - pref[x][cols] - pref[rows][y] + pref[x][y] > 0
            res = 0
            
            # å¼€å§‹é€’å½’ï¼š
            for upCut in range(x+1, rows):
                if pref[upCut][cols] - pref[x][cols] - pref[upCut][y] + pref[x][y] > 0:
                    res += f(upCut, y, k-1)
                    
            for leftCut in range(y+1, cols):
                if pref[rows][leftCut] - pref[x][leftCut] - pref[rows][y] + pref[x][y] > 0:
                    res += f(x, leftCut, k-1)
            return res
        
        return f(0, 0, k-1) % (10**9+7)
```

åŠ¨æ€ğŸš€è§„åˆ’ï¼šå¥½éš¾å•Š

```py
class Solution:
	def ways(self,pizza,k):
		row, col = len(pizza),len(pizza[0])
		pref, dp= [[0]*(col+1) for _ in range(row+1)], [[0]*col for _ in range(row)]
  
		for x in range(row-1,-1,-1):
			for y in range(col-1,-1,-1):
				pref[x][y] = pref[x+1][y] + pref[x][y+1] - pref[x+1][y+1] + (pizza[x][y] == "A")
				dp[x][y] += pref[x][y] != 0
    
		for turn in range(2,k+1):
			new_dp = [[0]*col for _ in range(row)]
			for x in range(row-1,-1,-1):
				for y in range(col-1,-1,-1):
					if row + col - x - y -1 >= turn:
						part1 = sum(dp[upCut][y] for upCut in range(x+1,row) if pref[x][y] - pref[upCut][y] > 0)
						part2 = sum(dp[x][leCut] for leCut in range(y+1,col) if pref[x][y] - pref[x][leCut] > 0)
						new_dp[x][y] = part1 + part2
			dp=new_dp
		return dp[0][0]%int(1e9+7)
```

```scala
object Solution {
  val M = 1000000007L

  def ways(pizza: Array[String], k: Int): Int = {
    val arr = Array.fill(pizza.length + 1, pizza(0).length + 1)(0)
    val dp = Array.fill(pizza.length + 1, pizza(0).length + 1, k)(0L)
    (1 to pizza.length).foreach(r => (1 to pizza(0).length).foreach(c => arr(r)(c) = arr(r - 1)(c) + arr(r)(c - 1) - arr(r - 1)(c - 1) + (if (pizza(pizza.length - r)(pizza(0).length - c) == 'A') 1 else 0)))
    (0 to pizza.length).foreach(r => (0 to pizza(0).length).foreach(c => dp(r)(c)(0) = if (arr(r)(c) > 0) 1 else 0))
    (1 until k).foreach(cuts => (1 to pizza.length).foreach(r => (1 to pizza(0).length).foreach(c => {
      (1 until r).withFilter(cr => arr(r)(c) - arr(r - cr)(c) > 0).foreach(cr => {
        dp(r)(c)(cuts) += dp(r - cr)(c)(cuts - 1)
        dp(r)(c)(cuts) %= M
      })
      (1 until c).withFilter(cc => arr(r)(c) - arr(r)(c - cc) > 0).foreach(cc => {
        dp(r)(c)(cuts) += dp(r)(c - cc)(cuts - 1)
        dp(r)(c)(cuts) %= M
      })
    })))
    (dp(pizza.length)(pizza(0).length)(k - 1) % M).toInt
  }
}
```

###  1.314. <a name='ConsecutiveCharacters'></a>1446 Consecutive Characters

[å°æ˜](https://www.bilibili.com/video/BV1QA411j7Qt?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1pp4y1Q7Rh?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxPower(self, s: str) -> int:
        return max(map(lambda x:len(list(x[1])),groupby(s)))
class Solution:
    def maxPower(self, s: str) -> int:
        return max(map(lambda x:len(list(x[1])),groupby(s)))
class Solution:
    def maxPower(self, s: str) -> int:
        ans, cnt = 1, 1
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                cnt += 1
                ans = max(ans, cnt)
            else:
                cnt = 1
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/consecutive-characters/solution/lian-xu-zi-fu-by-leetcode-solution-lctm/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
å·æ‡’çš„ä¸¤ç§æ–¹æ³• 1.itertools.groupby 2.re

#python3
from itertools import groupby
class Solution:
	def maxPower(self,s):
		return max(len(list(j)) for _,j in groupby(s))
#python3
from re import compile
from string import ascii_lowercase
class Solution:
	def maxPower(self,s):
		pattern=compile("{1,}|".join(ascii_lowercase+" ")[:-2])
		return max(map(len,(pattern.findall(s))))
```

###  1.315. <a name='CountGoodNodesinBinaryTree'></a>1448 Count Good Nodes in Binary Tree

[å°æ˜](https://www.bilibili.com/video/BV1Zg4y1q7kc?spm_id_from=333.999.0.0)

###  1.316. <a name='FormLargestIntegerWithDigitsThatAdd'></a>1449. ã€èƒŒåŒ… + åŠ¨æ€ğŸš€è§„åˆ’ã€‘Form Largest Integer With Digits That Add

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV19Q4y1A7Rf?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1j54y1D7vf?spm_id_from=333.999.0.0)

```py
# from 
# print(dp)
# [0, -1, -1, -1, -1, -1, -1, -1, -1, -1]
# [0, -1, 7, -1, -1, -1, -1, -1, -1, -1]
# [0, -1, 7, 2, -1, -1, -1, -1, -1, -1]
# [0, -1, 7, 2, 77, -1, -1, -1, -1, -1]
# [0, -1, 7, 2, 77, 72, -1, -1, -1, -1]
# [0, -1, 7, 2, 77, 72, 777, -1, -1, -1]
# [0, -1, 7, 2, 77, 72, 777, 772, -1, -1]
# [0, -1, 7, 2, 77, 72, 777, 772, 7777, -1]
# [0, -1, 7, 2, 77, 72, 777, 772, 7777, 7772]
class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [0] + [-1] * target
        for t in range(1, target + 1):
            for n, c in enumerate(cost,1):
                if c <= t:
                    dp[t] = max(dp[t], dp[t-c] * 10 + n)
        return str(max(dp[target], 0))

å‰ªæä¸€ä¸‹ï¼šæ˜¯é”™è¯¯âŒçš„

class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [0] + [-1] * target
        for t in range(cost[0], target + 1):
            for n, c in enumerate(cost,1):
                if c <= t:
                    dp[t] = max(dp[t], dp[t-c] * 10 + n)
        return str(max(dp[target], 0))

è¾“å…¥ï¼š
[4,3,2,5,6,7,2,5,5]
9
è¾“å‡ºï¼š
"977"
é¢„æœŸç»“æœï¼š
"7772"

class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [0] + [-1] * target # æ˜“é”™ç‚¹ï¼š ğŸ˜-1 ä¹Ÿå¯ä»¥å†™æˆ float('-inf')ï¼Œä½†æ˜¯ä¸å¯ä»¥æ˜¯ 0
        
        for n, c in reversed(list(enumerate(cost, 1))): # æ­£ç€å’Œåç€ï¼Œéƒ½ä¸€æ ·reversed(list(enumerate(cost, 1))):
            for t in range(c, target+1):
                dp[t] = max([dp[t], dp[t-c] * 10 + n])
                
        return str(max(dp[-1],0)) 
```


```scala
å·æ‡’ä½¿ç”¨äº†å­—ç¬¦ä¸²æ¯”è¾ƒï¼š

object P1449 {
  def largestNumber(costs: Array[Int], target: Int): String = {
    val dp = new Array[Boolean](target + 1)
    val nums = Array.fill(target + 1)("")
    dp(0) = true
    costs.indices.reverse.foreach { i =>
      val num = i + 1
      val cost = costs(i)
      (cost to target).foreach { j =>
        if (dp(j - cost)) {
          dp(j) = true
          val newStr = nums(j - cost) + num
          if (newStr.length > nums(j).length || (newStr.length == nums(j).length && newStr > nums(j))) {
            nums(j) = newStr
          }
        }
      }
    }

    if (nums(target) == "") "0" else nums(target)
  }
}
```

###  1.317. <a name='RearrangeWordsinaSentence'></a>1451 Rearrange Words in a Sentence

[å°æ˜](https://www.bilibili.com/video/BV1UA411t7Eg?spm_id_from=333.999.0.0)

###  1.318. <a name='MaximumNumberofDartsInsideofaCircularDartb'></a>1453 Maximum Number of Darts Inside of a Circular Dartb

[å°æ˜](https://www.bilibili.com/video/BV1Ut4y117jp?spm_id_from=333.999.0.0)

###  1.319. <a name='Pseudo-PalindromicPathsinaBin'></a>1457 Pseudo-Palindromic Paths in a Bin

[å°æ˜](https://www.bilibili.com/video/BV1t54y1t7KK?spm_id_from=333.999.0.0)

###  1.320. <a name='CheckIfaStringContainsAllBinar'></a>1461 Check If a String Contains All Binar

[å°æ˜](https://www.bilibili.com/video/BV13Z4y1w7K9?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1oU4y1p7Tr?spm_id_from=333.999.0.0)

```py
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        for i in range(2 ** k):
            c = bin(i)[2:]
            c = '0' * (k - len(c)) + c
            if c not in s:
                return False
        return True
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        rec = set()
        for i in range(len(s)-k+1):
            rec.add(s[i:i+k])
        return len(rec) == 2**k
æ¥ä¸ªæš´åŠ›! 7420ms ï¼Œå±…ç„¶è¿‡äº†ï¼Ÿï¼Ÿï¼Ÿ

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        from itertools import product
        for i in map(lambda x: ''.join(x), product('01', repeat=k)):
            if i not in s:
                return False
        return True
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        def gen_subs(choices, k, cur):
            if k == 0:
                yield cur
                return 
            for c in choices:
                yield from gen_subs(choices, k-1, cur+c)
        
        sets = set()

        for i in range(len(s) -k +1):
            sets.add(s[i: i+k])
        
        return all(sub in sets for sub in gen_subs('01', k, ''))
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        for i in range(2**k):
            if '0'*(k-len(bin(i)[2:]))+bin(i)[2:] not in s:
                return False
        return True

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        if len(s) < (1 << k) + k - 1:
            return False
        
        exists = set(s[i:i+k] for i in range(len(s) - k + 1))
        return len(exists) == (1 << k)

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/solution/jian-cha-yi-ge-zi-fu-chuan-shi-fou-bao-h-1no1/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        if len(s) < (1 << k) + k - 1:
            return False
        
        num = int(s[:k], base=2)
        exists = set([num])

        for i in range(1, len(s) - k + 1):
            num = (num - ((ord(s[i - 1]) - 48) << (k - 1))) * 2 + (ord(s[i + k - 1]) - 48)
            exists.add(num)
        
        return len(exists) == (1 << k)

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/solution/jian-cha-yi-ge-zi-fu-chuan-shi-fou-bao-h-1no1/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        return len(s) >= (1 << k) + k - 1 and len(set([s[i:i+k] for i in range(len(s)-k+1)])) == 1<<k 
```

```py

```

###  1.321. <a name='CherryPickupII'></a>1463 Cherry Pickup II

[å°æ˜](https://www.bilibili.com/video/BV1AA411s7Tc?spm_id_from=333.999.0.0)

###  1.322. <a name='PaintHouseIII'></a>1473. Paint House III

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV15K411p7nT?spm_id_from=333.999.0.0)

###  1.323. <a name='FinalPricesWithaSpecialDiscountinaSho'></a>1475. Final Prices With a Special Discount in a Sho

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1na4y1Y7VU?spm_id_from=333.999.0.0)

###  1.324. <a name='KthAncestorofaTreeNode'></a>1483. Kth Ancestor of a Tree Node

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1kt4y1X7fk?spm_id_from=333.999.0.0)

###  1.325. <a name='AvoidFloodinTheCity'></a>1488. Avoid Flood in The City

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1af4y1y7uW?spm_id_from=333.999.0.0)

###  1.326. <a name='FindCriticalandPseudo-CriticalEdgesin'></a>1489. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Find Critical and Pseudo-Critical Edges in

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cV41167oi?spm_id_from=333.999.0.0)

###  1.327. <a name='ThekthFactorofn'></a>1492 The kth Factor of n

[å°æ˜](https://www.bilibili.com/video/BV1ha4y1H7vz?spm_id_from=333.999.0.0)

###  1.328. <a name='LongestSubarrayof1sAfterDeletingOne'></a>1493. Longest Subarray of 1's After Deleting One

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1rC4y18751?spm_id_from=333.999.0.0)

###  1.329. <a name='MaxValueofEquation'></a>1499. Max Value of Equation

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1VK411H7zy?spm_id_from=333.999.0.0)

###  1.330. <a name='CanMakeArithmeticProgressionFromSequence'></a>1502 Can Make Arithmetic Progression From Sequence

[å°æ˜](https://www.bilibili.com/video/BV12T4y177vU?spm_id_from=333.999.0.0)

###  1.331. <a name='LastMomentBeforeAllAntsFallOutofaPlank'></a>1503 Last Moment Before All Ants Fall Out of a Plank

[å°æ˜](https://www.bilibili.com/video/BV1Fg4y1i7na?spm_id_from=333.999.0.0)

###  1.332. <a name='MinimumPossibleIntegerAfteratMostKAdjacent'></a>1505. Minimum Possible Integer After at Most K Adjacent

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1YD4y1S7BQ?spm_id_from=333.999.0.0)

###  1.333. <a name='RangeSumofSortedSubarraySums'></a>1508. Range Sum of Sorted Subarray Sums

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1fg4y1v7qe?spm_id_from=333.999.0.0)

###  1.334. <a name='StoneGameIV'></a>1510 Stone Game IV

[å°æ˜](https://www.bilibili.com/video/BV1pr4y1w7ao?spm_id_from=333.999.0.0)

###  1.335. <a name='DijkstraPathwithMaximumProbability'></a>1514 ã€DijkstrağŸš—ã€‘Path with Maximum Probability

[å°æ˜](https://www.bilibili.com/video/BV1Ak4y1B7yR?spm_id_from=333.999.0.0)

###  1.336. <a name='BestPositionforaServiceCentre'></a>1515 Best Position for a Service Centre

[å°æ˜](https://www.bilibili.com/video/BV1UA411e7PC?spm_id_from=333.999.0.0)

###  1.337. <a name='MaximumNumberofNon-OverlappingSubstrings'></a>1520. Maximum Number of Non-Overlapping Substrings

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yz4y1D7p3?spm_id_from=333.999.0.0)

###  1.338. <a name='NumberofGoodLeafNodesPairs'></a>1530. Number of Good Leaf Nodes Pairs

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1bv411q7SD?spm_id_from=333.999.0.0)

###  1.339. <a name='StringCompressionII'></a>1531. String Compression II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1aK4y1v7B9?spm_id_from=333.999.0.0)

###  1.340. <a name='CountGoodTriplets'></a>1534 Count Good Triplets

[å°æ˜](https://www.bilibili.com/video/BV11k4y1m7rV?spm_id_from=333.999.0.0)

###  1.341. <a name='FindtheWinnerofanArrayGame'></a>1535 Find the Winner of an Array Game

[å°æ˜](https://www.bilibili.com/video/BV1Xp4y1i7ey?spm_id_from=333.999.0.0)

###  1.342. <a name='GettheMaximumScore'></a>1537. Get the Maximum Score

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1KC4y1t7P8?spm_id_from=333.999.0.0)

###  1.343. <a name='KthMissingPositiveNumber'></a>1539. Kth Missing Positive Number

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1SC4y147Eo?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1QK4y1p7E3?spm_id_from=333.999.0.0)

```py
class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        missCount = 0
        lastMiss = -1
        current = 1
        ptr = 0

        while missCount < k:
            if current == arr[ptr]:
                if ptr + 1 < len(arr):
                    ptr += 1
            else:
                missCount += 1
                lastMiss = current
            current += 1
        
        return lastMiss

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/kth-missing-positive-number/solution/di-k-ge-que-shi-de-zheng-zheng-shu-by-leetcode-sol/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        if arr[0] > k:
            return k
        
        l, r = 0, len(arr)
        while l < r:
            mid = (l + r) >> 1
            x = arr[mid] if mid < len(arr) else 10**9
            if x - mid - 1 >= k:
                r = mid
            else:
                l = mid + 1

        return k - (arr[l - 1] - (l - 1) - 1) + arr[l - 1]

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/kth-missing-positive-number/solution/di-k-ge-que-shi-de-zheng-zheng-shu-by-leetcode-sol/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        pos = 0
        cnt = 0
        for i in arr:
            cnt+=i-pos-1
            if cnt>=k:
                return i-(cnt-k)-1
            pos = i
        return arr[-1]+k-cnt
class Solution:
    def findKthPositive(self, arr, k):
        for i in range(len(arr)):
            if arr[i] - i > k:
                return i + k
            if len(arr) + k > arr[-1]:
                return len(arr) + k
```

```py
Python 1è¡Œ:

class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        return list(set(range(2001)) - set(arr))[k]
```

###  1.344. <a name='FindLongestAwesomeSubstring'></a>1542. Find Longest Awesome Substring

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ZD4y1U79Y?spm_id_from=333.999.0.0)

###  1.345. <a name='MaximumNumberofNon-OverlappingSubarraysWithSum'></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1LA411n7L8?spm_id_from=333.999.0.0)

###  1.346. <a name='ThreeConsecutiveOdds'></a>1550. Three Consecutive Odds

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1aV411m7fy?spm_id_from=333.999.0.0)

###  1.347. <a name='MinimumOperationstoMakeArray'></a>1551 Minimum Operations to Make Array

[å°æ˜](https://www.bilibili.com/video/BV1u64y1S7fx?spm_id_from=333.999.0.0)

###  1.348. <a name='MinimumNumberofDaystoEatNOranges'></a>1553. Minimum Number of Days to Eat N Oranges

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Qf4y197Zk?spm_id_from=333.999.0.0)

###  1.349. <a name='ThousandSeparator'></a>1556. Thousand Separator

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Ka4y177HV?spm_id_from=333.999.0.0)

###  1.350. <a name='MinimumNumbersofFunctionCallstoMakeTarget'></a>1558. Minimum Numbers of Function Calls to Make Target

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1xC4y1t7Q3?spm_id_from=333.999.0.0)

###  1.351. <a name='StoneGameV'></a>1563. Stone Game V 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1B54y1U77f?spm_id_from=333.999.0.0)

###  1.352. <a name='NumberofWaystoReorderArraytoGetSa'></a>1569. Number of Ways to Reorder Array to Get Sa

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1pZ4y1T7TY?spm_id_from=333.999.0.0)

###  1.353. <a name='NumberofWaystoSplitaString'></a>1573. Number of Ways to Split a String

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1bi4y1u7c3?spm_id_from=333.999.0.0)

###  1.354. <a name='CheckIfStringIsTransformableWith'></a>1585. Check If String Is Transformable With

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1a54y1m75Y?spm_id_from=333.999.0.0)

###  1.355. <a name='SplitaStringIntotheMaxNumberofUniqueSubstri'></a>1593. Split a String Into the Max Number of Unique Substri

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14y4y1k77x?spm_id_from=333.999.0.0) 

###  1.356. <a name='MinimumCosttoConnectTwoGroupsofPoints'></a>1595. Minimum Cost to Connect Two Groups of Points

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Xf4y1D7SW?spm_id_from=333.999.0.0)

###  1.357. <a name='NumberofSetsofKNon-OverlappingLine'></a>1621. Number of Sets of K Non-Overlapping Line

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1JV411y7eK?spm_id_from=333.999.0.0)

###  1.358. <a name='DijkstraPathWithMinimumEffort'></a>1631. ã€DijkstrağŸš— + æœ€å°å †ğŸŒµã€‘Path With Minimum Effort

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1tr4y1w725?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ft4y1z71X?spm_id_from=333.999.0.0)

```py
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        left, right, ans = 0, 10**6 - 1, 0

        while left <= right:
            mid = (left + right) // 2
            q = collections.deque([(0, 0)])
            seen = {(0, 0)}
            
            while q:
                x, y = q.popleft()
                for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                    if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in seen and abs(heights[x][y] - heights[nx][ny]) <= mid:
                        q.append((nx, ny))
                        seen.add((nx, ny))
            
            if (m - 1, n - 1) in seen:
                ans = mid
                right = mid - 1
            else:
                left = mid + 1
        
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

# ğŸ’å¹¶æŸ¥é›†æ¨¡æ¿
class UnionFind:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n
        self.n = n
        # å½“å‰è¿é€šåˆ†é‡æ•°ç›®
        self.setCount = n
    
    def findset(self, x: int) -> int:
        if self.parent[x] == x:
            return x
        self.parent[x] = self.findset(self.parent[x])
        return self.parent[x]
    
    def unite(self, x: int, y: int) -> bool:
        x, y = self.findset(x), self.findset(y)
        if x == y:
            return False
        if self.size[x] < self.size[y]:
            x, y = y, x

        self.parent[y] = x
        self.size[x] += self.size[y]
        self.setCount -= 1
        return True
    
    def connected(self, x: int, y: int) -> bool:
        x, y = self.findset(x), self.findset(y)
        return x == y

class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        edges = list()
        for i in range(m):
            for j in range(n):
                iden = i * n + j
                if i > 0:
                    edges.append((iden - n, iden, abs(heights[i][j] - heights[i - 1][j])))
                if j > 0:
                    edges.append((iden - 1, iden, abs(heights[i][j] - heights[i][j - 1])))
        
        edges.sort(key=lambda e: e[2])

        uf = UnionFind(m * n)
        ans = 0
        for x, y, v in edges:
            uf.unite(x, y)
            if uf.connected(0, m * n - 1):
                ans = v
                break
        
        return ans

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
è¿™ä¸ªæœˆå·²ç»ç†Ÿç»ƒæŒæ¡ğŸ’å¹¶æŸ¥é›†äº† python

class UF():
    def __init__(self, M):
        self.parent = {}
        for i in range(M):
            self.parent[i] = i

    def find(self, p):
        while p != self.parent[p]:
            p = self.parent[p]
        return p

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def union(self, p, q):
        if self.connected(p, q): return 
        leader_p = self.find(p)
        leader_q = self.find(q)
        self.parent[leader_q] = leader_p



class Solution(object):
    def minimumEffortPath(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: int
        """
        value_list = []
        m = len(heights)
        n = len(heights[0])
        if m*n == 1:
            return 0
        else:
            for i in range(m):
                for j in range(n):
                    num1 = i * n + j
                    if i + 1 < m:
                        num2 = num1 + n
                        value = abs(heights[i][j]-heights[i+1][j])
                        value_list.append((value, num1, num2))
                    if j + 1 < n:
                        num2 = num1 + 1
                        value = abs(heights[i][j]-heights[i][j+1])
                        value_list.append((value, num1, num2))
            value_list.sort()
            # print(value_list)
            uf = UF(m*n)
            for i in range(len(value_list)):
                value, num1, num2 = value_list[i]
                uf.union(num1, num2)
                if uf.connected(0, m*n-1):
                    return value

class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        q = [(0, 0, 0)]
        dist = [0] + [float("inf")] * (m * n - 1)
        seen = set()

        while q:
            d, x, y = heapq.heappop(q)
            iden = x * n + y
            if iden in seen:
                continue
            if (x, y) == (m - 1, n - 1):
                break
            
            seen.add(iden)
            for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                if 0 <= nx < m and 0 <= ny < n and max(d, abs(heights[x][y] - heights[nx][ny])) <= dist[nx * n + ny]:
                    dist[nx * n + ny] = max(d, abs(heights[x][y] - heights[nx][ny]))
                    heapq.heappush(q, (dist[nx * n + ny], nx, ny))
        
        return dist[m * n - 1]

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

ğŸ’å¹¶æŸ¥é›†

1.å…ˆæ„å»ºå„ç‚¹ä¹‹é—´çš„è¾¹åˆ—è¡¨edgesã€‚ å…¶ä¸­ç”±edge=[x,y,d]ç»„æˆï¼Œdä¸ºç‚¹xä¸yå·®çš„ç»å¯¹å€¼

2.æ ¹æ®è¾¹åˆ—è¡¨ä¸­çš„ å„ç‚¹å·®çš„ç»å¯¹å€¼ ä»å°åˆ°å¤§æ’åº

3.ä¾æ¬¡éå†edgesï¼Œ å¹¶å°†å„ç‚¹è¿›è¡Œè¿é€šï¼Œ å½“æœ€å·¦ä¸Šä¸æœ€å·¦ä¸‹ ç¬¬ä¸€æ¬¡è¿é€šæ—¶ç»“æŸï¼Œå¹¶è¾“å‡º æ‰€éå†è¿‡edgesä¸­çš„æœ€å¤§d

class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m = len(heights)
        n = len(heights[0])
        parent = list(range(m*n))
        edges =[]
        def find(index):
            if parent[index]!=index:
                parent[index] = find(parent[index])
            return parent[index]
        def union(index1, index2):
            u = find(index1)
            v = find(index2)
            parent[u] = v
            
        def is_valid(x,y):
            # åˆ¤æ–­ èŠ‚ç‚¹æ˜¯å¦åˆç†
            return 0<=x<m and 0<=y<n

        # æ„å»º edges åˆ—è¡¨
        # edge ä¸ºä¸‰å…ƒç»„[x,y,d] ï¼Œå…¶ä¸­dä¸º xä¸y å·®çš„ç»å¯¹å€¼
        for i in range(m):
            for j in range(n):
                nx = i+1
                ny = j
                if is_valid(nx,ny):
                    d = abs(heights[i][j]-heights[nx][ny])
                    edges.append([i*n+j,nx*n+ny,d])
                nx= i
                ny = j+1
                if is_valid(nx,ny):
                    d = abs(heights[i][j] - heights[nx][ny])
                    edges.append([i*n+j,nx*n+ny,d])
        # å°† è¾¹ æ ¹æ®ç»å¯¹å·®å€¼ d è¿›è¡Œä»å°åˆ°å¤§æ’åº
        edges = sorted(edges, key=lambda x:x[-1])

        # ä¾æ¬¡éå† edges å¹¶ä¾æ¬¡è¿é€šæ‰€éå†çš„èŠ‚ç‚¹ï¼Œå½“å·¦ä¸Šä¸å·¦ä¸‹è¿é€šæ—¶ï¼Œç»“æŸï¼Œè¾“å‡ºæ‰€éå†è¿‡çš„æœ€å¤§ d
        cost = 0
        for edge in edges:
            if find(0)==find(m*n-1):
                break
            x,y,d = edge
            if find(x)!=find(y):
                union(x,y)
                cost=max(cost,d)
        return cost
```

###  1.359. <a name='RankTransformofaMatrix'></a>1632 Rank Transform of a Matrix

[å°æ˜](https://www.bilibili.com/video/BV1KX4y1F7UA?spm_id_from=333.999.0.0)

###  1.360. <a name='CheckArrayFormationThrough'></a>1640 Check Array Formation Through

[å°æ˜](https://www.bilibili.com/video/BV1uh411274P?spm_id_from=333.999.0.0)

###  1.361. <a name='CountSortedVowelStrings'></a>1641 Count Sorted Vowel Strings

[å°æ˜](https://www.bilibili.com/video/BV1jf4y1k7bJ?spm_id_from=333.999.0.0)

###  1.362. <a name='FurthestBuildingYouCanReach'></a>1642. Furthest Building You Can Reach

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1az4y1C7Pk?spm_id_from=333.999.0.0)

###  1.363. <a name='GetMaximuminGeneratedArray'></a>1646 Get Maximum in Generated Array

[å°æ˜](https://www.bilibili.com/video/BV1W54y1s7mg?spm_id_from=333.999.0.0)

###  1.364. <a name='SellDiminishing-ValuedColoredBalls'></a>1648. Sell Diminishing-Valued Colored Balls

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11z4y1C7PC?spm_id_from=333.999.0.0)

###  1.365. <a name='CreateSortedArraythroughInstru'></a>1649 Create Sorted Array through Instru

[å°æ˜](https://www.bilibili.com/video/BV1ua4y1H7KK?spm_id_from=333.999.0.0)

###  1.366. <a name='DistributeRepeatingIntegers'></a>1655. Distribute Repeating Integers

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1qt4y1a7Lm?spm_id_from=333.999.0.0)

###  1.367. <a name='DetermineifTwoStringsAreClose'></a>1657 Determine if Two Strings Are Close

[å°æ˜](https://www.bilibili.com/video/BV18z4y1S779?spm_id_from=333.999.0.0)

###  1.368. <a name='MinimumOperationstoReduceX'></a>1658 Minimum Operations to Reduce X

[å°æ˜](https://www.bilibili.com/video/BV18t4y1z7Hq?spm_id_from=333.999.0.0)

###  1.369. <a name='MaximizeGridHappiness'></a>1659. Maximize Grid Happiness

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1kf4y1v7Js?spm_id_from=333.999.0.0)

###  1.370. <a name='CheckIfTwoStringArraysareEqui'></a>1662 Check If Two String Arrays are Equi

[å°æ˜](https://www.bilibili.com/video/BV1LV411t7v4?spm_id_from=333.999.0.0)

###  1.371. <a name='SmallestStringWithAGivenNumer'></a>1663 Smallest String With A Given Numer

[å°æ˜](https://www.bilibili.com/video/BV1gv411e7Ly?spm_id_from=333.999.0.0)

###  1.372. <a name='FindtheMostCompetitiveSubseq'></a>1673 Find the Most Competitive Subseq

[å°æ˜](https://www.bilibili.com/video/BV1yK4y1H7ni?spm_id_from=333.999.0.0)

###  1.373. <a name='MinimumMovestoMakeArrayComplement'></a>1674. Minimum Moves to Make Array Complement

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1qz4y1k7Cm?spm_id_from=333.999.0.0)

###  1.374. <a name='MinimizeDeviationinArray'></a>1675. Minimize Deviation in Array

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV15541157p6?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV16f4y167uf?spm_id_from=333.999.0.0)

```py
ä»Šå¤©åšä¸€å›æ¬è¿å·¥ï¼Œå‚è€ƒå¤§ä½¬çš„

from sortedcontainers import SortedList
class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        ls = SortedList([val<<1 if val&1 else val for val in nums])
        ans = ls[-1] - ls[0]
        while not ls[-1] & 1:
            ls.add(ls.pop()>>1)
            ans = min(ans, ls[-1] - ls[0])            
        return ans
å…ˆå¾ªç¯å¤„ç†æœ€å°çš„å¥‡æ•°ï¼Œç„¶åå†å¾ªç¯å¤„ç†æœ€å¤§çš„å¶æ•°

from sortedcontainers import SortedList
class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        st = SortedList(nums)
        ans = st[-1] - st[0]
        while st[0] & 1:
            n = st[0]
            st.discard(n)
            st.add(n << 1)
            ans = min(ans, st[-1] - st[0])
        while st[-1] & 1 == 0:
            n = st[-1]
            st.discard(n)
            st.add(n >> 1)
            ans = min(ans, st[-1] - st[0])
        return ans
```

```py

```

###  1.375. <a name='MaxNumberofK-SumPairs'></a>1679 Max Number of K-Sum Pairsã€‘

[å°æ˜](https://www.bilibili.com/video/BV16t4y1z7kY?spm_id_from=333.999.0.0)

###  1.376. <a name='ConcatenationofConsecutiveBina'></a>1680 Concatenation of Consecutive Bina

[å°æ˜](https://www.bilibili.com/video/BV1Py4y117o5?spm_id_from=333.999.0.0)

###  1.377. <a name='MinimumIncompatibility'></a>1681. Minimum Incompatibility

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV16p4y1z79z?spm_id_from=333.999.0.0)

###  1.378. <a name='StoneGameVII'></a>1690. Stone Game VII

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1wf4y1e7xH?spm_id_from=333.999.0.0)

###  1.379. <a name='On-kO1JumpGameVI'></a>1696. ã€åŠ¨æ€ğŸš€è§„åˆ’ O(n-k) * ä¼˜å…ˆé˜Ÿåˆ— O(1) + æœ€å°å †ğŸŒµã€‘ Jump Game VI

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1554y1t7Tz?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        # æš´åŠ›æ±‚è§£æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼šO(k*(n-k))
        # dp[i] = nums[i] + max(dp[æ­¥é•¿ä¸­é—´çš„å…ƒç´ ]) for æ­¥é•¿ä¸­é—´çš„å…ƒç´  in range(i - æœ€å¤§æ­¥é•¿, i)
        # æ¯ä¸€æ¬¡, iè¿›ä¸€ä½çš„æ—¶å€™, max(dp[æ­¥é•¿ä¸­é—´çš„å…ƒç´ ])ä¹Ÿä¼šå˜åŒ–, ç›¸å½“äºä¸€ä¸ªæ»‘åŠ¨çª—å£
        
        dp = [0] * len(nums)
        dp[0] = nums[0]
        
        que = [0]
        for i in range(1, len(nums)):
            # ç»´æŠ¤æ»‘åŠ¨çª—å£çš„å®½åº¦: å½“æ­¥é•¿è¶…è¿‡äº†kï¼Œåˆ™å¼¹å‡º
            while que and i - que[0] > k:
                que.pop(0)
            dp[i] = dp[que[0]] + nums[i]
            # ç»´æŠ¤æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼: é˜Ÿåˆ—çš„æœ€åä¸€ä¸ªå…ƒç´ å§‹ç»ˆæ˜¯æœ€å¤§å€¼
            while que and dp[que[-1]] <= dp[i]:
                que.pop(-1)
            que.append(i)     
            print(que)
            # [0, 1]
            # [0, 1, 2]
            # [3]
            # [3, 4]
            # [5]
        return dp[-1]

if __name__ == "__main__":      
	s = Solution()
	print(s.maxResult(nums = [10,-5,-2,4,0,3], k = 3))
```


```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        # ç»´æŠ¤å½“å‰æœ€å¤§å€¼æ–¹æ³•
        # 1ï¼šæœ€å¤§å †æ–¹æ³•
        # 2: å•è°ƒé€’å‡é˜Ÿåˆ—ï¼ˆé˜Ÿé¦–ï¼‰
        n = len(nums)
        maxHeap = []
        heapq.heapify(maxHeap)
        heapq.heappush(maxHeap, (-nums[0], 0))
        res = nums[0]

        for i in range(1, n):
            while maxHeap and i - maxHeap[0][1] > k:    #indexçš„è·ç¦»å¤ªå¤§(> k)ï¼Œä»¥åiè¶Šæ¥è¶Šå¤§ï¼Œtop()å°±æ²¡ç”¨äº†
                heapq.heappop(maxHeap)
            res = -maxHeap[0][0] + nums[i]
            heapq.heappush(maxHeap, (-res, i) )         #dpçš„æ€æƒ³
            # print(maxHeap): [1,-1,-2,4,-7,3]
            # [(-1, 0), (0, 1)]
            # [(-1, 0), (0, 1), (1, 2)]
            # [(-4, 3), (1, 2), (0, 1)]
            # [(-4, 3), (1, 2), (0, 1), (3, 4)]
            # [(-7, 5), (-4, 3), (0, 1), (3, 4), (1, 2)]
        return res
```

PriorityQueueï¼Œæ²¡æœ‰ç´¢å¼•ï¼Œæœ€å¥½è¿˜æ˜¯ç”¨heap

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        from queue import PriorityQueue
        res, maxHeap = nums[0], PriorityQueue()
        maxHeap.put([-nums[0], 0])
        for i in range(1, len(nums)):
            while maxHeap:
                top = maxHeap.get()
                if i - top[-1] <= k:
                    maxHeap.put(top)
                    break
            res = -top[0] + nums[i]
            maxHeap.put([-res, i])
        return res
```

###  1.380. <a name='DetermineifStringHalvesAreAlike'></a>1704 Determine if String Halves Are Alike

[å°æ˜](https://www.bilibili.com/video/BV1WA41157sf?spm_id_from=333.999.0.0)

###  1.381. <a name='MaximumXORWithanElementFromArray'></a>1707. Maximum XOR With an Element From Array

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV13v411t742?spm_id_from=333.999.0.0)

###  1.382. <a name='MinimumOperationstoMakeaSubsequence'></a>1713. Minimum Operations to Make a Subsequence

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Yy4y127DQ?spm_id_from=333.999.0.0)

###  1.383. <a name='SwappingNodesinaLinkedList'></a>1721 Swapping Nodes in a Linked List

[å°æ˜](https://www.bilibili.com/video/BV1Ji4y1P7Xc?spm_id_from=333.999.0.0)

###  1.384. <a name='LargestSubmatrixWithRearrangements'></a>1727. Largest Submatrix With Rearrangements

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1XT4y1N7gy?spm_id_from=333.999.0.0)

###  1.385. <a name='PalindromePartitioningIV'></a>1745. Palindrome Partitioning IV

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1yo4y1R75T?spm_id_from=333.999.0.0)

###  1.386. <a name='MinimumLimitofBallsinaBag'></a>1760. Minimum Limit of Balls in a Bag

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1bK4y1H7Ly?spm_id_from=333.999.0.0)

###  1.387. <a name='MaximumScorefromPerformingMultiplication'></a>1770. Maximum Score from Performing Multiplication

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Li4y1T7j6?spm_id_from=333.999.0.0)

###  1.388. <a name='MaximizePalindromeLengthFromSubsequences'></a>1771. Maximize Palindrome Length From Subsequences

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Cp4y1H7Xq?spm_id_from=333.999.0.0)

###  1.389. <a name='EqualSumArraysWithMinimumNumberofOperatio'></a>1775. Equal Sum Arrays With Minimum Number of Operatio

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Di4y1T7nF?spm_id_from=333.999.0.0)

###  1.390. <a name='DijkstraNumberofRestrictedPathsFromFirsttoLastNode'></a>1786. ã€DijkstrağŸš—ã€‘ Number of Restricted Paths From First to Last Node

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Df4y147TB?spm_id_from=333.999.0.0)

###  1.391. <a name='MaximumAveragePassRatio'></a>1792. Maximum Average Pass Ratio

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1qb4y197zc?spm_id_from=333.999.0.0)

###  1.392. <a name='MaximizeScoreAfterNOperations'></a>1799. Maximize Score After N Operations

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Sf4y1x7Cy?spm_id_from=333.999.0.0)

###  1.393. <a name='MaximumNumberofGroupsGettingFreshDonuts'></a>1815. Maximum Number of Groups Getting Fresh Donuts

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1CU4y187tk?spm_id_from=333.999.0.0)

###  1.394. <a name='FrequencyoftheMostFrequentElement'></a>1838. Frequency of the Most Frequent Element

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Ai4y1P7Yt?spm_id_from=333.999.0.0)

###  1.395. <a name='ClosestRoom'></a>1847. Closest Room

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cy4y1x7sz?spm_id_from=333.999.0.0)

###  1.396. <a name='StoneGameVIII'></a>1872. Stone Game VIII

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1vb4y1z7wx?spm_id_from=333.999.0.0)

###  1.397. <a name='1976.Dijkstra'></a> 1976. ã€DijkstrağŸš—ã€‘åˆ°è¾¾ç›®çš„åœ°çš„æ–¹æ¡ˆæ•°

https://cloud.tencent.com/developer/article/1873122

```py
è¿ªæ°æ–¯ç‰¹æ‹‰ æœ€çŸ­è·¯å¾„ï¼Œä¼˜å…ˆé˜Ÿåˆ—
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        from queue import PriorityQueue
        q = PriorityQueue()
        g = [[] for _ in range(n)]
        for r in roads:
            g[r[0]].append((r[1], r[2]))
            g[r[1]].append((r[0], r[2]))
        time_roadnums = [[int(1e15), 0] for _ in range(n)]
        # å­˜å‚¨ ã€æœ€çŸ­æ—¶é—´ï¼Œæ–¹æ¡ˆæ•°ã€‘
        time_roadnums[0][0] = 0
        time_roadnums[0][1] = 1
        q.put([0, 0]) # [æ—¶é—´ï¼Œid] ç¬¬ä¸€ä¸ªå‚æ•°å°çš„ä¼˜å…ˆ
        while not q.empty():
            t, id = q.get()
            for it in g[id]:
                nid, times = it
                if time_roadnums[nid][0] > t+times: # æ›´çŸ­æ—¶é—´
                    time_roadnums[nid][0] = t+times
                    time_roadnums[nid][1] = time_roadnums[id][1] # æ–¹æ¡ˆæ•°æ¸…ç©ºï¼Œæ¢æˆå½“å‰çš„
                    q.put([t+times, nid])
                elif time_roadnums[nid][0] == t+times: # ç›¸åŒæ—¶é—´
                    time_roadnums[nid][1] += time_roadnums[id][1]  # æ–¹æ¡ˆæ•°ç´¯åŠ              
        return time_roadnums[n-1][1]%int(1e9+7)
```
