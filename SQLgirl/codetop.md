<!-- vscode-markdown-toc -->
* 1. [206. åè½¬é“¾è¡¨Reverse Linked List](#ReverseLinkedList)
* 2. [146. LRUç¼“å­˜æœºåˆ¶ã€æ„é€ ğŸ°ã€‘LRU Cache](#LRULRUCache)
* 3. [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘æ•°ç»„ä¸­é‡å¤çš„æ•°å­— Longest Substring Without Repeating Characters](#LongestSubstringWithoutRepeatingCharacters)
* 4. [215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ï¼ˆaddï¼‰](#Kadd)
* 5. [25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ï¼ˆaddï¼‰](#Kadd-1)
* 6. [912 è¡¥å……é¢˜4. æ‰‹æ’•å¿«é€Ÿæ’åºï¼ˆaddï¼‰](#add)
* 7. [15. ä¸‰æ•°ä¹‹å’Œ](#)
* 8. [53. æœ€å¤§å­åºå’Œ53-ã€è´ªå¿ƒğŸ§¡ã€‘Maximum subarray](#Maximumsubarray)
* 9. [1. ä¸¤æ•°ä¹‹å’Œ](#-1)
* 10. [21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](#-1)
* 11. [141-Linked List Cycle](#LinkedListCycle)
* 12. [102-Binary Tree Level Order Traversal](#BinaryTreeLevelOrderTraversal)
* 13. [121. Best Time to Buy and Sell Stock  121-ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº](#BestTimetoBuyandSellStock121-)
* 14. [160-Intersection of Two Linked Lists](#IntersectionofTwoLinkedLists)
* 15. [88-Merge sorted array](#Mergesortedarray)
* 16. [103. Binary Tree Zigzag Level Order Traversal](#BinaryTreeZigzagLevelOrderTraversal)
* 17. [236-äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](#-1)
* 18. [20-Valid parentheses](#Validparentheses)
* 19. [5. ã€å›æ–‡ğŸŒˆã€‘Longest Palindromic Substring -æœ€é•¿å›æ–‡ğŸŒˆå­ä¸²](#LongestPalindromicSubstring-)
* 20. [33. Search in Rotated Sorted Array](#SearchinRotatedSortedArray)
* 21. [200 ã€ğŸ’å¹¶æŸ¥é›†ã€‘å²›å±¿æ•°é‡](#-1)
* 22. [415-Add Strings](#AddStrings)
* 23. [46- â˜… å…¨æ’åˆ—](#-1)
* 24. [92-Reverse Linked List II](#ReverseLinkedListII)
* 25. [142 Linked List Cycle II](#LinkedListCycleII)
* 26. [23. ã€æœ€å°å †ğŸŒµã€‘Merge k Sorted Lists](#MergekSortedLists)
* 27. [54. Spiral Matrix](#SpiralMatrix)
* 28. [300 ã€åŠ¨æ€ğŸš€è§„åˆ’ + äºŒåˆ†ã€‘Longest Increasing Subsequence æœ€é•¿ä¸Šå‡å­åºåˆ—](#LongestIncreasingSubsequence)
* 29. [704.Binary SearchäºŒåˆ†æŸ¥æ‰¾](#BinarySearch)
* 30. [42. Trapping Rain Water](#TrappingRainWater)
* 31. [232-ã€æ„é€ ğŸ°ã€‘Implement Queue using Stacks](#ImplementQueueusingStacks)
* 32. [94-Inorder wih stack](#Inorderwihstack)
* 33. [144-Binary Tree Preorder Traversal](#BinaryTreePreorderTraversal)
* 34. [145-Binary Tree Postorder Traversal](#BinaryTreePostorderTraversal)
* 35. [199 Binary Tree Right Side View](#BinaryTreeRightSideView)
* 36. [143 Reorder List](#ReorderList)
* 37. [70. Climbing Stairs](#ClimbingStairs)
* 38. [124. Binary Tree Maximum Path Sum](#BinaryTreeMaximumPathSum)
* 39. [56. Merge Intervals](#MergeIntervals)
* 40. [å‰‘æŒ‡ Offer 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹](#Offer22.k)
* 41. [82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II(Remove Duplicates from Sorted List](#IIRemoveDuplicatesfromSortedList)
* 42. [69 Sqrt(x) è§ HJ107 æ±‚è§£ç«‹æ–¹æ ¹](#SqrtxHJ107)
* 43. [8. String to Integer(atoi)](#StringtoIntegeratoi)
* 44. [19-Remove Nth Node From End of List](#RemoveNthNodeFromEndofList)
* 45. [2. Add Two Numbers](#AddTwoNumbers)
* 46. [148. Sort List](#SortList)
* 47. [72. Edit Distance 72-ç¼–è¾‘è·ç¦»](#EditDistance72-)
* 48. [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•° Median of Two Sorted Arrays](#MedianofTwoSortedArrays)
* 49. [105-ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„](#-1)
* 50. [151. Reverse Words in a String](#ReverseWordsinaString)
* 51. [104-Maximum Depth of Binary](#MaximumDepthofBinary)
* 52. [76-ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘æœ€å°è¦†ç›–å­ä¸²](#-1)
* 53. [31 â˜… Next Permutation](#NextPermutation)
* 54. [239. â˜…ã€æœ€å°å †ğŸŒµ + æ»‘åŠ¨çª—å£ğŸ”¹å•è°ƒé˜Ÿåˆ—ã€‘Sliding Window Maximum](#SlidingWindowMaximum)
        * 54.1. [ä¸ç±»ä¼¼567ï¼Œ567ç±»ä¼¼187](#567567187)
* 55. [1143 ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ã€‘Longest Common Subsequence](#LongestCommonSubsequence)
        * 55.1. [ç±»ä¼¼é¢˜ç›®ï¼š516æœ€é•¿å›æ–‡ğŸŒˆå­åºåˆ—](#516)
* 56. [129 Sum Root to Leaf Numbers](#SumRoottoLeafNumbers)
* 57. [93. å¤åŸ IP åœ°å€](#IP)
* 58. [110-Balanced Binary Tree](#BalancedBinaryTree)
* 59. [113. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„](#-1)
* 60. [22. Generate Parentheses](#GenerateParentheses)
* 61. [41 First Missing Positive](#FirstMissingPositive)
* 62. [543 Diameter of Binary Tree](#DiameterofBinaryTree)
* 63. [155-ã€æ„é€ ğŸ°ã€‘Min Stack](#MinStack)
* 64. [98. Validate Binary Search Tree 98-éªŒè¯äºŒå‰æœç´¢æ ‘](#ValidateBinarySearchTree98-)
* 65. [470. Implement Rand10() Using Rand7()](#ImplementRand10UsingRand7)
* 66. [101-Symmetric tree](#Symmetrictree)
* 67. [32 Longest Valid Parentheses](#LongestValidParentheses)
* 68. [43. å­—ç¬¦ä¸²ç›¸ä¹˜](#-1)
* 69. [64. Minimum Path Sum 64-æœ€å°è·¯å¾„å’Œ](#MinimumPathSum64-)
* 70. [718. æœ€é•¿é‡å¤å­æ•°ç»„](#-1)
* 71. [78. Subsets å­é›†](#Subsets)
* 72. [112-Path Sum](#PathSum)
* 73. [48. æ—‹è½¬å›¾åƒ Rotate Image](#RotateImage)
* 74. [234. ã€å›æ–‡ğŸŒˆã€‘Palindrome Linked List](#PalindromeLinkedList)
* 75. [322. ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + dfsã€‘Coin Change](#dfsCoinChange)
* 76. [39. Combination Sum 39-ç»„åˆæ€»å’Œ](#CombinationSum39-)
* 77. [169. ã€ä½è¿ç®—ğŸ˜œã€‘Majority Element](#MajorityElement)
* 78. [83-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray)
* 79. [226-ç¿»è½¬äºŒå‰æ ‘](#-1)
* 80. [165. Compare Version Numbers](#CompareVersionNumbers)
* 81. [34-åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ª](#-1)
* 82. [153-å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼](#-1)
* 83. [62-ä¸åŒè·¯å¾„](#-1)
* 84. [128. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Longest Consecutive Sequence](#LongestConsecutiveSequence)
* 85. [468 Validate IP Address](#ValidateIPAddress)
* 86. [136 ã€ä½è¿ç®—ğŸ˜œã€‘Single Number](#SingleNumber)
* 87. [162. Find Peak Element](#FindPeakElement)
* 88. [240. äºŒç»´æ•°ç»„çš„æŸ¥æ‰¾](#-1)
* 89. [221-ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘æœ€å¤§æ­£æ–¹å½¢](#-1)
* 90. [14-Longest common prefix](#Longestcommonprefix)
* 91. [179 Largest Number](#LargestNumber)
* 92. [138. å¤åˆ¶å¸¦éšæœºæŒ‡é’ˆçš„é“¾è¡¨](#-1)
* 93. [695-å²›å±¿çš„æœ€å¤§é¢ç§¯](#-1)
* 94. [å‰‘æŒ‡ Offer 36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨](#Offer36.)
* 95. [24-Swap Nodes in Pairs](#SwapNodesinPairs)
* 96. [394 Decode String](#DecodeString)
* 97. [198. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘House Robber 198-æ‰“å®¶åŠ«èˆ](#HouseRobber198-)
* 98. [209-é•¿åº¦æœ€å°çš„å­æ•°ç»„](#-1)
* 99. [227 Basic Calculator II](#BasicCalculatorII)
* 100. [958. äºŒå‰æ ‘çš„å®Œå…¨æ€§æ£€éªŒ](#-1)
* 101. [å‰‘æŒ‡ Offer 09. ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—](#Offer09.)
* 102. [122. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II](#II)
* 103. [å‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹](#Offer54.k)
* 104. [283. ç§»åŠ¨é›¶](#-1)
* 105. [498. å¯¹è§’çº¿éå†](#-1)
* 106. [662. äºŒå‰æ ‘æœ€å¤§å®½åº¦](#-1)
* 107. [297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–](#-1)
* 108. [460. LFUç¼“å­˜](#LFU)
* 109. [145. äºŒå‰æ ‘çš„ååºéå†](#-1)
* 110. [152. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„](#-1)
* 111. [79. å•è¯æœç´¢](#-1)
* 112. [è¡¥å……é¢˜5. æ‰‹æ’•å½’å¹¶æ’åº](#5.)
* 113. [å‰‘æŒ‡ Offer 10- I. æ–æ³¢é‚£å¥‘æ•°åˆ—](#Offer10-I.)
* 114. [å‰‘æŒ‡ Offer 10- II. é’è›™è·³å°é˜¶é—®é¢˜](#Offer10-II.)
* 115. [å‰‘æŒ‡ Offer 21. è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢](#Offer21.)
* 116. [59. èºæ—‹çŸ©é˜µ II](#II-1)
* 117. [è¡¥å……é¢˜1. æ’åºå¥‡å‡å¶é™é“¾è¡¨](#1.)
* 118. [å‰‘æŒ‡ Offer 40. æœ€å°çš„kä¸ªæ•°](#Offer40.k)
* 119. [518. é›¶é’±å…‘æ¢ II](#II-1)
* 120. [224. åŸºæœ¬è®¡ç®—å™¨](#-1)
* 121. [402. ç§»æ‰Kä½æ•°å­—](#K)
* 122. [è¡¥å……é¢˜23. æ£€æµ‹å¾ªç¯ä¾èµ–](#23.)
* 123. [7. æ•´æ•°åè½¬](#-1)
* 124. [328. å¥‡å¶é“¾è¡¨](#-1)
* 125. [739. æ¯æ—¥æ¸©åº¦](#-1)
* 126. [61. æ—‹è½¬é“¾è¡¨](#-1)
* 127. [å‰‘æŒ‡ Offer 62. åœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°å­—](#Offer62.)
* 128. [å‰‘æŒ‡ Offer 51. æ•°ç»„ä¸­çš„é€†åºå¯¹](#Offer51.)
* 129. [560. å’Œä¸ºKçš„å­æ•°ç»„](#K-1)
* 130. [50. Pow(x, n)](#Powxn)
* 131. [è¡¥å……é¢˜2. åœ†ç¯å›åŸç‚¹é—®é¢˜](#2.)
* 132. [225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ](#-1)
* 133. [230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ ](#K-1)
* 134. [75. é¢œè‰²åˆ†ç±»](#-1)
* 135. [47. å…¨æ’åˆ— II](#II-1)
* 136. [11. ç››æœ€å¤šæ°´çš„å®¹å™¨](#-1)
* 137. [139. å•è¯æ‹†åˆ†](#-1)
* 138. [125. éªŒè¯å›æ–‡ä¸²](#-1)
* 139. [189. æ—‹è½¬æ•°ç»„](#-1)
* 140. [å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ](#Offer27.)
* 141. [74. æœç´¢äºŒç»´çŸ©é˜µ](#-1)
* 142. [287. å¯»æ‰¾é‡å¤æ•°](#-1)
* 143. [384. æ‰“ä¹±æ•°ç»„](#-1)
* 144. [329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„](#-1)
* 145. [349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](#-1)
* 146. [26. åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹](#-1)
* 147. [40. ç»„åˆæ€»å’Œ II](#II-1)
* 148. [9. å›æ–‡æ•°](#-1)
* 149. [å‰‘æŒ‡ Offer 52. ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹](#Offer52.)
* 150. [208. å®ç° Trie (å‰ç¼€æ ‘)](#Trie)
* 151. [440. å­—å…¸åºçš„ç¬¬Kå°æ•°å­—](#K-1)
* 152. [123. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III](#III)
* 153. [135. åˆ†å‘ç³–æœ](#-1)
* 154. [å‰‘æŒ‡ Offer 04. äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾](#Offer04.)
* 155. [207. è¯¾ç¨‹è¡¨](#-1)
* 156. [572. å¦ä¸€ä¸ªæ ‘çš„å­æ ‘](#-1)
* 157. [10. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…](#-1)
* 158. [55. è·³è·ƒæ¸¸æˆ](#-1)
* 159. [1047. åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ç›¸é‚»é‡å¤é¡¹](#-1)
* 160. [91. è§£ç æ–¹æ³•](#-1)
* 161. [å‰‘æŒ‡ Offer 42. è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ](#Offer42.)
* 162. [445. ä¸¤æ•°ç›¸åŠ  II](#II-1)
* 163. [213. æ‰“å®¶åŠ«èˆ II](#II-1)
* 164. [è¡¥å……é¢˜9. 36è¿›åˆ¶åŠ æ³•](#9.36)
* 165. [å‰‘æŒ‡ Offer 45. æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°](#Offer45.)
* 166. [509. æ–æ³¢é‚£å¥‘æ•°](#-1)
* 167. [295. æ•°æ®æµçš„ä¸­ä½æ•°](#-1)
* 168. [å‰‘æŒ‡ Offer 61. æ‰‘å…‹ç‰Œä¸­çš„é¡ºå­](#Offer61.)
* 169. [106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](#-1)
* 170. [678. æœ‰æ•ˆçš„æ‹¬å·å­—ç¬¦ä¸²](#-1)
* 171. [å‰‘æŒ‡ Offer 39. æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—](#Offer39.)
* 172. [86. åˆ†éš”é“¾è¡¨](#-1)
* 173. [114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](#-1)
* 174. [å‰‘æŒ‡ Offer 29. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ](#Offer29.)
* 175. [16. æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ](#-1)
* 176. [450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹](#-1)
* 177. [347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](#K-1)
* 178. [å‰‘æŒ‡ Offer 53 - I. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾æ•°å­— I](#Offer53-I.I)
* 179. [344. åè½¬å­—ç¬¦ä¸²](#-1)
* 180. [191. ä½1çš„ä¸ªæ•°](#-1)
* 181. [443. å‹ç¼©å­—ç¬¦ä¸²](#-1)
* 182. [400. ç¬¬Nä¸ªæ•°å­—](#N)
* 183. [242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯](#-1)
* 184. [100. ç›¸åŒçš„æ ‘](#-1)
* 185. [459. é‡å¤çš„å­å­—ç¬¦ä¸²](#-1)
* 186. [442. æ•°ç»„ä¸­é‡å¤çš„æ•°æ®](#-1)
* 187. [120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ](#-1)
* 188. [268. ç¼ºå¤±æ•°å­—](#-1)
* 189. [887. é¸¡è›‹æ‰è½](#-1)
* 190. [å‰‘æŒ‡ Offer 34. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„](#Offer34.)
* 191. [557. åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯ III](#III-1)
* 192. [è¡¥å……é¢˜14. é˜¿æ‹‰ä¼¯æ•°å­—è½¬ä¸­æ–‡æ•°å­—](#14.)
* 193. [168. Excelè¡¨åˆ—åç§°](#Excel)
* 194. [1095. å±±è„‰æ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼](#-1)
* 195. [670. æœ€å¤§äº¤æ¢](#-1)
* 196. [å‰‘æŒ‡ Offer 11. æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—](#Offer11.)
* 197. [210. è¯¾ç¨‹è¡¨ II](#II-1)
* 198. [525. è¿ç»­æ•°ç»„](#-1)
* 199. [å‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²](#Offer48.)
* 200. [556. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  III](#III-1)
* 201. [111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](#-1)
* 202. [37. è§£æ•°ç‹¬](#-1)
* 203. [134. åŠ æ²¹ç«™](#-1)
* 204. [è¡¥å……é¢˜22. IPåœ°å€ä¸æ•´æ•°çš„è½¬æ¢](#22.IP)
* 205. [876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](#-1)
* 206. [63. ä¸åŒè·¯å¾„ II](#II-1)
* 207. [171. Excelè¡¨åˆ—åºå·](#Excel-1)
* 208. [17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](#-1)
* 209. [494. ç›®æ ‡å’Œ](#-1)
* 210. [å‰‘æŒ‡ Offer 03. æ•°ç»„ä¸­é‡å¤çš„æ•°å­—](#Offer03.)
* 211. [å‰‘æŒ‡ Offer 24. åè½¬é“¾è¡¨](#Offer24.)
* 212. [å‰‘æŒ‡ Offer 33. äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—](#Offer33.)
* 213. [862. å’Œè‡³å°‘ä¸º K çš„æœ€çŸ­å­æ•°ç»„](#K-1)
* 214. [343. æ•´æ•°æ‹†åˆ†](#-1)
* 215. [673. æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°](#-1)
* 216. [é¢è¯•é¢˜ 17.24. æœ€å¤§å­çŸ©é˜µ](#17.24.)
* 217. [611. æœ‰æ•ˆä¸‰è§’å½¢çš„ä¸ªæ•°](#-1)
* 218. [45. è·³è·ƒæ¸¸æˆ II](#II-1)
* 219. [154. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ II](#II-1)
* 220. [85. æœ€å¤§çŸ©å½¢](#-1)
* 221. [679. 24 ç‚¹æ¸¸æˆ](#-1)
* 222. [108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](#-1)
* 223. [222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°](#-1)
* 224. [84. æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢](#-1)
* 225. [71. ç®€åŒ–è·¯å¾„](#-1)
* 226. [167. ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„](#II-)
* 227. [622. è®¾è®¡å¾ªç¯é˜Ÿåˆ—](#-1)
* 228. [6. Z å­—å½¢å˜æ¢](#Z)
* 229. [96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘](#-1)
* 230. [547. çœä»½æ•°é‡ï¼ˆåŸæœ‹å‹åœˆï¼‰](#-1)
* 231. [264. ä¸‘æ•° II](#II-1)
* 232. [706. è®¾è®¡å“ˆå¸Œæ˜ å°„](#-1)
* 233. [97. äº¤é”™å­—ç¬¦ä¸²](#-1)
* 234. [410. åˆ†å‰²æ•°ç»„çš„æœ€å¤§å€¼](#-1)
* 235. [44. é€šé…ç¬¦åŒ¹é…](#-1)
* 236. [18. å››æ•°ä¹‹å’Œ](#-1)
* 237. [405. æ•°å­—è½¬æ¢ä¸ºåå…­è¿›åˆ¶æ•°](#-1)
* 238. [è¡¥å……é¢˜8. è®¡ç®—æ•°ç»„çš„å°å’Œ](#8.)
* 239. [863. äºŒå‰æ ‘ä¸­æ‰€æœ‰è·ç¦»ä¸º K çš„ç»“ç‚¹](#K-1)
* 240. [337. æ‰“å®¶åŠ«èˆ III](#III-1)
* 241. [166. åˆ†æ•°åˆ°å°æ•°](#-1)
* 242. [é¢è¯•é¢˜ 08.12. å…«çš‡å](#08.12.)
* 243. [73. çŸ©é˜µç½®é›¶](#-1)
* 244. [å‰‘æŒ‡ Offer 46. æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²](#Offer46.)
* 245. [503. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II](#II-1)
* 246. [763. åˆ’åˆ†å­—æ¯åŒºé—´](#-1)
* 247. [340. è‡³å¤šåŒ…å« K ä¸ªä¸åŒå­—ç¬¦çš„æœ€é•¿å­ä¸²](#K-1)
* 248. [130. è¢«å›´ç»•çš„åŒºåŸŸ](#-1)
* 249. [117. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II](#II-1)
* 250. [å‰‘æŒ‡ Offer 07. é‡å»ºäºŒå‰æ ‘](#Offer07.)
* 251. [378. æœ‰åºçŸ©é˜µä¸­ç¬¬Kå°çš„å…ƒç´ ](#K-1)
* 252. [å‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III](#Offer32-III.III)
* 253. [77. ç»„åˆ](#-1)
* 254. [528. æŒ‰æƒé‡éšæœºé€‰æ‹©](#-1)
* 255. [279. å®Œå…¨å¹³æ–¹æ•°](#-1)
* 256. [257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](#-1)
* 257. [692. å‰Kä¸ªé«˜é¢‘å•è¯](#K-1)
* 258. [å‰‘æŒ‡ Offer 50. ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦](#Offer50.)
* 259. [137. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— II](#II-1)
* 260. [è¡¥å……é¢˜21. å­—ç¬¦ä¸²ç›¸å‡](#21.)
* 261. [354. ä¿„ç½—æ–¯å¥—å¨ƒä¿¡å°é—®é¢˜](#-1)
* 262. [253. ä¼šè®®å®¤ II](#II-1)
* 263. [628. ä¸‰ä¸ªæ•°çš„æœ€å¤§ä¹˜ç§¯](#-1)
* 264. [674. æœ€é•¿è¿ç»­é€’å¢åºåˆ—](#-1)
* 265. [å‰‘æŒ‡ Offer 57 - II. å’Œä¸ºsçš„è¿ç»­æ­£æ•°åºåˆ—](#Offer57-II.s)
* 266. [315. è®¡ç®—å³ä¾§å°äºå½“å‰å…ƒç´ çš„ä¸ªæ•°](#-1)
* 267. [107. äºŒå‰æ ‘çš„å±‚æ¬¡éå† II](#II-1)
* 268. [172. é˜¶ä¹˜åçš„é›¶](#-1)
* 269. [647. å›æ–‡å­ä¸²](#-1)
* 270. [260. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— III](#III-1)
* 271. [188. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IV](#IV)
* 272. [å‰‘æŒ‡ Offer 35. å¤æ‚é“¾è¡¨çš„å¤åˆ¶](#Offer35.)
* 273. [12. æ•´æ•°è½¬ç½—é©¬æ•°å­—](#-1)
* 274. [386. å­—å…¸åºæ’æ•°](#-1)
* 275. [752. æ‰“å¼€è½¬ç›˜é”](#-1)
* 276. [395. è‡³å°‘æœ‰Kä¸ªé‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](#K-1)
* 277. [231. 2çš„å¹‚](#-1)
* 278. [977. æœ‰åºæ•°ç»„çš„å¹³æ–¹](#-1)
* 279. [437. è·¯å¾„æ€»å’Œ III](#III-1)
* 280. [617. åˆå¹¶äºŒå‰æ ‘](#-1)
* 281. [60. ç¬¬kä¸ªæ’åˆ—](#k)
* 282. [28. å®ç° strStr()](#strStr)
* 283. [204. è®¡æ•°è´¨æ•°](#-1)
* 284. [å‰‘æŒ‡ Offer 65. ä¸ç”¨åŠ å‡ä¹˜é™¤åšåŠ æ³•](#Offer65.)
* 285. [416. åˆ†å‰²ç­‰å’Œå­é›†](#-1)
* 286. [51. Nçš‡å](#N-1)
* 287. [è¡¥å……é¢˜24. åŒæ ˆæ’åº](#24.)
* 288. [680. éªŒè¯å›æ–‡å­—ç¬¦ä¸² â…¡](#-1)
* 289. [å‰‘æŒ‡ Offer 38. å­—ç¬¦ä¸²çš„æ’åˆ—](#Offer38.)
* 290. [701. äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ](#-1)
* 291. [530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®](#-1)
* 292. [698. åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†](#k-1)
* 293. [173. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨](#-1)
* 294. [426. å°†äºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºæ’åºçš„åŒå‘é“¾è¡¨](#-1)
* 295. [836. çŸ©å½¢é‡å ](#-1)
* 296. [99. æ¢å¤äºŒå‰æœç´¢æ ‘](#-1)
* 297. [316. å»é™¤é‡å¤å­—æ¯](#-1)
* 298. [109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘](#-1)
* 299. [115. ä¸åŒçš„å­åºåˆ—](#-1)
* 300. [1312. è®©å­—ç¬¦ä¸²æˆä¸ºå›æ–‡ä¸²çš„æœ€å°‘æ’å…¥æ¬¡æ•°](#-1)

<!-- vscode-markdown-toc-config
    numbering=true
    autoSave=true
    /vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

[Hive SQLé¢è¯•é¢˜(é™„ç­”æ¡ˆ)](https://mp.weixin.qq.com/s/4C4wQdaLdtLuTADi16dEsA)

# 1 day (å¾—åˆ† = 30åˆ†) 30

##  1. <a name='ReverseLinkedList'></a>206. åè½¬é“¾è¡¨Reverse Linked List

https://leetcode-cn.com/problems/reverse-linked-list/submissions/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Q7411V7zr?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV16Q4y1M767?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        res = None
        while head:
            headnxt = head.next
            head.next = res
            res = head
            head = headnxt
        return res
```

```scala
/**
* time complexity: O(n)
* space complexity: O(1) 
*/
object Solution {
    def reverseList(head: ListNode): ListNode = {
        var res: ListNode = null
        var pre = head

        while (pre != null) {
            val prenxt = pre.next
            pre.next = res
            res = pre
            pre = prenxt
        }
        res
    }
}

```

##  2. <a name='LRULRUCache'></a>146. LRUç¼“å­˜æœºåˆ¶ã€æ„é€ ğŸ°ã€‘LRU Cache 

https://leetcode-cn.com/problems/lru-cache/submissions/

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV19b411c7ue?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gt411Y7c6?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1vi4y1t7zj?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ZQ4y1A74H?spm_id_from=333.999.0.0)

```py
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = collections.OrderedDict()


    def get(self, key: int) -> int:
        if key in self.cache:
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
        return -1


    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        if len(self.cache) == self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value

```

```scala

/**
* chosen solution
* build-in linkedHashMap
* time complexity: O(1)
*/
class LRUCache(_capacity: Int) {

    private val capacity = _capacity
    val cache = collection.mutable.LinkedHashMap[Int, Int]()


    def get(key: Int): Int = {
        cache.get(key) match {
            case Some(v) => 
                cache.remove(key)
                cache.put(key, v)
                v
            case None => -1
        }
    }

    def put(key: Int, value: Int): Unit = {
        cache.get(key) match {
            case Some(_) =>
                cache.remove(key)
                cache.update(key, value)

            case None =>
                if(cache.size >= capacity){
                cache.remove(cache.head._1)
                }
                cache.put(key, value)
        }   

    }
}

```

##  3. <a name='LongestSubstringWithoutRepeatingCharacters'></a>3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘æ•°ç»„ä¸­é‡å¤çš„æ•°å­— Longest Substring Without Repeating Characters

https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1h54y1B7No?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1CJ411G7Nn?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1va4y1J7Gx?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1ob411n7mv?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV18K411M7d2?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1DK4y1b7xp?spm_id_from=333.999.0.0)

æ¶‰åŠ sub çš„é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ â€œæ»‘åŠ¨çª—å£â€

ç‰¹æ®Šæƒ…å†µï¼š

* æ—¶é—´å¤æ‚åº¦: O(n) + hashsetåˆ¤æ–­æ˜¯å¦é‡å¤O(n)
  
```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        dic = {}
        leftI = 0
        res = 0
        for rightI, char in enumerate(s):
            # char é‡å¤å‡ºç°ï¼Œå¹¶ä¸” ä¸Šä¸€ä¸ªå‡ºç° åœ¨çª—å£å†…éƒ¨
            # å«ä¹‰ä¸º"tmmzuxt", startåœ¨mï¼Œå½“æœ‰æ–°çš„tè¿›æ¥æ—¶ï¼Œä¸Šä¸€ä¸ªtåœ¨startçš„å‰é¢ï¼Œæ‰€ä»¥ï¼Œæ­¤æ—¶çš„startä¸éœ€è¦ä¿®æ”¹
            if char in dic and leftI <= dic[char]:      # æ˜“é”™ç‚¹: and start <= dic[char]: 
                leftI = dic[char] + 1        # æ˜“é”™ç‚¹: è¿™é‡Œçš„dic[char]è¿˜æ˜¯å‰ä¸€ä¸ª,ä¸” +1
            else:
                res = max(res, rightI - leftI + 1) # æ˜“é”™ç‚¹: +1
            dic[char] = rightI         # æ˜“é”™ç‚¹: dic[char]æ»åæ›´æ–°
        return res
    
```

```scala
/**
* my first commit
* sliding windows
*  time  complexity: O(N), worst: O(2N) -> each char was visited twice
*/
object Solution1 {
    def lengthOfLongestSubstring(s: String): Int = {
        var right = 0
        var left = 0
        var current = ""
        var ret = ""
        
        while(right < s.length) {
            val char = s(right)
            if (current.contains(char)){
                current = current.drop(1)
                left += 1
                 
            }else {
                right += 1
                current += char
            }     
            if(current.length > ret.length) ret = current
        }
        ret.length
    }
}

```

##  4. <a name='Kadd'></a>215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ï¼ˆaddï¼‰

https://leetcode-cn.com/problems/kth-largest-element-in-an-array/

```py
æ—¶é—´å¤æ‚åº¦å°±æ˜¯nlogn
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        q = []
        for num in nums:
            # n*log(k+1)
            heapq.heappush(q, num)
            if len(q) > k:
                # n*log(k)
                heapq.heappop(q)
        return heapq.heappop(q)

è¾“å…¥: [3,2,1,5,6,4] å’Œ k = 2
[1, 3, 2]
[2, 3, 5]
[3, 5, 6]
[4, 6, 5]
```

```py
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k]
```

##  5. <a name='Kadd-1'></a>25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ï¼ˆaddï¼‰

https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/dong-hua-yan-shi-di-gui-25-kge-yi-zu-fan-y6hv/

```py
é€’å½’
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        cur = head
        cnt = 0
        while cur and cnt != k:
            cur = cur.next
            cnt += 1
        if cnt == k:
            cur = self.reverseKGroup(cur,k)
            while cnt:
                headnxt = head.next
                head.next = cur
                cur = head
                head = headnxt
                cnt -= 1
            head = cur # æ˜“é”™ç‚¹: è¿™ä¸€æ­¥ä¸èƒ½æ¼
        return head # head è¿›æ¥ï¼Œhead è¿”å›


```

##  6. <a name='add'></a>912 è¡¥å……é¢˜4. æ‰‹æ’•å¿«é€Ÿæ’åºï¼ˆaddï¼‰

https://leetcode-cn.com/problems/sort-an-array/submissions/

å¿«é€Ÿæ’åº:

```py
class Solution:
    # è¿™é‡Œéœ€è¦ç”¨åˆ° pivot
    def randomized_partition(self, nums, l, r):
        pivot = random.randint(l, r)
        # å…ˆæŠŠ nums[pivot] é è¾¹ç«™
        nums[pivot], nums[r] = nums[r], nums[pivot]
        i = l - 1
        for j in range(l, r):
            if nums[j] < nums[r]: # nums[r] å°±æ˜¯ pivot
                i += 1
                nums[j], nums[i] = nums[i], nums[j] # nums[i] å­˜çš„éƒ½æ˜¯è¾ƒå°çš„æ•°å­—
        i += 1
        nums[i], nums[r] = nums[r], nums[i] # pivot æ”¾åˆ°ä¸­é—´
        return i
    # è¿™é‡Œéœ€è¦ç”¨åˆ° mid
    def randomized_quicksort(self, nums, l, r):
        if r - l <= 0:
            return
        mid = self.randomized_partition(nums, l, r)
        self.randomized_quicksort(nums, l, mid - 1)
        self.randomized_quicksort(nums, mid + 1, r)

    def sortArray(self, nums: List[int]) -> List[int]:
        self.randomized_quicksort(nums, 0, len(nums) - 1)
        return nums

æ—¶é—´å¤æ‚åº¦ï¼šO(n log(n))
ç©ºé—´å¤æ‚åº¦ï¼šO(log n) ~ O(n)
```



```py
å †æ’åº:

     0
    / \
   1   2
  / \ / \
 3  4 5  6

class Solution:
    def max_heapify(self, heap, root, heap_len):
        p = root
        while p * 2 + 2 <= heap_len: # å½“ä¸æ˜¯å¶å­èŠ‚ç‚¹
            l, r = p * 2 + 1, p * 2 + 2 # ä»£è¡¨å·¦å³ç»“ç‚¹
            if r < heap_len and heap[l] < heap[r]:
                bigger = r
            else:
                bigger = l
            # æŠŠæœ€å¤§çš„å…ƒç´ å¾€ä¸Šæ
            if heap[p] < heap[bigger]:
                heap[p], heap[bigger] = heap[bigger], heap[p]
                p = bigger
            else:
                break
        
    def sortArray(self, nums: List[int]) -> List[int]:
        # æ—¶é—´å¤æ‚åº¦O(N)
        # ä»å¶å­èŠ‚ç‚¹å¼€å§‹éå†
        # å¦‚æœä¸æ˜¯ä»å¶å­å¼€å§‹ï¼Œå¯èƒ½ç™½è·‘ä¸€é
        for i in range(len(nums) - 1, -1, -1):
            self.max_heapify(nums, i, len(nums))
            
        # æ—¶é—´å¤æ‚åº¦O(N logN)
        for i in range(len(nums) - 1, -1, -1):
            # æŠŠæœ€å¤§çš„å…ƒç´ æ”¾åˆ°æœ«å°¾
            nums[i], nums[0] = nums[0], nums[i]
            self.max_heapify(nums, 0, i)
        return nums

æ—¶é—´å¤æ‚åº¦ï¼šO(n log(n))
ç©ºé—´å¤æ‚åº¦ï¼šO(1)
```

å½’å¹¶æ’åº:

```py
class Solution:
    def merge_sort(self, nums, l, r):
        if l == r:
            return
        mid = (l + r) // 2
        # å…ˆæŠŠå­åºåˆ—æ’åºå®Œæˆ
        self.merge_sort(nums, l, mid)
        self.merge_sort(nums, mid + 1, r)
        tmp = []
        i, j = l, mid + 1   # i, j æ˜¯ä¸¤ä¸ªèµ·å§‹ç‚¹
        while i <= mid or j <= r:
            # å¦‚æœ å‰åŠéƒ¨éƒ¨åˆ†ç»“æŸäº†ï¼Œæˆ–è€…ååŠéƒ¨åˆ†æ²¡æœ‰ç»“æŸ
            if i > mid or (j <= r and nums[j] < nums[i]): # å› ä¸ºå‰é¢æ˜¯orï¼Œæ‰€ä»¥è¿™é‡Œå¿…é¡»æ˜¯å¯¹iè¿›è¡Œçº¦æŸ
                tmp.append(nums[j])
                j += 1
            else:
                tmp.append(nums[i])
                i += 1

        nums[l: r + 1] = tmp

    def sortArray(self, nums: List[int]) -> List[int]:
        self.merge_sort(nums, 0, len(nums) - 1)
        return nums

æ—¶é—´å¤æ‚åº¦ï¼šO(n log(n))
ç©ºé—´å¤æ‚åº¦ï¼šO(n)
```

```py
æ’åºé—®é¢˜å„æœ‰å„çš„æ‹›ï¼Œæˆ‘æ¥è¯´ä¸€ä¸ªå‡‘çƒ­é—¹çš„æ¡¶æ’åºã€‚åæ­£æ‰€æœ‰æ•°å­—åœ¨æ­£è´Ÿäº”ä¸‡ä¹‹é—´ï¼Œä½ å°±æ‹¿100001ä¸ªæ¡¶ï¼Œéå†ä¸€éæŠŠæ•°å­—ä»å¯¹åº”çš„æ¡¶é‡Œè¾¹ï¼Œç„¶åä½ å°±æ’å¥½äº†ã€‚

class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        bucket = collections.defaultdict(int)
        for n in nums:
            bucket[n] += 1
        ans = []
        for i in range(-50000, 50001):
            ans += [i] * bucket[i]
        return ans
ä½ ä¸€çœ‹è¿™æ–¹æ³•èƒ½è¡Œå•Šï¼Œå¤æ‚åº¦ä¹Ÿä½ï¼é‚£ä¸ºå•¥ä¸ç»å¸¸ç”¨å‘¢ï¼Ÿä½ çŒœï¼Ÿä½ æƒ³æƒ³è¦æœ‰å°æ•°å¯å’‹æ•´ï¼Ÿ
```

##  7. <a name=''></a>15. ä¸‰æ•°ä¹‹å’Œ

https://leetcode-cn.com/problems/3sum/

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1wp4y1W72o?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Tb411578b?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV19K4y1s7co?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV19i4y1s7VZ?spm_id_from=333.999.0.0)

æš´åŠ›è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(n3)

* æ—¶é—´å¤æ‚åº¦:O(1)

åŒæŒ‡é’ˆæ³•ï¼š

å…ˆæ’åºï¼šæ—¶é—´å¤æ‚åº¦:O(n log(n)) + O(n2)

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        # nums.sort() # å¦ä¸€ç§å†™æ³•
        nums = sorted(nums)
        res = []
        for i in range(n-2):
            # ä¼˜åŒ–éƒ¨åˆ†ï¼š
            if nums[i] > 0: break
            if nums[i] + nums[i+1] + nums[i+2] > 0: break
            # è¿™ä¸ªå†™æ³•ä¸å¯¹ï¼šif i+1 < n-2 and nums[i] == nums[i+1]: continue
            # è¿™æ ·å¯èƒ½ç›´æ¥è·³è¿‡äº†[-1,-1,2,3]çš„å‰ä¸‰ä¸ª
            # è¿™ä¸ªå†™æ³•æ˜¯æ­£ç¡®çš„â†“ï¼š
            if i - 1 >= 0 and nums[i] == nums[i-1]: continue
            if nums[i] + nums[n-2] + nums[n-1] < 0: continue
            # åŒæŒ‡é’ˆéƒ¨åˆ†ï¼š
            left = i + 1
            right = n - 1
            while left < right: 
                if nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                elif nums[i] + nums[left] + nums[right] < 0:
                    left += 1
                else:
                    res.append([nums[i],nums[left],nums[right]])
                    # å»é‡ï¼š
                    while nums[left] == nums[left + 1] and left + 1 < right: # æ³¨æ„è¾¹ç•Œ
                        left += 1
                    left +=1
                    while nums[right] == nums[right - 1] and left < right - 1: # æ³¨æ„è¾¹ç•Œ
                        right -= 1
                    right -=1
        return res
```

```scala
/**
* my first commit
* hashset in twoSum
* a very time consuming version
* O(N^2)
*/
object Solution1 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {

      val l = nums.groupBy(identity).mapValues(aa => if(aa.length >=3) aa.take(3) else aa ).values.flatten.toList

     l.zipWithIndex.flatMap {
      case (value, index) =>
        val ll = collection.mutable.ListBuffer(l: _*)
        ll.remove(index)

        twoSum(ll.toList, -value).filter(_.nonEmpty)
          .map(_ :+ value)
    }.map(pair => (pair.toSet, pair)).toMap.values.toList

  }

   def twoSum(nums: List[Int], target: Int): List[List[Int]] = {
    val valueCounter = nums.groupBy(identity).mapValues(_.length)

    nums.collect {
      case value if target - value == value && valueCounter.get(target - value).exists(_ >= 2) =>
        List(value, target - value)
      case value if target - value != value && valueCounter.contains(target - value) =>
        List(value, target - value)

    }
  }

}


```

##  8. <a name='Maximumsubarray'></a>53. æœ€å¤§å­åºå’Œ53-ã€è´ªå¿ƒğŸ§¡ã€‘Maximum subarray

https://leetcode-cn.com/problems/maximum-subarray/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1QJ411R75H?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i7dn?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV11A41187AR?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Ta4y1i7Sh?spm_id_from=333.999.0.0)

è´ªå¿ƒ

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5qrso4wuc440.png)

```py
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = preSum = nums[0]
        for num in nums[1:]:
            preSum = max(preSum + num, num)
            res = max(res, preSum)
        return res
```

æ—¶é—´å¤æ‚åº¦ï¼šO(n)
æ—¶é—´å¤æ‚åº¦ï¼šO(1)

```scala
object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
        for (i <- Range(1, nums.length)) {
            if (nums(i-1) > 0) {
                nums(i) += nums(i-1)
            }
        }
        nums.max
    }
}
```

##  9. <a name='-1'></a>1. ä¸¤æ•°ä¹‹å’Œ


[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1rE411Y7UN?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV19b411v7qp?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Zf4y1G7W4?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1rv411k7VY?spm_id_from=333.999.0.0)

æš´åŠ›æ±‚è§£ï¼š

* æ—¶é—´å¤æ‚åº¦:O(n2)

* æ—¶é—´å¤æ‚åº¦:O(1)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                if nums[i] + nums [j] == target:
                    return [i,j]
```

æŸ¥æ‰¾è¡¨æ³•:

* å“ˆå¸Œè¡¨(ä¸éœ€è¦ç»´æŠ¤è¡¨çš„é¡ºåºæ€§)

* å¹³è¡¡äºŒå‰æœç´ æ ‘

* æ—¶é—´å¤æ‚åº¦:O(n)

* æ—¶é—´å¤æ‚åº¦:O(n)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i, num in enumerate(nums):
            if num in dic:
                return [dic[num], i]
            dic[target - num] = i
```

```scala
/**
* chosen solution
* time complexity: O(N)
*/


object Solution0 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}


/**
* more elegant
*/


object Solution1-2 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}
```

##  10. <a name='-1'></a>21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

https://leetcode-cn.com/problems/merge-two-sorted-lists/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1rJ41127ry?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7D7?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1my4y127bK?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1qZ4y1j7Jb?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ck4y1k7J9?spm_id_from=333.999.0.0)

æš´åŠ›è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(M+N)

* æ—¶é—´å¤æ‚åº¦:O(1)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        cur = dummy # dummyæ˜¯å›ºå®šèŠ‚ç‚¹ï¼Œcuræ˜¯ç§»åŠ¨æŒ‡é’ˆ
        while list1 and list2: # è¿™é‡Œæ˜¯and
            if list1.val < list2.val: # æ˜“é”™ç‚¹ï¼šè¿™é‡Œæ˜¯list.valï¼Œè€Œä¸æ˜¯list
                cur.next = list1
                list1 = list1.next # å‘åè¿›ä¸€ä½
            else:
                cur.next = list2
                list2 = list2.next # å‘åè¿›ä¸€ä½
            cur = cur.next # å‘åè¿›ä¸€ä½
        cur.next = list1 or list2 # æ˜“é”™ç‚¹ï¼šè¿™é‡Œæ˜¯cur.nextï¼Œè€Œä¸æ˜¯curã€‚è¿™é‡Œæ˜¯or
        # ç­‰æ•ˆäºï¼š
        # if list1:
        #     cur.next = list1
        # else:
        #     cur.next = list2
        return dummy.next
```

é€’å½’è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(M+N)

* æ—¶é—´å¤æ‚åº¦:O(M+N)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        elif not list2:
            return list1
        elif list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2) # æ‰¾åˆ°è¾ƒå°å¤´ç»“ç‚¹ï¼Œæå–å‡ºæ¥
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next) # æ‰¾åˆ°è¾ƒå°å¤´ç»“ç‚¹ï¼Œæå–å‡ºæ¥
            return list2
```

```scala
/**
* iterative version
* time complexity: O(N + M), N is the length of l1, M is the length of l2
*/
object Solution1 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        val headNode = new ListNode(-1, null)
        var cur = headNode
        
        var no1 = l1;
        var no2 = l2;
        
        while(no1 != null && no2 != null) {
            if (no1.x >= no2.x){
                
                cur.next = no2
                no2 = no2.next
            }else {
                cur.next = no1
                no1 = no1.next
            }
            cur = cur.next
        }
        (no1, no2) match {
            case (_, null) => cur.next = no1
            case (null, _) => cur.next = no2
            case _ => throw new RuntimeException()
        }
        
        headNode.next
    }
}



/**
* recursive version
*/

object Solution1-2 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        (l1, l2) match {
            case (null, _) => l2
            case (_, null) => l1
            case (a, b) => 
                if (a.x >= b.x){
                    b.next = mergeTwoLists(b.next, a)
                    b
                } else {
                    a.next = mergeTwoLists(a.next, b)
                    a   
                }
        }
    }
}

object Solution {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
    if(l1 == null) return l2
    if(l2 == null) return l1

    if (l1.x < l2.x) {
      l1.next = mergeTwoLists(l1.next, l2)
      l1
    } else {
      l2.next = mergeTwoLists(l1, l2.next)
      l2
    }
  }
}

```

##  11. <a name='LinkedListCycle'></a>141-Linked List Cycle

https://leetcode-cn.com/problems/linked-list-cycle/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1g7411a7ta?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411H7XP?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1KX4y157vh?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1PA411b7gq?spm_id_from=333.999.0.0)

```py
æ–¹æ³•ä¸€ï¼šé›†åˆ å¦‚æœå‘ç°èŠ‚ç‚¹å·²åœ¨é›†åˆå†…åˆ™è¯´æ˜å­˜åœ¨ç¯

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            visited.add(head)
            head = head.next
            if head in visited:
                return True
        return False

æ„Ÿè§‰åˆå§‹æ—¶æŠŠå¿«æ…¢æŒ‡é’ˆéƒ½æŒ‡å‘ head åè€Œæ›´ç®€æ´ï¼š

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
        
```


```scala
object Solution1 {
    def hasCycle(head: ListNode): Boolean = {
        
        var cur = head
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        
        var res: Boolean = false
        while (cur != null && res != true) {

            if(visited.contains(cur))  
                res = true
            else {
                visited += cur
                cur = cur.next
            }
        }
        res
    }
}


object Solution3 {
    def hasCycle(head: ListNode): Boolean = {
        var fast = head
        var slow = head
        
        
        var result = false
        while (fast != null && fast.next != null && result != true) {
            fast = fast.next.next
            slow = slow.next
        
            if(fast == slow) result = true
        }
        result
    }
}
```


##  12. <a name='BinaryTreeLevelOrderTraversal'></a>102-Binary Tree Level Order Traversal

https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1W54y197Lc?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV14T4y1u7Wk?spm_id_from=333.999.0.0)

> python queue

```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)): # å½“å‰å±‚çš„ä¸ªæ•°!!!
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res


from collections import deque
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        if not root:
            return []

        queue = deque([root]) 
        res = []
        
        while queue: 
            level = [] 
            for _ in range(len(queue)): 
                node = queue.popleft() 
                level.append(node.val) 
                if node.left:
                    queue.append(node.left) 
                if node.right:
                    queue.append(node.right) 
            res.append(level) 
        return res
```


> python é€’å½’


```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []

        def bfs(node, level):
            if node: 
                if len(res) < level + 1:
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0)
        return res

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        dic = collections.defaultdict(list)

        def bfs(node, level):
            if node:
                dic[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0) 
        return [*dic.values()]
```

> scala queue

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val buffer =  scala.collection.mutable.Queue[TreeNode]()
        val res =  scala.collection.mutable.ListBuffer[List[Int]]()

        if(root == null) return List[List[Int]]()
        buffer.enqueue(root)
    
        while(buffer.nonEmpty) {
          val cur = scala.collection.mutable.ListBuffer[Int]()
          for ( _ <- 0 until buffer.size) {
            val node = buffer.dequeue
            cur.append(node.value)
            if(node.left != null) buffer.enqueue(node.left)
            if(node.right != null) buffer.enqueue(node.right)
        }
        res += cur.toList
        }
        res.toList
    }
}
```

> scala é€’å½’

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val oderMap = scala.collection.mutable.Map[Int, List[Int]]()
        bfs(root, 1, oderMap)
        oderMap.values.toList
    }
    def bfs(node: TreeNode, level: Int, map: scala.collection.mutable.Map[Int, List[Int]]): Unit = {
        if (node != null) {
            val l = map.get(level)
                .map(_ :+ node.value)
                .getOrElse(List(node.value))

            map(level) = l
            bfs(node.left, level + 1, map)
            bfs(node.right, level + 1, map)
        }
    }
}
```

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        bfs(if(root == null) List() else List(root), List())
    }

    // @annotation.tailrec
    // @annotation.tailrec å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œä¸‹é¢è¿™ä¸ªå‡½æ•°æ˜¯é€’å½’çš„ï¼Œåœ¨æ ˆæ¡¢çš„ç®¡ç†ä¸Šï¼Œå¸Œæœ›ç¼–è¯‘å™¨èƒ½æ‰€æœ‰ä¼˜åŒ–ã€‚
    def bfs(queue: List[TreeNode], ans: List[List[Int]]): List[List[Int]] = {
        if(queue.isEmpty) ans
        else{
        bfs(queue.flatMap(n => List(n.left, n.right)).filter(_ != null), ans :+ queue.map(n => n.value))
        }
    }
}
```

##  13. <a name='BestTimetoBuyandSellStock121-'></a>121. Best Time to Buy and Sell Stock  121-ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1oW411C7UB?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1cZ4y1K7HP?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1D7411s7A1?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qb411e7by?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV16z4y1Z7jD?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1hA411t76C?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        minprice = 1e9
        for price in prices:
            maxprofit = max(maxprofit,price - minprice)
            minprice = min(minprice,price)
        return maxprofit
```

```scala
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices.foldLeft((Int.MaxValue, 0)){
            case ((minPriceSoFar, maxProfit), price) => (minPriceSoFar min price, maxProfit max (price - minPriceSoFar))
        }._2
    }
}
```

##  14. <a name='IntersectionofTwoLinkedLists'></a>160-Intersection of Two Linked Lists

https://leetcode-cn.com/problems/intersection-of-two-linked-lists/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1n741187X6?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1eb411H7uq?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV18K4y1J7wx?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1np4y1y789?spm_id_from=333.999.0.0)

```py
## 1. å“ˆå¸Œè¡¨

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        visited = set()
        while headA:
            visited.add(headA)
            headA = headA.next
        while headB:
            if headB in visited:
                return headB
            headB = headB.next
        return None

# > æ—¶é—´å¤æ‚åº¦ $O(M+N)$, ç©ºé—´å¤æ‚åº¦ $O(M)$

## 2. åŒæŒ‡é’ˆ

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        pa,pb = headA, headB
        while pa != pb:
            pa = pa.next if pa else headB
            pb = pb.next if pb else headA
        return pa

# > æ—¶é—´å¤æ‚åº¦ $O(M+N)$, ç©ºé—´å¤æ‚åº¦ $O(1)$
```


```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getIntersectionNode(headA: ListNode, headB: ListNode): ListNode = {
        var ha = headA
        var hb = headB
        
        while(ha != hb){
            if(ha == null){
                ha = headB
            }else{
                ha = ha.next
            }
            
            if(hb == null){
                hb = headA
            }else{
                hb = hb.next
            }
        }
        
        ha
    }
}

```

##  15. <a name='Mergesortedarray'></a>88-Merge sorted array

https://leetcode-cn.com/problems/merge-sorted-array/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV14J411X7JE?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7bg?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1g54y1s7ZG?spm_id_from=333.999.0.0)

ç›´æ¥åˆå¹¶åæ’åº

```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # ä¸‰ä¸ªæŒ‡é’ˆ
        cur1 = m - 1
        cur2 = n - 1
        i = m + n -1
        # ä»åå¾€å‰éå†
        while cur1 >= 0 and cur2 >= 0:
            if nums1[cur1] < nums2[cur2]:
                nums1[i] = nums2[cur2]
                cur2 -= 1
            else:
                nums1[i] = nums1[cur1]
                cur1 -= 1
            i -= 1
        # å¦‚æœåé¢çš„é‚£ä¸ªnè¿˜æœ‰å¤šä½™
        if cur2 >= 0:
            nums1[:cur2+1] = nums2[:cur2+1] # æ˜“é”™ç‚¹ï¼šä¸åŒ…æ‹¬å³è¾¹ç•Œ

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()
```

```scala
object Solution {
    def merge(nums1: Array[Int], m: Int, nums2: Array[Int], n: Int): Unit = {
        var trail = m+n-1
        
        var t1 = m-1
        var t2 = n-1
        
        while(t1 > -1 && t2 > -1){
            val e1 = nums1(t1)
            val e2 = nums2(t2)
            
            if(e1 > e2){
                nums1(trail) = e1
                t1 -= 1
                trail -= 1
            }else{
                nums1(trail) = e2
                t2 -= 1
                trail -= 1
            }
        }
        
        if(t1 == -1){
            while(t2 > -1){
                nums1(trail) = nums2(t2)
                t2 -= 1
                trail -= 1
            }
        }else{
            while(t1 > -1){
                nums1(trail) = nums1(t1)
                t1 -= 1
                trail -= 1
            }
        }
        
    }
}

```

##  16. <a name='BinaryTreeZigzagLevelOrderTraversal'></a>103. Binary Tree Zigzag Level Order Traversal

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1NE411M7Fm?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV15h411Z7h5?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1GA411W7NY?spm_id_from=333.999.0.0)

> python é˜Ÿåˆ—

```py
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: 
            return []

        queue = [root]
        res = []
        indexflag = 1 
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

```

é€’å½’

```py
class Solution:
    def zigzagLevelOrder(self, root):
        res = []
        def bfs(node, level):
            if node:
                if level >= len(res):
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0)
        for i in range(1, len(res), 2): # flagï¼Œå„ä¸¤ä¸ªé€†åº
            res[i] = res[i][::-1]
        return res
```

##  17. <a name='-1'></a>236-äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1ov411172r?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV125411p7dr?spm_id_from=333.999.0.0)

```py
# Python è¶…è¶Š99%æ‰§è¡Œé€Ÿåº¦çš„è§£æ³•ï¼šè€Œä¸”ä¹Ÿç®€çŸ­

class Solution:
    def lowestCommonAncestor(self, root, p, q) -> 'TreeNode':

        if root in (None, p, q):
            return root 

        L = self.lowestCommonAncestor(root.left, p, q)
        R = self.lowestCommonAncestor(root.right, p, q)

        return R if None == L else L if None == R else root
```

```scala
/**
*  chosen solution
*  DFS with recursive
*  time complexity O(N), N is the number of node in the tree
*  space complexity O(N)
*/
object Solution0 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }

  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    if (node == null || node == p || node == q) return node
    /**
    *  1. if p and q are node 's child, return p q 's LCA 
    *  2.  if p and q are not node's child return null
    *  3. if p and q, only one of then ar node's child return that node (p or q)
    */
    val left = _lowestCommonAncestor(node.left, p, q)
    val right = _lowestCommonAncestor(node.right, p, q)

    (left, right) match {
      case (null, _) => right  // p and q are both not in left
      case (_, null) => left  // p and q are both not in right
      case (l, r) =>  node // only lowest common ancestor could return both non null node
      // p and q, one of then in left and the other one in right
    }
  }
}
```

##  18. <a name='Validparentheses'></a>20-Valid parentheses

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1DJ41127uA?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7ek?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Hr4y1M7Sc?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1sC4y1H7Hs?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1QA411L7y7?spm_id_from=333.999.0.0)

å…ˆè¿›åå‡ºï¼Œæ‰€ä»¥ç”¨æ ˆ

* æ—¶é—´å¤æ‚åº¦:O(n)

* æ—¶é—´å¤æ‚åº¦:O(n)

```py
# è¿™é“é¢˜èƒŒä¸€èƒŒï¼
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {'{':'}','[':']','(':')'}
        stack = [] # stack è¦æå‰å®šä¹‰å¥½
        for char in s:
            if char in dic: # æ˜¯â€œkeyâ€
                stack.append(char) # ä¸€ä¸ªcharè¿›æ¥ï¼Œè¦ä¹ˆè¢«append
            elif not stack or dic[stack.pop()] != char: 
                # å¦‚æœä¸Šä¸€æ­¥ä¸è¢«appendå°±æ˜¯ä¸å¯¹çš„
                # å¦‚æœè¿™ä¸€æ­¥ä¸åŒ¹é…ä¹Ÿæ˜¯ä¸å¯¹
                return False
        return not stack # å¦‚æœappendä¸Šäº†ï¼Œä½†æ²¡æœ‰è¢«å®Œå…¨popä¹Ÿæ˜¯ä¸å¯¹çš„
```

```scala
/**
* my first commitment
* using stack
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def isValid(s: String): Boolean = {
        if(s.isEmpty || s.length % 2 != 0) return false
        val stack = scala.collection.mutable.Stack[Char]()
        
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')

        s.foreach{c => 
            
            if (mapping.contains(c)){
                stack push c
            }else{
                if(stack.isEmpty || mapping(stack.pop) != c) return false 
             
            }
        }
        stack.isEmpty
        
    }
}


/**
* using stack X FP
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1-3 {
    def isValid(s: String): Boolean = {
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        s.foldLeft(List.empty[Char]){ (stack, c) => 
            stack match {
                case pop :: stackAfterPop if  c.equals(mapping.getOrElse(pop, None)) => stackAfterPop
                case _ => c +: stack
            }
           
        }.isEmpty
        
    }
}

```

##  19. <a name='LongestPalindromicSubstring-'></a>5. ã€å›æ–‡ğŸŒˆã€‘Longest Palindromic Substring -æœ€é•¿å›æ–‡ğŸŒˆå­ä¸²

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV18J411j7Pb?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1ra4y1Y7Gx?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7P6?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1so4y1o765?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1L54y1D7pa?spm_id_from=333.999.0.0)

æš´åŠ›è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(n3),åœ¨ä¸¤ä¸ªforå¾ªç¯é‡Œé¢ï¼Œè¿˜åšäº†ä¸€æ¬¡éå†

* æ—¶é—´å¤æ‚åº¦:O(1)

ä¸­å¿ƒæ‰©æ•£æ³•ï¼š

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.4sfvjkqc4qo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ur1lzo89kk0.png)

* æ—¶é—´å¤æ‚åº¦:O(n2)

* æ—¶é—´å¤æ‚åº¦:O(1)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s


        def palinLen(l,r) -> int:
            while l >= 0 and r < lenStr and s[l] == s[r]: # æ³¨æ„ï¼šè¾¹ç•Œ
                l -= 1
                r += 1
            return r - l - 1 # æ³¨æ„ï¼šæ˜¯ â€œ-1â€

        start = 0  
        end = 1 # æ³¨æ„ï¼šåœ¨ç¬¬ä¸€æ¬¡çš„æ—¶å€™ï¼Œend = 1
        maxmaxLen = maxLen = 1

        for mid in range(lenStr):
            maxLen = max(palinLen(mid, mid), palinLen(mid, mid + 1))
            
            if maxLen > maxmaxLen:
                maxmaxLen = maxLen
                start = mid - (maxLen - 1) // 2 #æ˜“é”™ç‚¹ï¼š-1ï¼Œæœ€å¥½èƒŒä¸€èƒŒ
                end = start + maxLen
        return s[start:end]
```

åŠ¨æ€è§„åˆ’æ³•ï¼š

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.67y5euem0vo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.90ngy2t8j3k.png)

* æ—¶é—´å¤æ‚åº¦:O(n2)

* æ—¶é—´å¤æ‚åº¦:O(n2)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)
        maxlen = maxmaxlen = 1
        start = 0

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s

        dp = [[False for _ in range(lenStr)] for _ in range(lenStr)]
        for i in range(lenStr):
            dp[1][1] = True 
            # dp[1][1]æ˜¯æ­£ç¡®å†™æ³•ï¼Œdp[1,1]æ˜¯é”™è¯¯å†™æ³•

        for j in range(1, lenStr): # æŠŠä¸‰è§’å½¢ç”»å‡ºæ¥ï¼Œå…ˆjï¼Œå†iï¼Œ
            for i in range(j): # å…ˆæ¡†å®šç»“æŸjï¼Œå†æ¡†å®šå¼€å§‹iã€‚
                if s[i] == s[j]:
                    if j - i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                if dp[i][j]:
                    maxlen = j - i + 1
                    if maxlen > maxmaxlen:
                        maxmaxlen = maxlen
                        start = i
        return s[start: start + maxmaxlen]
```


```scala
/**
* chosen solution
* expand around center
* time complexity: O(N * 2 * N) = O(N^2)
*        expandLengths: O(N)
* space complexity: O(1)
*/

object Solution0 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty) return ""
        
        // 0 1 2 3 4 5 6 7
        // r a c e c a r
        // r a c e e c a r
        // b b c e c a a
        val (head, maxlen) = s.indices.foldLeft((0, 1)){
            case ((h, maxlen), i) => 
                val oddlen =  expandLengths(s, i, i)
                val evenlen = expandLengths(s, i, i + 1)
                val len = oddlen max evenlen
                if(len > maxlen)  (i -  (len - 1) / 2, len)
                else (h, maxlen)
        }
        s.slice(head, head + maxlen)
    }
    // return length
    @annotation.tailrec
    def expandLengths(s: String, left: Int, right: Int): Int = {
        if(0 <= left && right < s.length && s(left) == s(right)) expandLengths(s, left - 1, right + 1)
        else right - left - 1
    }
}

/**
* dynamic programming
*/
object Solution3 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty ) return ""
        if(s.length < 2) return s
 
        val dp = Array.ofDim[Boolean](s.length, s.length)
        var maxLen = 1
        var head = 0
 
        for(j <- 1 until s.length; i <- 0 until j){
            val currentLen = j - i + 1
            if(s(i) != s(j))  dp(i)(j) = false
            else if(currentLen < 4)  dp(i)(j) = true // currentLen - 2 < 2
            else dp(i)(j) = dp(i + 1)(j - 1)
            
            
            if(dp(i)(j) && currentLen > maxLen){
                maxLen = currentLen
                head = i

            }
        }
        
        s.slice(head, head + maxLen)
    }
}
```

##  20. <a name='SearchinRotatedSortedArray'></a>33. Search in Rotated Sorted Array

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1gJ411V7Sq?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV14t4y127hK?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV16A41147Fp?spm_id_from=333.999.0.0)

```py
# æˆ‘çš„æ¨¡ä»¿ï¼å•ŠğŸ˜‹

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # å®šä¹‰ç¬¬ä¸€ä¸ªå…ƒç´ å’Œæœ€åä¸€ä¸ªå…ƒç´ 
        l = 0
        r = len(nums) - 1

        while l <= r:
            m = (l+r) // 2
            if nums[m] == target:
                return m
            # åªå­˜åœ¨ä¸€ä¸ªä¸Šå‡åºåˆ—
            if nums[l] <= nums[m]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else: 
                    l = m + 1
            # åªå­˜åœ¨ä¸€ä¸ªä¸Šå‡åºåˆ—
            else:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else: 
                    r = m - 1
        
        return -1
```

```py
# è¿™é“é¢˜ç®€ç›´æ˜¯åœ¨è·Ÿæˆ‘å¼€ç©ç¬‘ï¼ˆç‹—å¤´ï¼‰

class Solution(object):
    def search(self, nums, target):
        return nums.index(target) if target in nums else -1
```

```scala

/**
* binary search - iterative version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      
      var ans = -1
      while(ans == -1 && left <= right) {
        val mid = left + (right - left) / 2

        if (target == nums(mid) ){
          ans = mid

        } else if (nums(left) <= nums(mid)){ // left part is in order
          if (nums(mid) > target && target >= nums(left)) { // target is in left part
            right = mid - 1
          } else {
            left = mid + 1
          }
        } else { // right part is in order
          if (nums(mid) < target && target <= nums(right)) { // target is in right part
            left = mid + 1
          } else {
            right = mid - 1
          }
        } 
      }
      ans
    }
}
```

# 2 day (å¾—åˆ† = 15åˆ†) 45

##  21. <a name='-1'></a>200 ã€ğŸ’å¹¶æŸ¥é›†ã€‘å²›å±¿æ•°é‡

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV15K411p72j?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Cg4y1i7dZ?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1KK4y1U7Ds?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1E64y1T7Nk?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Np4y1977S?spm_id_from=333.999.0.0)

[ä¸€ä¿©ä¸‰å››äº”](https://www.bilibili.com/video/BV114411q7sP?from=search&seid=1135814820928819139&spm_id_from=333.337.0.0)

```py
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        f = {}
        def find(x):
            f.setdefault(x,x)
            if f[x] != x:
                f[x] = find(f[x])
            return f[x]
        def union(x,y):
            f[find(y)] = find(x)
            
        if not grid:
            return 0
        row, col = len(grid), len(grid[0])
        # è¿™é‡Œæ˜¯ union
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    for x, y in [[-1, 0], [0, -1]]:
                        tmp_i = i + x
                        tmp_j = j + y
                        if 0 <= tmp_i < row and 0 <= tmp_j < col and grid[tmp_i][tmp_j] == "1":
                            # æŠŠ array ç¿»è¯‘æˆ list
                            union(tmp_i * col + tmp_j, i * col + j)
        # è¿™é‡Œæ˜¯ find
        res = set()
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    res.add(find(col * i + j))
        return len(res)
```

```py
# dfs
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0]) # è¡Œåˆ—
        ans = 0
        # å°±åƒæ˜¯æŠŠå²›å±¿ä¸€ä¸ªä¸ªèš•é£Ÿ
        # !!! è¿™é‡Œæ²¡æœ‰ visited
        def dfs(i, j): 
            if 0 <= i < m and 0 <= j < n and grid[i][j] == '1':   # è¡¥å……è¾¹ç•Œæ¡ä»¶ï¼Œé˜²æ­¢æº¢å‡º
                grid[i][j] = '0' # dfsç½®ä¸º0
                dfs(i + 1, j)  # éå†4ä¸ªé¢†åŸŸ
                dfs(i - 1, j)  # éå†4ä¸ªé¢†åŸŸ
                dfs(i, j - 1)  # éå†4ä¸ªé¢†åŸŸ
                dfs(i, j + 1)  # éå†4ä¸ªé¢†åŸŸ

        for i in range(m): # è¡Œåˆ—
            for j in range(n): # è¡Œåˆ—
                if grid[i][j] == '1': # å¦‚æœgrid[i][j]ä¸º1ï¼Œåˆ™dfs
                    ans += 1
                    dfs(i, j)
        return ans

```

```py
# å‰å®³çš„è§£æ³•ï¼šSink and count the islands.
class Solution(object):
    def numIslands(self, grid):
        def sink(i, j):
            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '1':
                grid[i][j] = '0'
                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))
                return 1
            return 0
        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[0])))

```

```scala
/**
* chosen solution
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/

object Solution0 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}

/**
* Union & Find 
* memo
*    1. without modify original grid's elements
* time complexity: O(N * M) both N M is the dimension of grid 
*     both union and find operation's amortized time complexity in UnionFind class are very very close to 1 but not 1
*/


object Solution {
  private val endLabel = '0'
  def numIslands(grid: Array[Array[Char]]): Int = {
    val unionFind = new UnionFind(grid)
    for(i <- grid.indices; j <- grid(0).indices)
      union((i, j), unionFind, grid)
    unionFind.counter

  }

  def union(coord: (Int, Int), unionFind: UnionFind, grid: Array[Array[Char]]): Unit = {
    val (row, col) = coord
    if(grid(row)(col) == endLabel) return

    neighbors(coord, (grid.length, grid(0).length)).foreach {
      case (nr, nc) if grid(nr)(nc) != endLabel  =>
        unionFind.union(coord, (nr, nc))
      case _ =>
    }
  }

  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{ case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

##  22. <a name='AddStrings'></a>415-Add Strings

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV18E411n7Cy?spm_id_from=333.999.0.0)

```py
python

class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # ä»æœ€åä¸€ä½å¼€å§‹ç›¸åŠ 
        i, j, carry, tail = len(num1)-1, len(num2)-1, 0, 0
        res = ''

        while i >= 0 or j >= 0 or carry != 0:
            val = carry

            if i >= 0:
                val += ord(num1[i]) - ord('0')
                i -= 1
            if j >= 0:
                val += ord(num2[j]) - ord('0')
                j -= 1

            carry, tail = divmod(val, 10)
            res = str(tail) + res

        return res  

æ—¶é—´å¤æ‚åº¦ï¼š n

ç©ºé—´å¤æ‚åº¦ï¼š 1


è­¦å¯Ÿå”å”ï¼Œæˆ‘æ²¡æœ‰ç”¨ int
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        equation = num1+'+'+num2
        return str(eval(equation))

class Solution(object):
    def addStrings(self, num1, num2):
        return str((eval(num1)+eval(num2)))
```

##  23. <a name='-1'></a>46- â˜… å…¨æ’åˆ—

ç±»ä¼¼é¢˜ç›®ï¼š

https://leetcode-cn.com/problems/permutation-i-lcci/

```py
class Solution:
    def permutation(self, S: str) -> List[str]:
        res = []
        path = ''
        def backtrack(S, path):
            if S == '':
                res.append(path) # è¿™é‡Œä¸éœ€è¦ï¼špath[:]ï¼Œå› ä¸ºè¿™é‡Œ path æ˜¯ str
                return 

            for i in range(len(S)):
                cur = S[i]
                backtrack(S[:i] + S[i+1:], path + cur)
                
        backtrack(S, path)

        return res
```

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1YA411v7zF?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7fm?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1oa4y1v7Kz?spm_id_from=333.999.0.0)

```py
# class Solution:
#     def permute(self, nums: List[int]) -> List[List[int]]:
#         res = []
#         path = []
#         def backtrack(nums):
#             if not nums: 
#                 res.append(path[:]) 
#                 return
#             else:
#                 for i in range(len(nums)):
#                     path.append(nums[i])
#                     backtrack(nums[:i]+nums[i+1:]) 
#                     path.pop()
#         backtrack(nums)
#         return res

# å¦ä¸€ç§å†™æ³•ğŸ˜‹
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        # n = len(nums)
        def backtrack(nums, path):
            # æ˜“é”™ç‚¹ï¼šif len(path) == n:
            if not nums: # åˆ¤æ–­æ¡ä»¶åº”è¯¥æ˜¯è¿™ä¸ª
                res.append(path[:]) # æ˜“é”™ç‚¹ï¼špath[:]
                return
            else:
                for i in range(len(nums)):
                    backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) # æ˜“é”™ç‚¹ï¼šnæ˜¯ä¸æ–­å˜å°çš„
        backtrack(nums, [])
        return res
```

```scala
object Solution {
    var output = List.empty[List[Int]]
    
    def backtrack(nums: Array[Int], l: Int, r: Int): Unit = {
        def swap(a: Int, b: Int) = {
            val temp = nums(a)
            nums(a) = nums(b)
            nums(b) = temp
        }
        
        if(l == r){
            output = output :+ nums.toList
        }else{
            (l to r).map(i => {
                swap(l, i)
                backtrack(nums, l+1, r)
                swap(l, i) //backtrack step
            })
        }
    }
    
    def permute(nums: Array[Int]): List[List[Int]] = {
        output = List.empty[List[Int]]
        var input = nums
        backtrack(input, 0, input.length - 1)
        output
    }
}

```

##  24. <a name='ReverseLinkedListII'></a>92-Reverse Linked List II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1n7411G7N4?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV19c411h7UE?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        dummy = ListNode(0, head)
        pre = dummy
        for _ in range(left - 1):
            pre = pre.next
            # å› ä¸ºéœ€è¦ä¿ç•™ pre, æ‰€ä»¥ left - 1

        cur = pre.next
        for _ in range(right - left):
            # æ˜“é”™ç‚¹ï¼šé¡ºåºä¸èƒ½é”™ï¼Œä¸­ï¼Œåï¼Œå‰ï¼Œå¿ åšé’±
            aft = cur.next
            cur.next = aft.next
            aft.next = pre.next
            pre.next = aft
        
        return dummy.next
```

##  25. <a name='LinkedListCycleII'></a>142 Linked List Cycle II

https://leetcode-cn.com/problems/merge-k-sorted-lists/

[å°æ˜](https://www.bilibili.com/video/BV1W5411L7AF?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV15e41147EY?spm_id_from=333.999.0.0)

![](https://s3.bmp.ovh/imgs/2022/02/5ca7ad17ae2ceeed.png)

```py
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            # å¦‚æœç›¸é‡
            if slow == fast:
                p = head
                q = slow
                while p != q:
                    p = p.next
                    q = q.next
                # ä½ ä¹Ÿå¯ä»¥ return q
                return p
        return None
```

```scala
object Solution {
    def detectCycle(head: ListNode): ListNode = {
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        var cur = head
        
        var result: ListNode = null

        while (cur != null && result == null) {
            // println(result)
            if(visited.contains(cur))  
                result = cur
            else {
                visited += cur
                cur = cur.next
            }
        }
        result
        
    }
}

```

##  26. <a name='MergekSortedLists'></a>23. ã€æœ€å°å †ğŸŒµã€‘Merge k Sorted Lists

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1X4411u7xF?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ty4y1178e?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1GK41157mu?spm_id_from=333.999.0.0)

æš´åŠ›æ±‚è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦: O(N) + O(N logN) + O(N)

* ç©ºé—´å¤æ‚åº¦: O(N) + O(N)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.65tcjjz2oy80.png" width="50%">

```py
# so easyï¼Œä¸€éè¿‡
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        arr = []
        for listhead in lists:
            while listhead:
                arr.append(listhead.val)
                listhead = listhead.next
        arr.sort()
        dummy = ListNode(0)
        cur = dummy
        for value in arr:
            cur.next = ListNode(value)
            cur = cur.next
        return dummy.next
```

ä¼˜å…ˆé˜Ÿåˆ—ï¼š

* æ—¶é—´å¤æ‚åº¦: O(N logk) 

* ç©ºé—´å¤æ‚åº¦: O(N) + O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3tftyqf2g4s0.png" width="50%">

```py
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        q = []  # æ˜“é”™ç‚¹ï¼šå…ˆè¦å®šä¹‰ä¸€ä¸ªç©º
        dummy = ListNode(0)
        cur = dummy
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(q, (lists[i].val, i))  # æ˜“é”™ç‚¹ï¼šè¦å¯ä»¥æ’åºçš„
                lists[i] = lists[i].next # æ˜“é”™ç‚¹ï¼šæ³¨æ„ï¼Œå‘åä¸€ä½
        while q: # æ˜“é”™ç‚¹ï¼šæ³¨æ„è¿™ä¸ªå¾ªç¯æ¡ä»¶
            val, idx = heapq.heappop(q)
            cur.next = ListNode(val)
            cur = cur.next
            if lists[idx]:
                heapq.heappush(q, (lists[idx].val, idx))
                lists[idx] = lists[idx].next # æ˜“é”™ç‚¹ï¼šæ³¨æ„ï¼Œå‘åä¸€ä½
        return dummy.next
```

ä¸¤ä¸¤åˆå¹¶ï¼š

* æ—¶é—´å¤æ‚åº¦: O(N logk) 

* ç©ºé—´å¤æ‚åº¦: O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.60itjgowwpo0.png" width="50%">

```py
class Solution:
    def merge2Lists(self, list1, list2):
        dummy = ListNode(0)
        cur = dummy # dummyæ˜¯å›ºå®šèŠ‚ç‚¹ï¼Œcuræ˜¯ç§»åŠ¨æŒ‡é’ˆ
        while list1 and list2: # è¿™é‡Œæ˜¯and
            if list1.val < list2.val: # æ˜“é”™ç‚¹ï¼šè¿™é‡Œæ˜¯list.valï¼Œè€Œä¸æ˜¯list
                cur.next = list1
                list1 = list1.next # å‘åè¿›ä¸€ä½
            else:
                cur.next = list2
                list2 = list2.next # å‘åè¿›ä¸€ä½
            cur = cur.next # å‘åè¿›ä¸€ä½
        cur.next = list1 or list2 # æ˜“é”™ç‚¹ï¼šè¿™é‡Œæ˜¯cur.nextï¼Œè€Œä¸æ˜¯curã€‚è¿™é‡Œæ˜¯or
        return dummy.next

    def mergeKLists(self, lists: List[ListNode]) -> ListNode:     
        amount = len(lists)
        interval = 1
        while amount > interval:
            # 0,1,2,3,4,5,6  7-1
            # 0, ,2, ,4, ,6  7-2
            # 0, , , ,4, ,   7-3
            # 0, , , , , ,   7-4
            for i in range(0, amount - interval, 2 * interval):
                lists[i] = self.merge2Lists(lists[i], lists[i + interval]) # æ˜“é”™ç‚¹ï¼šæ–¹æ‹¬å·å’Œå°æ‹¬å·ä¸è¦ç”¨é”™
            interval *= 2
        return lists[0] if amount > 0 else None
```

##  27. <a name='SpiralMatrix'></a>54. Spiral Matrix

https://leetcode-cn.com/problems/spiral-matrix/

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1N7411h7i1?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        # print(list(matrix.pop(0)))
        print(list(zip(*matrix)))
        print(list(zip(*matrix))[::-1])
        return matrix and list(matrix.pop(0)) + self.spiralOrder(list(zip(*matrix))[::-1])
        # å«ä¹‰æ˜¯ï¼Œå¦‚æœmatrixä¸ºç©ºï¼Œåˆ™è¿”å›matrix
```

```py
return a and b
 
ç­‰ä»·äº
 
return b if a else a
```

```py
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            res += matrix.pop(0) # æ˜“é”™ç‚¹ï¼šæ³¨æ„æ˜¯ +=
            matrix = list(zip(*matrix))[::-1] # æ˜“é”™ç‚¹ï¼šæ³¨æ„ [::-1] çš„æ‘†æ”¾
        return res
```

```scala
/**
* counterclockwise rotate matrix
* step:
*  1. add first line to list
*  2. counter-clockwise rotate remaining matrix: transpose + entire reverse
*  
*  remaining:
*  4 5 6
*  7 8 9
* 
* transpose:
*   4 7
*   5 8
*   6 9
* 
* reverse:
*   6 9
*   5 8
*   4 7
*/

object Solution2-1 {
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = { 
        def dfs(mx: Array[Array[Int]]): List[Int] = mx match {
            case mx if mx.isEmpty => List()
            case mx if mx.length == 1 => mx.head.toList
            case _ => mx.head.toList ::: spiralOrder(mx.tail.transpose.reverse)  // counter-clockwise
        }
        dfs(matrix)

    }    
}

```

##  28. <a name='LongestIncreasingSubsequence'></a>300 ã€åŠ¨æ€ğŸš€è§„åˆ’ + äºŒåˆ†ã€‘Longest Increasing Subsequence æœ€é•¿ä¸Šå‡å­åºåˆ—

https://leetcode-cn.com/problems/longest-increasing-subsequence/

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Wf4y1y7ou?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1rT4y1ujV?spm_id_from=333.999.0.0)

åŠ¨æ€è§„åˆ’ï¼š æ—¶é—´å¤æ‚åº¦ä¸º O(n2)

```py

class Solution(object):
    def lengthOfLIS(self, nums):
        if not nums:
            return 0

        dp = [1 for i in range(len(nums))]
        # [10,9,2,5,3,7,101,18]
        # [1,1,1,1,1,1,1,1]
        # [1,1, , , , , , ]
        # [1,1,1, , , , , ]
        # [1,1,1,2, , , , ]
        # [1,1,1,2,1+1, , , ]
        # [1,1,1,2,2,1+1æˆ–2+1æˆ–2+1, , ]
        # [1,1,1,2,2,3,1+1æˆ–2+1æˆ–3+1, ]

        for i in range(1, len(nums)): # å…ˆç¡®å®šç»“æŸï¼Œå†ç¡®å®šå¼€å§‹
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[j] + 1, dp[i])

        return max(dp)

```

è´ªå¿ƒ + äºŒåˆ†æŸ¥æ‰¾

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6wjfuj0uqvo0.webp)

```py
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        res = []
        for num in nums:
            # bisect_leftä¼šæŠŠæ–°çš„å…ƒç´ æ”¾åœ¨ç›¸ç­‰å…ƒç´ å‰é¢, å³åŸæ¥å€¼5çš„ç´¢å¼•ä½ç½®2
            i = bisect_left(res, num)
            if i == len(res):
                res.append(num) # å¦‚æœæ–°å…ƒç´ æ’å…¥åœ¨æœ€åé¢
            else:
                res[i] = num # å¦‚æœæ–°å…ƒç´ ä»£æ›¿æ—§å…ƒç´ 
        return len(res)
```

```scala
/**
* dynamic programming 
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution0 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}

```

##  29. <a name='BinarySearch'></a>704.Binary SearchäºŒåˆ†æŸ¥æ‰¾

https://leetcode-cn.com/problems/binary-search/

[å›¾çµ](https://www.bilibili.com/video/BV1Dh411v7yT?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1qa4y157E4?spm_id_from=333.999.0.0)

```py
å¯¹ä¸èµ·æ²¡å¿ä½

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target in nums :
            return nums.index(target)
        else:
            return -1

ï¼ˆç‰ˆæœ¬ä¸€ï¼‰å·¦é—­å³é—­åŒºé—´ï¼Œè¿™ä¸ªæ¨¡æ¿è¦è®°ä½

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2

            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                return mid
        return -1

ï¼ˆç‰ˆæœ¬äºŒï¼‰å·¦é—­å³å¼€åŒºé—´ï¼Œå®¹æ˜“å†™é”™

# class Solution:
#     def search(self, nums: List[int], target: int) -> int:
#         left, right = 0, len(nums)
#         while left < right:
#             mid = (left + right) // 2
#             if nums[mid] < target:
#                 left = mid+1
#             elif nums[mid] > target:
#                 right = mid
#             else:
#                 return mid
#         return -1
```

```scala
object Solution {
    def search(nums: Array[Int], target: Int): Int = {
        nums.lastIndexOf(target)
    }
}

/**
* my first commitment:
* time complexity: O(logn)
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        println(left, right)
        val mid: Int = left  + (right - left) / 2
        if(nums(mid) == target){
          ans = mid
        } else if(target > nums(mid)) {
          left = mid + 1
        } else {
          right = mid - 1
        }
 
      }
      ans
    }
}

```

##  30. <a name='TrappingRainWater'></a>42. Trapping Rain Water

https://leetcode-cn.com/problems/trapping-rain-water/

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1hJ41177gG?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1fi4y1t7BP?spm_id_from=333.999.0.0)


åŒæŒ‡é’ˆï¼š

* æ—¶é—´å¤æ‚åº¦: O(n)

* ç©ºé—´å¤æ‚åº¦: O(1)

```py
#   ğŸ˜‹æˆ‘çš„æ¨¡ä»¿
[0,1,0,2,1,0,1,3,2,1,2,1]

class Solution:
    def trap(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        leftmax = 0
        rightmax = 0
        res = 0
        while left < right:
            if height[left] < height[right]:
                # çŸ­æ¿æ•ˆåº”ï¼Œç§»åŠ¨å°çš„é‚£ä¸ªå€¼
                leftmax = max(leftmax, height[left])
                # æ˜“é”™ç‚¹ï¼šæ³¨æ„reså’Œleftçš„æ¬¡åºï¼šå…ˆresï¼Œåleft
                res += leftmax - height[left] 
                left += 1
            else:
                rightmax = max(rightmax, height[right])
                # æ˜“é”™ç‚¹ï¼šæ³¨æ„reså’Œrightçš„æ¬¡åºï¼šå…ˆresï¼Œåright
                res += rightmax - height[right]
                right -= 1
        return res
```

##  31. <a name='ImplementQueueusingStacks'></a>232-ã€æ„é€ ğŸ°ã€‘Implement Queue using Stacks

https://leetcode-cn.com/problems/implement-queue-using-stacks/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1p741177pp?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1Gf4y147Vj?spm_id_from=333.999.0.0)


```py
class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def push(self, x):
        # è¦æŠŠæ–°æ¥çš„å…ƒç´ å‹å…¥
        while self.s1:
            self.s2.append(self.s1.pop())
        self.s2.append(x) # ç›®çš„æ˜¯æŠŠæœ€åè¿›æ¥çš„å…ƒç´ æœ€ä¸‹é¢
        while self.s2:
            self.s1.append(self.s2.pop())

    def pop(self):
        # å‡è£…æœ€åä¸€ä¸ªå…ƒç´ æ˜¯å¼€å¤´
        return self.s1.pop() if self.s1 else None
        

    def peek(self):
        # å‡è£…æœ€åä¸€ä¸ªå…ƒç´ æ˜¯å¼€å¤´
        return self.s1[-1] if self.s1 else None

    def empty(self):
        return False if self.s1 else True
```

```scala
/**
* using two stack to implement
* one for push, the other for pop
* time complexity amortized O(1) per operation
* space complexity
*/

class MyQueue() {

  /** Initialize your data structure here. */
  private val inputStack = scala.collection.mutable.ArrayStack[Int]()
  private val outputStack = scala.collection.mutable.ArrayStack[Int]()


  /** Push element x to the back of queue. */
  def push(x: Int) {
    inputStack.push(x)

  }

  /** Removes the element from in front of queue and returns that element. */
  def pop(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.pop()

  }

  /** Get the front element. */
  def peek(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.head
  }

  /** Returns whether the queue is empty. */
  def empty(): Boolean = {
    outputStack.isEmpty && inputStack.isEmpty
  }

}

```

##  32. <a name='Inorderwihstack'></a>94-Inorder wih stack

https://leetcode-cn.com/problems/binary-tree-inorder-traversal/

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1uV411o78x?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1o54y1B7Z8?spm_id_from=333.999.0.0)

```py

æœ€å°‘ä»£ç é€’å½’ï¼š

class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []

class Solution(object):
    def preorderTraversal(self, root):
        if not root:
            return []
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []            
        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if root:
            res += self.inorderTraversal(root.left)
            res.append(root.val)
            res += self.inorderTraversal(root.right)
        return res

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        res = []
        res.extend(self.inorderTraversal(root.left))
        res.append(root.val)
        res.extend(self.inorderTraversal(root.right))
        return res

# å‰åºéå†-é€’å½’-LC144_äºŒå‰æ ‘çš„å‰åºéå†

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # ä¿å­˜ç»“æœ
        result = []
        
        def traversal(root: TreeNode):
            if root == None:
                return
            result.append(root.val) # å‰åº
            traversal(root.left)    # å·¦
            traversal(root.right)   # å³

        traversal(root)
        return result

ä¸­åºéå†-é€’å½’-LC94_äºŒå‰æ ‘çš„ä¸­åºéå†

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # å·¦
            result.append(root.val) # ä¸­åº
            traversal(root.right)   # å³

        traversal(root)
        return result

# ååºéå†-é€’å½’-LC145_äºŒå‰æ ‘çš„ååºéå†
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # å·¦
            traversal(root.right)   # å³
            result.append(root.val) # ååº

        traversal(root)
        return result

# # ä¸­åºéå†éœ€å…ˆåˆ¤æ–­å½“å‰ç»“ç‚¹æ˜¯å¦å­˜åœ¨ï¼Œè‹¥å­˜åœ¨åˆ™å°†è¯¥èŠ‚ç‚¹æ”¾å…¥æ ˆä¸­ï¼Œå†å°†å½“å‰ç»“ç‚¹è®¾ç½®ä¸ºç»“ç‚¹çš„å·¦å­©å­ï¼Œ
# # è‹¥ä¸å­˜åœ¨åˆ™å–æ ˆé¡¶å…ƒç´ ä¸ºcurï¼Œå½“ä¸”ä»…å½“æ ˆç©ºcurä¹Ÿä¸ºç©ºï¼Œå¾ªç¯ç»“æŸã€‚

# class Solution:
#     def inorderTraversal(self, root: TreeNode) -> List[int]: 
#         stack, res = [], []
#         node = root
#         while stack or node:
#             if node:
#                 stack.append(node)
#                 node = node.left
#             else:
#                 node = stack.pop()
#                 res.append(node.val)
#                 node = node.right
#         return res

# class Solution:
#     def preorderTraversal(self, root: TreeNode) -> List[int]:
#         stack, res = [], []
#         node = root
#         while stack or node:
#             while node:
#                 res.append(node.val)
#                 stack.append(node)
#                 node = node.left
#             node = stack.pop()
#             node = node.right
#         return res

# class Solution:
#     def preorderTraversal(self, root: TreeNode) -> List[int]:
#         def addAllLeft(node):
#             while node:
#                 res.append(node.val) # append ä¼˜å…ˆ
#                 stack.append(node)
#                 node = node.left

#         stack, res = [], []
#         node = root
#         while stack or node:
#             addAllLeft(node)
#             node = stack.pop()
#             node = node.right
#         return res

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def appendAllLeft(node):
            while node:
                stack.append(node)
                node = node.left

        stack, res = [], []
        appendAllLeft(root)
        while stack:
            node = stack.pop()
            res.append(node.val) # res.append åœ¨ä¸­é—´
            appendAllLeft(node.right)
        return res

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        stack = [root]
        while stack:
            tmp = stack.pop()
            res.append(tmp.val)
            if tmp.left: stack.append(tmp.left) # ç›®çš„æ˜¯leftå…ˆå‡ºï¼šå…ˆè¿›ï¼Œåå‡ºï¼Œå–ååˆ™å…ˆ
            if tmp.right: stack.append(tmp.right) 
        return res[::-1]

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        stack = [root]
        while stack:
            tmp = stack.pop()
            res.append(tmp.val)
            if tmp.right: stack.append(tmp.right)
            if tmp.left: stack.append(tmp.left) # ç›®çš„æ˜¯leftå…ˆå‡ºï¼šåè¿›ï¼Œå…ˆå‡º
        return res
```

##  33. <a name='BinaryTreePreorderTraversal'></a>144-Binary Tree Preorder Traversal

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1n7411D7NZ?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1Ch411Q74P?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1RD4y1D7C7?spm_id_from=333.999.0.0)

##  34. <a name='BinaryTreePostorderTraversal'></a>145-Binary Tree Postorder Traversal

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1n7411D7ub?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1uv411h7Gc?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1xZ4y1H7uS?spm_id_from=333.999.0.0)

##  35. <a name='BinaryTreeRightSideView'></a>199 Binary Tree Right Side View

[å°æ˜](https://www.bilibili.com/video/BV1854y1W7CB?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1xK4y1b7Wh?spm_id_from=333.999.0.0)

```py
class Solution:
    def rightSideView(self, root: TreeNode):
        res, level = [], root and [root]
        while level:
            res.append(level[-1].val)
            level = [nxt for n in level for nxt in (n.left, n.right) if nxt]
        return res

class Solution:
    def rightSideView(self, root: TreeNode):
        if not root:
            return []
        res = []
        level = [root]
        while level:
            tmp = []
            for n in level:
                if n.left: tmp.append(n.left)
                if n.right: tmp.append(n.right)
            res.append(level[-1].val)
            level = tmp
        return res

# é€’å½’
class Solution:
    def rightSideView(self, root: TreeNode):
        res = []
        def bfs(node, level):
            if node:
                if level == len(res):
                    res.append(node.val)
                bfs(node.right, level + 1)
                bfs(node.left, level + 1)
        bfs(root, 0)
        return res
```

##  36. <a name='ReorderList'></a>143 Reorder List

https://leetcode-cn.com/problems/reorder-list/

[å°æ˜](https://www.bilibili.com/video/BV1Jf4y1Q7y7?spm_id_from=333.999.0.0)

```py
class Solution:
    def reorderList(self, head: ListNode) -> None:
        que = []
        
        cur1 = head
        while cur1.next: # é“¾è¡¨é™¤äº†é¦–å…ƒç´ å…¨éƒ¨åŠ å…¥åŒå‘é˜Ÿåˆ—
            que.append(cur1.next)
            cur1 = cur1.next
        # åŒæŒ‡é’ˆ
        cur2 = head
        i, j = 0, len(que) - 1
        while i <= j: # ä¸€åä¸€å‰åŠ å…¥é“¾è¡¨
            cur2.next = que[j] # å¤´éƒ¨è¿æ¥åˆ°å°¾éƒ¨
            cur2 = cur2.next
            j -= 1
            cur2.next = que[i] # å½“i = jè¿˜æ˜¯æŒ‡å‘æœ¬èº«
            cur2 = cur2.next
            i += 1
        cur2.next = None # å°¾éƒ¨ç½®ç©º

# åŒå‘é˜Ÿåˆ—
class Solution:
    def reorderList(self, head: ListNode) -> None:
        que = collections.deque()
        cur = head
        while cur.next: # é“¾è¡¨é™¤äº†é¦–å…ƒç´ å…¨éƒ¨åŠ å…¥åŒå‘é˜Ÿåˆ—
            que.append(cur.next)
            cur = cur.next
        cur = head
        # ä¸€åä¸€å‰åŠ å…¥é“¾è¡¨
        while len(que): # ä¸€åä¸€å‰åŠ å…¥é“¾è¡¨
            cur.next = que.pop()
            cur = cur.next
            if len(que):
                cur.next = que.popleft()
                cur = cur.next
        cur.next = None # å°¾éƒ¨ç½®ç©º
 

```

##  37. <a name='ClimbingStairs'></a>70. Climbing Stairs ï¼ˆé‡è¦ï¼‰

https://leetcode-cn.com/problems/climbing-stairs/

[5:32 èŠ±èŠ±é…± DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1gJ411R7X1?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ 70(é‡åˆ¶ç‰ˆ)](https://www.bilibili.com/video/BV1G54y197eZ?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7s9?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1DZ4y1H7k9?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ki4y1u7tn?spm_id_from=333.999.0.0)

```py
# æˆ‘çš„æ¨¡ä»¿

class Solution:
    def climbStairs(self, n: int) -> int:
        dp0 = 1
        dp1 = 1
        for _ in range(n - 1):
            dp1, dp0 = dp0 + dp1, dp1 # ç”¨2ä¸ªæ•°å­—åˆ†åˆ«å­˜å‚¨
        return dp1
```

```scala
/**
* dynamic programming
*   1. dp(i) represent climb to i floor's distinct ways
*   2. dp(i) could be calculate from dp(i - 1) + dp(i - 2)
*           (1) taking a single step from dp(i - 1)
*           (2) taking a step of two from dp(i - 2)
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution0 {
    def climbStairs(n: Int): Int = {
        val dp = Array.ofDim[Int](n + 1)
        dp(0) = 1
        dp(1) = 1
        (2 to n).foreach(i => dp(i) = dp(i - 1) + dp(i - 2))
        dp(n)
    }
}
```

```scala
object Solution {
    
    def climbStairs(n: Int): Int = {
        if(n==1){
            1
        }else if(n == 2){
            2
        }else{
            climbStairs(n-1) + climbStairs(n-2)
        }
    }
}
```

##  38. <a name='BinaryTreeMaximumPathSum'></a>124. Binary Tree Maximum Path Sum

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1ct411r7qw?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1CT4y1g7bR?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1qT4y1J71C?spm_id_from=333.999.0.0)

```py
æˆ‘çš„æ€è€ƒï¼š
        # æœ‰ä¸¤ç§æƒ…å†µï¼š
        # node.val å¾€ä¸Šå›æ”¶, æ„æˆé€’å½’
        return max(left, right) + node.val
        # node.val ä¸å¾€ä¸Šå›æ”¶, å·¦ä¸­å³
        res = max(left + right + node.val, res)

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = -1e9
        # left = right = 0
        def subsum(node) -> int:
            nonlocal res # ä¹Ÿå¯ä»¥å†™æˆ self.res
            if not node:
                return 0
            # if node.left:
            left = max(subsum(node.left), 0)     # æ­£è´Ÿæ€§ï¼šleft ä¸ºè´Ÿï¼Œå°±ä¸å›æ”¶
            # if node.right:
            right = max(subsum(node.right), 0)   # æ­£è´Ÿæ€§ï¼šright ä¸ºè´Ÿï¼Œå°±ä¸å›æ”¶
            # æœ‰ä¸¤ç§æƒ…å†µï¼šnode.val ä¸å¾€ä¸Šå›æ”¶, å·¦ä¸­å³
            res = max(left + right + node.val, res)
            # æœ‰ä¸¤ç§æƒ…å†µï¼šnode.val å¾€ä¸Šå›æ”¶, æ„æˆé€’å½’
            return max(left, right) + node.val # æ­£è´Ÿæ€§ï¼šnode.valå¿…é¡»å›æ”¶
        subsum(root)
        return res
```

```scala
object Solution1 {
    def maxPathSum(root: TreeNode): Int = {
        dfs(root)._1
    }

    def dfs(node: TreeNode): (Int, Int) = {
      if (node == null) return (Int.MinValue, 0)
      
      val (leftSoFar, leftEndingHere) = dfs(node.left)
      val (rightSoFar, rightEndingHere) = dfs(node.right)

      val maxSoFar = leftSoFar max rightSoFar max (node.value + leftEndingHere + rightEndingHere)

      val maxEndingHere = 0 max (node.value + (leftEndingHere max rightEndingHere))
      (maxSoFar, maxEndingHere)
    }
}
```

##  39. <a name='MergeIntervals'></a>56. Merge Intervals

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV11t411J7zV?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1w7411a7Wo?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1pV411a7t4?spm_id_from=333.999.0.0)

```py
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort() # ç­‰ä»·äºï¼šintervals.sort(key = lambda x: x[0])
        res = []
        for interval in intervals: # res[-1] å’Œ interval æ¯”è¾ƒ
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1], interval[1])
                # æ˜“é”™ç‚¹ï¼šä¸æ˜¯interval[1]ï¼Œè€Œæ˜¯max(res[-1][1],interval[1])
                # æ¯”å¦‚ï¼Œ[[1,4],[2,3]]
        return res
```

```scala

/**
*  time complexity: O(nlogn) + O(n) = O(nlogn) 
*  space complexity: O(n): sorted array
*/

object Solution1-2 {
    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {
      intervals.sortBy(_(0)).foldLeft(List.empty[Array[Int]]){
        case (last::ans, arr) =>
          if (last.last < arr.head) {
            arr::last::ans
          } else {
            Array(last.head, last.last max arr.last)::ans
          }
        case (ans, arr) => arr::ans // for empty ans list
      }.toArray
    }
}
```

##  40. <a name='Offer22.k'></a>å‰‘æŒ‡ Offer 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹

```py
æ ˆ
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        stack = []
        while head:
            stack.append(head)
            head = head.next
        return stack[-k]

å¿«æ…¢æŒ‡é’ˆ
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        slow, fast = head, head
        for i in range(k):
            fast = fast.next
        while fast:
            slow = slow.next
            fast = fast.next
        return slow

æ€»é•¿åº¦å‡k
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        node, listlen = head, 0  
        while node:
            node = node.next
            listlen += 1

        node = head
        for _ in range(listlen - k):
            node = node.next
        return node  
```

##  41. <a name='IIRemoveDuplicatesfromSortedList'></a>82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II(Remove Duplicates from Sorted List

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/

[æ´›é˜³](https://www.bilibili.com/video/BV1Fi4y187pj?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0, head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                # æŠŠæ‰€æœ‰ç­‰äº x çš„ç»“ç‚¹å…¨éƒ¨åˆ é™¤
                x = cur.next.val
                while cur.next and cur.next.val == x:
                    cur.next = cur.next.next
            else:
                cur = cur.next
        return dummy.next
```

##  42. <a name='SqrtxHJ107'></a>69 Sqrt(x) è§ HJ107 æ±‚è§£ç«‹æ–¹æ ¹

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1WW411C7YN?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1gJ411R7XR?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i7TN?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1PK411s72g?spm_id_from=333.999.0.0)

äºŒåˆ†æŸ¥æ‰¾:

æ—¶é—´å¤æ‚åº¦ï¼šO(logN)

ç©ºé—´å¤æ‚åº¦ï¼šO(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r = 0, x
        ans = -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x: # 2*2=4
                ans = mid # ans å¿…é¡»æ”¾ç½®åœ¨è¿™ä¸ªä½ç½®
                l = mid + 1
            else:
                r = mid - 1
        return ans
```

ç‰›é¡¿è¿­ä»£æ³•:

æ—¶é—´å¤æ‚åº¦ï¼šO(logN)

ç©ºé—´å¤æ‚åº¦ï¼šO(1)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3g2xmodb40u0.png)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x <= 1:
            return x
        res = x # åˆå§‹å€¼
        c = x # ç‰›é¡¿è¿­ä»£æ³•ä¸­çš„å¸¸æ•°
        while res > c / res:
            res = (res + c / res) // 2 # è¿™é‡Œå¿…é¡»ç”¨æ•´é™¤
        return int(res)
        
class Solution:
    def mySqrt(self, num: int) -> int:
        x = 1 # èƒŒä¸€èƒŒè¿™ä¸ªå¥—è·¯
        while abs(x**2 - num) > 0.001:
            x -= (x**2 - num) / (2 * x) # æ³¨æ„è¿™é‡Œæ˜¯å‡å·
        return floor(x)
```

```scala

/**
* Newton's method - iterative
* y = x^2 => f(x) = x^2 - y
* x_{k+1} = x_k - f(x_k) / f'(x_k)
* x_{k+1} = x_k - (x_k^2 - y) / (2x_k) = (x_k + y / x_k) / 2
* time complexity: O(logN)
*/

object Solution2 {
     def mySqrt(x: Int): Int = {
        val precision = math.pow(10, -5)
        
        var ans: Double = x
        while(math.abs(ans * ans - x) > precision){
            ans = (ans + x / ans) / 2
            // println(ans)
        }
        ans.toInt
    }
}


```

```scala
object Solution {
    def mySqrt(x: Int): Int = {
        if(x == 0){
            0
        }else if(x == 1){
            1
        }else{
            var start = 1
            var end = x
            var result = 0
            
            while(start <= end){
                var mid = start + (end - start)/2
                if(mid <= x/mid){
                    result = mid
                    start = mid+1
                }else{
                    end = mid-1
                }
            }
            result
        }
    }
}

```    

# 3 day (å¾—åˆ† = 10åˆ†) 55

##  43. <a name='StringtoIntegeratoi'></a>8. String to Integer(atoi)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Cb411e7pz?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1AZ4y1s7TD?spm_id_from=333.999.0.0)

* æ—¶é—´å¤æ‚åº¦:O(n)

* æ—¶é—´å¤æ‚åº¦:O(1)

|æ¨¡å¼|æè¿°|
|---|---|
|^|åŒ¹é…å­—ç¬¦ä¸²çš„å¼€å¤´|
|[...]|ç”¨æ¥è¡¨ç¤ºä¸€ç»„å­—ç¬¦,å•ç‹¬åˆ—å‡ºï¼š[amk] åŒ¹é… 'a'ï¼Œ'm'æˆ–'k'|
|*|åŒ¹é…0ä¸ªæˆ–å¤šä¸ªçš„è¡¨è¾¾å¼ã€‚|
|?|åŒ¹é…0ä¸ªæˆ–1ä¸ªç”±å‰é¢çš„æ­£åˆ™è¡¨è¾¾å¼å®šä¹‰çš„ç‰‡æ®µï¼Œéè´ªå©ªæ–¹å¼|
|+|åŒ¹é…1ä¸ªæˆ–å¤šä¸ªçš„è¡¨è¾¾å¼ã€‚|
|\d|åŒ¹é…ä»»æ„æ•°å­—ï¼Œç­‰ä»·äº [0-9]ã€‚|
|\D|åŒ¹é…ä»»æ„éæ•°å­—ï¼Œç­‰ä»·äº [^0-9]ã€‚|

[æ­£åˆ™è¡¨è¾¾å¼ä¸­å°æ‹¬å·ã€ä¸­æ‹¬å·ã€å¤§æ‹¬å·çš„ä½œç”¨](https://blog.csdn.net/weixin_45621662/article/details/103921232)

```py
import re
class Solution(object):
    def myAtoi(self, s):
        return max(min(int(*re.findall('^[+-]?\d+', s.lstrip())), 2**31 - 1), -2**31)

import re
class Solution:
    def myAtoi(self, s: str) -> int:
        at_oi_re = re.compile('^[ ]*([+-]?\d+)')
        # æ˜“é”™ç‚¹ï¼šè¦æ³¨æ„ä¸­æ‹¬å·[]å’Œå°æ‹¬å·()çš„åŒºåˆ«
        # æ˜“é”™ç‚¹ï¼šè¦æ³¨æ„å°æ‹¬å·()çš„ä½ç½®ï¼Œå°æ‹¬å·çš„ä½œç”¨æ˜¯åŒ¹é…å¹¶æå–ï¼Œæ‰€ä»¥+-è¦åŒ…æ‹¬èµ·æ¥
        # æ˜“é”™ç‚¹ï¼šä¸èƒ½æ¼æ‰*ï¼Ÿ

        # å­—ç¬¦ä¸²çš„ å¼€å¤´ åŒ¹é… 0ä¸ªæˆ–å¤šä¸ª[ç©ºæ ¼]
        # åŒ¹é… 0ä¸ªæˆ–å¤šä¸ª[+-]
        # åŒ¹é… 0ä¸ªæˆ–å¤šä¸ª[0-9]
        if not at_oi_re.search(s):
            return 0
        res = int(at_oi_re.findall(s)[0])
        # æ˜“é”™ç‚¹ï¼šfindallè¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œæ‰€ä»¥å¿…é¡»æœ‰[0]
        # æ˜“é”™ç‚¹ï¼šå¿…é¡»æœ‰int()
        #  åœ¨èŒƒå›´ [-2^31, 2^31 - 1] å†…
        return min(max(res, -(1<<31)), (1<<31) - 1) # åœ¨ä¸¤è€…ä¹‹é—´ï¼ŒèƒŒä¸€èƒŒ
        # è¦åŠ å°æ‹¬å·(1<<31)

class Solution(object):
    def myAtoi(self, str):
        str = str.strip()
        strNum = 0
        if len(str) == 0:
            return strNum

        flag = 1
        if str[0] == '+' or str[0] == '-':
            if str[0] == '-':
                flag = -1
            str = str[1:]
        
        for char in str:
            if '0' <= char <='9':
                strNum = strNum * 10 +  ord(char) - ord('0')
            if char < '0' or char > '9':
                break
        strNum *= flag
        return min(max(strNum, -(1<<31)), (1<<31) - 1) 
```

##  44. <a name='RemoveNthNodeFromEndofList'></a>19-Remove Nth Node From End of List

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Q7411V7DQ?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1eL411n7KE?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1654y1R7Xe?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1KK4y1E7st?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Z5411c79y?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ccdr2kcw7c0.png)

```py
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        def getLength(head: ListNode) -> int:
            length = 0
            while head:
                length += 1
                head = head.next
            return length
        
        dummy = ListNode(0, head)
        length = getLength(head)
        cur = dummy
        for i in range(1, length - n + 1):
            cur = cur.next
        cur.next = cur.next.next
        return dummy.next


class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = ListNode(0,head)
        slow = dummy # æ…¢æŒ‡é’ˆéœ€è¦æŒ‡å‘å‰ä¸€ä¸ª
        fast = head
        for _ in range(n):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next

        return dummy.next
```

```scala
/**
* my first commitment - fast & slow pointer
* time complexity O(N + N / 2)
*   1. keep fast pointer is n + 1 ahead to slow pointer
*   2. if fast == null, slow pointer would points to the  preNode of target removing node
*           t 
*   0 1 2 3 4 5
*   s     f
*     s     f
*       s     f
*         s     f
*/
object Solution1-2 {
    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
      val dummyHead = ListNode(0, head)
      var slow = dummyHead
      var fast = dummyHead
      
      for (i <- 0 until (n + 1) if fast != null) {
        fast = fast.next
      }
      
      while(fast != null) {
        slow = slow.next
        fast = fast.next
      }
      
      slow.next = slow.next.next
      dummyHead.next
    }
  
}
```

##  45. <a name='AddTwoNumbers'></a>2. Add Two Numbers

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1EJ411h72z?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1gJ411V7gJ?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³](https://www.bilibili.com/video/BV1Wb411e77s?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1rZ4y1j7V3?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1DA411L7YQ?spm_id_from=333.999.0.0)

* æ—¶é—´å¤æ‚åº¦:O(max(m,n))

* æ—¶é—´å¤æ‚åº¦:O(max(m,n))

ç‰¹æ®Šæƒ…å†µï¼š

ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ä¸åŒã€‚

è¿›ä½

```py

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = cur = ListNode(0) # æ˜“é”™ç‚¹ï¼šå®šä¹‰ä¸€ä¸ªdummyå’Œä¸€ä¸ªpointerï¼Œéƒ½æŒ‡å‘ListNode(0)
        carry = 0 # æ˜“é”™ç‚¹ï¼šcarryéœ€è¦å…ˆèµ‹å€¼
        while l1 or l2 or carry: # æ˜“é”™ç‚¹ï¼šcarryè¦å­˜åœ¨
            # æ˜“é”™ç‚¹ï¼šl1,l2ä¸ä¸€å®šå­˜åœ¨ï¼Œæ‰€ä»¥ä¸èƒ½å†™æˆï¼šsumNode = l1 + l2
            # æ˜“é”™ç‚¹ï¼šè°ƒç”¨listnodeè¦æœ‰.val
            sumNode = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            tail = sumNode % 10
            carry = sumNode // 10
            cur.next = ListNode(tail)
            cur = cur.next
            # # l1,l2ä¸ä¸€å®šå­˜åœ¨ï¼Œæ‰€ä»¥ä¸èƒ½å†™æˆï¼šl1 = l1.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
```

```scala
object Solution {
    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
      var cur1 = l1
      var cur2 = l2
      val dummy = ListNode(0)
      var prev=dummy
      var carry = 0
      while (cur1!=null ||  cur2!=null || carry !=0) {
        val (s1,next1) = cur1 match {
          case null => (0,null)
          case _=> (cur1.x, cur1.next)
        }
        val (s2,next2) = cur2 match {
          case null => (0,null)
          case _=> (cur2.x,cur2.next)
        }
        val s = s1+s2+carry
        val node = ListNode(s % 10)
        prev.next = node
        prev=node
        carry=s/10
        cur1 = next1
        cur2=next2
      }
      dummy.next
    }
  }
```

##  46. <a name='SortList'></a>148. Sort List

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1jW411d7z7?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1VK411A7Gm?spm_id_from=333.999.0.0)

```py
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        sortlist = []
        # å…ˆæŠŠé“¾è¡¨æ–­å¼€
        while head:
            aft = head.next
            head.next = None
            sortlist.append(head)
            head = aft
        # æ’åº
        sortlist = sorted(sortlist, key=lambda x: x.val)
        # æŠŠé“¾è¡¨ä¸²è”èµ·æ¥
        n = len(sortlist)
        if n == 0:
            return None
        dummy.next = sortlist[0]
        for i in range(n-1):
            sortlist[i].next = sortlist[i+1]
        
        return dummy.next
```

```py
# py3 å½’å¹¶æ’åºï¼Œé€’å½’å®ç°ã€‚ç©ºé—´å¤æ‚åº¦ä¸»è¦åœ¨é€’å½’æ ˆæ·±åº¦ï¼šO( log(n) )ï¼Œæ•´ä¸ªé€’å½’è¿‡ç¨‹æœ‰ç‚¹åƒååºéå†

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        mid = self.findmid(head)
        left = head # æŒ‡å®šå·¦å³
        right = mid.next # æŒ‡å®šå·¦å³
        mid.next = None # æ–­å¼€é“¾æ¥
        l = self.sortList(left)
        r = self.sortList(right)
        return self.merge(l, r)

    def findmid(self,head):
        slow, fast = head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        return slow

    def merge(self,l,r):
        dummy = ListNode(0)
        cur = dummy
        while l and r:
            if l.val <= r.val:
                cur.next = l
                l = l.next # ä¸‹ä¸€ä¸ª
            else:
                cur.next = r
                r = r.next # ä¸‹ä¸€ä¸ª
            cur = cur.next # ä¸‹ä¸€ä¸ª
        cur.next = l or r
        return dummy.next

        # åŸºæœ¬ç”¨æ³•ï¼š
        # v = p1 or p2

        # å®ƒå®Œæˆçš„æ•ˆæœç­‰åŒäºï¼š
        # if p1:
        #     v = p1
        # else:
        #     v = p2
```

##  47. <a name='EditDistance72-'></a>72. Edit Distance 72-ç¼–è¾‘è·ç¦»

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cb411u7uX?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1wv411P7aQ?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV13Z4y1W7UB?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ea4y147FK?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5kci5ryyi3k0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7fq2ehol7rg0.png)

```py
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2 + 1)] for _ in range(len1 + 1)]
        
        for i in range(0, len1 + 1):
            for j in range(0, len2 + 1):
                if i == 0:               # åˆå§‹åŒ–
                    DP[i][j] = j
                elif j == 0:             # åˆå§‹åŒ–
                    DP[i][j] = i
                elif word1[i - 1] == word2[j - 1]:
                    DP[i][j] = DP[i-1][j-1]
                else:
                    DP[i][j] = min(DP[i-1][j], DP[i][j-1], DP[i-1][j-1]) + 1
                    
        return DP[-1][-1]
```

```py
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        @cache
        def dp(i, j) -> int:
            if i == -1:
                return j + 1
            if j == -1:
                return i + 1
            # åšå‡ºé€‰æ‹©
            if word1[i] == word2[j]:
                return dp(i - 1, j - 1) # ä»€ä¹ˆéƒ½ä¸åš
            else:
                return min(
                    dp(i, j-1) + 1,  # insert
                    dp(i-1, j) + 1,  # delete
                    dp(i-1, j-1) + 1 # replace
                )
        return dp(len(word1)-1, len(word2)-1)
```

```scala
/**
* dynamic programming  - Levenshtein distance
* memo
*    1. dp(i)(j) represent the minimum edit distance from the length i substring from word1 to the length j substring from word2
*    2. dp(i)(j) is solved by its sub-optimal problem 
*         1, delete op: dp(i -1)(j)
*         2. replacement op: dp(i -1)(j - 1)
*         3. insertion op: dp(i)(j - 1)
* time complexity: O(NM) N is the length of word1, N is the length of word2
* space complexity: O(NM)
*/
object Solution1 {
  def minDistance(word1: String, word2: String): Int = {
    val m = word1.length
    val n = word2.length
    /* initial  Levenshtein distance table 
    * dp(i)(j) represent the minimum distance transforming from length i of substring word1 to length j of substring word2
    */
    val dp = Array.tabulate(m + 1, n + 1) {
      case (0, j) => j
      case (i, 0) => i
      case _ => 0
    }

    for (i <- 1 to m; j <- 1 to n) {
      /* i-1 is word1 index, j-1 is word2 index */
      if (word1(i - 1) == word2(j - 1)) {
        // do nothing case
        dp(i)(j) = dp(i - 1)(j - 1)
      } else {
        /**
        *       i-1,    i
        * j-1 replace  insertion     
        *  j   delete  dp(i)(j)
        */
        val replace = dp(i - 1)(j - 1)
        val insert = dp(i)(j - 1)
        val delete = dp(i - 1)(j)
        dp(i)(j) = (replace min insert min delete) + 1
      }
    }
    dp(m)(n)
  }
}
```

##  48. <a name='MedianofTwoSortedArrays'></a>4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•° Median of Two Sorted Arrays

[å®˜æ–¹](https://www.bilibili.com/video/BV1Xv411z76J?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMedianSortedArrays(self, A: List[int], B: List[int]) -> float:
        lenA = len(A)
        lenB = len(B) 
        n = lenA + lenB
        slow, fast = -1, -1
        i, j = 0, 0
        for _ in range(n//2 + 1) :
            slow = fast  
            # æ¯æ¬¡å¾ªç¯å‰å°† fast çš„å€¼èµ‹ç»™ slow
            # Aç§»åŠ¨çš„æ¡ä»¶: Béå†åˆ°æœ€å æˆ– å½“å‰A<B,æ»¡è¶³ä¸€ä¸ªå³å¯
            if j >= lenB or (i < lenA and A[i] < B[j]):
                fast = A[i]
                i += 1
            else :
                fast = B[j]
                j += 1
            
        if (n & 1) == 0: # ä¸1äº¤,åˆ¤æ–­å¥‡å¶æ•°,æ›´å¿«é€Ÿ
            return (slow + fast) / 2.0
        else:
            return fast

```

##  49. <a name='-1'></a>105-ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1uv411B73D?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1x54y1d7e8?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1ry4y1U7ZR?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV14A411q7Nv?spm_id_from=333.999.0.0)

> PYTHON é€’å½’

```py
class Solution:
    def buildTree(self, preorder, inorder):
        if inorder:
            root = TreeNode(preorder.pop(0)) # preorder åœ¨è¿™é‡Œçš„ä½œç”¨å°±æ˜¯ pop(0)
            i = inorder.index(root.val)
            root.left = self.buildTree(preorder, inorder[: i])
            root.right = self.buildTree(preorder, inorder[i + 1:])
            return root

```

##  50. <a name='ReverseWordsinaString'></a>151. Reverse Words in a String

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411i7g4?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1rT4y1g7AJ?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ei4y1V7yA?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))
```

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        s = s.strip()
        s = s + ' ' # æ ¹æ®åé¢çš„è®¡ç®—è§„åˆ™ï¼Œåœ¨såé¢åŠ ä¸ªç©ºæ ¼
        left, right = 0, len(s) - 1
        que = collections.deque()
        word = []
        for char in s:
            if char == ' ' and word:
                que.appendleft(''.join(word))
                word = []
            elif char != ' ':
                word.append(char)

        return ' '.join(que)
```

##  51. <a name='MaximumDepthofBinary'></a>104-Maximum Depth of Binary

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1AJ411Q7xG?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7eK?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1u54y1D7Nx?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1tK41137GM?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

```scala
object Solution1 {
    def maxDepth(root: TreeNode): Int = {
        if (root == null) return 0
        math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}

object Solution {
    def maxDepth(root: TreeNode): Int = root match {
        case null => 0
        case x: TreeNode => Math.max((1 + maxDepth(x.left)), (1 + maxDepth(x.right)))
    }
}

```

##  52. <a name='-1'></a>76-ã€æ»‘åŠ¨çª—å£ğŸ”¹ã€‘æœ€å°è¦†ç›–å­ä¸²

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1PM4y1K7p6?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1aK4y1t7Qd?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1ud8tslp4vz4.png)

```py
class Solution:
    def minWindow(self, s: str, t: str) -> str:
    
        def isContains(windic,targetdic):
            for key in targetdic:
                if windic[key] < targetdic[key]:
                    return False # åªè¦æœ‰ä¸€ä¸ªä¸æ»¡è¶³ï¼Œåˆ™ä¸æ»¡è¶³
            return True

        tdic = defaultdict(int) # å›ºå®šçš„
        wdic = defaultdict(int) # å˜åŠ¨çš„
        for char in t:
            tdic[char] += 1

        minlen = len(s)
        l = 0
        res = ''

        for r in range(len(s)): # æ‰©å±•å³è¾¹ç•Œ
            if s[r] in tdic:
                wdic[s[r]] += 1  # å˜åŠ¨çš„
            while isContains(wdic,tdic):
                # å¦‚æœæ˜¯ minWindow
                if r-l+1 <= minlen:
                    minlen = r-l+1
                    res = s[l:r+1]
                # æ”¶ç¼©å·¦è¾¹ç•Œ
                if s[l] in wdic:
                    wdic[s[l]] -= 1  # å˜åŠ¨çš„
                l += 1   
        return res
```

```scala
/**
* chosen solution
*   time complexity: O(|S| + |T|)
*   space complexity: O(|s| + |T|)

*/
object Solution1 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    val tMap = t.groupBy(identity).mapValues(_.length).toMap

    val budgetMap = scala.collection.mutable.Map() ++ tMap
    var currentString = ""
    var answer = ""

    for (char <- s) {
        budgetMap.get(char) match {

          case Some(e) => budgetMap.update(char, e - 1)
          case None =>
        }
      
      currentString += char

      while(!budgetMap.exists{case (_, v) => v > 0}) {

        val tempChar = s(left)
        if(tMap.contains(tempChar)){
          budgetMap.update(tempChar, budgetMap.getOrElse(tempChar, 0) + 1)
        }

        if(answer.length > currentString.length || answer.isEmpty) {
          answer = currentString
        }
        currentString = currentString.drop(1)
        left += 1
      }
    }

    answer
  }
}

```

##  53. <a name='NextPermutation'></a>31 â˜… Next Permutation

[å°æ˜](https://www.bilibili.com/video/BV1Uz4y1m72N?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1SK4y1V7ch?spm_id_from=333.999.0.0)

```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        # å…³é”®åœ¨äºä»åå¾€å‰ï¼Œæ‰¾åˆ°éé€’å‡åºåˆ—
        i = len(nums) - 2
        while i >= 0:
            if nums[i] >= nums[i+1]:
                i -= 1
            else:
                # å¯»æ‰¾iåé¢æ¯”iå¤§çš„æ•°ï¼Œäº¤æ¢ä½ç½®,å¹¶ä¸”æ’åº
                for j in range(len(nums)-1,i,-1): # æ˜“é”™ç‚¹:len(nums)-1,içš„åŒºé—´
                    # 12(3)5(4)
                    if nums[j] > nums[i]:
                        nums[i],nums[j] = nums[j],nums[i]
                        nums[i+1:] = sorted(nums[i+1:])
                        return
        nums.reverse() # æ˜“é”™ç‚¹:å¯¹äº[3,2,1]è¿™ç§æƒ…å†µï¼Œi = 0
```

```scala
/**
* my first commitment
* memo
* 1. find the first index i which breaks the increasing order
* 2. find the last index  j which is larger than index i
* 3. swap(i, j)
* 4. sorting: reverse sequence from i + 1 to the end 
* time complexity: O(n)
*/

object Solution1 {
    def nextPermutation(nums: Array[Int]): Unit = {
        /**
        * find the first index i which breaks the increasing order
        * 0 1 2 3 4 5 6
        * 5 4 7 6 5 4 3
        *   i     j 
        */
      ((nums.length - 2) to 0 by -1).find(idx => nums(idx) < nums(idx + 1)) match {
        case Some(idx) => 
          /* 
          * find the last index  j which  is larger than index i
          */
          val j = ((idx + 1) until nums.length).findLast(i => nums(idx) < nums(i)).getOrElse(idx)
          swap(nums, idx, j)
          reverse(nums, idx + 1, nums.length - 1)
        case None => reverse(nums, 0, nums.length - 1)
      }
    }
    @annotation.tailrec
    def reverse(nums: Array[Int], from: Int, to: Int) {
      if (from < to) {
        swap(nums, from, to)
        reverse(nums, from + 1, to - 1)
      }
    }
  
    def swap(nums: Array[Int], index1: Int, index2: Int) {
      val tmp = nums(index2)
      nums(index2) = nums(index1)
      nums(index1) = tmp
    }
}


```

##  54. <a name='SlidingWindowMaximum'></a>239. â˜…ã€æœ€å°å †ğŸŒµ + æ»‘åŠ¨çª—å£ğŸ”¹å•è°ƒé˜Ÿåˆ—ã€‘Sliding Window Maximum

####  54.1. <a name='567567187'></a>ä¸ç±»ä¼¼567ï¼Œ567ç±»ä¼¼187

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1WW411C763?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Bf4y1v758?spm_id_from=333.999.0.0)

```py
æ€è·¯ï¼š

ç»´æŠ¤ï¼šæœ€æ¥è¿‘å³è¾¹çš„æœ€å¤§å€¼çš„pos
        
# print(winpos)
# [1,3,-1,-3,5,3,6,7]
ä¿è¯çª—å£å†…çš„å€¼æ˜¯é€’å‡çš„å³å¯
# []
# [0]
# [1]
# [1, 2]
# [1, 2, 3]
# [4]
# [4, 5]
# [6]

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        winQ = deque()
        res = []
        for r, v in enumerate(nums):
            # å¦‚æœæ–°æ¥çš„æ•°å­—æ›´å¤§, æ‰€ä»¥æœ€å³è¾¹çš„æ•°å­—æ˜¯æœ€å¤§çš„
            while winQ and nums[winQ[-1]] < v:
                winQ.pop() # pop() å¯èƒ½æœ‰å¤šæ¬¡
            winQ.append(r)
            # å¦‚æœå‡ºç•Œ
            l = winQ[0]
            if r - k == l:
                winQ.popleft() # popleft() é¡¶å¤šä¸€ä¸ª
            # å¼€å§‹å†™å…¥ç­”æ¡ˆ
            if r >= k - 1:
                res.append(nums[winQ[0]])

        return res
```

```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # æ³¨æ„ Python é»˜è®¤çš„ä¼˜å…ˆé˜Ÿåˆ—æ˜¯å°æ ¹å †ï¼Œæ±‚æœ€å¤§å€¼ï¼Œåˆ™éœ€è¦å–å¤æ•°
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)

        res = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k: 
                heapq.heappop(q) # æŠŠæ‰€æœ‰å‡ºç•Œçš„æœ€å¤§å€¼å¼¹å‡ºï¼Œå¯èƒ½ä¸å°å¿ƒæ”’äº†è®¸å¤šä¸ª
            res.append(-q[0][0]) # æœ€å¤§å€¼æ°¸è¿œåœ¨ q[0]
        
        return res

```

```scala

/**
* using max heap, may not AC
* pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)} : keep element's time complexity is O(K)
* time complexity: O(N log K)
*/

object Solution1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        var pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
        val rest = scala.collection.mutable.ArrayBuffer[Int]()
        
        nums.zipWithIndex.foreach{case (v: Int, idx: Int) => {
     
            pq += ((v, idx))
            
            /* keep the elements that is only larger than newest v and the nearest k */
            pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)}       

            if (idx + 1 >= k) {
                rest += pq.head._1
            }
          
        }}        
        rest.toArray
    }
}

/**
* using scala vector, due to scala vector is immutable, any operation about add update remove is generate a new vector
* so it's not a proper substitute for deque
*/

object Solution2 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    var windows = Vector.empty[Int]
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.head <= index - k)
        windows = windows.drop(1)

      while (windows.nonEmpty && nums(windows.last) <= value){
        windows = windows.dropRight(1)
      }
      windows = windows :+ index
      if (index + 1 >= k) {
        ret += nums(windows.head)
      }
    }
    ret.toArray
  }
}



```

##  55. <a name='LongestCommonSubsequence'></a>1143 ã€äºŒç»´åŠ¨æ€ğŸš€è§„åˆ’ã€‘Longest Common Subsequence

####  55.1. <a name='516'></a>ç±»ä¼¼é¢˜ç›®ï¼š516æœ€é•¿å›æ–‡ğŸŒˆå­åºåˆ—

[å°æ˜](https://www.bilibili.com/video/BV19Z4y1W7Xi?spm_id_from=333.999.0.0)

```py
åšäº†å‡ ä¸ªdpçš„é¢˜ä¹‹åï¼Œæ€»ç»“äº†dpéœ€è¦æ³¨æ„çš„å‡ ä¸ªè¦ç´ ï¼š

1ã€ æ˜ç¡®dpäºŒç»´æ•°ç»„è¡¨ç¤ºçš„å«ä¹‰

2ã€ base case

3ã€ çŠ¶æ€çš„è½¬ç§»ï¼šå¯¹äº`å›æ–‡ğŸŒˆ/LCS`ä¹‹ç±»çš„é—®é¢˜åˆ™æ˜¯è€ƒè™‘å½“å‰å­—ä¸²å’Œå·²ç»è®¡ç®—è¿‡çš„å­ä¸²ä¹‹é—´çš„å…³ç³»

4ã€ ç”±`çŠ¶æ€çš„è½¬ç§»`æ¥ç¡®å®š loopçš„è¾¹ç•Œ

5ã€ ç”±loopçš„è¾¹ç•Œ`æ‰“å‡ºè¡¨æ ¼` å¯å¾—å‡ºæœ€åä¸€ä¸ªdpçš„çŠ¶æ€å€¼ï¼Œå³ç»“æœã€‚


class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0] * (len(text2)+1) for _ in range(len(text1)+1)]
        for i in range(1, len(text1)+1): 
            for j in range(1, len(text2)+1): 
                if text1[i-1] == text2[j-1]: 
                    dp[i][j] = dp[i-1][j-1] + 1 
                else: 
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]


class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n1, n2 = len(text1), len(text2)
        pre = [0 for _ in range(n2 + 1)]
        dp = [0 for _ in range(n2 + 1)]
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if text1[i-1] == text2[j-1]:
                    dp[j] = pre[j-1] + 1
                else:
                    dp[j] = max(pre[j], dp[j-1])
                pre[j-1] = dp[j-1] # æ³¨æ„è¿™é‡Œçš„ç¼©è¿›å…³ç³»
            pre[j] = dp[j]
        return dp[-1]
```



```scala


  object Solution {
    def longestCommonSubsequence(text1: String, text2: String): Int = {
      val m = text1.length
      val n = text2.length
      //val dp = Array.ofDim[Int](1001,1001)
      val dp = Array.fill(1001,1001)(0)
      for (i<- 1 to m) { // must have space?
        for (j<- 1 to n) {
          dp(i)(j) = if (text1(i-1)== text2(j-1)) dp(i-1)(j-1)+1 else Math.max(dp(i-1)(j),dp(i)(j-1))
        }
      }
      dp(m)(n)
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.longestCommonSubsequence("abcde", "ace") == 3)
    }
    val name = "1143 Longest common sequence"
  }

```

##  56. <a name='SumRoottoLeafNumbers'></a>129 Sum Root to Leaf Numbers

[å°æ˜](https://www.bilibili.com/video/BV1VK411H7o5?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        res = 0
        
        def dfs(root, acc):
            nonlocal res
            if not root.left and not root.right: # æ˜“é”™ç‚¹ï¼šä¸è¦å¿½è§†äº†è¿™ç§æƒ…å†µ
                res += acc * 10 + root.val 
            if root.left:
                dfs(root.left, acc * 10 + root.val)
            if root.right:
                dfs(root.right, acc * 10 + root.val)
        dfs(root, 0)
        return res # åœ¨æ ¹èŠ‚ç‚¹å¤„curä¸º0ï¼Œè€Œä¸æ˜¯sums

```

##  57. <a name='IP'></a>93. å¤åŸ IP åœ°å€

```py
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        def backtrack(s,path):
            if len(path) == 4 and len(s) == 0:
                res.append('.'.join(path))
                return # æ³¨æ„ç‚¹ï¼šä¸€å®šè¦è¿”å›
            for i in range(len(s)):
                left,right = s[:i+1],s[i+1:]
                if 0 <= int(left) <= 255 and str(int(left)) ==  left:
                    backtrack(right,path + [left])  
        backtrack(s,[])    
        return res


```

##  58. <a name='BalancedBinaryTree'></a>110-Balanced Binary Tree

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1NJ411v7b1?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7Lb?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1sV411b7hR?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            return max(height(root.left), height(root.right)) + 1

        if not root:
            return True
        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)
        # æ³¨æ„ï¼šå·¦å³ä¸¤ä¸ªå­æ ‘ä¹Ÿå¿…é¡»balanced
```

##  59. <a name='-1'></a>113. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1P54y1i73U?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1k54y177fu?spm_id_from=333.999.0.0)

```py
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res=[]

        def dfs(node,path,tsum): # node.val == tsum ç»“æŸ

            if not node:
                return

            if node.val == tsum and not node.left and not node.right: # ç»“æŸæ¡ä»¶
                res.append(path[:] + [node.val])  # éœ€è¦æ·±æ‹·è´

            dfs(node.left, path + [node.val], tsum - node.val) # ä¸‰ä¸ªéƒ¨åˆ†éƒ½éœ€è¦çŠ¶æ€è½¬ç§»
            dfs(node.right, path + [node.val], tsum - node.val)
            
        dfs(root, [], targetSum)
        return res
```

##  60. <a name='GenerateParentheses'></a>22. Generate Parentheses

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i7t7?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1vK4y1b744?spm_id_from=333.999.0.0)

å›æº¯æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O($\frac{4^n}{\sqrt{n}}$)

* æ—¶é—´å¤æ‚åº¦:O($\frac{4^n}{\sqrt{n}}$)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.ud5vx6kpbvk.png" width="50%">

```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def dfs(left,right,itm):
            if left == 0 and right == 0:
                res.append(itm)
                return  # è¿™é‡Œreturnå†™ä¸å†™å±…ç„¶éƒ½acäº†ï¼Œå¯èƒ½æ˜¯å› ä¸ºæ²¡æœ‰å¾ªç¯å§
            if left > 0:
                dfs(left-1, right, itm + '(') #   çŠ¶æ€è½¬ç§»
            if right > left:
                dfs(left, right-1, itm + ')')
        
        res = []
        dfs(n, n, '')
        return res
```


```py
# ç›¸å½“äºæ¯”ä¸Šä¸€å±‚å°‘äº†ä¸€å±‚å¾ªç¯ã€‚
# ä¸æ‡‚æ˜¯ä¸æ˜¯åŠ¨æ€è§„åˆ’ï¼Œæ¯æ–°å¢ä¸€å¯¹æ‹¬å·ï¼Œ
# å°±æ˜¯åœ¨ä¸Šä¸€æ¬¡çš„ç»“æœçš„å„ä¸ªä½ç½®æ’å…¥ä¸€ä¸ª"()"ï¼Œç”¨é›†åˆé˜²æ­¢é‡å¤

class Solution:
    def generateParenthesis(self, n):
        res = {''}
        for i in range(n):
            ini = set()
            for s in res:  # åœ¨ä¸Šä¸€æ¬¡çš„ç»“æœçš„æ‰€æœ‰å­—ç¬¦ä¸²çš„å„ä¸ªä½ç½®ä¸Šæ’å…¥'()'
                for j in range(len(s) + 1): # å¦‚æœsçš„é•¿åº¦ä¸º4ï¼Œé‚£ä¹ˆå°±æœ‰5ä¸ªå¯ä»¥æ’å…¥çš„ä½ç½®
                    ini.add(s[:j] + '()' + s[j:])
            res = ini
        return list(res)
                    
                # é”™è¯¯å†™æ³•ï¼š
                # itm = itm[:j] + '()' + itm[j:]
                # res = res.add(itm)
                # é”™è¯¯å†™æ³•ï¼š
                # res = res.add(itm[:j] + '()' + itm[j:])
                # æ­£ç¡®å†™æ³•ï¼š



```

```scala

object Solution {
    
    def generateParenthesis(n: Int): List[String] = {
        import scala.collection.mutable._
        def backtrack(acc: ListBuffer[String], curr: String, left: Int, right: Int): Unit = {
            if (left == 0 && right == 0) acc.append(curr)
            else {
                if (left > 0) backtrack(acc, curr + "(", left-1, right)
                if (right > left) backtrack(acc, curr + ")", left, right-1)
            }
        }
      
        val acc = ListBuffer[String]()
        backtrack(acc, "", n, n)
        acc.toList
    }
}

```

##  61. <a name='FirstMissingPositive'></a>41 First Missing Positive

[å°æ˜](https://www.bilibili.com/video/BV1fy4y1k7pV?spm_id_from=333.999.0.0)

```py
ç½®æ¢æ³•
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)

        for i in range(n):
            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
# nums[nums[i] - 1]
# [-1, 4, 3, 1] 4 åœ¨ 4 çš„ä½ç½®â†“
# [-1, 1, 3, 4] 1 åœ¨ 1 çš„ä½ç½®â†“
# [1, -1, 3, 4]

        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
                
        return n + 1
        # è¾“å…¥ï¼š[1] é¢„æœŸç»“æœï¼š2

```

##  62. <a name='DiameterofBinaryTree'></a>543 Diameter of Binary Tree

[å°æ˜](https://www.bilibili.com/video/BV12K4y1r78T?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1qA411t7LR?spm_id_from=333.999.0.0)

```py
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        res = 0
        def depth(node):
            nonlocal res
            if not node:
                return 0
            L = depth(node.left) + 1 if node.left else 0 # æ³¨æ„ï¼šè¿™é‡Œä¸€å®šè¦ç”¨ if else ç»“æ„
            R = depth(node.right) + 1 if node.right else 0 # æ³¨æ„ï¼šè¿™é‡Œæ˜¯è¾¹çš„æ¡æ•°
            res = max(res, L + R)
            return max(L, R)

        depth(root)
        return res
```

# 4 day (å¾—åˆ† = 8åˆ†) 63

##  63. <a name='MinStack'></a>155-ã€æ„é€ ğŸ°ã€‘Min Stack

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1H74118748?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1YK4y1r77W?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ja4y1Y7vY?spm_id_from=333.999.0.0)

   
å…³é”®åœ¨äº  def getMi

```py
class MinStack:

    def __init__(self):
        # å¦å¤–ç”¨ä¸€ä¸ªstackï¼Œæ ˆé¡¶è¡¨ç¤ºåŸæ ˆé‡Œæ‰€æœ‰å€¼çš„æœ€å°å€¼
        self.minStack = []
        self.stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if self.minStack == [] or self.minStack[-1] >= val:
            self.minStack.append(val) # minStack åª append æŸä¸€çŠ¶æ€ä¸‹çš„æœ€å°å€¼

    def pop(self) -> None:
        if self.stack[-1] == self.minStack[-1]:
            self.minStack.pop()
        return self.stack.pop() # minStack åª pop æŸä¸€çŠ¶æ€ä¸‹çš„æœ€å°å€¼

    def top(self) -> int:
        return self.stack[-1]


    def getMin(self) -> int:
        return self.minStack[-1]        
```

```py
é¢è¯•çš„æ—¶å€™è¢«é—®åˆ°ä¸èƒ½ç”¨é¢å¤–ç©ºé—´ï¼Œå°±å»ç½‘ä¸Šæœäº†ä¸‹ä¸ç”¨é¢å¤–ç©ºé—´çš„åšæ³•ã€‚æ€è·¯æ˜¯æ ˆé‡Œä¿å­˜å·®å€¼ã€‚
                [3,2,1,4] [0,-1,-1, 3]
                mins = 3, 2, 1, 1
                å…ˆæŠŠè¿™ä¸ªéƒ¨åˆ†å†™å‡ºæ¥
class MinStack:
    def __init__(self):

        self.diffstack = []
        self.mins = -1


    def push(self, x: int) -> None:
        if not self.diffstack:
            self.diffstack.append(0)
            self.mins = x
        else:
            diff = x-self.mins
            self.diffstack.append(diff)
            self.mins = self.mins if diff > 0 else x
            # mins æ˜¯ä¼šå˜åŒ–çš„

    def pop(self) -> None:
        if self.diffstack:
            diff = self.diffstack.pop()
            if diff < 0: 

                top = self.mins # ç¬¬ä¸€æ­¥ï¼šé¡ºåºä¸èƒ½é”™
                self.mins = self.mins - diff # ç¬¬äºŒæ­¥ï¼šå¦‚æœ diff < 0, é‚£å°±éœ€è¦è¿˜åŸ self.mins
            else:     # å¦‚æœ diff ä¸€ç›´éƒ½ > 0, é‚£å°±éå¸¸å¥½
                top = self.mins + diff
            return top

    def top(self) -> int:
        return self.mins if self.diffstack[-1] < 0 else self.diffstack[-1] + self.mins

    def getMin(self) -> int:
        return self.mins if self.diffstack else -1
```


```scala
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var min = Int.MaxValue

    def push(x: Int) {
        stack = stack :+ x
        if(x < min){
            min = x
        }
    }

    def pop() {
        stack = stack.init
        min = Int.MaxValue
        stack.map(x => {
            if(x < min) min = x
        })
    }

    def top(): Int = {
        stack.last
    }

    def getMin(): Int = {
        min
    }

}

//æ›¿ä»£è§£å†³æ–¹æ¡ˆï¼šæ›´å¿«
//è¿™é‡Œæˆ‘ä»¬å°†å…ƒç´ æ·»åŠ åˆ°åˆ—è¡¨ä¸­è€Œä¸æ˜¯é™„åŠ 
//è¯·æ³¨æ„ï¼Œç”±äºListå®é™…ä¸Šæ˜¯ä¸€ä¸ªLinkedListï¼Œå› æ­¤å¤„ç†åˆ—è¡¨çš„â€œå¤´éƒ¨â€è¦å®¹æ˜“å¾—å¤š
//è¿˜æœ‰å¦ä¸€ä¸ªåˆ—è¡¨æ¥ç»´æŠ¤åˆ—è¡¨çš„æœ€å°å…ƒç´ 
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var mins = List.empty[Int]

    def push(x: Int) {
        //å¦‚æœæˆ‘ä»¬å°†ç¬¬äºŒä¸ªæ¡ä»¶è®¾ä¸º x < mins.headï¼Œåˆ™æ­¤è¡Œå¤±è´¥
        //with NoSuchElementException: ç©ºåˆ—è¡¨çš„å¤´éƒ¨
        //ä¸ºä»€ä¹ˆï¼Ÿï¼Ÿï¼Ÿ
        if(mins.isEmpty || mins.head >= x) mins = x +: mins
        stack = x +: stack
    }

    def pop() {
        if(mins.head == stack.head) mins = mins.tail
        stack = stack.tail
    }

    def top(): Int = {
        stack.head
    }

    def getMin(): Int = {
        mins.head
    }

}

```

##  64. <a name='ValidateBinarySearchTree98-'></a>98. Validate Binary Search Tree 98-éªŒè¯äºŒå‰æœç´¢æ ‘

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV12t411Y7TP?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Wz4y1R7dF?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7FV?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Hv411478d?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Fi4y147Ng?spm_id_from=333.999.0.0)

```py
æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š

èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚
```

ä¸­åºéå†ä¸€ä¸‹å°±è¡Œäº†

```py
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        result = [float('-inf')]
        valid = True # å¿…é¡»ç”¨validè¿™ä¸ªå˜é‡ï¼Œä¸èƒ½ç”¨return False

        def traversal(root: TreeNode):
            nonlocal valid # è¿™ä¸€è¡Œå¿…ä¸å¯å°‘ï¼Œä¸ç„¶è™½ç„¶ä¸æŠ¥é”™ï¼Œä½†ä¸èƒ½ac
            if root == None:
                return
            traversal(root.left)    # å·¦
            if result[-1] >= root.val: valid = False
            result.append(root.val) # ä¸­åº
            traversal(root.right)   # å³

        traversal(root)
        return valid


class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def appendAllLeft(node):
            while node:
                stack.append(node)
                node = node.left
        # è¿™é‡Œå¯ä»¥ç›´æ¥ returnï¼Œä¸éœ€è¦valid
        stack, res = [], float('-inf')
        appendAllLeft(root)
        while stack:
            node = stack.pop()
            if res >= node.val: return False
            res = node.val # res.append åœ¨ä¸­é—´
            appendAllLeft(node.right)
        return True

```

å®šä¹‰ä¸Šä¸‹ç•Œï¼š

```py
class Solution:
    def isValidBST(self, root):
        def BFS(node, lower, upper):
            if not node:
                return True
            return lower < node.val < upper and BFS(node.left, lower, node.val) and BFS(node.right, node.val, upper)

        return fun(root, float('-inf'), float('inf'))
```

```scala
/**
* chosen solution
* inorder iterative version only keep pre node
* this is also the inorder-iterative-template
* 
* time complexity: O(N)
*/

object Solution0 {
   def isValidBST(root: TreeNode): Boolean = {
    val stack = new collection.mutable.Stack[TreeNode]()
    var node = root
    var pre: TreeNode = null
    var result = true
    while ((node != null || stack.nonEmpty) && result) {
      while (node != null) {
        stack push node
        node = node.left
      }

      node = stack.pop
      if (pre != null && node.value <= pre.value) result = false
      pre = node
      node = node.right

    }
    result
  }
}

/**
* inorder recursive traversal
* memo:
*    1. recursive version with all element storing
* Time complexity O(NlogN)  there are a distinct and sorted operation
* space complexity O(N)
*/
object Solution1 {
  def isValidBST(root: TreeNode): Boolean = {
    val inorder = traversal(root)
    inorder equals inorder.distinct.sorted // why distinct here? [1, 1] is not a BST because left tree should be smaller than root. 
  }
  def traversal(node: TreeNode): List[Int] = {
    if(node == null){
      List.empty[Int]
    }else {
      // (traversal(node.left) :+ node.value) ::: traversal(node.right) 
      traversal(node.left) ::: List(node.value) ::: traversal(node.right)
    }
  }
}



/**
* giving min max range when recursive
* time complexity: O(N)
*/

object Solution4 {
  def isValidBST(root: TreeNode): Boolean = {

    def _isValidBST(node: TreeNode, min: TreeNode, max: TreeNode): Boolean = {

      if(node == null) true
      else {
        if((min != null && node.value <= min.value) || (max != null  && node.value >= max.value)) false
        else {
          _isValidBST(node.lefmt, min, node) && _isValidBST(node.right, node, max)
        }
      }
    }
    _isValidBST(root, null, null)
  }

}
```

##  65. <a name='ImplementRand10UsingRand7'></a>470. Implement Rand10() Using Rand7()

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Ut411Z7KX?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1AD4y1m7Qb?spm_id_from=333.999.0.0)

```py
class Solution:
    def rand10(self) -> int:
        while True:
            row = rand7()
            col = rand7()
            idx = (row - 1) * 7 + col #ï¼ˆ0-42ï¼‰ + ï¼ˆ1-7ï¼‰
            if idx <= 40: # 1-40
                return 1 + (idx - 1) % 10

è¿™æ ·å†™ä¹Ÿæ˜¯å¯¹çš„ï¼Œå› ä¸º 0-9 ç­‰æ¦‚ç‡å‡ºç°
class Solution:
    def rand10(self):
        while True:
            row = rand7()
            col = rand7()
            idx = (row - 1) * 7 + col #ï¼ˆ0-42ï¼‰ + ï¼ˆ1-7ï¼‰
            if idx <= 30: # 1-40
                return 1 + (idx + 1) % 10

class Solution:
    def rand10(self):
        while True:
            res = (rand7()-1)*7 + rand7()#æ„é€ 1~49çš„å‡åŒ€åˆ†å¸ƒ
            if res <= 40: #å‰”é™¤å¤§äº40çš„å€¼ï¼Œ1-40ç­‰æ¦‚ç‡å‡ºç°ã€‚
                break
        return res%10+1 #æ„é€ 1-10çš„å‡åŒ€åˆ†å¸ƒ
```

##  66. <a name='Symmetrictree'></a>101-Symmetric tree

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1VJ41197KD?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7eb?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1xv41167z8?spm_id_from=333.999.0.0)

> Python è¿­ä»£ï¼šå…¶å®å°±æ˜¯å±‚åºéå†ï¼Œç„¶åæ£€æŸ¥æ¯ä¸€å±‚æ˜¯ä¸æ˜¯å›æ–‡ğŸŒˆæ•°ç»„

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        dic = collections.defaultdict(list)

        def bfs(node, level):
            if node:
                dic[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)
            else:
                dic[level].append(None)
        
        bfs(root, 0) 
        for key in dic:
            if dic[key] != dic[key][::-1]:
                return False

        return True

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        # if not root:
        #     return [] åˆ é™¤
        level = [root]
        while level:
            tmp = []
            vals = [] # è¡¥å……
            for n in level:
                if n: # ä¿®æ”¹ï¼Œå› ä¸ºnoneèŠ‚ç‚¹ä¹Ÿéœ€è¦append
                    tmp.append(n.left) # if n.left è¢«åˆ é™¤
                    tmp.append(n.right) #  if n.right è¢«åˆ é™¤
                    vals.append(n.val)  # è¡¥å……
                else:
                    vals.append(None) # ä¿®æ”¹ï¼Œå› ä¸ºnoneèŠ‚ç‚¹ä¹Ÿéœ€è¦append
            if vals != vals[::-1]:  # è¡¥å……
                return False  # è¡¥å……
            level = tmp
        return True
```

> Python é€’å½’ï¼š

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def twoSym(node1, node2):
            if node1 and node2 and node1.val == node2.val: 
                return twoSym(node1.left, node2.right) and twoSym(node1.right, node2.left)
            elif not node1 and not node2:
                return True
            else:
                return False
        return twoSym(root.left, root.right)
```

> scala:

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def symmetric(nodeA: TreeNode, nodeB: TreeNode): Boolean = {
        if(nodeA == null && nodeB == null){
            true
        }else if(nodeA !=null && nodeB != null){
            if(nodeA.value != nodeB.value){
                false
            }else{
                symmetric(nodeA.left, nodeB.right) && symmetric(nodeA.right, nodeB.left)
            }
        }else{
            false
        }
    }
    
    def isSymmetric(root: TreeNode): Boolean = {
        if(root == null){
            true
        } else{
            symmetric(root.left, root.right)
        }
    }
}

```

##  67. <a name='LongestValidParentheses'></a>32 Longest Valid Parentheses

[å°æ˜](https://www.bilibili.com/video/BV1RZ4y1F7nJ?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1yi4y1G74d?spm_id_from=333.999.0.0)

åŠ¨æ€è§„åˆ’ï¼š

* æ—¶é—´å¤æ‚åº¦: O(n) 

* ç©ºé—´å¤æ‚åº¦: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6dkova4yjvk0.png)

```py
# èƒŒä¸€èƒŒå§ï¼Œå¥½éš¾ã€‚
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0]*n
        if n == 0: return 0
        for i in range(n):
            if s[i] == ')' and s[i-dp[i-1]-1] == '(' and i - dp[i-1] - 1 >= 0:
                dp[i] = 2 + dp[i-1] + dp[i-dp[i-1]-2]
        return max(dp)
```

æ ˆï¼š

* æ—¶é—´å¤æ‚åº¦: O(n) 

* ç©ºé—´å¤æ‚åº¦: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1dgqk0ervhb4.png)

```py
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        length = maxlength = 0
        for i,c in enumerate(s):
            if c == '(':
                stack.append(i)
            if c == ')':
                stack.pop()
                if not stack:
                    stack.append(i) # è®°å½•ä¸€ä¸‹stack[-1]ä¸º')'ï¼Œæ–­å¼€åŒºé—´
                else:
                    length = i - stack[-1] # stack[-1]ä¸º')'ï¼Œæ–­å¼€åŒºé—´
                    maxlength = max(maxlength,length)
        return maxlength

```

```scala



/**
* using stack to record the char index in oder to calculate the valid length
* memo:
* 1. always only have one invalid symbol at stack and its position index is 0
* time complexity O(n)
* space complexity O(n)
*/
object Solution1 {

  import collection.mutable

  def longestValidParentheses(s: String): Int = {
    val mapping = Map('(' -> ')')
    val stack = mutable.Stack[Int]()
    stack.push(-1)
    s.indices.foldLeft(0) {
      case (maxLength, idx) =>
        val char = s(idx)
        if (mapping.contains(char)) {
          stack push idx
          maxLength
        } else {
          stack.pop()
          if (stack.isEmpty) {
            stack push idx
            maxLength
          } else {
            (idx - stack.head) max maxLength
          }
        }
    }
  }
}
```

##  68. <a name='-1'></a>43. å­—ç¬¦ä¸²ç›¸ä¹˜

```py
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        m, n = len(num1), len(num2)
        ansArr = [0] * (m + n)
        # ä»åå¾€å‰
        for i in range(m - 1, -1, -1):
            x = int(num1[i])
            for j in range(n - 1, -1, -1):
                ansArr[i + j + 1] += x * int(num2[j])
        
        # ä»åå¾€å‰
        for i in range(m + n - 1, 0, -1):
            ansArr[i - 1] += ansArr[i] // 10
            ansArr[i] %= 10
        
        res = ''.join(str(x) for x in ansArr)
        return str(int(res))
```

```py
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == "0" or num2 == "0":
            return "0"
        
        m, n = len(num1), len(num2)
        ansArr = [0] * (m + n)
        for i in range(m - 1, -1, -1):
            x = int(num1[i])
            for j in range(n - 1, -1, -1):
                ansArr[i + j + 1] += x * int(num2[j])
        
        for i in range(m + n - 1, 0, -1):
            ansArr[i - 1] += ansArr[i] // 10
            ansArr[i] %= 10
        
        index = 1 if ansArr[0] == 0 else 0
        ans = "".join(str(x) for x in ansArr[index:])
        return ans

```

##  69. <a name='MinimumPathSum64-'></a>64. Minimum Path Sum 64-æœ€å°è·¯å¾„å’Œ

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV12W411679S?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Ka4y1i7Vu?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1JC4y1x7j1?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1vi4y1u7a6?spm_id_from=333.999.0.0)

```py
# å¯ä»¥ç›´æ¥åœ¨åŸæ•°ç»„ä¸Šè¿›è¡Œè®°å¿†ï¼Œä¸éœ€è¦é¢å¤–çš„ç©ºé—´
# so easy,ç›´æ¥AC
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == j == 0:
                    continue
                if i == 0:
                    grid[i][j] += grid[i][j-1]
                if j == 0:
                    grid[i][j] += grid[i-1][j]
                if i > 0 and j > 0:
                    grid[i][j] += min(grid[i-1][j],grid[i][j-1])
        return grid[-1][-1]
```

##  70. <a name='-1'></a>718. æœ€é•¿é‡å¤å­æ•°ç»„

```py
# è¿™ä¸ªæ»‘åŠ¨çª—å£ï¼Œç”¨çš„æ˜¯ left å’Œ lenth

class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        lenth = left = 0
        if nums1 and nums2:
            # å°†æ•°å­—è½¬æ¢ä¸ºå­—ç¬¦ä¸²
            a, b, n = ''.join(map(chr, nums1)), ''.join(map(chr, nums2)), len(nums1)
            while lenth + left < n:
                # è¿™é‡Œä½¿ç”¨lenthä¿å­˜ç»“æœï¼Œç”¨leftè·³å‡ºå¾ªç¯
                if a[left : left + lenth + 1] in b:
                    lenth += 1
                else:
                    left += 1
        return lenth 



class Solution:
    def findLength(self, A: List[int], B: List[int]) -> int:
        dp = [[0] * (len(B)+1) for _ in range(len(A)+1)]
        result = 0
        for i in range(1, len(A)+1):
            for j in range(1, len(B)+1):
                if A[i-1] == B[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                result = max(result, dp[i][j])
        return result


  3 2 1 4 7
1 0 0 1 0 0
2 0 1 0 0 0
3 1 0 0 0 0
2 0 2 0 0 0
1 0 0 3 0 0

```

##  71. <a name='Subsets'></a>78. Subsets å­é›†

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1jt411k7py?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1HD4y1Q7Te?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1YK4y1s7pq?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1154y1R72Q?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.xmmpwe7mlzk.webp)

æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ·2^n)

```py
# ã€ä½è¿ç®—ğŸ˜œã€‘
# class Solution:
#     def subsets(self, nums: List[int]) -> List[List[int]]:
#         size = len(nums)
#         n = 1 << size
#         res = []
#         # i = 0,1,2,3,4,5,6,7
#         for i in range(n):
#             cur = []
#             # j = 0,1,2
#             for j in range(size):
#                 if i >> j & 1:
#                     cur.append(nums[j])
#             res.append(cur)
#         return res

```

```py
class Solution(object):
    def subsets(self, nums):
        res = [[]]
        for num in nums:
            res.extend([subres+[num] for subres in res])
        return res  

# bfs
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        n = len(nums)
        for num in nums:
            for subres in res[:]:
                res.append(subres+[num])
        return res

# æ³¨æ„ä»£ç ä¸­res[:]æ˜¯å¿…é¡»çš„ï¼Œå› ä¸ºåˆ‡ç‰‡æ˜¯å¼•ç”¨æ–°çš„å¯¹è±¡ï¼Œ
# æ­¤æ—¶åœ¨å¾ªç¯ä¸­res[:]æ˜¯ä¸æ›´æ–°çš„ï¼Œè€Œresæ˜¯ä¸æ–­æœ‰å…ƒç´ pushè¿›å»çš„ï¼Œå¾ˆtrick
```

```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  
        def backtrack(startIndex,path):
            res.append(path[:])  # unconditional, æ”¶é›†å­é›†
            for i in range(startIndex, len(nums)):  #å½“startIndexå·²ç»å¤§äºæ•°ç»„çš„é•¿åº¦äº†ï¼Œå°±ç»ˆæ­¢äº†ï¼Œforå¾ªç¯æœ¬æ¥ä¹Ÿç»“æŸäº†ï¼Œæ‰€ä»¥ä¸éœ€è¦ç»ˆæ­¢æ¡ä»¶
                backtrack(i + 1, path + [nums[i]])  # nums[i] ä¸€å®šè¦ç”¨ä¸­æ‹¬å·æ‹¬èµ·æ¥
        backtrack(0,[])
        return res
```

```scala
object Solution {
    //We either use or don't use the current item at the given index and continue until we are at the end of the array.
    
    def subsets(nums: Array[Int]): List[List[Int]] = {
        def backtrack(nums: List[Int], returnValue: List[Int]): List[List[Int]] = {
            nums
            .headOption
            .map(currentElem => 
                 backtrack(nums.tail, returnValue) ++ backtrack(nums.tail, currentElem +: returnValue))
            .getOrElse(List(returnValue))
        }
        
        backtrack(nums.toList, List.empty[Int])
    }
}

```

##  72. <a name='PathSum'></a>112-Path Sum

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1T7411r7Yr?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1pb411e7r7?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1uK411T7kX?spm_id_from=333.999.0.0)

é€’å½’

```py
# æ­£ç¡®å†™æ³•
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if not root:
            return False
        if root.val == targetSum and not root.left and not root.right:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

# é”™è¯¯å†™æ³•
# class Solution:
#     def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
#         if not root:
#             return False
#         if root.val == targetSum:
#             return not root.left and not root.right
#         return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

# class Solution:
#     def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
#         if not root:
#             return False
#         if root.val == targetSum:
#             return True
#         return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

```py
é˜Ÿåˆ—
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que = collections.deque([(root, root.val)])
        while que:
            node, tmpsum = que.popleft()
            if not node.left and not node.right and tmpsum == sum:
                return True
            if node.left:
                que.append((node.left, node.left.val + tmpsum))
            if node.right:
                que.append((node.right, node.right.val + tmpsum))
        return False
```

##  73. <a name='RotateImage'></a>48. æ—‹è½¬å›¾åƒ Rotate Image

[å®˜æ–¹](https://www.bilibili.com/video/BV1mf4y1e7ox?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Wy4y1s7fs?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3kl7avrsvhi0.png" width="30%">

```py
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n//2): # n å’Œ ä¸‹é¢çš„(n+1) å¯ä»¥è°ƒæ¢ä½ç½®
            for j in range((n+1)//2):
                matrix[i][j], matrix[j][n-1-i], matrix[n-1-i][n-1-j], matrix[n-1-j][i] = \
                matrix[n-1-j][i], matrix[i][j], matrix[j][n-1-i], matrix[n-1-i][n-1-j]
        return matrix
```

```scala
/**
* my first commitment
* rotate 4 cell in each iteration
*
*   pattern:  (row, col) -> (col, n - 1- row)
*       1. (i, j) - > (j, n - 1 -i)
*       2. (j, n - 1 -i) -> (n - 1 - i, n - 1 - j)
*       3. (n - 1 - i, n - 1 - j) -> (n -1 -j, n - 1 - (n -1 - i) ) =  (n - 1 -j, i)
*       4. (n - 1 -j, i) -> (i, n - 1 - (n - 1 - j)) = (i, j)
*
* ((0,0) -> (0,3) -> (3,3) -> (3,0))
* ((0,1) -> (1,3) -> (3,2) -> (2,0))
* ((1,0) -> (0,2) -> (2,3) -> (3,1))
* ((1,1) -> (1,2) -> (2,2) -> (2,1))
* 
*/
object Solution1 {
    def rotate(matrix: Array[Array[Int]]): Unit = {
      val n = matrix.size
      printMatrix(n)
      
      for (i <- 0 until (n / 2).toInt + n % 2; j <- 0 until (n / 2).toInt){      
        val tmp = matrix(n - 1 -j)(i)
        matrix(n - 1 - j)(i) = matrix(n - 1 - i)(n - j - 1)
        matrix(n - 1 - i)(n - j - 1) = matrix(j)(n - 1 - i)
        matrix(j)(n - 1 - i) = matrix(i)(j)
        matrix(i)(j) = tmp
      }
    }

    /**
        (0, 0) (0, 1) (0, 2) (0, 3)  
        (1, 0) (1, 1) (1, 2) (1, 3)  
        (2, 0) (2, 1) (2, 2) (2, 3)  
        (3, 0) (3, 1) (3, 2) (3, 3)  
    */
}

```

##  74. <a name='PalindromeLinkedList'></a>234. ã€å›æ–‡ğŸŒˆã€‘Palindrome Linked List

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7ML?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        vals = []
        cur = head
        while cur:
            vals.append(cur.val)
            cur = cur.next
        return vals == vals[::-1]



```

```scala
/**
* very brilliant solution
*/
object Solution2 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null) {
            return true
        }
        var p = head
        var result = true
        def go(node: ListNode): Unit = {
            if (node.next != null) {
                go(node.next)
            }
            if (p.x != node.x) {
                result = false
            }
            p = p.next
        }
        go(head)
        result
    }
}
```


##  75. <a name='dfsCoinChange'></a>322. ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + dfsã€‘Coin Change - è§ 518 Coin Change

https://leetcode-cn.com/problems/coin-change/

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1SW411C7d1?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1tz4y1d7XM?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ty4y187dh?spm_id_from=333.999.0.0)

```py
åŠ¨æ€ğŸš€è§„åˆ’

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [10e9] * (amount + 1)
        dp[0] = 0

        for i in range(1, amount + 1):
            for coin in coins:
                if i >= coin:
                    # i å°±æ˜¯ä¸€ä¸ª target, æ±‚å‡ºæ¯ä¸ª target çš„æœ€å°å€¼
                    dp[i] = min(dp[i], dp[i-coin] + 1)
         # è¿™é“é¢˜çš„éš¾ç‚¹åœ¨äºï¼šæœ€åç»“æœçš„è¾“å‡º
        return dp[-1] if dp[-1] != 10e9 else -1


import functools
class Solution:
    def coinChange(self, coins, amount):
        @functools.lru_cache(None)
        def helper(amount):
            tmp = float("inf")
            if amount == 0:
                return 0
            for c in coins:
                if amount - c >= 0:
                    tmp = min(tmp, helper(amount - c) + 1) # è¿™ä¸ª +1 ä¸€å®šè¦åœ¨å¤§æ‹¬å·é‡Œé¢
            return tmp
            
        res = helper(amount)
        return res if res != float("inf") else -1



class Solution:
    def coinChange(self, coins, amount):
        import functools

        @functools.lru_cache(None)
        def helper(amount):
            if amount == 0:
                return 0
            return min(helper(amount - c) if amount - c >= 0 else float("inf") for c in coins) + 1

        res = helper(amount)
        return res if res != float("inf") else -1


```

```scala
/**
* dynamic programming: bottom up
* time complexity: O(S * N), S is the amount, N is the coin denomination count
* space complexity: O(S)
*/

object Solution {
    def coinChange(coins: Array[Int], amount: Int): Int = {
         
        val dp = Array.fill[Int](amount + 1)(amount + 1) // record the minimum needed coins of each denominations

        dp(0) = 0
        for (i <- 1 to amount; denominations <- coins) {

            if(denominations <= i) {
                dp(i) = dp(i) min (dp(i - denominations) + 1)
            }        
        }
    
        if (dp.last > amount) -1 else dp.last
    }
}

```

##  76. <a name='CombinationSum39-'></a>39. Combination Sum 39-ç»„åˆæ€»å’Œ

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1gb411u7dy?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Wz411e79d?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV12Z4y157nE?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []

        def backtrack(firstIdx, path):
            if sum(path) == target:
                res.append(path[:]) 
                # æ˜“é”™ç‚¹ï¼Œè¿™é‡Œæ˜¯res.append(path[:])ï¼Œè€Œä¸æ˜¯res.append(path)
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx, len(candidates)):
                    backtrack(i, path + [candidates[i]])
        backtrack(0, [])
        return res
```

```scala

/**
* my first commitment: dfs - backtracking
*/

object Solution1-1 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(combination: List[Int], ans: mutable.Set[List[Int]]): Unit = {
        val currentSum = combination.sum
        
        if (currentSum == target) {
          ans += combination.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          candidates.filter(n => n <= diff).foreach{ case n => dfs(n :: combination, ans)}
        }
      }
      val ans = mutable.Set.empty[List[Int]]
      dfs(List.empty[Int], ans)
      ans.map(l => l.groupBy(identity).mapValues(_.length).toMap -> l).toMap.values.toList // distinct 
    }
}
```

##  77. <a name='MajorityElement'></a>169. ã€ä½è¿ç®—ğŸ˜œã€‘Majority Element

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1hb411c7bF?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7pW?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Ff4y1U7Vn?spm_id_from=333.999.0.0)


```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        return sorted(nums)[len(nums) // 2]

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        return nums[len(nums) // 2]


class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)

# æŠ•ç¥¨ç­–ç•¥ï¼ŒåŠæ•°ä»¥ä¸Šè·èƒœ

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = None

        for vot in nums:
            if count == 0:
                candidate = vot
            count += (1 if vot == candidate else -1)

        return candidate
```

```scala
/**
* HashMap
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution2 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.groupBy(identity).mapValues(_.length).maxBy(_._2)._1  
    }
}


/**
* sorting array and pick middle element
* time complexity O(NlogN)
*/

object Solution3 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.sorted(Ordering.Int)(nums.length / 2)
    }
}

//Alternate solution O(n) but NO EXTRA SPACE
object Solution {
    def majorityElement(nums: Array[Int]): Int = {     
        var candidate = nums.head
        var count = 0
        nums.foreach(vot => {
            if(count == 0) { 
                candidate = vot
                count = 0
            }
            if(vot == candidate) count+=1;
            else count-=1;
        })
        
        candidate
    }
}

```

##  78. <a name='Removeduplicatesfromsortedarray'></a>83-Remove duplicates from sorted array

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1yJ411R7FZ?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Wb411e7s7?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1zK411L7Gg?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next # è¦ä¹ˆåˆ é™¤
            else:
                cur =  cur.next # è¦ä¹ˆä¸‹ä¸€ä¸ª
        return head
```

##  79. <a name='-1'></a>226-ç¿»è½¬äºŒå‰æ ‘

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Sh411R7B2?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H73E?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1FK411p7Co?spm_id_from=333.999.0.0)

```py
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```

```py
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        Q = deque([root])
        while Q:
            r = Q.pop()
            if r.left or r.right:
                r.left, r.right = r.right, r.left
                if r.left: Q.append(r.left)
                if r.right: Q.append(r.right)
        return root
```

##  80. <a name='CompareVersionNumbers'></a>165. Compare Version Numbers

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV19K4y1C7L3?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Pk4y117dF?spm_id_from=333.999.0.0)

```py
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = version1.split(".")
        v2 = version2.split(".")

        while v1 or v2:
            x = int(v1.pop(0)) if v1 else 0
            y = int(v2.pop(0)) if v2 else 0

            if x > y:
                return 1
            elif x < y:
                return -1
        return 0
```

##  81. <a name='-1'></a>34-åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ª

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Zv411y71t?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1GU4y1j7dq?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ef4y1v7Vz?spm_id_from=333.999.0.0)

```py
# Python äºŒåˆ†æ³•

class Solution:
    def searchRange(self, nums, target):
        left = 0
        right = len(nums)-1
        res = [0,0]
        
        if target not in nums:
            return [-1,-1]

        # å¯»æ‰¾å·¦ä¾§è¾¹ç•Œ
        while left <= right:
            mid = (right + left) // 2
            if nums[mid] == target:
                right = mid - 1 # ç»“æŸæ¡ä»¶, å› ä¸ºä¿ç•™ leftï¼Œæ‰€ä»¥ç§»åŠ¨ right
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[0] = left

        # å¯»æ‰¾å³ä¾§è¾¹ç•Œ
        right = len(nums)-1 # åªç§»åŠ¨ right ç«¯ç‚¹
        while left <= right:
            mid = (right + left) // 2
            if nums[mid] == target:
                left = mid + 1 # ç»“æŸæ¡ä»¶, å› ä¸ºä¿ç•™ rightï¼Œæ‰€ä»¥ç§»åŠ¨ left
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[1] = right

        return res
```


```scala
/**
* modify binary search template
* memo
*  1. search first and last the the same function
*  2. if nums(mid) == target we could move left to check if left part exists target number
*  3. finding last by target + 1,  then we could get last position of target by first position of (target + 1) - 1
* tricky:
*  1. ans = nums.length
*  2. first > last  means that target doesn't exists
*
* time complexity: O(2logN)
*/
 
 object Solution2 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
        val first = search(nums, target)
        val last = search(nums, target + 1) - 1
        if (first > last) Array(-1, -1) else Array(first, last)
    }

    def search(nums: Array[Int], target: Int): Int = {
      var ans = nums.length
      var left = 0
      var right = nums.length - 1
      while (left <= right) {
        val mid = left + (right - left) / 2
        if (nums(mid) >= target) {
          ans = mid
          right = mid - 1
        }else {
          left = mid + 1
        } 
      }
      ans
    }
}

```

# 5 day (å¾—åˆ† = 6åˆ†) 69

##  82. <a name='-1'></a>153-å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1bT4y1w7yK?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1yK411L7rp?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMin(self, nums):
        left, right = 0, len(nums) - 1
        # [4,5,6,7,0,1,2]
        # åªç”¨ mid å’Œ right æ¯”è¾ƒ

        while left <= right:
            mid = (right + left) // 2       
            if nums[mid] == nums[right]:    # æ­¤æ—¶ left å’Œ right ç›¸ç­‰ï¼Œç›´æ¥è¿”å›
                return nums[right]
            elif nums[mid] < nums[right]:   # æ¯”å³ç•Œå°ï¼Œnums[mid] å¯èƒ½æ˜¯æœ€å°å€¼ï¼Œä¸èƒ½å»æ‰
                right = mid                 # æ¯”å¦‚ [5,6,7,0,1,2,4]
            else:                           # æ¯”å³ç•Œå¤§ï¼Œnums[mid] è‚¯å®šä¸ä¼šæ˜¯æœ€å°å€¼     
                left = mid + 1
```

```scala

/**
* my first commitment binary search
*/
object Solution1 {
    def findMin(nums: Array[Int]): Int = {
        search(nums, 0, nums.length - 1)
    }
  
    def search(nums: Array[Int], left: Int, right: Int): Int = {
      if (left > right) return nums(left)
      val mid = left + (right - left) / 2
      val leftAns = if (nums(mid) >= nums(left)){ // left part in order
        nums(left)
      } else {
        search(nums, left, mid - 1)
      }
      
      val rightAns = if (nums(mid) <= nums(right)) { // right part in order
        nums(mid)
      } else {
        search(nums, mid + 1, right)
      }
      
      leftAns min rightAns
    }
}
```

##  83. <a name='-1'></a>62-ä¸åŒè·¯å¾„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1mC4y1W7Je?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Sg4y1v7PM?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1cp4y167qx?spm_id_from=333.999.0.0)

äºŒç»´åŠ¨æ€è§„åˆ’ï¼š

æ—¶é—´å¤æ‚åº¦ï¼šO(mn)

ç©ºé—´å¤æ‚åº¦ï¼šO(mn)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # æ˜“é”™ç‚¹ï¼šdpåƒä¸‡ä¸è¦å†™é”™
        # å…¶ä»–å†™æ³•ï¼šdp = [[1 for i in range(n)] for j in range(m)]
        # å…¶ä»–å†™æ³•ï¼šdp = [[1]*n]*m
        dp = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]
        for i in range(1, m): # è¿™é‡Œä» 1 å¼€å§‹
            for j in range(1, n): # è¿™é‡Œä» 1 å¼€å§‹
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]
```

ä¸€ç»´åŠ¨æ€è§„åˆ’ï¼š

æ—¶é—´å¤æ‚åº¦ï¼šO(mn)

ç©ºé—´å¤æ‚åº¦ï¼šO(n)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # æ˜“é”™ç‚¹ï¼šdpåƒä¸‡ä¸è¦å†™é”™
        dp = [1] * n
        for i in range(1, m):
            for j in range(1, n):
                dp[j] += dp[j - 1]
        return dp[-1]
```

```scala
/**
* fill dp array with 1
*/
object Solution2-1{
    def uniquePaths(m: Int, n: Int): Int = {
      val dp = Array.fill[Int](m, n)(1)
      for (i <- 1 until m; j <- 1 until n) {
        dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)
      }
      
      dp.last.last
    }
}
```

##  84. <a name='LongestConsecutiveSequence'></a>128. ã€ğŸ’å¹¶æŸ¥é›†ã€‘Longest Consecutive Sequence

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14t411Y7cg?spm_id_from=333.999.0.0)

[ä¸€ä¿©ä¸‰å››äº”](https://www.bilibili.com/video/BV1LJ41137r2?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

```py
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        res = 0
        numSet = set(nums)

        for num in numSet:
            if num - 1 not in numSet: # å»é‡ï¼Œè¡¨ç¤ºå’Œå‰é¢çš„ä¸è¿ç»­
                cur = num
                curlen = 1

                while cur + 1 in numSet: # è¡¨ç¤ºå’Œåé¢çš„è”ç³»
                    cur += 1
                    curlen += 1

                res = max(res, curlen)

        return res
```

##  85. <a name='ValidateIPAddress'></a>468 Validate IP Address

[å°æ˜](https://www.bilibili.com/video/BV1tg4y1q7Kq?spm_id_from=333.999.0.0)

```py

class Solution:
    def validIPAddress(self, IP: str) -> str:
        if "." in IP:
            # ipv4
            ipv4 = IP.split(".")
            if len(ipv4) != 4:
                return "Neither"
            for num in ipv4:
                # 192.168.01.1 ä¸ºæ— æ•ˆIPv4åœ°å€
                # 192.168@1.1 ä¸ºæ— æ•ˆIPv4åœ°å€
                # 0 <= xi <= 255 
                if (len(num) > 1 and num[0] == "0")  \
                    or not num.isdigit()  \
                    or (int(num) < 0)  \
                    or (int(num) > 255):
                    return "Neither"
            return "IPv4"
        else:
            ipv6 = IP.split(":")
            if len(ipv6) != 8:
                return "Neither"
            for num in ipv6:
                # 1 <= xi.length <= 4
                # å¯ä»¥åŒ…å«æ•°å­—ã€å°å†™è‹±æ–‡å­—æ¯( 'a' åˆ° 'f' )å’Œå¤§å†™è‹±æ–‡å­—æ¯( 'A' åˆ° 'F' )ã€‚
                if not num \
                    or len(num) > 4  \
                    or not all(map(lambda x: x.lower() in "0123456789abcdef", num)):
                    return "Neither"
            return "IPv6"


```

##  86. <a name='SingleNumber'></a>136 ã€ä½è¿ç®—ğŸ˜œã€‘Single Number

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1g7411a7bf?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Sp4y1D7M3?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qb411e7PU?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1pa4y1t7tr?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

```py
class Solution:
    def singleNumber(self, nums):
        a = 0
        for num in nums:
            a = a ^ num
        return a

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)
```

```scala
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        nums.reduce(_^_)
    }
}
```

##  87. <a name='FindPeakElement'></a>162. Find Peak Element

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Rb411n7dT?spm_id_from=333.999.0.0)

```py
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l = 0 
        r = len(nums) - 1 

        while l <= r:
            mid = (l + r) >> 1

            if l == r : return r # å…³é”®åœ¨äºè¿™é‡Œ

            elif nums[mid] < nums[mid + 1]: # å…³é”®åœ¨äºè¿™é‡Œï¼ŒèƒŒä¸€èƒŒå§
                l = mid + 1
            elif nums[mid] > nums[mid + 1]:
                r = mid # right å¯èƒ½æ˜¯æœ€ç»ˆç»“æœï¼Œæ‰€ä»¥ä¸èƒ½çœç•¥
# [1,2,1,3,5,6,4]
# 3 < 5, å‘å³ç§»åŠ¨ï¼Œleft æŒ‡å‘ 5ï¼Œright æŒ‡å‘ 4ï¼Œæƒ³è¾ƒå¤§å€¼æ–¹å‘ç§»åŠ¨
# 6 > 4, å‘å·¦ç§»åŠ¨ï¼Œleft æŒ‡å‘ 5ï¼Œright æŒ‡å‘ 6 
# 5 < 6, å‘å³ç§»åŠ¨ï¼Œleft æŒ‡å‘ 6ï¼Œright æŒ‡å‘ 6 
```

##  88. <a name='-1'></a>240. äºŒç»´æ•°ç»„çš„æŸ¥æ‰¾

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1dz411i7jC?spm_id_from=333.999.0.0)


```py
class Solution:
    def searchMatrix(self, matrix, target):
        # ä»å³ä¸Šè§’å¼€å§‹æ‰¾
        i, j = 0, len(matrix[0]) - 1
        while i < len(matrix) and j >= 0:
            if matrix[i][j] == target: 
                return True
            elif target < matrix[i][j]: 
                j -= 1 # è‹¥ç›®æ ‡å°äº†å°±å·¦ç§»
            elif target > matrix[i][j]: 
                i += 1 # ç›®æ ‡å¤§äº†å°±ä¸‹ç§»
        return False
```

##  89. <a name='-1'></a>221-ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘æœ€å¤§æ­£æ–¹å½¢

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1XT4y137Gq?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV16K411575r?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1mA411q7Sw?spm_id_from=333.999.0.0)

```py
# å³ä¸‹è§’çš„åæ ‡ä¸º (x, y)
# é‚£ä¹ˆ (x - 1, y - 1) ä¸€å®šéœ€è¦æ˜¯ä¸€ä¸ª squareï¼Œ
# å¹¶ä¸”è¯¥ç‚¹çš„å·¦è¾¹å…¨ä¸º1ï¼Œä¸Šè¾¹ä¹Ÿä¸º1ï¼ŒæŒ‰ç…§è¿™ä¸ªè¿›è¡Œç†è§£å˜é•¿çš„å¢åŠ ã€‚
æ„å»ºdpï¼š
class Solution:
    def maximalSquare(self, matrix):
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * n for _ in range(m)]
        maxEdge = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    # å½“ i å’Œ j ç­‰äº0æ—¶ï¼Œi-1 ä¸º -1
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                    maxEdge = max(dp[i][j], res)
        return maxEdge * maxEdge

åŸåœ°ä¿®æ”¹ï¼š
class Solution:
    def maximalSquare(self, matrix):
        maxEdge = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                if i and j: # è¿™ä¸ªå†™æ³•å¦™å•Šï¼Œåˆšå¥½å°±è·³è¿‡äº† i-1
                    if matrix[i][j] == "1":
                        matrix[i][j] = min(int(matrix[i-1][j-1]), int(matrix[i][j-1]), int(matrix[i-1][j])) + 1
                    else:
                        matrix[i][j] = 0
                maxEdge = max(maxEdge, int(matrix[i][j]))
        return maxEdge**2       
```

##  90. <a name='Longestcommonprefix'></a>14 - Longest common prefix

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1cJ411D7qU?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Eb411i7QN?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1tV411k7GY?spm_id_from=333.999.0.0)

* æ—¶é—´å¤æ‚åº¦: O(mn), m æ˜¯å­—ç¬¦ä¸²å¹³å‡é•¿åº¦, n æ˜¯å­—ç¬¦ä¸²æ•°é‡

* æ—¶é—´å¤æ‚åº¦: O(1)

```py
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        lookup = set()
        res = ''
        i = 0
        minlen = min(len(string) for string in strs)
        while i < minlen:
            lookup = set(string[i] for string in strs)
            if len(lookup) == 1:
                res += lookup.pop() # seté›†åˆä¸­ç”¨popå¼¹å‡ºæ•°æ®
                i += 1
            else:
                break
        return res
```

```scala
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var flag = true
            var count = 1
            var output = ""
        
            var minLength = strs.map(_.length).min
        
        while(flag && count <= minLength){
            
            /**
            lst.forall(_ == lst.head)  // true  if empty or all the same
            lst.exists(_ != lst.head)  // false if empty or all the same
            */
            
            if(strs.map(s => s.substring(0, count)).distinct.length == 1){
                output = strs(0).substring(0, count)
                count += 1
            }else{
                flag = false
            }
        }
        
        output
        }
    }
}

//Alternate solution (better complexity)
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var prefix = strs(0)
            
            (1 until strs.length).map(i => {
                
                while(strs(i).indexOf(prefix) != 0){
                    prefix = prefix.substring(0, prefix.length - 1)
                }
                
            })
            
            prefix
        }
    }
}

```

##  91. <a name='LargestNumber'></a>179 Largest Number

[å°æ˜](https://www.bilibili.com/video/BV1mV411m7aN?spm_id_from=333.999.0.0)

```py
from functools import cmp_to_key
class Solution(object):
    def largestNumber(self, nums):
        # ç¬¬ä¸€æ­¥ï¼šå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼ŒæŠŠæœ€å¤§çš„æ”¾å·¦è¾¹
        # ç¬¬äºŒæ­¥ï¼šæ’åº
        # ç¬¬ä¸‰æ­¥ï¼šè¿”å›ç»“æœ
        def compare(a, b):
            return int(b + a) - int(a + b)
        nums = sorted([str(x) for x in nums], key = cmp_to_key(compare))
        # nums = sorted(map(str, nums), key = cmp_to_key(compare))
        return str(int(''.join(nums)))
```

```py
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        # æŒ‰ç…§å­—å…¸åºç”±å¤§åˆ°å°æ’åº
        nums = sorted([str(x) for x in nums], reverse = True)
        for i in range(len(nums) - 1):
            for j in range(i, len(nums)):
        # [3,30,34,5,9] çš„ 3,30 ä¸èƒ½æŒ‰ç…§å­—å…¸åºæ’åºï¼Œéœ€è¦äº¤æ¢ä½ç½®
                if str(nums[i]) + str(nums[j]) < str(nums[j]) + str(nums[i]):
                    nums[i], nums[j] = nums[j], nums[i]
        return str(int(''.join(nums)))
```

##  92. <a name='-1'></a>138. å¤åˆ¶å¸¦éšæœºæŒ‡é’ˆçš„é“¾è¡¨

```py
"""
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

hashè§£æ³•ï¼š

class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head: return
        hash = {}

        cur = head
        while cur:
            hash[cur] = Node(cur.val)
            cur = cur.next
        
        cur = head
        while cur:
            hash[cur].next = hash.setdefault(cur.next)
            # hash[cur].next = hash.get(cur.next) è¿™é‡Œä¹Ÿå¯ä»¥ç”¨ get
            hash[cur].random = hash.setdefault(cur.random)
            cur = cur.next
            
        return hash[head]

dict.setdefault(key, default = None)  -->  æœ‰keyè·å–å€¼ï¼Œå¦åˆ™è®¾ç½® defaultï¼Œå¹¶è¿”å›default
dict.get(key, default = None)  -->  æœ‰keyè·å–å€¼ï¼Œå¦åˆ™è¿”å› default
```

```py
å°±èƒŒä¸€èƒŒå§ï¼Œåæ­£çœ‹ä¸æ‡‚
class Solution:
    def copyRandomList(self, head):
        def copyNode(node, visited):
            if not node: 
                return None
            if node in visited: 
                return visited[node]
            # ç¬¬ä¸€æ­¥ï¼š
            copy = Node(node.val, None, None)
            visited[node] = copy
            # ç¬¬äºŒæ­¥ï¼šé¡ºåºä¸èƒ½é”™
            copy.next = copyNode(node.next, visited)
            copy.random = copyNode(node.random, visited)
            return copy

        return copyNode(head, {})
```

##  93. <a name='-1'></a>695-å²›å±¿çš„æœ€å¤§é¢ç§¯

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1s54y1B77k?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1wz4y1R7e6?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1k64y1c798?spm_id_from=333.999.0.0)

```py
å †æ ˆï¼š

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        res = 0
        for i, lists in enumerate(grid):
            for j, n in enumerate(lists):
                area = 0
                stack = [(i, j)]
                while stack:
                    x, y = stack.pop()
                    # if èŒƒå›´ + å€¼
                    if x < 0 or y < 0 or x == len(grid) or y == len(grid[0]) or grid[x][y] != 1:
                        continue
                    area += 1
                    grid[x][y] = 0
                    for dx, dy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        newX, newY = x + dx, y + dy
                        stack.append((newX, newY))
                res = max(res, area)
        return res

dfs

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        
        def dfs(i, j):
            grid[i][j] = 0 # åˆ é™¤è¿™ä¸ªgrid
            acc = 1
            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                # if èŒƒå›´ + å€¼
                if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:
                    acc += dfs(x, y)
            return acc
        
        res = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    res = max(res, dfs(i, j))
        return res

å¹¶æŸ¥é›†

unioné¢ç§¯ æ˜¯åŸºäº find å’Œ dpArea
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        def find(v):
            if parent[v] != v:
                parent[v] = find(parent[v])
            return parent[v]
        # ç®€æ´çš„å†™æ³•æ˜¯ï¼š
        # def union(i, j):
        #     parent[find(i)] = find(j)
        def union(v1, v2):
            r1 = find(v1)
            r2 = find(v2)
            if r1 != r2:
                parent[r2] = r1
                dpArea[r1] += dpArea[r2] # åˆå¹¶, åˆ°r1
        
        m, n = len(grid), len(grid[0])
        parent = [i * n + j for i in range(m) for j in range(n)]
        dpArea = [0] * (m * n) # åˆå¹¶
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    cur = i * n + j
                    dpArea[cur] = 1  # åˆå¹¶
                    if 0 <= i + 1 < m and grid[i + 1][j]:
                        dpArea[cur + n] = 1  # åˆå¹¶
                        union(cur, cur + n)
                    if 0 <= j + 1 < n and grid[i][j + 1]:
                        dpArea[cur + 1] = 1  # åˆå¹¶
                        union(cur, cur + 1)
        return max(dpArea)
```



##  94. <a name='Offer36.'></a>å‰‘æŒ‡ Offer 36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨

```py
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: 
            return

        rootlist = []
        treefunc = lambda r: r and (treefunc(r.left) or rootlist.append(r) or treefunc(r.right))
        def dfs(cur):
            if cur:
                dfs(cur.left) # é€’å½’å·¦å­æ ‘, è¿›å…¥ä¸‹ä¸€å±‚
                rootlist.append(cur)
                dfs(cur.right) # é€’å½’å³å­æ ‘, è¿›å…¥ä¸‹ä¸€å±‚
        
        dfs(root)
        lenth = len(rootlist)
        for i, cur in enumerate(rootlist):
            # i + 1 - lenth çš„åæ ‡å€¼: -6 -5 -4 -3 -2 -1  0
            # i çš„åæ ‡å€¼:              0  1  2  3  4  5  6
            # i - 1 çš„åæ ‡å€¼:         -1  0  1  2  3  4  5
            cur.left, cur.right = rootlist[i - 1], rootlist[i + 1 - lenth]
        return rootlist[0]
```

##  95. <a name='SwapNodesinPairs'></a>24-Swap Nodes in Pairs

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1M7411n7FT?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV13J411V7hG?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ih411f7YK?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1VC4y1s75E?spm_id_from=333.999.0.0)

![](https://s3.bmp.ovh/imgs/2022/02/3738eb13202e2566.png)

```py
# æ–¹æ³•ä¸€ï¼šé€’å½’
class Solution(object):
    def swapPairs(self, head):

        if not head or not head.next:
            return head

        tmp = head.next
        # tmp å’Œ head äº¤æ¢ä½ç½®
        head.next = self.swapPairs(head.next.next)
        tmp.next = head
        return tmp # æ˜“é”™ç‚¹ï¼šæ³¨æ„ï¼Œæ–°çš„å¤´å·²ç»å˜æˆäº†tmp
``` 

![](https://s3.bmp.ovh/imgs/2022/02/18153c0d0979e358.png)

```py
# æ–¹æ³•äºŒï¼šè¿­ä»£
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head # æ˜“é”™ç‚¹ï¼šè¿™å¥è¯ä¸è¦æ¼
        cur = dummy
        while cur.next and cur.next.next:
            # ä¸€å…±3ä¸ªæŒ‡é’ˆ: first,second,cur
            first = cur.next
            second = cur.next.next
            
            # æŠŠå›¾ç”»å‡ºæ¥
            first.next = second.next
            second.next = first
            cur.next = second
            # æŒ‡é’ˆç§»åŠ¨
            cur = cur.next.next
        return dummy.next
```

```scala
/**
* chosen solution
* iterative version
* memo
*   1. dummyHead
*   2. need two pointer: pre node and current node
*  time complexity: O(N), each node only visit once
*/
object Solution0 {
    def swapPairs(head: ListNode): ListNode = {
        val nHead = new ListNode(0, head)
        var pre: ListNode  = nHead
        var curr = pre.next

        while (curr != null && curr.next != null) {
            val (pos1, pos2, next) = (curr, curr.next, curr.next.next)
            pre.next = pos2
            pos2.next = pos1
            pos1.next = next

            pre = pre.next.next
            curr = pre.next  
        }
        
        nHead.next
    }
}



/**
* recursive version
*/
object Solution2 {
    def swapPairs(head: ListNode): ListNode = {
        _swap(head)
    }   
    
    def _swap(n: ListNode): ListNode = {
        if(n == null) n
        else {
            (n, n.next) match {
                case (a, null) => a
                case (a: ListNode, b: ListNode) => 
                    /** a b è¦äº¤æ›ä½å­
                     */
                    a.next = _swap(b.next) // a æŒ‡å‘ b çš„ next (å·²äº¤æ›å®Œæˆï¼‰
                    b.next = a // b çš„ next æ¥ä¸Š a å°±äº¤æ›å®Œæˆ
                    b
            }
        } 
    }
}
```

##  96. <a name='DecodeString'></a>394 Decode String

[å°æ˜](https://www.bilibili.com/video/BV145411V75E?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1GZ4y1p7pE?spm_id_from=333.999.0.0)

```py
æœ¬é¢˜æ ¸å¿ƒæ€è·¯ï¼šæ˜¯åœ¨æ ˆé‡Œé¢æ¯æ¬¡å­˜å‚¨ä¸¤ä¸ªä¿¡æ¯, 

(å·¦æ‹¬å·å‰çš„`å­—ç¬¦ä¸²`, å·¦æ‹¬å·å‰çš„`æ•°å­—`)

class Solution:
    def decodeString(self, s: str) -> str:
        stack = []  
        tmp, num = "", 0 
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c) # 3
            elif c == "[":
                stack.append((tmp, num)) # æ¯”å¦‚abc3[def], å½“é‡åˆ°ç¬¬ä¸€ä¸ª "[" çš„æ—¶å€™ï¼Œå‹å…¥æ ˆä¸­çš„æ˜¯("abc", 3)
                tmp, num = "", 0
            elif c == "]":
                top = stack.pop() # ç„¶åéå†æ‹¬å·é‡Œé¢çš„å­—ç¬¦ä¸²def, å½“é‡åˆ° "]" çš„æ—¶å€™, ä»æ ˆé‡Œé¢å¼¹å‡ºä¸€ä¸ªå…ƒç´ (s1, n1)
                tmp = top[0] + tmp * top[1] # å¾—åˆ°æ–°çš„å­—ç¬¦ä¸²ä¸º abc + def * 3
            else:
                tmp += c # abc def
        return tmp

```

##  97. <a name='HouseRobber198-'></a>198. ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘House Robber 198-æ‰“å®¶åŠ«èˆ

[12:45 èŠ±èŠ±é…± DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1tW411676f?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1u64y1M7PA?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7hu?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1gZ4y1N75c?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV18g4y1i7f9?spm_id_from=333.999.0.0)

```py
åŠ¨æ€ğŸš€è§„åˆ’ï¼Œå…¸å‹ä¾‹é¢˜ï¼š
class Solution:
    def rob(self, nums: List[int]) -> int:
        dp0 = 0
        dp1 = 0
        for num in nums:
            dp0, dp1 = dp1, max(dp0 + num, dp1) # (éš”ä¸€ä¸ªçš„å’Œ+å½“å‰, å‰ä¸€ä¸ªçš„å’Œ)
        return dp1
```


```scala
//While using DP: we try to store values of repetitive calculations
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var dp = Array.fill(nums.length+1)(0)
            
            dp(0) = 0
            dp(1) = nums(0)
            (1 to nums.length-1).map(i => {
                dp(i+1) = Math.max(dp(i), dp(i-1) + nums(i))
            })
            
            dp(nums.length)
        }
    }
}

//Another way to do the same
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.isEmpty){
            0
        }else{
            var rob = nums(0)
            var no_rob = 0
            var prev = rob
            for(i <- 1 until nums.length){
                prev = rob
                rob = no_rob + nums(i)
                no_rob = Math.max(prev, no_rob)
                
            }
            Math.max(no_rob, rob)
        }
    }
}

```

##  98. <a name='-1'></a>209-é•¿åº¦æœ€å°çš„å­æ•°ç»„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1JZ4y1N7Rt?spm_id_from=333.999.0.0)

```py
æš´åŠ›è§£æ³•ï¼›

class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        minlen = n + 1
        for i in range(n):
            total = 0
            #  è¿ç»­å­æ•°ç»„, æ‰€ä»¥æ˜¯ i åˆ° j ç´¯åŠ 
            for j in range(i, n):
                total += nums[j]
                if total >= s:
                    minlen = min(minlen, j - i + 1)
                    break
        
        return 0 if minlen == n + 1 else minlen
```


```py
       
O(n log n) æ—¶é—´å¤æ‚åº¦ï¼Œç”¨äºŒåˆ†

class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        l, r, res = 0, len(nums), 0
        def isWinEnough(size):
            sums = 0
            for i in range(len(nums)):
                sums += nums[i]
                # å›ºå®šå¤§å°çš„æ»‘åŠ¨çª—å£
                if i >= size:
                    sums -= nums[i - size]
                # ç„¶ååˆ¤æ–­æ˜¯å¦æ»¡è¶³è¦æ±‚
                if sums >= s:
                    return True
            return False
            
        while l <= r:
            mid = (l + r) // 2  # æ»‘åŠ¨çª—å£å¤§å°
            if isWinEnough(mid):  # å¦‚æœè¿™ä¸ªå¤§å°çš„çª—å£å¯ä»¥é‚£ä¹ˆå°±ç¼©å°
                res = mid
                r = mid - 1
            else:  # å¦åˆ™å°±å¢å¤§çª—å£
                l = mid + 1
        return res

```

##  99. <a name='BasicCalculatorII'></a>227 Basic Calculator II - è§ 224. åŸºæœ¬è®¡ç®—å™¨

[å°æ˜](https://www.bilibili.com/video/BV1Qy4y167Ax?spm_id_from=333.999.0.0)

https://www.bilibili.com/video/BV1t4411c7m6?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

https://www.bilibili.com/video/BV1v54y1a74b?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

```py
class Solution:
    def calculate(self, s: str) -> int:
        stack = []
        num, op = 0, "+"  # è¿™ä¸ª"+", åœ¨æœ€å‰é¢,æ˜¯å› ä¸ºç®—æ³•ç¬¦å·å…·æœ‰æ»åæ€§
        for i, char in enumerate(s):
            if char.isdigit():
                num = 10 * num + int(char)
            if char in "+-*/" or i == len(s)-1:
                if op == "+":
                    stack.append(num)
                elif op == "-":
                    stack.append(-num)
                elif op == "*":
                    stack.append(stack.pop()*num)
                elif op == "/":
                    stack.append(int(stack.pop()/float(num)))
                num, op = 0, char # op çš„èµ‹å€¼æ”¾åœ¨æœ€åé¢, æ˜¯å› ä¸ºç®—æ³•ç¬¦å·å…·æœ‰æ»åæ€§
        return sum(stack)

```

```py
# æœ¬é¢˜ä¸å«æ‹¬å·å’Œç¬¦å·ä½ï¼Œæ‰€ä»¥å°† '/' æ›¿æ¢ä¸º '//' å°±å¯ä»¥ç›´æ¥è°ƒç”¨ eval äº†ã€‚
class Solution(object):
    def calculate(self, s):
        return eval(s.replace('/', '//'))
```

##  100. <a name='-1'></a>958. äºŒå‰æ ‘çš„å®Œå…¨æ€§æ£€éªŒ

```py
2 * v å’Œ 2 * v + 1
         1
        / \
       2   3
      / \ / \
     4  5 6  7

2 * v + 1 å’Œ 2 * v + 2
         0
        / \
       1   2
      / \ / \
     3  4 5  6

class Solution(object):
    def isCompleteTree(self, root):
        stack = [(root, 1)]
        i = 0
        # æœ¬æ¥è¿™è¾¹åº”è¯¥è¦ç”¨ queue çš„ï¼Œå› ä¸ºéœ€è¦ popleft
        while i < len(stack):
            node, v = stack[i]
            i += 1
            if node:
                stack.append((node.left,  2 * v))
                stack.append((node.right, 2 * v + 1))

        return stack[-1][1] == len(stack)
```

# 6 day (å¾—åˆ† = 5åˆ†) 74

##  101. <a name='Offer09.'></a>å‰‘æŒ‡ Offer 09. ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—

```py
stack_in åªè´Ÿè´£è¿›å…¥
stack_out åªè´Ÿè´£å–å‡º

åªæœ‰ stack_out ä¸ºç©ºæ—¶æ‰æŠŠ stack_in çš„æ‰€æœ‰å…ƒç´ å€¾å€’è¿›stack_outä¸­ï¼Œè¿™æ ·é¡ºåºå°±ä¸ä¼šä¹±äº†
class CQueue:

    def __init__(self):
        self.stack_in = []
        self.stack_out = []

    def appendTail(self, value: int) -> None:
        self.stack_in.append(value)

    def deleteHead(self) -> int:
        # å¦‚æœ self.stack_out æ²¡æœ‰å†…å®¹ï¼Œå°± å‘¼å« self.stack_in
        if not self.stack_out:
            if not self.stack_in: # éƒ½ä¸ºç©º
                return -1
            else: # æŠŠinæ ˆä¸­çš„ä¸œè¥¿å…¨éƒ¨å€’å…¥outæ ˆä¸­
                while self.stack_in:
                    self.stack_out.append(self.stack_in.pop())
        # å¦‚æœ self.stack_out æœ‰å†…å®¹ï¼Œå°±ç›´æ¥ pop
        return self.stack_out.pop()
```

##  102. <a name='II'></a>122-ã€è´ªå¿ƒğŸ§¡ã€‘ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II 122-Best Time to Buy and Sell Stock II

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV12K411A7rL?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1d7411x78d?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qb411e7iq?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Fk4y1R7ve?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV17i4y1L7LG?spm_id_from=333.999.0.0)

```py
è´ªå¿ƒç®—æ³•ï¼šä¸€æ¬¡éå†ï¼Œåªè¦`ä»Šå¤©ä»·æ ¼`å°äº`æ˜å¤©ä»·æ ¼`å°±åœ¨ä»Šå¤©ä¹°å…¥ç„¶åæ˜å¤©å–å‡ºï¼Œæ—¶é—´å¤æ‚åº¦ O(n)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
            preprice = price
        return maxprofit
```

```scala

/**
* greedy alg: one line pass
*/

object Solution1-2 {
  def maxProfit(prices: Array[Int]): Int = {
    if(prices.length > 1) prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum else 0
  }
}

//Alternate solution
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices
            .foldLeft(0,Int.MaxValue)((t, current) => (t._1 + 0.max(current-t._2), current))
            ._1
    }
}

```


##  103. <a name='Offer54.k'></a>å‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹ - 230 Kth Smallest Element in a B

```py
class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        def inorder(root):
            if not root:
                return

            inorder(root.right)
            self.k -= 1
            if self.k == 0: 
                self.res = root.val
                return
            inorder(root.left)

        self.k = k
        inorder(root)
        return self.res
```

##  104. <a name='-1'></a>283. Move Zeros

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1m441187Kt?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ba4y1t7eK?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1Wp4y1y7pT?spm_id_from=333.999.0.0)

```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0:
                # æŠŠ index çš„ä½ç½®å˜æˆä¸æ˜¯ 0, i çš„ä½ç½®å˜æˆæ˜¯ 0
                nums[slow], nums[fast] = nums[fast], nums[slow]
                # slow çš„ä½ç½®ä¸æ˜¯ 0, éƒ½åœ¨å‰é¢
                slow += 1
#                       [0, 1, 0, 3, 12]
# slow: 0 fast: 1 nums: [1, 0, 0, 3, 12]
# slow: 1 fast: 3 nums: [1, 3, 0, 0, 12]
# slow: 2 fast: 4 nums: [1, 3, 12, 0, 0]

```

```scala
//Alternate solution: calculate the number of shifts 
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        
        var zeroCount = 0
        //count of zero is amount character is shifted to left
        //from first zero position traverse array left
        for(a <- 0 to nums.size-1){   
            //count zeroes and shift when not zero
            if(nums(a) == 0){
                zeroCount = zeroCount + 1
            }else if(zeroCount > 0){
                //shift left if not 0 by zeroCount
                nums(a - zeroCount) = nums(a)
                nums(a) = 0
            }
        }
    }
}

```

##  105. <a name='-1'></a>498. å¯¹è§’çº¿éå†

```py
class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        m, n, res = len(matrix), len(matrix) and len(matrix[0]), []
        for idx in range(m + n - 1):
            tmp = [matrix[i][idx - i] for i in range(max(0, idx + 1 - n), min(idx + 1, m))] # èŒƒå›´å…¶å®æ˜¯: min(idx, m-1)
            res += tmp if idx % 2 else tmp[::-1]
        return res

'''
æ¯å±‚çš„ç´¢å¼•å’Œç›¸ç­‰ï¼š
1. å‡è®¾çŸ©é˜µæ— é™å¤§ï¼›
2. ç´¢å¼•å’Œä¸º{å¶}æ•°ï¼Œå‘ä¸Šéå†ï¼Œ{æ¨ª}ç´¢å¼•å€¼é€’å‡ï¼Œéå†å€¼ä¾æ¬¡æ˜¯(x,0),(x-1,1),(x-2,2),...,(0,x)
3. ç´¢å¼•å’Œä¸º{å¥‡}æ•°ï¼Œå‘ä¸‹éå†ï¼Œ{çºµ}ç´¢å¼•å€¼é€’å‡ï¼Œéå†å€¼ä¾æ¬¡æ˜¯(0,y),(1,y-1),(2,y-2),...,(y,0)

    m, n = 7
   æ¯å±‚çš„ç´¢å¼•å’Œ:
            0:              (00)               i: 0 ~ 0
            1:            (01)(10)             i: 0 ~ 1
            2:          (20)(11)(02)           i: 0 ~ 2
            3:        (03)(12)(21)(30)         i: 0 ~ 3
            4:      (40)(31)(22)(13)(04)       i: 0 ~ 4
            5:    (05)(14)(23)(32)(41)(50)     i: 0 ~ 5
            6:  (60)(51)................(06)   i: 0 ~ 6
            7:    (16)................(61)     i: 1 ~ 6
            8:      (62)............(26)       i: 2 ~ 6
            9:        (36)........(36)         i: 3 ~ 6
           10:          (64)....(46)           i: 4 ~ 6
           11:            (56)(65)             i: 5 ~ 6
           12:              (66)               i: 6 ~ 6

        æŒ‰ç…§â€œå±‚æ¬¡â€éå†ï¼Œä¾æ¬¡appendåœ¨ç´¢å¼•è¾¹ç•Œå†…çš„å€¼å³å¯
'''


class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        m, n = len(matrix), len(matrix) and len(matrix[0])
        tmp = collections.defaultdict(list)
        for i in range(m):
            for j in range(n):
                tmp[i + j].append(matrix[i][j])
                # 00 é€†åº  i % 2 = 0  diag[::-1]
                # 01 æ­£åº  i % 2 = 1  diag
                # 02 é€†åº  i % 2 = 0  diag[::-1]
                # 03 æ­£åº  i % 2 = 1  diag
        res = []
        sign = -1
        for k in tmp: # å¿…é¡»æ’åºï¼Œå»ºè®®è®°å¿†ä¸‹é¢çš„
            res.extend(tmp[k][::sign])
            sign *= -1
        return res


class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        m, n = len(matrix), len(matrix) and len(matrix[0])
        tmp = [[] for _ in range(m + n - 1)]
        for i in range(m):
            for j in range(n):
                tmp[i + j].append(matrix[i][j])
        res = []
        for i, diag in enumerate(tmp):
            res.extend(diag if i % 2 else diag[::-1])
        return res
```

##  106. <a name='-1'></a>662. Maximum Width of Binary Tree

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1cv411q7pb?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV16a4y1h7fG?spm_id_from=333.999.0.0)

```py
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        res = 0
        queue = collections.deque([(root, 1)])
        while queue:
            res = max(res, queue[-1][1] - queue[0][1] + 1)# åªèƒ½å†™åœ¨è¿™é‡Œï¼å¦åˆ™ä¸å­˜åœ¨
            for _ in range(len(queue)):
                node, pos = queue.popleft()
                if node.left:  queue.append((node.left,  pos * 2))
                if node.right: queue.append((node.right, pos * 2 + 1))
        return res 
```

##  107. <a name='-1'></a>297. Serialize and Deserialize Binary Tree

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Hb411c7cr?spm_id_from=333.999.0.0)

```py
class Codec:
    def serialize(self, root):
        # å‰åºéå†
        def func(r):
            return str(r.val) + ',' + func(r.left) + func(r.right) if r else ','
        return func(root)

    def deserialize(self, data):
        # å‰åºéå†
        lis = data.split(',')[::-1]
        def func():
            val = lis.pop()
            return TreeNode(val, func(), func()) if val else None
        return func()

```

##  110. <a name='-1'></a>152 ã€åŠ¨æ€ğŸš€è§„åˆ’ã€‘ä¹˜ç§¯æœ€å¤§å­æ•°ç»„

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV12a4y1i76G?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1iK411K7yG?spm_id_from=333.999.0.0)

maxdp * num, mindp * num, num

```py
# åŠ¨æ€ğŸš€è§„åˆ’ï¼š

# éå†æ—¶ï¼Œæ¯æ¬¡åˆ†åˆ«å­˜å‚¨ å‰iä¸ªä¸­è¿ç»­æ•°ç»„ [æœ€å¤§çš„ä¹˜ç§¯å’Œ] å’Œ [æœ€å°ä¹˜ç§¯å’Œ]

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums: return 
        res = nums[0]
        maxdp = nums[0]
        mindp = nums[0]
        for num in nums[1:]:
            maxdp, mindp = max(maxdp * num, mindp * num, num), min(maxdp * num, mindp * num, num)
            res = max(res, maxdp)
        return res

# ä¹‹æ‰€æœ‰å­˜ [æœ€å°ä¹˜ç§¯å’Œ]ï¼Œæ˜¯å› ä¸º [æœ€å°ä¹˜ç§¯å’Œ] å¦‚æœæ˜¯è´Ÿæ•°æœ‰å¯èƒ½é‡åˆ°è´Ÿæ•°ï¼Œ

# ç›¸ä¹˜åç»“æœæ›´å¤§ Python
```

```scala

object Solution2-1 {
    def maxProduct(nums: Array[Int]): Int = {
        
        val (_, _, ans) = (1 until nums.length).foldLeft((nums.head, nums.head, nums.head)){
            case ((min, max, ans), idx) => 
                val a = nums(idx) * min 
                val b = nums(idx) * max
                val newMin = a min b min nums(idx)
                val newMax = a max b max nums(idx)
                (newMin, newMax, ans max newMax)
        }
        ans
    }
}



```

##  111. <a name='-1'></a>79. Word Search

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1yE411g7Tb?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1iZ4y1T78D?spm_id_from=333.999.0.0)

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def dfs(i, j, word):
            # å•è¯æ˜¯å¦å‡ºç°åœ¨ä»¥iï¼Œjä¸ºèµ·ç‚¹çš„ç½‘æ ¼ä¸­
            # word[0] å’Œ word[1:] åˆ’åˆ†
            # ç»“æŸæ¡ä»¶ï¼š
            if len(word) == 1:
                return word[0] == board[i][j]
            # ç»“æŸæ¡ä»¶ï¼š
            if board[i][j] != word[0]:
                return False
            
            # è®¾ç½®ç°åœº
            visit[i][j] = True
            for dire in direction: # å¯¹å››ä¸ªæ–¹å‘è¿›è¡Œæœç´¢
                newi, newj = i + dire[0], j + dire[1]
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]) and not visit[newi][newj]:
                    if dfs(newi, newj, word[1:]): # dfsæˆåŠŸ
                        return True
            # è¿˜åŸç°åœº
            visit[i][j] = False

        direction = [(0,1), (0, -1), (1, 0), (-1, 0)]
        m = len(board)
        n = len(board[0])
        visit = [[False] * n for _ in range(m)]
        for i in range(m): # éå†æ‰€æœ‰æ ¼å­ä½œä¸ºå•è¯èµ·ç‚¹
            for j in range(n):
                if dfs(i, j, word): # dfsæˆåŠŸ
                    return True
        return False
```


```scala
/**
* directly compare with char by char
* if there are only one word should be checked in board, brute force is a more efficient method
*/

object Solution2 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    dfs(word, board)
  }

  def dfs(word: String, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), wordIdx: Int): Boolean = {
      val char = board(coord._1)(coord._2)

      if(wordIdx >= word.length || char != word.charAt(wordIdx)) false
      else if(char == word.charAt(wordIdx) && wordIdx == word.length - 1) true
      else {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), wordIdx + 1)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      }
    }
    
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, 0))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

##  113. <a name='Offer10-I.'></a>å‰‘æŒ‡ Offer 10- I. æ–æ³¢é‚£å¥‘æ•°åˆ—

```py

from functools import lru_cache
class Solution:
    @lru_cache(None)
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return (self.fib(n - 1) + self.fib(n - 2)) % 1000000007
        # 1 1 2 3 5


ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼ŒåŒæ—¶èµ‹å€¼ã€‚
class Solution:
    def fib(self, n: int) -> int:
        MOD = 10 ** 9 + 7
        if n < 2:
            return n
        dp0, dp1 = 0, 1
        for _ in range(2, n + 1):
            dp1, dp0 = (dp1 + dp0) % MOD, dp1
            # index: 1 2 3 4 5
            # fib:   1 1 2 3 5
        return dp1
```

##  115. <a name='Offer21.'></a>å‰‘æŒ‡ Offer 21. è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢

```py
ç±»ä¼¼å‰é¢çš„ç§»åŠ¨0
class Solution:
    def exchange(self, nums: List[int]) -> List[int]:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] & 1 == 1:
                # æŠŠ [fastä¸Šçš„å¥‡æ•°] ç§»åŠ¨åˆ° [slowçš„ä½ç½®] ä¸Š
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
        return nums
```

##  116. <a name='II-1'></a>59. Spiral Matrix II 

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1J741157Kt?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1q5411G7MY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[0 for _ in range(n)] for _ in range(n)]
        x, y, dx, dy = 0, 0, 0, 1 
        # 0,1 -> 1,0 -> 0,-1 -> -1,0
        for num in range(1, n * n + 1):
            res[x][y] = num

            if not 0 <= x + dx < n or not 0 <= y + dy < n or res[x+dx][y+dy] != 0:
            # æ˜“é”™ç‚¹ï¼šor res[x+dx][y+dy] != 0 é¡ºåºå¾ˆé‡è¦ï¼Œä¸€å®šè¦åœ¨æœ€åï¼Œå°±åƒè´ªåƒè›‡
                dx, dy = dy, -dx # è°ƒå¤´

            x += dx
            y += dy
        return res
```

## 328. å¥‡å¶é“¾è¡¨ (Odd Even Linked List)

[æ´›é˜³](https://www.bilibili.com/video/BV1v64y1u7AH?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ag4y1B78z?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def oddEvenList(self, head):
        if head == None:
            return head

        odd = oddHead = head
        even = evenHead = head.next
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next 
            even = even.next
        odd.next = evenHead # å…ˆå¥‡æ•°ï¼Œåå¶æ•°
        return head 
```

##  117. <a name='1.'></a>è¡¥å……é¢˜1. æ’åºå¥‡å‡å¶é™é“¾è¡¨

1. æŒ‰å¥‡å¶ä½ç½®æ‹†åˆ†é“¾è¡¨ï¼Œå¾— 1->3->5->7->NULL å’Œ 8->6->4->2->NULL  328. å¥‡å¶é“¾è¡¨
2. åè½¬å¶é“¾è¡¨ï¼Œå¾— 1->3->5->7->NULL å’Œ 2->4->6->8->NULL         206. åè½¬é“¾è¡¨
3. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼Œå¾— 1->2->3->4->5->6->7->8->NULL           21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

https://mp.weixin.qq.com/s/0WVa2wIAeG0nYnVndZiEXQ

```py
è¾“å…¥: 1->8->3->6->5->4->7->2->NULL
è¾“å‡º: 1->2->3->4->5->6->7->8->NULL

class ListNode:    
    def __init__(self, x):        
        self.val = x        
        self.next = None

class Solution:    
    def sortOddEvenList(self,head):     
        if not head or not head.next:      
            return head        
        oddList,evenList = self.partition(head)        
        evenList = self.reverse(evenList)        
        return self.merge(oddList,evenList)    

    def partition(self, head: ListNode) -> ListNode:        
        evenHead = head.next        
        odd, even = head, evenHead        
        while even and even.next:            
            odd.next = even.next            
            odd = odd.next            
            even.next = odd.next            
            even = even.next        
        odd.next = None # èŠ‚ç‚¹éœ€è¦æ–­å¼€
        return [head,evenHead]    

    def reverse(self,head):        
        dummy = ListNode(-1)        
        p = head        
        while p:            
            tmp = p.next            
            p.next = dummy.next            
            dummy.next = p            
            p = tmp        
        return dummy.next    

    def merge(self,p,q):        
        head = ListNode(-1)        
        r = head        
        while p and q:            
            if p.val <= q.val:               
                r.next = p                
                p = p.next            
            else:                
                r.next = q                
                q = q.next            
            r = r.next        
        r.next = p or q        
        return head.next
```

##  118. <a name='Offer40.k'></a>å‰‘æŒ‡ Offer 40. æœ€å°çš„kä¸ªæ•°

```py
import heapq
class Solution(object):
    def getLeastNumbers(self, arr, k):
        return heapq.nsmallest(k, arr)

class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        arr.sort()
        return arr[:k]

class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        if k == 0:
            return list()
        # è¿™é‡Œéœ€è¦å¼¹å‡ºæœ€å¤§å€¼ï¼Œè€Œheapqåªèƒ½å¼¹å‡ºæœ€å°å€¼ï¼Œæ‰€ä»¥éœ€è¦å–å
        hp = [-x for x in arr[:k]]
        heapq.heapify(hp)
        for i in range(k, len(arr)):
            if -hp[0] > arr[i]:
                heapq.heappushpop(hp, -arr[i])
        ans = [-x for x in hp]
        return ans

```

##  119. <a name='II-1'></a>518 Coin Change 2 - è§ 322. ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ… + dfsã€‘Coin Change

https://leetcode-cn.com/problems/coin-change-2/

[å°æ˜](https://www.bilibili.com/video/BV1jC4y1a7YT?spm_id_from=333.999.0.0)

```py
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        # dp[i]ä»£è¡¨é‡‘é¢ä¸ºiçš„æ—¶å€™èƒ½å‡‘æˆæ€»é‡‘é¢çš„ç¡¬å¸ç»„åˆæ•°é‡
        dp = [0] * (amount + 1)
        dp[0] = 1
        for i in range(len(coins)):
            # å‡å¦‚åªæœ‰1ä¸ªç¡¬å¸ï¼Œå‡å¦‚æœ‰2ä¸ªç¡¬å¸ï¼Œå‡å¦‚æœ‰3ä¸ªç¡¬å¸~ ~ ~
            for j in range(coins[i], amount + 1):
               dp[j] += dp[j - coins[i]]
        return dp[-1]
```

##  120. <a name='-1'></a>224. åŸºæœ¬è®¡ç®—å™¨ - è§ 227 Basic Calculator II ä¸¤é“é¢˜å®Œå…¨ä¸åŒ

https://www.bilibili.com/video/BV1Nb4y1z7hG?from=search&seid=1882841343164929357&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.71qtf391s5w0.png" width="40%">

```py

class Solution:
    def calculate(self, s: str) -> int:
        stack = [1]
        sign = 1
        i = 0
        res = 0
        while i < len(s):
            if s[i].isdigit():
                n = 0
                while i < len(s) and s[i].isdigit():
                    n = 10 * n + int(s[i])
                    i += 1
                res += sign * n
            else:
                if s[i] == '+':   sign = stack[-1]
                elif s[i] == '-': sign = -stack[-1]
                # -(1-(4+5+2)-3)+(6+8)
                # stack[-1] æ˜¯å› ä¸ºè´Ÿè´Ÿå¾—æ­£
                elif s[i] == '(': stack.append(sign)
                elif s[i] == ')': stack.pop()
                i += 1
        return res
```

# 7 day (å¾—åˆ† = 4åˆ†) 78

##  121. <a name='K'></a>402 Remove K Digits

[å°æ˜](https://www.bilibili.com/video/BV1PV411C79X?spm_id_from=333.999.0.0)

å½¢æˆä¸€ä¸ªæ–°çš„æœ€å°çš„æ•°å­—ï¼š

```py
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        numStack = []
        
        # æ„å»ºå•è°ƒé€’å¢çš„æ•°å­—ä¸²
        for digit in num:
            while k and numStack and numStack[-1] > digit:
                numStack.pop()
                k -= 1
        
            numStack.append(digit)
        
        # å¦‚æœ K > 0ï¼Œåˆ é™¤æœ«å°¾çš„ K ä¸ªå­—ç¬¦
        finalStack = numStack[:-k] if k else numStack
        
        # æŠ¹å»å‰å¯¼é›¶
        return "".join(finalStack).lstrip('0') or "0"

```

##  122. <a name='23.'></a>è¡¥å……é¢˜23. æ£€æµ‹å¾ªç¯ä¾èµ–

```s
ç°æœ‰nä¸ªç¼–è¯‘é¡¹ï¼Œç¼–å·ä¸º 0 ~ n-1ã€‚ç»™å®šä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œ

è¡¨ç¤ºç¼–è¯‘é¡¹ä¹‹é—´æœ‰ä¾èµ–å…³ç³»ã€‚å¦‚[0, 1]è¡¨ç¤º1ä¾èµ–äº0ã€‚

è‹¥å­˜åœ¨å¾ªç¯ä¾èµ–åˆ™è¿”å›ç©ºï¼›ä¸å­˜åœ¨ä¾èµ–åˆ™è¿”å›å¯è¡Œçš„ç¼–è¯‘é¡ºåºã€‚
```

```py
class Solution:
    def haveCircularDependency(self, n: int, prerequisites):
        graph = [[] for _ in range(n)] # é‚»æ¥è¡¨å­˜å‚¨å›¾ç»“æ„
        indegree = [0 for _ in range(n)] # æ¯ä¸ªç‚¹çš„å…¥åº¦
        # å°†ä¾èµ–å…³ç³»åŠ å…¥é‚»æ¥è¡¨ä¸­gï¼Œå¹¶å„ä¸ªç‚¹å…¥åº¦
        for pre in prerequisites:
            a, b = pre[0], pre[1]
            graph[a].append(b)
            indegree[b] += 1
            
        res = [] # å­˜å‚¨ç»“æœåºåˆ—
        que = deque()
        # ä¸€æ¬¡æ€§å°†å…¥åº¦ä¸º0çš„ç‚¹å…¨éƒ¨å…¥é˜Ÿ
        for i in range(n):
            if indegree[i] == 0:
                que.append(i)
        while que:
            start = que.popleft()
            res.append(start)
            # åˆ é™¤è¾¹æ—¶ï¼Œå°†ç»ˆç‚¹çš„å…¥åº¦-1ã€‚è‹¥å…¥åº¦ä¸º0ï¼Œæœæ–­å…¥é˜Ÿ
            for end in graph[start]:
                indegree[end] -= 1
                if indegree[end] == 0:
                    que.append(end)
        return res if len(res) == n else []
```

##  123. <a name='-1'></a>7 Reverse Integer

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1sE411e73m?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Jb411i7bM?spm_id_from=333.999.0.0)

* æ—¶é—´å¤æ‚åº¦: O(log10(n)), æ¯æ¬¡è¿­ä»£éƒ½ä¼šé™¤ä»¥ 10

* æ—¶é—´å¤æ‚åº¦: O(1)

```py
å­—ç¬¦ä¸²æ³•ï¼š
class Solution:
    def reverse(self, x: int) -> int:
        s = str(x)

        if '-' in s:
            sn = '-'
            s = s[1:len(s)]
        else:
            sn = ''

        for i in range(len(s)):
            sn = sn + s[len(s)-1-i]
        if int(sn)<-2**31 or int(sn)>2**31-1:
            return 0
        return int(sn)

è®¡ç®—æ³•ï¼š
class Solution:
    def reverse(self, x: int) -> int:
        res = 0 
        a = abs(x)

        while a != 0:
            tmp = a % 10
            res = res * 10 + tmp
            a = a // 10
        # è¦æ³¨æ„returnå’Œwhileçš„ç›¸å¯¹ä½ç½®
        # ä¸è¦å†™åœ¨whileå¾ªç¯å†…éƒ¨

        if x > 0 and res < 1<<31:
            return res 
        elif x < 0 and res <= 1<<31:
            return -res
        else:
            return 0
```


```scala
object Solution {
    def reverse(x: Int): Int = {
        if(x == 0){
            0
        }else{
            var output = 0L
            var num = x
            var flag = false
            
            if(x < 0){
                num = Math.abs(num)
                flag = true
            }
            
        
            while(num!=0){
                var mod = num%10
            
                output = (output*10) + mod
            
                num = num/10
            }
            
            val res = if(flag){
                output * (-1)
            }else{
                output
            }
            //To avoid overflow
            if(res < Int.MinValue || res > Int.MaxValue) 0 else res.toInt
        }
    }
}
```

##  125. <a name='-1'></a>739-Daily Temperatures

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Q7411L7w8?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ov411z7rM?spm_id_from=333.999.0.0)

```py
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res = [0] * n
        stack = []
        # ç”¨ i æ¥è§¦å‘è®¡ç®—
        for i in range(n):
            tmpt = temperatures[i]
            # æŒ‡åœ¨ç¬¬ i å¤©ä¹‹åï¼Œæ‰ä¼šæœ‰æ›´é«˜çš„æ¸©åº¦ã€‚
            # [73,74,75,71,69,72,76,73]
            # []
            # [0]
            # [1]
            # [2]
            # [2, 3]
            # [2, 3, 4]
            # [2, 5]
            # [6]
            # å¦‚æœæ¯”å‰ä¸€é¡¹å¤§ï¼Œåˆ™ç›´æ¥popï¼ŒæˆåŠŸ
            # å¦‚æœæ¯”å‰ä¸€é¡¹å°ï¼Œåˆ™ä¸éœ€è¦pop
            while stack and temperatures[stack[-1]] < tmpt:
                preIdx = stack.pop()
                res[preIdx] = i - preIdx
            stack.append(i) 
        return res
```

##  126. <a name='-1'></a>61. Rotate List

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV14y4y1r728?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV117411L7UG?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1jK411N7e6?spm_id_from=333.999.0.0)

[æ´›é˜³](https://www.bilibili.com/video/BV1Xk4y1d7gF?spm_id_from=333.999.0.0)

```py
# python è§£æ³• æ€è·¯ï¼šå…ˆæŠŠé“¾è¡¨é¦–å°¾ç›¸è¿ï¼Œå†æ‰¾åˆ°ä½ç½®æ–­å¼€å¾ªç¯
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # æ˜“é”™ç‚¹ï¼šè¦æ’é™¤ä¸€äº›ç‰¹æ®Šæƒ…å†µ
        if not head or not head.next:
            return head
            
        cur = head
        nodeNum = 1
        # é“¾æ¥æˆä¸€ä¸ªç¯
        while cur.next:
            cur = cur.next
            nodeNum += 1
        cur.next = head


        # cur æŒ‡é’ˆæŒ‡å‘å¼€å¤´
        cur = cur.next
        # è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 2
        # è¾“å‡ºï¼š[4,5,1,2,3]
        # steps åˆ°è¾¾ new head çš„å‰ä¸€ä¸ª nodeï¼Œå°±æ˜¯ 3ï¼Œsteps = 5-2-1
        steps = nodeNum - k % nodeNum - 1
        for _ in range(steps):
            cur = cur.next


        res = cur.next
        cur.next = None
        return res
```

##  127. <a name='Offer62.'></a>å‰‘æŒ‡ Offer 62. åœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°å­—

```py
https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/

0ä¸ªäººæ—¶å€™æ¸¸æˆå°±ä¸å­˜åœ¨äº†ï¼Œ 1ä¸ªäººæ—¶å€™ç›´æ¥è·èƒœï¼Œ 
 
åæ¨å…¬å¼ï¼š

f(n,m) = (f(n,m) + m) % i #iä¸ºå½“å‰äººæ•°

f(8,3) = [f(7,3) + 3] % 8

çº¦ç‘Ÿå¤«ç¯

class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        res = 0
        for i in range(2, n + 1):
            res = (res + m) % i
        return res
```

##  128. <a name='Offer51.'></a>å‰‘æŒ‡ Offer 51. æ•°ç»„ä¸­çš„é€†åºå¯¹

```py
å¦‚æœå‰é¢ä¸€ä¸ªæ•°å­—å¤§äºåé¢çš„æ•°å­—ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªé€†åºå¯¹ï¼š
è¾“å…¥: [7,5,6,4]
è¾“å‡º: 5
class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        q = []
        res = 0
        for v in nums:
            # å˜è´Ÿæ•°æ’å…¥ï¼Œç»äº†-vï¼Œæ„æˆé€’å¢åºåˆ—
            i = bisect.bisect_left(q,-v) # bisect_left è¿”å›çš„å¾…æ’å…¥ä½ç½®åˆ†åˆ«æ˜¯ 0ï¼Œ1ï¼Œ1ï¼Œ3ï¼Œ
            res += i # å‰é¢æœ‰å¤šå°‘ä¸ªæ¯”å®ƒå¤§çš„ï¼Œå½“å‰æ•°å°±æœ‰å¤šå°‘ä¸ªé€†åºå¯¹,åŠ èµ·æ¥å°±æ˜¯é€†åºå¯¹æ€»æ•° 5
            q[i:i] = [-v]
            # è¿™é‡Œä¹Ÿå¯ä»¥å†™ï¼šq.insert(i, -v)
        return res
# q[i:i] = [-v] çš„æ•ˆæœå¦‚ä¸‹ï¼Œæ˜¯ä¸€ä¸ªæ’å¥½åºçš„æ•°ç»„ï¼š
# [-7]
# [-7, -5]
# [-7, -6, -5]
# [-7, -6, -5, -4]

å¦‚æœä¸ç”¨è´Ÿæ•°ï¼Œå°±è¦ç”¨ res += len(q) - i äº†ï¼Œ

å¹¶ä¸”è¦æ”¹ç”¨ i = bisect.bisect(q, v)ã€‚

```

##  129. <a name='K-1'></a>560. ã€å‰ç¼€å’ŒğŸ¨ã€‘Subarray Sum Equals K å’Œä¸ºKçš„å­æ•°ç»„

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1XW411d71i?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1d54y127ri?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1vK4y1k7ku?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV13t4y1y7ya?spm_id_from=333.999.0.0)

```py
æŸ¥è¡¨æ³•ï¼š
class Solution:
    def subarraySum(self, nums: 'List[int]', target: 'int') -> 'int':
        sums, res, dic = 0, 0, {}
        dic[0] = 1
        for i in range(len(nums)):
            sums += nums[i]
            if sums - target in dic:
                res += dic[sums - target]
                # sums - target å°±æ˜¯å‰ç¼€å’Œ
            if sums not in dic:
                dic[sums] = 0
            dic[sums] += 1
        # è¾“å…¥ï¼šnums = [1,2,3], k = 3
        # è¾“å‡ºï¼š2
        # -1000 <= nums[i] <= 1000 æ³¨æ„: nums æœ‰æ­£è´Ÿ
        # {0:1, 1:1}
        # {0:1, 1:1, 3:1}
        # {0:1, 1:1, 3:1, 6:1}
        return res
```


##  130. <a name='Powxn'></a>50 Pow(x, n)

[å°æ˜](https://www.bilibili.com/video/BV1W54y1q7CV?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Ai4y147kr?spm_id_from=333.999.0.0)

```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        res = 1

        if n < 0:
            x = 1 / x
            n = - n

        # ç±»ä¼¼2åˆ†ï¼Œé€Ÿåº¦æ›´å¿«
        while n > 0:
            if n % 2 == 1:
                res *= x # æ³¨æ„: res è¿™é‡Œ, å‘ç”Ÿå˜åŒ–
            n >>= 1 # ç­‰ä»·äº n //= 2
            x *= x       # æ³¨æ„: x è¿™é‡Œ, å‘ç”Ÿå˜åŒ–
        return res
```

```scala

/**
* recursive version : bottom-up
* memo
*   1. n may be negative or positive
*   2. n may be odd or even
* O(logN) in time
*/
object Solution1 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) 1
    else if(n > 0) {
      n % 2 match{
        case 1 => myPow(x * x, n / 2) * x
        case 0 => myPow(x * x, n / 2)
      }
    }else{
      val t = myPow(x, n / 2)
      math.abs(n % 2) match{
        case 1 => t * t * (1 / x)
        case 0 => t * t
      }
    }

  }
}

/**
* top-down - iterative version 
* Binary Exponentiation with negative n
*
* each iteration is calculate pow(base, nn) * ans
*   ex: input x = 2, n = 10
*    0. base: 2.0, nn: 10 ans: 1.0 => pow(2, 10) * 1 =  1024
*    1. base: 4.0, nn: 5, ans: 1.0  => pow(4, 5) * 1 = 1024
*    2. base: 16.0, nn: 2, ans: 4.0 => pow(16, 2) * 4 = 1024
*    3. base: 256.0, nn: 1, ans: 4.0 => pow(256, 1) * 4 = 1024
*    4. base: 65536.0, nn: 0, ans: 1024.0 => pow(65536, 0) * 1024 = 1024
*
* time complexity: O(logN)
*/

object Solution2 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) return 1
    var ans = 1.0
    var nn = n
    var base = x

    while (nn != 0) {
     /* nn could be -1 if nn < 0 and run nn % 2, so using nn & 1 here */
      if((nn & 1) == 1)  ans = ans * base
      nn = nn / 2
      base = base * base
    }
    // judge n to decide whether reverse ans
    if (n < 0) 1.0 / ans else ans  
  }
}

```

##  131. <a name='2.'></a>è¡¥å……é¢˜2. åœ†ç¯å›åŸç‚¹é—®é¢˜

```s
åœ†ç¯ä¸Šæœ‰ 10 ä¸ªç‚¹ï¼Œç¼–å·ä¸º 0 ~ 9ã€‚
ä»`0ç‚¹`å‡ºå‘ï¼Œæ¯æ¬¡å¯ä»¥`é€†æ—¶é’ˆ`å’Œ`é¡ºæ—¶é’ˆ`èµ°ä¸€æ­¥ï¼Œé—®èµ°`næ­¥`å›åˆ°`0ç‚¹`å…±æœ‰å¤šå°‘ç§èµ°æ³•ã€‚

è¾“å…¥: 2
è¾“å‡º: 2
è§£é‡Šï¼šæœ‰ 2 ç§æ–¹æ¡ˆã€‚åˆ†åˆ«æ˜¯ 0->1->0 å’Œ 0->9->0
```

```py
# èµ°næ­¥åˆ°0çš„æ–¹æ¡ˆæ•° = èµ°n-1æ­¥åˆ°1çš„æ–¹æ¡ˆæ•° + èµ°n-1æ­¥åˆ°9çš„æ–¹æ¡ˆæ•°ã€‚
# å…¬å¼ä¹‹æ‰€ä»¥å–ä½™æ˜¯å› ä¸º j-1 æˆ– j+1 å¯èƒ½ä¼šè¶…è¿‡åœ†ç¯ 0~9 çš„èŒƒå›´
class Solution:
    def backToOrigin(self,n):
        # ç‚¹çš„ä¸ªæ•°ä¸º10
        circle = 10
        dp = [[0 for site in range(circle)] for step in range(n + 1)]
        dp[0][0] = 1
        for step in range(1, n + 1):
            for site in range(circle):
                # dp[i][j]è¡¨ç¤ºä»0å‡ºå‘ï¼Œèµ°iæ­¥åˆ°jçš„æ–¹æ¡ˆæ•°
                # ps:å…¬å¼ä¹‹æ‰€ä»¥`å–ä½™`æ˜¯å› ä¸º j-1 æˆ– j+1 å¯èƒ½ä¼šè¶…è¿‡åœ†ç¯ 0~9 çš„èŒƒå›´
                dp[step][site] = dp[step-1][(site-1+circle)%circle] + dp[step-1][(site+1)%circle]
        return dp[n][0]
```

##  132. <a name='-1'></a>225-ã€æ„é€ ğŸ°ã€‘Implement Stack using Queues

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1p741177pK?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1ep4y1Y77j?spm_id_from=333.999.0.0)

```py
class MyStack:

    def __init__(self):
        self.queue = collections.deque()


    def push(self, x: int) -> None:
        n = len(self.queue)
        self.queue.append(x)
        for _ in range(n):
            self.queue.append(self.queue.popleft())


    def pop(self) -> int:
        return self.queue.popleft()


    def top(self) -> int:
        return self.queue[0]


    def empty(self) -> bool:
        return not self.queue
```

ä»¥ä¸‹ä¸¤ç§å†™æ³•ï¼Œé€Ÿåº¦æ›´å¿«ä¸€ç‚¹ç‚¹ï¼Œä½†æ˜¯å†™æ³•å¤æ‚

```py
q2å½“ä½œç¼“å­˜é˜Ÿåˆ—

class MyStack:

    def __init__(self):
        # q1å’Œq2æ˜¯ä¸¤ä¸ªé˜Ÿåˆ—
        ## ä¿è¯q1å½“ä¸­æ°¸è¿œæœ‰å…ƒç´ 
        ## ä¿è¯q2å½“ä¸­æ°¸è¿œæ²¡æœ‰å…ƒç´ 
        self.q1 = deque([])
        self.q2 = deque([])

    def push(self, x: int) -> None:
        self.q1.append(x)
        
    def pop(self) -> int:
        while len(self.q1) > 1:
            self.q2.append(self.q1.popleft())
        self.q1,self.q2 = self.q2, self.q1
        return self.q2.popleft()
        
        
    def top(self) -> int:
        return self.q1[-1]

    def empty(self) -> bool:
        return not self.q1

```

```scala
/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */


/**
* chosen solution
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack0() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}




 /**
 * my first commit
 * two queue version
 * time complexity: 
 *   push: O(1)
 *   pop: O(2n - 1)  n is the element in queue1
 *   top: O(2n - 1)
 */
class MyStack1() {

    /** Initialize your data structure here. */
    var queue1 = scala.collection.mutable.Queue[Int]()
    var queue2 = scala.collection.mutable.Queue[Int]()

    /** Push element x onto stack. */
    def push(x: Int) {
        queue1.enqueue(x)
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
       }
    
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        ret
        
    }

    /** Get the top element. */
    def top(): Int = {
        while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
        }
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        queue1.enqueue(ret)
        ret
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty && queue2.isEmpty
    }

}

```

##  133. <a name='K-1'></a>230 Kth Smallest Element in a B - è§ å‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹

[å°æ˜](https://www.bilibili.com/video/BV1ha4y1i7dZ?spm_id_from=333.999.0.0)

```py
# ä¸­åºéå†
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        def appendAllLeft(node):
            while node:
                stack.append(node)
                node = node.left

        stack, res = [], []
        appendAllLeft(root)
        while stack:
            node = stack.pop()
            k -= 1
            if k == 0:
                return node.val
            appendAllLeft(node.right)

kthLargest:
class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        def inorder(root):
            if not root: return
            inorder(root.right)
            self.k -= 1
            if self.k == 0: 
                self.res = root.val
                return
            inorder(root.left)

        self.k = k
        inorder(root)
        return self.res

kthSmallest:
class Solution:
    def kthSmallest(self, root, k: int) -> int:
        def dfs(root):
            if not root:
                return

            dfs(root.left)
            self.k -= 1
            if self.k == 0: 
                self.res = root.val
                return
            dfs(root.right)

        self.k = k
        dfs(root)
        return self.res
```


```scala
/**
* my first commit
* inorder iterative template
* time complexity: O(H + K) => H is tree height, H + K = element in stack
*/

object Solution1 {
    def kthSmallest(root: TreeNode, k: Int): Int = {
        
        val stack = collection.mutable.Stack[TreeNode]()
        var node = root
        var counter = 0
        
        
        while(node != null || stack.nonEmpty) {
            while(node != null) {
                stack push node
                node = node.left
            }
            node = stack.pop
            counter += 1
            if(counter == k) return node.value
            else node = node.right
            
        }
        -1
    }
}

/**
* inorder traversal - recursive version
* time complexity: O(H + k)
*/

object Solution2-1 {
    import scala.collection.mutable
    def kthSmallest(root: TreeNode, k: Int): Int = {
        val ret = _kthSmallest(root, k, mutable.ListBuffer.empty)

        ret(k - 1)
    }
    
    def _kthSmallest(node: TreeNode, k:Int, l: mutable.ListBuffer[Int]): mutable.ListBuffer[Int]  = {
       if(node == null) l
       else {
           _kthSmallest(node.left, k, l)
           l += node.value
           if(l.size >= k) l  // shortcut
           else  _kthSmallest(node.right, k, l)  
       }
    }
}



```

##  134. <a name='-1'></a>75. Sort Colors

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1rE411n7mL?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1ua4y1v7yd?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1tz4y1o7n5?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5l1bfbznzwc0.png)

```py
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        idx, left, right = 0, 0, len(nums) - 1
        while idx <= right:
            if nums[idx] == 2 and idx < right:
                nums[idx], nums[right] = nums[right], 2
                right -= 1
            elif nums[idx] == 0 and idx > left:
                nums[idx], nums[left] = nums[left], 0
                left += 1
            else:
                idx += 1
```

##  135. <a name='II-1'></a>47 - â˜… å…¨æ’åˆ— II-å‰ªæç‰ˆ

ç±»ä¼¼é¢˜ç›®ï¼š

https://leetcode-cn.com/problems/permutation-ii-lcci/

```py
class Solution:
    def permutation(self, S: str) -> List[str]:
        res = []
        S = sorted(S)
        def backtrack(S,path):
            if not S:
                res.append(path)
            else:
                for i in range(len(S)):
                    if i > 0 and S[i] == S[i-1]:  # å‰ªæ
                        continue
                    backtrack(S[:i] + S[i+1:],path + S[i])

        backtrack(S,'')
        return res
```

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Ev411672A?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1qK4y1x7Qs?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1z54y1a7rQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        def backtrack(nums,path):
            if not nums:
                res.append(path[:])
            else:
                for i in range(len(nums)):
                    if i > 0 and nums[i] == nums[i-1]: # å‰ªæ
                        continue
                    backtrack(nums[:i] + nums[i+1:],path + [nums[i]])

        backtrack(nums,[])
        return res
```

##  136. <a name='-1'></a>11. Container With Most Water 

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1CW41167qB?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7Gn?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1A5411E7oM?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1TK41157jH?spm_id_from=333.999.0.0)

æš´åŠ›è§£æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(n2)

* æ—¶é—´å¤æ‚åº¦:O(1)

åŒæŒ‡é’ˆæ³•ï¼š

ç”±äºç››æ°´é¢ç§¯ç”±è¾ƒçŸ­è¾¹æ§åˆ¶ï¼Œæ‰€ä»¥ï¼ŒæŒ‡é’ˆæ”¾åœ¨ä¸¤ç«¯ï¼Œæ¯æ¬¡åªç§»åŠ¨è¾ƒçŸ­è¾¹ã€‚å› ä¸ºï¼Œç§»åŠ¨è¾ƒé•¿è¾¹çš„è¯ã€‚ä¸€å®šä»ç„¶æ˜¯ä¸å˜çš„ã€‚

* æ—¶é—´å¤æ‚åº¦:O(n)

* æ—¶é—´å¤æ‚åº¦:O(1)

```py
# è¿™ä¸ªå†™èµ·æ¥è¶…çº§ç®€å•ï¼
# NO BUG
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        maxRes = res = 0
        while left < right:
            res = (right - left) * min(height[left], height[right])
            if height[left] < height[right]:
                # ç”±äºçŸ­æ¿æ•ˆåº”ï¼Œåªéœ€è¦ç§»åŠ¨çŸ­æ¿å³å¯
                left += 1
            else:
                right -= 1
            maxRes = max(maxRes,res)
        return maxRes
```

```scala

/**
* two pointer version
* memo
*  1. fix left side,, the volume is bounded by left side if left side is shorter 
*  2. fix right side. the volume is bounded by right side if right side is shorter
*/

object Solution2 {
    def maxArea(height: Array[Int]): Int = {
      
      var left = 0
      var right = height.length - 1
      var volume = 0
      
      while(left < right) {
        val current = (right - left) * (height(right) min height(left))
        volume = volume max current
        
        if (height(left) < height(right)) // left is shorter
          left += 1
        else // right is shorter
          right -= 1
      }
      volume
    }
         
}

```

##  137. <a name='-1'></a>139 ã€åŠ¨æ€ğŸš€è§„åˆ’ + èƒŒåŒ…ã€‘Word Break

[å°æ˜](https://www.bilibili.com/video/BV1p54y1k7vf?spm_id_from=333.999.0.0)

```py
# python åŠ¨æ€ğŸš€è§„åˆ’

# ä» i = 0 å¼€å§‹åˆ†æï¼ši = 0ï¼Œ éå† j in range(1, n+1)ï¼Œ 

# å³éå†æ‰€æœ‰ä»¥ s[0] å¼€å¤´çš„ç»„åˆï¼ŒæŠŠç¬¬ä¸€ä¸ªå•è¯å¯èƒ½çš„æƒ…å†µå…¨éƒ¨æ‰¾å‡ºæ¥ã€‚

# æ­¤æ—¶ç›¸å½“äºæŠŠæ‰“å¤´çš„å•è¯å¯èƒ½çš„æƒ…å†µå…¨éƒ¨æ‰¾å‡ºæ¥äº†ã€‚

# ç„¶ååŸºäºç¬¬ä¸€ä¸ªå•è¯ä¸€ä¸ªå•è¯ä¸€ä¸ªå•è¯åœ°æ¥ä¸Šå»ã€‚

class Solution:
    def wordBreak(self, s, wordDict):
        n = len(s) 
        dp = [True] + [False]*n

        for end in range(1, n + 1):
            for start in range(end):
                if dp[start] and s[start: end] in wordDict:
                    dp[end] = True # è¯´æ˜s[: i] åœ¨wordDictä¸­
                    break # ä¼˜åŒ–éƒ¨åˆ†ï¼šå‰©ä¸‹çš„åˆ‡åˆ†ç‚¹jä¸ç”¨å†å¯»æ‰¾äº†ï¼Œä¹Ÿå¯ä»¥ä¸å†™ï¼Œåƒä¸‹æ–¹ä¸€æ ·
        return dp[-1]

```

##  138. <a name='-1'></a>125 ã€å›æ–‡ğŸŒˆã€‘Valid Palindrome

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1d7411n7cF?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Qb411e7ML?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV17h411Z7ey?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

isalnum() æ–¹æ³•æ£€æµ‹å­—ç¬¦ä¸²æ˜¯å¦ç”±å­—æ¯å’Œæ•°å­—ç»„æˆã€‚

isalpha() æ–¹æ³•æ£€æµ‹å­—ç¬¦ä¸²æ˜¯å¦åªç”±å­—æ¯ç»„æˆã€‚

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s) - 1
        while left < right:
            # æ˜“é”™ç‚¹ï¼šif not s[left].isalnum(): æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸ºå­˜åœ¨è¿ç»­å¤šä¸ªâ€œéæ•°å­—çš„æƒ…å†µâ€
            while left < right and not s[left].isalnum(): 
                left += 1
            while left < right and not s[right].isalnum(): 
                right -= 1
            if s[left].lower() == s[right].lower():
                left += 1
                right -= 1
            else:
                return False
        return True
```

pythonç‰›é€¼çš„ä¸€è¡Œä»£ç ï¼š

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        sgood = "".join(ch.lower() for ch in s if ch.isalnum())
        return sgood == sgood[::-1]

class Solution:
    def isPalindrome(self, s):
        s = ''.join(filter(str.isalnum,s)).lower()
        return s==s[::-1]
```


```scala
/**
* two pointer comparison
* memo
*  1. alphanumeric = letters + numerals
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def isPalindrome(s: String): Boolean = {
      val newString = s.filter(_.isLetterOrDigit).toLowerCase
      isPalindrome(newString, 0, newString.length - 1)
    }
    @annotation.tailrec
    def isPalindrome(s: String, left: Int, right: Int): Boolean = {
      if (left > right) return true
      if (s(left) == s(right)) isPalindrome(s, left + 1, right - 1)
      else false
    }
}
```



##  139. <a name='-1'></a>189. Rotate Array 

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Yb411H7Yy?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1N541177Bk?spm_id_from=333.999.0.0)

```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        r = k % len(nums)
        if r:
            nums[:] = nums[::-1]
            nums[:r] = nums[:r][::-1]
            nums[r:] = nums[r:][::-1]
```

# 8 day (å¾—åˆ† = 3åˆ†) 81

##  141. <a name='-1'></a>74 Search a 2D Matrix

[å°æ˜](https://www.bilibili.com/video/BV1aK4y1h7Bb?spm_id_from=333.999.0.0)

```py
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix)
        n = len(matrix[0])
        l = 0
        r = m*n-1
        while l <= r:
            mid = (l + r) // 2
            midRow = mid // n
            midCol = mid % n
            if matrix[midRow][midCol] == target:
                return True
            elif matrix[midRow][midCol] > target:
                r = mid - 1 # æ˜“é”™ç‚¹ï¼š+1,-1ä¸è¦å†™åäº†
            else:
                l = mid + 1
        return False
```

##  142. <a name='-1'></a>287 Find the Duplicate Number

[å°æ˜](https://www.bilibili.com/video/BV1Ug4y1v7mF?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Pz4y1X7qR?spm_id_from=333.999.0.0)

```py
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        #æ•°ç»„åªèƒ½è¯» æ‰€ä»¥ä¸èƒ½æ’åº,ä¸èƒ½swapæ•°ç»„ä¸‹æ ‡
        #æ—¶é—´å¤æ‚åº¦å°äº O(n^2) ä¸èƒ½æš´åŠ›
        #ç©ºé—´å¤æ‚åº¦ O(1) ä¸èƒ½é¢å¤–å¼€è¾Ÿæ•°ç»„
        
        ''' 1ã€æš´åŠ›ä¸ç¬¦åˆé¢˜æ„
        for i in nums:
            count = 0
            for num in nums:
                if num == i:
                    count += 1
            if count > 1:
                return i
        return -1
        '''
        
        '''2ã€å°äºO(n^2) äºŒåˆ†æŸ¥æ‰¾
        æˆ‘ä»¬ä¸è¦è€ƒè™‘æ•°ç»„,åªéœ€è¦è€ƒè™‘ æ•°å­—éƒ½åœ¨ 1 åˆ° n ä¹‹é—´
        ç¤ºä¾‹ 1:
        arr = [1,3,4,2,2] æ­¤æ—¶æ•°å­—åœ¨ 1 â€” 5 ä¹‹é—´

        mid = (1 + 5) / 2 = 3 arrå°äºç­‰äºçš„3æœ‰4ä¸ª(1,2,2,3)ï¼Œ1åˆ°3ä¸­è‚¯å®šæœ‰é‡å¤çš„å€¼
        mid = (1 + 3) / 2 = 2 arrå°äºç­‰äºçš„2æœ‰3ä¸ª(1,2,2)ï¼Œ1åˆ°2ä¸­è‚¯å®šæœ‰é‡å¤çš„å€¼
        mid = (1 + 2) / 2 = 1 arrå°äºç­‰äºçš„1æœ‰1ä¸ª(1)ï¼Œ2åˆ°2ä¸­è‚¯å®šæœ‰é‡å¤çš„å€¼
        æ‰€ä»¥é‡å¤çš„æ•°æ˜¯ 2 
        '''
        left = 1
        right = len(nums)
        while left < right:
            mid = int(left + (right - left)/2)
            cnt = 0
            for num in nums:
                if num <= mid:
                   cnt += 1
            if cnt <= mid:
                left = mid + 1
            else:
                right = mid
        return right

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        low, high = 1, len(nums) - 1
        while low <= high:
            mid = (low + high) >> 1
            cnt = sum(x <= mid for x in nums)
            if cnt > mid:
                high = mid - 1
            else:
                low = mid + 1

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = {}
        # dic = dict()
        for n in nums:
            dic[n] = dic.get(n, 0) + 1
            print(dic)
            if dic[n] >= 2:
                return n
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        print(set(nums))
        return (sum(nums)-sum(set(nums)))//(len(nums) - len(set(nums)))
```

##  143. <a name='-1'></a>384. æ‰“ä¹±æ•°ç»„

https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode-solution-og5u/

```py
class Solution:
    def __init__(self, nums: List[int]):
        self.nums = nums
        self.original = nums.copy()

    def reset(self) -> List[int]:
        self.nums = self.original.copy()
        return self.nums

    def shuffle(self) -> List[int]:
        shuffled = [0] * len(self.nums)
        for i in range(len(self.nums)):
            j = random.randrange(len(self.nums))
            shuffled[i] = self.nums.pop(j)
        self.nums = shuffled
        return self.nums

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode-solution-og5u/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def __init__(self, nums: List[int]):
        self.nums = nums
        self.original = nums.copy()

    def reset(self) -> List[int]:
        self.nums = self.original.copy()
        return self.nums

    def shuffle(self) -> List[int]:
        for i in range(len(self.nums)):
            j = random.randrange(i, len(self.nums))
            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]
        return self.nums

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode-solution-og5u/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

é¢˜ç›®å¯æ²¡ä¸è®©æˆ‘ç”¨random.shuffleå•Šï¼ˆç‹—å¤´

class Solution:

    def __init__(self, nums: List[int]):
        self.arr1 = nums


    def reset(self) -> List[int]:
        return self.arr1


    def shuffle(self) -> List[int]:
        shuffArr = self.arr1.copy()
        random.shuffle(shuffArr)
        return shuffArr


# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.reset()
# param_2 = obj.shuffle()

æ·±æµ…æ‹·è´åˆ’é‡ç‚¹ï¼ŒææŒ‡ä¸€ç®—é¢è¯•å¿…è€ƒ

class Solution:

    def __init__(self, nums: List[int]):
        self.nums = nums


    def reset(self) -> List[int]:
        return self.nums


    def shuffle(self) -> List[int]:
        from copy import deepcopy
        tmp = deepcopy(self.nums)
        shuffle(tmp)
        return tmp

ä½¿ç”¨random.shuffleéšæœºæ‰“ä¹±åˆ—è¡¨ï¼Œæ‰§è¡Œç”¨æ—¶ï¼š136 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†90.63%çš„ç”¨æˆ·
class Solution:
    def __init__(self, nums: List[int]):
        self._initnums=nums

    def reset(self) -> List[int]:
        return self._initnums

    def shuffle(self) -> List[int]:
        nums = list(self._initnums)
        random.shuffle(nums)
        return nums

from random import random
class Solution:

    def __init__(self, nums: [int]):
        self.nums = nums

    def reset(self) -> [int]:
        return self.nums

    def shuffle(self) -> [int]:
        return sorted(self.nums, key=lambda k: random())
```

##  144. <a name='-1'></a>329. ã€åŠ¨æ€ğŸš€è§„åˆ’ + dfsã€‘Longest Increasing Path in a Matrix

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1mW411d7q8?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1VK4y1K7SX?spm_id_from=333.999.0.0)

åŠ¨æ€ğŸš€è§„åˆ’

```py
å…ˆé¢„å¤„ç†ï¼Œå¯¹çŸ©é˜µçš„å€¼æŒ‰ä»å°åˆ°å¤§æ’åºï¼ŒæŒ‰å¤§å°é¡ºåºæ‰èƒ½ä¿è¯ä¾èµ–çš„å­é—®é¢˜éƒ½æ±‚è§£è¿‡äº†

dp[i][j]è¡¨ç¤ºä»¥matrix[i][j]ç»“å°¾çš„æœ€é•¿é€’å¢é•¿åº¦

åˆå§‹dp[i][j]éƒ½ç­‰äº1
è‹¥matrix[i][j]å››ä¸ªæ–¹å‘æœ‰ä»»æ„å°äºå®ƒï¼Œåˆ™å¯ä»¥æ›´æ–°dp[i][j] = max(dp[i][j], 1 + dp[r][c])

class Solution(object):
    def longestIncreasingPath(self, matrix):
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        lst = []
        for i in range(m):
            for j in range(n):
                lst.append((matrix[i][j], i, j))
        lst.sort()
        dp = [[0 for _ in range(n)] for _ in range(m)]
        for num, i, j in lst:
            dp[i][j] = 1
            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                r, c = i + di, j + dj
                if 0 <= r < m and 0 <= c < n:
                    if matrix[i][j] > matrix[r][c]:
                        dp[i][j] = max(dp[i][j], 1 + dp[r][c])
        return max([dp[i][j] for i in range(m) for j in range(n)])
```

```py
class Solution:
    
    DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        @lru_cache(None)
        def dfs(row: int, column: int) -> int:
            best = 1
            for dx, dy in Solution.DIRS:
                newRow, newColumn = row + dx, column + dy
                if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] > matrix[row][column]:
                    best = max(best, dfs(newRow, newColumn) + 1)
            return best

        ans = 0
        rows, columns = len(matrix), len(matrix[0])
        for i in range(rows):
            for j in range(columns):
                ans = max(ans, dfs(i, j))
        return ans


class Solution:

    DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        rows, columns = len(matrix), len(matrix[0])
        outdegrees = [[0] * columns for _ in range(rows)]
        queue = collections.deque()
        for i in range(rows):
            for j in range(columns):
                for dx, dy in Solution.DIRS:
                    newRow, newColumn = i + dx, j + dy
                    if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] > matrix[i][j]:
                        outdegrees[i][j] += 1
                if outdegrees[i][j] == 0:
                    queue.append((i, j))

        ans = 0
        while queue:
            ans += 1
            size = len(queue)
            for _ in range(size):
                row, column = queue.popleft()
                for dx, dy in Solution.DIRS:
                    newRow, newColumn = row + dx, column + dy
                    if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] < matrix[row][column]:
                        outdegrees[newRow][newColumn] -= 1
                        if outdegrees[newRow][newColumn] == 0:
                            queue.append((newRow, newColumn))
        
        return ans






```

```py
æ–¹æ³•ä¸€ï¼šä»£ç æ¸…æ™°

æ–¹æ³•äºŒï¼šæ•ˆç‡æœ€é«˜

æ–¹æ³•ä¸‰ï¼šä»£ç ç®€æ´

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]: return 0

        row = len(matrix)
        col = len(matrix[0])
        lookup = [[0] * col for _ in range(row)]

        def dfs(i, j):
            if lookup[i][j] != 0:
                return lookup[i][j]
            # æ–¹æ³•ä¸€
            res = 1
            for x, y in [[-1, 0], [1, 0], [0, 1], [0, -1]]:
                tmp_i = x + i
                tmp_j = y + j
                if 0 <= tmp_i < row and 0 <= tmp_j < col and \
                        matrix[tmp_i][tmp_j] > matrix[i][j]:
                    res = max(res, 1 + dfs(tmp_i, tmp_j))
            lookup[i][j] = max(res, lookup[i][j])
            # æ–¹æ³•äºŒ
            # val = matrix[i][j]
            # lookup[i][j] = 1 + max(
            #     dfs(i + 1, j) if 0 <= i + 1 < row and 0 <= j < col and matrix[i + 1][j] > val else 0,
            #     dfs(i - 1, j) if 0 <= i - 1 < row and 0 <= j < col and matrix[i - 1][j] > val else 0,
            #     dfs(i, j + 1) if 0 <= i < row and 0 <= j + 1 < col and matrix[i][j + 1] > val else 0,
            #     dfs(i, j - 1) if 0 <= i < row and 0 <= j - 1 < col and matrix[i][j - 1] > val else 0,
            # )
            # æ–¹æ³•ä¸‰
            # lookup[i][j] = 1 + max(
            #     [dfs(i + x, y + j) for x, y in [[-1, 0], [1, 0], [0, 1], [0, -1]] \
            #      if 0 <= (i + x) < row and 0 <= (j + y) < col and matrix[i + x][j + y] > matrix[i][j]] or [0]
            # )
            
            return lookup[i][j]

        return max(dfs(i, j) for i in range(row) for j in range(col))
```

##  145. <a name='-1'></a>349. Intersection of Two Arrays

https://leetcode-cn.com/problems/intersection-of-two-arrays/

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1zx411o7i1?spm_id_from=333.999.0.0)

```py
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1 = set(nums1)
        set2 = set(nums2)
        return self.set_intersection(set1, set2)

    def set_intersection(self, set1, set2):
        if len(set1) > len(set2):
            return self.set_intersection(set2, set1)
        return [x for x in set1 if x in set2]

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/intersection-of-two-arrays/solution/liang-ge-shu-zu-de-jiao-ji-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        length1, length2 = len(nums1), len(nums2)
        intersection = list()
        index1 = index2 = 0
        while index1 < length1 and index2 < length2:
            num1 = nums1[index1]
            num2 = nums2[index2]
            if num1 == num2:
                # ä¿è¯åŠ å…¥å…ƒç´ çš„å”¯ä¸€æ€§
                if not intersection or num1 != intersection[-1]:
                    intersection.append(num1)
                index1 += 1
                index2 += 1
            elif num1 < num2:
                index1 += 1
            else:
                index2 += 1
        return intersection

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/intersection-of-two-arrays/solution/liang-ge-shu-zu-de-jiao-ji-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        return list(set(nums1) & set(nums2))

```

##  146. <a name='-1'></a>26-Remove duplicates from sorted array

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1UJ411m7Pz?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1hb411i77e?spm_id_from=333.999.0.0)

[å›¾çµ](https://www.bilibili.com/video/BV13V41177Mq?spm_id_from=333.999.0.0)

> forå¾ªç¯æ³•ï¼š

```py
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        if n == 0: return 0
        left = 0
        for right in range(1, n):
            if nums[right] != nums[left]:
                left += 1
                nums[left] = nums[right]
        return left + 1

# ğŸ˜æˆ‘çš„æ¨¡ä»¿
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        count = 0 #æ³¨æ„ï¼šcountæ˜¯ä»0å¼€å§‹çš„
        for i in range(len(nums)):
            if nums[i] != nums[count]:
                count += 1
                nums[count] = nums[i]
        return count + 1
```

##  147. <a name='II-1'></a>40. Combination Sum II 40-ç»„åˆæ€»å’Œ II

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Pb411u7Yd?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1gT4y1J7JE?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        candidates.sort()
        # candidates.reverse()
        def dfs(firstIdx):
            if sum(path) == target:
                res.append(path[:])
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    # æ˜“é”™ç‚¹ï¼šéœ€è¦å‰ªæ
                    if i > firstIdx and candidates[i] == candidates[i-1]: continue
                    # [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]ä¼šè¶…æ—¶
                    path.append(candidates[i])
                    dfs(i+1)
                    path.pop()
        dfs(0)
        return res
```

##  148. <a name='-1'></a>9-ã€å›æ–‡ğŸŒˆã€‘Palindrome

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1hJ411S7kt?spm_id_from=333.999.0.0)

[å°æ¢¦æƒ³å®¶](https://www.bilibili.com/video/BV1Jb411i7YG?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Af4y1m7kk?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        return True if str(x) == str(x)[::-1] else False
```

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False

        if x < 10:
            return True

        bkp = x
        res = 0

        while x != 0:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return bkp == res
```

ç¿»è½¬ä¸€åŠå­—ç¬¦æ³•ï¼š

* æ—¶é—´å¤æ‚åº¦:O(log10(n)), æ¯æ¬¡è¿­ä»£éƒ½ä¼šé™¤ä»¥10

* æ—¶é—´å¤æ‚åº¦:O(1)

ç»è¿‡å°è¯•ï¼Œè¿™ä¸ªæ–¹æ³•åœ¨è¾¹ç•Œå¤„ç†ä¸Šå®¹æ˜“å‡ºé”™ï¼Œä¸æ¨èã€‚

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 10 and x >= 0:
            return True

        if x < 0 or x % 10 == 0:
            return False

        res = 0

        # ç¿»è½¬ä¸€åŠå­—ç¬¦ä¸²

        while x > res:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return x == res or x == res//10
```

```scala
package lc009 {
  object Solution {
    def isPalindrome(x: Int): Boolean = {
      if (x<0) return false
      if (x==0) return true
      if (x%10==0) return false
      val y=x.toString.reverse
      return y==x.toString
    }
  }
}
```

##  150. <a name='Trie'></a>208. ã€æ„é€ ğŸ°ã€‘Implement Trie (Prefix Tree)

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Ut411a74P?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Zz4y1R7j8?spm_id_from=333.999.0.0)

```py
# ç®€å•ç‰ˆï¼šç›´æ¥ç”¨å­—å…¸

# å†™æ³•ä¸€ï¼š

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            r = r.setdefault(c, {})
        r['#'] = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r: return False
            r = r[c]
        return r.get("#", False)

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r: return False
            r = r[c]
        return True

# å†™æ³•äºŒï¼š

class Trie:

    def __init__(self):
        self.root = {}


    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            if not r.get(c):
                r[c] = {}
            r = r[c]
        r['end'] = True


    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            try:
                r = r[c]
            except:
                return False
        return 'end' in r


    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            try:
                r = r[c]
            except:
                return False
        return True

# å†™æ³•ä¸‰ï¼š

class Trie:

    def __init__(self):
        self.root = {}


    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            if c not in r:
                r[c] = {}
            r = r[c]
        r['end'] = True


    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r:
                return False
            r = r[c]
        return 'end' in r


    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r:
                return False
            r = r[c]
        return True
```

```scala
/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

/**
* chosen solution
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie0() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}



/**
* my first commitment
*/
case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
}

class Trie1() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach { c =>

      val cIdx = c.asDigit - 'a'.asDigit
      if (node.childNode(cIdx) == null) {
        node.childNode(cIdx) = Node()
      }
      node = node(cIdx)
    }
    node.isWord = true

  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    val node = searchUtil(word)

    node != null && node.isWord

  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix) != null
  }


   private def searchUtil(s: String): Node = {
    var node = root
    var continue = true
    for {
      c <- s
      if continue
    } {
      val cIdx = c.asDigit - 'a'.asDigit
      if (node(cIdx) == null) {
        continue = false
      } 
      node = node(cIdx)
    }
    node
  }
}


/**
*  more elegant
*  Node with apply and update
*/

case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
  
  def update(idx: Int, node: Node): Unit = {
    childNode(idx) = node
  }

  def update(c: Char, node: Node): Unit = {
    this.update(c.asDigit - 'a'.asDigit, node)
  }
}
class Trie1-2() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach {
      case c if node(c) == null => 
        node(c) = Node()
        node = node(c)

      case c => node = node(c)
    }
    node.isWord = true
      
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }


  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach {
      case c if node(c) != null => node = node(c)
      case _ => return None
    }
    Some(node)
  }
  def traversal(): Unit = {
    val result = scala.collection.mutable.ListBuffer[String]()

    def _traversal(prefix: String, node: Node): Unit = {
      if (node.isWord) {
        result += prefix
      }
      node.childNode.zipWithIndex.foreach {
        case (n, idx) if n != null => _traversal(prefix + ('a' + idx).toChar, n)
        case _ =>
      }

    }

    _traversal("", root)
    result.foreach(s => println(s.mkString("")))

  }

}

/**
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie2() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}
```

##  151. <a name='K-1'></a>440. å­—å…¸åºçš„ç¬¬Kå°æ•°å­—

https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/

```py
class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        def getCnt(prefix, n):
            cnt, cur, next = 0, prefix, prefix + 1
            while cur <= n:
                cnt += min(next, n + 1) - cur
                cur, next = cur * 10, next * 10
            return cnt
        
        poi, prefix = 1, 1
        while poi < k:
            cnt = getCnt(prefix, n)
            if poi + cnt > k:
                prefix *= 10
                poi += 1
            else:
                prefix += 1
                poi += cnt
        return prefix

## æ€è·¯:

åå‰æ ‘ï¼Œç”¨é¢˜ç›®çš„æµ‹è¯•ç”¨ä¾‹æ¥ä¸¾ä¾‹å­ã€‚

æˆ‘ä»¬æ±‚å­—å…¸åºç¬¬kä¸ªå°±æ˜¯ä¸Šå›¾å‰åºéå†è®¿é—®çš„ç¬¬kèŠ‚ç‚¹ï¼ä½†æ˜¯ä¸éœ€è¦ç”¨å‰åºéå†ï¼Œå¦‚æœæˆ‘ä»¬èƒ½é€šè¿‡æ•°å­¦æ–¹æ³•æ±‚å‡ºèŠ‚ç‚¹1å’ŒèŠ‚ç‚¹2ä¹‹é—´éœ€è¦èµ°å‡ æ­¥ï¼Œå‡å°‘å¾ˆå¤šæ²¡å¿…è¦çš„ç§»åŠ¨ã€‚

å…¶å®åªéœ€è¦**æŒ‰å±‚èŠ‚ç‚¹ä¸ªæ•°è®¡ç®—**å³å¯ï¼Œå›¾ä¸­èŠ‚ç‚¹1å’ŒèŠ‚ç‚¹2åœ¨ç¬¬äºŒå±‚ï¼Œå› ä¸ºn = 13ï¼ŒèŠ‚ç‚¹1å¯ä»¥ç§»åŠ¨åˆ°èŠ‚ç‚¹2ï¼ˆåŒä¸€å±‚ï¼‰æ‰€ä»¥åœ¨ç¬¬äºŒå±‚éœ€è¦ç§»åŠ¨1æ­¥ã€‚

ç¬¬ä¸‰å±‚ï¼Œç§»åŠ¨ä¸ªæ•°å°±æ˜¯ (13 - 10 + 1) = 4 ï¼ˆminï¼ˆ13 + 1ï¼Œ 20ï¼‰ - 10ï¼‰

æ‰€ä»¥èŠ‚ç‚¹1åˆ°èŠ‚ç‚¹2éœ€è¦ç§»åŠ¨ 1 + 4 = 5 æ­¥

å½“ç§»åŠ¨æ­¥æ•°å°äºç­‰äºkï¼Œè¯´æ˜éœ€è¦å‘å³èŠ‚ç‚¹ç§»åŠ¨ï¼Œå›¾ä¸­å°±æ˜¯èŠ‚ç‚¹1ç§»åŠ¨åˆ°èŠ‚ç‚¹2ã€‚

å½“ç§»åŠ¨æ­¥æ•°å¤§äºkï¼Œè¯´æ˜ç›®æ ‡å€¼åœ¨èŠ‚ç‚¹1å’ŒèŠ‚ç‚¹2ä¹‹é—´ï¼Œæˆ‘ä»¬è¦å‘ä¸‹ç§»åŠ¨ï¼å³ä»èŠ‚ç‚¹1ç§»åŠ¨åˆ°èŠ‚ç‚¹10ã€‚

## ä»£ç :

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        
        def cal_steps(n, n1, n2):
            step = 0
            while n1 <= n:
                step += min(n2, n + 1) - n1
                n1 *= 10
                n2 *= 10
            return step
                
        cur = 1
        k -= 1
        
        while k > 0:
            steps = cal_steps(n, cur, cur + 1)
            if steps <= k:
                k -= steps
                cur += 1
            else:
                k -= 1
                cur *= 10
        
        return cur

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        
        def cal_steps(n, n1, n2):
            step = 0
            while n1 <= n:
                step += min(n2, n + 1) - n1
                n1 *= 10
                n2 *= 10
            return step
                
        cur = 1
        k -= 1
        
        while k > 0:
            steps = cal_steps(n, cur, cur + 1)
            if steps <= k:
                k -= steps
                cur += 1
            else:
                k -= 1
                cur *= 10
        
        return cur

ä½œè€…ï¼špowcai
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/shi-cha-shu-by-powcai/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚


'''
æŠŠæ‰€æœ‰æ•°å­—æƒ³è±¡æˆå­—ç¬¦ä¸²ï¼Œç„¶åç”¨å‰ç¼€æ ‘å…ˆåºéå†çš„è§†è§’å»çœ‹ï¼Œéå†é¡ºåºå°±æ˜¯æ•°å€¼åœ¨å­—å…¸åºåºåˆ—ä¸­çš„
é¡ºåºï¼Œç”¨æ•°å­¦æ€»ç»“åŒä¸€å±‚ä¸¤ä¸ªèŠ‚ç‚¹é—´ç§»åŠ¨éœ€è¦çš„æ­¥æ•°ï¼Œå¦‚æœç´¯è®¡æ­¥æ•°æ²¡æœ‰è¶…è¿‡nå°±å³ç§»ï¼Œå¦åˆ™åªèƒ½
æ¶ˆè€—ä¸€ä¸ªæ­¥æ•°ï¼Œè¿›è¡Œä¸‹ç§»ï¼Œæœ€åç§»åŠ¨åˆ°åºåˆ—å·æ˜¯kçš„èŠ‚ç‚¹ï¼Œå³å¯å¾—å‡ºç­”æ¡ˆ
'''

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        # åŒä¸€å±‚çš„ä¸¤ä¸ªèŠ‚ç‚¹é—´ï¼Œç§»åŠ¨éœ€è¦çš„æ­¥æ•°
        def count_steps(val1, val2) -> int:
            # é€å±‚ç´¯åŠ æ­¥æ•°
            cnt = 0
            while val1 <= n:
                cnt += min(val2, n+1) - val1
                val1, val2 = val1 * 10, val2 * 10

            return cnt

        cur_val, idx = 1, 1
        while True:
            if idx == k:
                return cur_val

            steps = count_steps(cur_val, cur_val + 1)
            if idx + steps <= k:
                idx += steps
                cur_val = cur_val + 1
            else:
                idx += 1
                cur_val = cur_val * 10

ä½œè€…ï¼šhao-shou-bu-juan
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/python-10cha-qian-zhui-shu-shu-de-xian-xu-bian-li-/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

##  152. <a name='III'></a>123-ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1Xp4y1k7aD?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1rk4y117z8?spm_id_from=333.999.0.0)

```py
# æˆ‘çš„å†™æ³•ï¼š
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        profit1 = profit2 = 0
        buy1 = buy2 = prices[0]
        for i in range(1,n):
            # å®é™…ä¸Šï¼Œæ˜¯ä»å–å‡ºé‚£å¤©å¼€å§‹ç®—ï¼Œä¹Ÿå°±æ˜¯ç¬¬äºŒå¤©
            buy1 = min(buy1,prices[i])
            profit1 = max(profit1,prices[i]-buy1)
            buy2 = min(buy2,prices[i]-profit1)  # buy2[i]-profit1[i-1] ç›¸å½“äºä¸€ä¸ªè™šæ‹Ÿçš„ä¹°å…¥ä»·æ ¼
            profit2 = max(profit2,prices[i]-buy2)
        return profit2

## æœªè¿›è¡Œç©ºé—´ä¼˜åŒ–
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy1 = [0] * n
        sell1 = [0] * n
        buy2 = [0] * n
        sell2 = [0] * n
        buy1[0] = buy2[0] = -prices[0]
        sell1[0] = sell2[0] = 0
        for i in range(1, n):
            buy1[i]  = max(buy1[i-1], -prices[i]) 
            sell1[i] = max(sell1[i-1], buy1[i-1] + prices[i])
            buy2[i]  = max(buy2[i-1], sell1[i-1] - prices[i])
            sell2[i] = max(sell2[i-1], buy2[i-1] + prices[i])
        return sell2[-1]
```

```scala
object Solution3{
    def maxProfit(prices: Array[Int]): Int = {
        val r = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case (acc, px) =>
                val (buy1, sell1, buy2, sell2) = acc
                val newBuy1 = buy1 max - px
                val newSell1 =  sell1 max (buy1 + px)
                val newBuy2 = buy2 max (sell1 - px)
                val newSell2 = sell2 max (buy2 + px)
                (newBuy1, newSell1, newBuy2, newSell2)
        }
        r._2 max r._4
    }
}

object Solution3-1 {
    def maxProfit(prices: Array[Int]): Int = {
        val (buy1, sell1, buy2, sell2) = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case ((buy1, sell1, buy2, sell2), cost) =>
                (
                    buy1 max -cost,
                    sell1 max (buy1 + cost),
                    buy2 max (sell1 - cost),
                    sell2 max (buy2 + cost)
                )
        }
        sell1 max.sell2
    }
}
```

##  153. <a name='-1'></a>135. åˆ†å‘ç³–æœ

https://leetcode-cn.com/problems/candy/

```py
å…ˆç»™æ¯ä¸ªäººä¸€ä¸ªç³–ï¼Œåˆå§‹åŒ–tmpæ•°ç»„ä¸ºé¢å¤–ç³–æœã€‚ä»å·¦å‘å³éå†ï¼Œå¦‚æœi+1åˆ†æ•°é«˜ï¼Œtmp[i+1]=tmp[i]+1ã€‚å†ä»åå¾€å‰éå†ï¼Œå¦‚æœiæ¯”i+1åˆ†æ•°é«˜ï¼Œé‚£ä¹ˆæ¯”è¾ƒtmp[i]å’Œtmp[i+1]+1ï¼Œå¦‚æœtmp[i]å°ï¼Œæ›´æ–°ã€‚å‡å¦‚åˆ†æ•°i-1<iï¼Œé‚£ä¹ˆä¸‹ä¸€æ¬¡ç»§ç»­æ£€æŸ¥ï¼Œå¦‚æœåˆ†æ•°i-1>iï¼Œå› ä¸ºç¬¬ä¸€æ¬¡tmp[i]>tmp[i-1]ï¼Œä»å³å¾€å·¦æ›´æ–°tmp[i]åªå¯èƒ½å¢åŠ ï¼Œä¾ç„¶æ»¡è¶³å¤§å°å…³ç³»

class Solution:
    def candy(self, ratings):
        """
        :type ratings: List[int]
        :rtype: int
        """
        s = 0
        n=len(ratings)
        s+=n
        tmp =[0]*n
        for i in range(1,n):
            if ratings[i]>ratings[i-1]:
                tmp[i] = tmp[i-1]+1
        for i in range(n-2,-1,-1):
            if ratings[i]>ratings[i+1]:
                tmp[i]=max(tmp[i],tmp[i+1]+1)
        s+=sum(tmp)
        return s
@äº‘ç«¯ è¯·é—®ä¸ºä»€ä¹ˆæœ€åæ˜¯å–æœ€å¤§å€¼å‘¢ï¼Ÿæˆ‘çŸ¥é“å¤§æ¦‚æ€è·¯æ˜¯ï¼šä»å·¦åˆ°å³çš„å…³ç³»éœ€è¦è¢«æ»¡è¶³ï¼Œä»å³åˆ°å·¦çš„å…³ç³»ä¹Ÿéœ€è¦è¢«æ»¡è¶³ï¼Œæ‰€ä»¥åšäº†ä¸€ä¸ªâ€ä¸â€œæ“ä½œã€‚ä½†æ˜¯ä¸ºä»€ä¹ˆå–æœ€å¤§å€¼å°±ç›¸å½“äºå–â€ä¸â€œæ“ä½œäº†å‘¢ï¼Ÿ
@abcuzi ç”¨minæ‰æ˜¯ä¸ï¼Œä»–è¿™maxç›¸å½“äºæˆ–ï¼Œmax(tmp[i],tmp[i+1]+1)ä¿è¯äº†tmp[i]èµ·ç æ¯”tmp[i+1]+1å¤§ï¼Œä¹Ÿå°±æ˜¯ä»å³åˆ°å·¦ä¹Ÿæ˜¯æ»¡è¶³çš„

class Solution:
    def candy(self, ratings: List[int]) -> int:
        candyVec = [1] * len(ratings)
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                candyVec[i] = candyVec[i - 1] + 1
        for j in range(len(ratings) - 2, -1, -1):
            if ratings[j] > ratings[j + 1]:
                candyVec[j] = max(candyVec[j], candyVec[j + 1] + 1)
        return sum(candyVec)

class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        ret = 1
        inc, dec, pre = 1, 0, 1

        for i in range(1, n):
            if ratings[i] >= ratings[i - 1]:
                dec = 0
                pre = (1 if ratings[i] == ratings[i - 1] else pre + 1)
                ret += pre
                inc = pre
            else:
                dec += 1
                if dec == inc:
                    dec += 1
                ret += dec
                pre = 1
        
        return ret

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        left = [0] * n
        for i in range(n):
            if i > 0 and ratings[i] > ratings[i - 1]:
                left[i] = left[i - 1] + 1
            else:
                left[i] = 1
        
        right = ret = 0
        for i in range(n - 1, -1, -1):
            if i < n - 1 and ratings[i] > ratings[i + 1]:
                right += 1
            else:
                right = 1
            ret += max(left[i], right)
        
        return ret

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

##  155. <a name='-1'></a>207-è¯¾ç¨‹è¡¨

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Ut411a74a?spm_id_from=333.999.0.0)

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV19k4y1r76s?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1jz411B7UJ?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1Xp4y1Y7FJ?spm_id_from=333.999.0.0)

```py
class Solution(object):

    # è¿™é‡Œä½¿ç”¨é€†é‚»æ¥è¡¨

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int è¯¾ç¨‹é—¨æ•°
        :type prerequisites: List[List[int]] è¯¾ç¨‹ä¸è¯¾ç¨‹ä¹‹é—´çš„å…³ç³»
        :rtype: bool
        """
        # è¯¾ç¨‹çš„é•¿åº¦
        clen = len(prerequisites)
        if clen == 0:
            # æ²¡æœ‰è¯¾ç¨‹ï¼Œå½“ç„¶å¯ä»¥å®Œæˆè¯¾ç¨‹çš„å­¦ä¹ 
            return True
        # æ·±åº¦ä¼˜å…ˆéå†ï¼Œåˆ¤æ–­ç»“ç‚¹æ˜¯å¦è®¿é—®è¿‡
        # è¿™é‡Œè¦è®¾ç½® 3 ä¸ªçŠ¶æ€
        # 0 å°±å¯¹åº” False ï¼Œè¡¨ç¤ºç»“ç‚¹æ²¡æœ‰è®¿é—®è¿‡
        # 1 å°±å¯¹åº” True ï¼Œè¡¨ç¤ºç»“ç‚¹å·²ç»è®¿é—®è¿‡ï¼Œåœ¨æ·±åº¦ä¼˜å…ˆéå†ç»“æŸä»¥åæ‰ç½®ä¸º 1
        # 2 è¡¨ç¤ºå½“å‰æ­£åœ¨éå†çš„ç»“ç‚¹ï¼Œå¦‚æœåœ¨æ·±åº¦ä¼˜å…ˆéå†çš„è¿‡ç¨‹ä¸­ï¼Œ
        # æœ‰é‡åˆ°çŠ¶æ€ä¸º 2 çš„ç»“ç‚¹ï¼Œå°±è¡¨ç¤ºè¿™ä¸ªå›¾ä¸­å­˜åœ¨ç¯
        visited = [0 for _ in range(numCourses)]
        print("visited:", visited)

        # é€†é‚»æ¥è¡¨ï¼Œå­˜çš„æ˜¯æ¯ä¸ªç»“ç‚¹çš„å‰é©±ç»“ç‚¹çš„é›†åˆ
        # æƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºä»–ä»¬: [0,1]
        # 1 åœ¨å‰ï¼Œ0 åœ¨å
        inverse_adj = [set() for _ in range(numCourses)]
        print("inverse_adj:",inverse_adj)
        for second, first in prerequisites:
            print("[first]:",first)
            print("[second]:",second)
            inverse_adj[second].add(first)
            print("inverse_adjè¡¨ç¤ºåœ¨å­¦ä¹ ç¬¬[",second,"]èŠ‚è¯¾å‰ï¼Œè¦å…ˆå­¦ä¹ :",inverse_adj[second])

        for i in range(numCourses):
            # åœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‘ç°æœ‰ç¯ï¼Œåˆ™dfsè¿”å›trueï¼Œå°±é€€å‡º
            if self.__dfs(i, inverse_adj, visited,1): # visited åˆå§‹åŒ–ä¸º 0
                return False
        return True

    def __dfs(self, vertex, inverse_adj, visited,depth):
        """
        æ³¨æ„ï¼šè¿™ä¸ªé€’å½’æ–¹æ³•çš„è¿”å›å€¼æ˜¯è¿”å›æ˜¯å¦æœ‰ç¯
        :param vertex: ç»“ç‚¹çš„ç´¢å¼•
        :param inverse_adj: é€†é‚»æ¥è¡¨ï¼Œè®°å½•çš„æ˜¯å½“å‰ç»“ç‚¹çš„å‰é©±ç»“ç‚¹çš„é›†åˆ
        :param visited: è®°å½•äº†ç»“ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡ï¼Œ2 è¡¨ç¤ºå½“å‰æ­£åœ¨ DFS è¿™ä¸ªç»“ç‚¹
        :return: æ˜¯å¦æœ‰ç¯
        """
        # ç»“æŸæ¡ä»¶ï¼š
        # 2 è¡¨ç¤ºè¿™ä¸ªç»“ç‚¹æ­£åœ¨è®¿é—®
        # 2 è¡¨ç¤ºå½“å‰æ­£åœ¨éå†çš„ç»“ç‚¹ï¼Œå¦‚æœåœ¨æ·±åº¦ä¼˜å…ˆéå†çš„è¿‡ç¨‹ä¸­ï¼Œ
            # -------------ğŸ¨å¾ˆé‡è¦ğŸ¨-------------
        if visited[vertex] == 2:
            # è¡¨ç¤ºé‡åˆ°ç¯
            # æœ‰é‡åˆ°çŠ¶æ€ä¸º 2 çš„ç»“ç‚¹ï¼Œå°±è¡¨ç¤ºè¿™ä¸ªå›¾ä¸­å­˜åœ¨ç¯
            return True
            # -------------ğŸ¨å¾ˆé‡è¦ğŸ¨-------------
        if visited[vertex] == 1: # 1 è¡¨ç¤ºç»“ç‚¹å·²ç»è®¿é—®è¿‡ï¼Œåœ¨æ·±åº¦ä¼˜å…ˆéå†ç»“æŸä»¥åæ‰ç½®ä¸º 1
            return False

        print("ç¬¬1æ­¥vertex:",vertex,"visited:", visited," depth:",depth)
        visited[vertex] = 2
        print("ç¬¬2æ­¥vertex:",vertex,"visited:", visited," depth:",depth)
        for precursor in inverse_adj[vertex]: # æ˜¯ä¸ªset()
            # å¦‚æœæœ‰ç¯ï¼Œå°±è¿”å› True è¡¨ç¤ºæœ‰ç¯
            # -------------ğŸ¨å¾ˆé‡è¦ğŸ¨-------------
            if self.__dfs(precursor, inverse_adj, visited,depth+1):
                return True 
            # -------------ğŸ¨å¾ˆé‡è¦ğŸ¨-------------
        print("ç¬¬3æ­¥vertex:",vertex,"visited:", visited," depth:",depth)

        # 1 è¡¨ç¤ºè®¿é—®ç»“æŸ
        visited[vertex] = 1
        print("ç¬¬4æ­¥vertex:",vertex,"visited:", visited," depth:",depth)
        return False

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        visited = [0] * numCourses
        result = list()
        valid = True

        for info in prerequisites:
            edges[info[1]].append(info[0])
        
        def dfs(u: int):
            nonlocal valid
            visited[u] = 1
            for v in edges[u]:
                if visited[v] == 0:
                    dfs(v)
                    if not valid:
                        return
                elif visited[v] == 1:
                    valid = False
                    return
            visited[u] = 2
            result.append(u)
        
        for i in range(numCourses):
            if valid and not visited[i]:
                dfs(i)
        
        return valid

class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        def dfs(i, colors, prerequisites):
        	colors[i] = 'G'
        	#print i, colors
        	for front, tail in prerequisites:
        		if tail == i:
        			if colors[front] == 'G':
        				return False
        			elif colors[front] == 'B':
        				continue
        			elif dfs(front, colors, prerequisites) == False:
        				return False
        	colors[i] = 'B'
        	return True

        colors = ['W' for i in range(numCourses)]
        for i in range(numCourses):
        	if colors[i] == 'W':
        		if dfs(i, colors, prerequisites) == False:
        			return False
        return True
```

```py
# python
from collections import defaultdict 
class Solution:
    def canFinish(self, numCourses, prerequisites):
        inde = defaultdict(lambda:0)  # keep track of indegree of a course
        g = defaultdict(list)          # digraph of courses 
        for t,f in prerequisites:
            g[f].append(t)
            inde[t]+=1
        inde0 = []                   # inde0 holds courses whose indegree is 0
        for i in range(numCourses):
            if inde[i]==0:
                inde0.append(i)      # initialize inde0
        for i in inde0:
            for j in g[i]:
                inde[j]-=1
                if inde[j]==0:
                    inde0.append(j)
        return len(inde0)==numCourses

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        indeg = [0] * numCourses

        for info in prerequisites:
            edges[info[1]].append(info[0])
            indeg[info[0]] += 1
        
        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])
        visited = 0

        while q:
            visited += 1
            u = q.popleft()
            for v in edges[u]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)

        return visited == numCourses

class Solution(object):

    # æ€æƒ³ï¼šè¯¥æ–¹æ³•çš„æ¯ä¸€æ­¥æ€»æ˜¯è¾“å‡ºå½“å‰æ— å‰è¶‹ï¼ˆå³å…¥åº¦ä¸ºé›¶ï¼‰çš„é¡¶ç‚¹

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int è¯¾ç¨‹é—¨æ•°
        :type prerequisites: List[List[int]] è¯¾ç¨‹ä¸è¯¾ç¨‹ä¹‹é—´çš„å…³ç³»
        :rtype: bool
        """
        # è¯¾ç¨‹çš„é•¿åº¦
        clen = len(prerequisites)
        if clen == 0:
            # æ²¡æœ‰è¯¾ç¨‹ï¼Œå½“ç„¶å¯ä»¥å®Œæˆè¯¾ç¨‹çš„å­¦ä¹ 
            return True
        # å…¥åº¦æ•°ç»„ï¼Œä¸€å¼€å§‹å…¨éƒ¨ä¸º 0
        in_degrees = [0 for _ in range(numCourses)]
        # é‚»æ¥è¡¨
        adj = [set() for _ in range(numCourses)]

        # æƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºä»–ä»¬: [0,1]
        # [0,1] è¡¨ç¤º 1 åœ¨å…ˆï¼Œ0 åœ¨å
        # æ³¨æ„ï¼šé‚»æ¥è¡¨å­˜æ”¾çš„æ˜¯åç»§ successor ç»“ç‚¹çš„é›†åˆ
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)

        # print("in_degrees", in_degrees)
        # é¦–å…ˆéå†ä¸€éï¼ŒæŠŠæ‰€æœ‰å…¥åº¦ä¸º 0 çš„ç»“ç‚¹åŠ å…¥é˜Ÿåˆ—
        res = []
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)
        counter = 0
        while queue:
            top = queue.pop(0)
            counter += 1

            for successor in adj[top]:
                in_degrees[successor] -= 1
                if in_degrees[successor] == 0:
                    queue.append(successor)

        return counter == numCourses
```

```scala

// new and apply
// Use the new keyword when you want to refer to a class's own constructor:
// è§£æ³•æ˜¯ æ¯ä¸ªnode(node)ï¼Œ1.å®ƒä¾èµ–çš„nodeä¸ªæ•°(parent) 2.ç»Ÿè®¡ä¾èµ–å®ƒçš„nodeä¸ªæ•°(son)ï¼Œ
// ä¸€ä¸ªnodeæ²¡æœ‰ä¾èµ–å…¶å®ƒèŠ‚ç‚¹ï¼Œæ”¾å…¥zeroInDegree
// å¯¹zeroIndegreeçš„nodeéå†ï¼Œå¯¹æ¯ä¸ªä¾èµ–å®ƒçš„nodeéƒ½å¯ä»¥ç›´æ¥é™¤å»ä¾èµ–


  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def canFinish(numCourses: Int, prerequisites: Array[Array[Int]]): Boolean = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //å¿…é¡»åˆå§‹åŒ–

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum == numCourses
    }
  }

  class Test extends BaseExtension {
    def init {
      val input = Array(Array(0,1),Array(1,2))
      println(Solution.canFinish(3,input) == true)
      //println(lru.get(1) == 1)
    }

    val name = "207 course schedule"
  }

```

##  156. <a name='-1'></a>572-å¦ä¸€ä¸ªæ ‘çš„å­æ ‘

[å“ˆå“ˆå“ˆ](https://www.bilibili.com/video/BV1cA411t7zD?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1wt4y197aB?spm_id_from=333.999.0.0)

```py
è¿™é¢˜ä¸å¯èƒ½æ˜¯ç®€å•é¢˜

class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        def dfs(A,B): # å‡½æ•°çš„åŠŸèƒ½è¦æ˜ç¡®ï¼Œç”¨æ¥åˆ¤æ–­å½“å‰å­æ ‘æ˜¯å¦ä¸€è‡´
            if not B and not A: # å¦‚æœåŒæ—¶ä¸ºç©ºï¼Œåˆ™å­æ ‘ä¸€è‡´
                return True
            if not A and B: # ä¸€ä¸ªä¸ºç©ºï¼Œå¦ä¸€ä¸ªä¸ä¸ºç©ºï¼Œåˆ™å­æ ‘ä¸ä¸€è‡´
                return False
            if not B and A:
                return False
            if A.val != B.val: # å¦‚æœå½“å‰èŠ‚ç‚¹çš„å€¼ä¸ç›¸ç­‰ï¼Œæ˜¾ç„¶ä¸ä¸€è‡´
                return False
            return dfs(A.left, B.left) and dfs(A.right, B.right) # é€’å½’å»å¯¹ç…§ä¸¤ä¸ªå­æ ‘çš„å·¦å­æ ‘å’Œå³å­æ ‘
        
        if not root or not subRoot:
            return False
        if root.val == subRoot.val:
            if dfs(root, subRoot):
                return True
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
```

```py
python

class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        if not root or not subRoot: return False
        l = self.isSubtree(root.left, subRoot)
        r = self.isSubtree(root.right, subRoot)    
        def equal(root1, root2):
            if not root1 and not root2: return True
            elif not root1 or not root2: return False
            elif root1.val != root2.val: return False
            else: return equal(root1.left, root2.left) and equal(root1.right, root2.right)
        return equal(root, subRoot) or l or r
å­¦ä¹ ä¸€ä¸‹é€Ÿåº¦æœ€å¿«é‚£å‡ ç§æ–¹æ³•ä¹‹ä¸€:åºåˆ—åŒ–ï¼ˆå…ƒç»„åŒ–ï¼‰+å­—ç¬¦ä¸²æ¯”è¾ƒ-----æ‰“è´¥96%

class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        def toTup(t):#è¿™ä¸ªå‡½æ•°æŠŠæ ‘åºåˆ—åŒ–ä¸ºä¸€ä¸ªå…ƒç»„
            return (t.val,toTup(t.left),toTup(t.right)) if t else None
        return str(toTup(t)) in str(toTup(s))#æŠŠå…ƒç»„è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ä»¥æ–¹ä¾¿æ¯”è¾ƒ
```

##  157. <a name='-1'></a>10. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…

https://leetcode-cn.com/problems/regular-expression-matching/solution/

```py
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)

        def matches(i: int, j: int) -> bool:
            if i == 0:
                return False
            if p[j - 1] == '.':
                return True
            return s[i - 1] == p[j - 1]

        f = [[False] * (n + 1) for _ in range(m + 1)]
        f[0][0] = True
        for i in range(m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    f[i][j] |= f[i][j - 2]
                    if matches(i, j - 1):
                        f[i][j] |= f[i - 1][j]
                else:
                    if matches(i, j):
                        f[i][j] |= f[i - 1][j - 1]
        return f[m][n]

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

åŠ¨æ€è§„åˆ’

def isMatch(self, s: str, p: str) -> bool:
        """
        æ€è·¯ï¼šåŠ¨æ€è§„åˆ’ï¼Œ å®šä¹‰äºŒç»´dpæ•°ç»„ï¼Œå…¶ä¸­dp[i][j]è¡¨ç¤ºsçš„å‰iä¸ªå­—ç¬¦å’Œpçš„å‰jä¸ªå­—ç¬¦æ˜¯å¦åŒ¹é…ï¼Œ
        ä¸ºäº†æ–¹ä¾¿åˆå§‹åŒ–ï¼Œæˆ‘ä»¬å°†så’Œpçš„é•¿åº¦å‡+1
        è€ƒè™‘åˆ°Pä¸­å¯èƒ½å‡ºç°ä¸‰ç§å­—ç¬¦ï¼šæ™®é€šå­—æ¯(a-z)ã€'*'æˆ–è€…æ˜¯'.', åˆ™å…¶åŠ¨æ€è½¬ç§»æ–¹ç¨‹åˆ†åˆ«æ˜¯ï¼š
        1) å¦‚æœp[j]ä¸ºæ™®é€šå­—æ¯ï¼Œdp[i][j]==dp[i-1][j-1] and s[i]==p[j]
        2) å¦‚æœp[j]ä¸º'.', dp[i][j]==dp[i-1][j-1]
        3) å¦‚æœp[j]ä¸º'*', åˆ™æƒ…å†µæ¯”è¾ƒå¤æ‚, åˆ†ä»¥ä¸‹ä¸¤ç§æƒ…å†µè®¨è®ºï¼š
           A. ä»¥s="c", p="ca*"ä¸ºä¾‹ï¼Œæ­¤æ—¶'*'åŒ¹é…0æ¬¡ï¼Œdp[i][j]==dp[i][j-2]
           B. ä»¥s="caa", p="ca*"ä¸ºä¾‹ï¼Œæ­¤æ—¶'*'åŒ¹é…å¤šæ¬¡ï¼Œdp[i][j]==dp[i-1][j] and s[i]==p[j-1] (è€ƒè™‘åˆ°é€šé…ç¬¦'.', è¿˜æœ‰p[j-1]=='.'çš„æƒ…å†µ)
        """
        # ä¸ºäº†è§£å†³s="a", p="c*a"ä¸­*ç»„åˆåœ¨på¼€å¤´0æ¬¡åŒ¹é…çš„é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦é¢å¤–åˆå§‹åŒ–dp[0][:], ä¸ºæ­¤ï¼Œåœ¨så‰åŠ ä¸€ç‰¹æ®Šå­—ç¬¦ï¼Œä»¥æ–¹ä¾¿æ“ä½œ
        s = " " + s
        dp = [[False]*(len(p)+1) for _ in range(len(s))]   # [len(s)+1, len(s)+1]
        dp[0][0] = True  # å‡å®šså’Œpéƒ½ä»ç©ºå­—ç¬¦å¼€å§‹
        
        for i in range(len(s)):  # sçš„ç©ºå­—ç¬¦éœ€è¦é¢å¤–åˆå§‹åŒ–
            for j in range(1, len(p)+1):
                if p[j-1] == '*':   # *å¯ä»¥å‡ºç°0æ¬¡æˆ–è€…å¤šæ¬¡
                    dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (s[i]==p[j-2] or p[j-2]=='.'))

                else: # '.'å’Œæ™®é€šå­—æ¯çš„æƒ…å†µå¯åˆä¸ºä¸€ç§
                    dp[i][j] = dp[i-1][j-1] and (s[i]==p[j-1] or p[j-1]=='.')

        return dp[-1][-1]

æ…¢å·¥å‡ºç»†æ´»ï¼Œå¦‚æœä¸æ¸…æ¥šçš„è¯ï¼Œä¸€å®šè¦ä»”ç»†è®¨è®ºæ‰€æœ‰çš„å¯èƒ½ï¼Œä¸è¦æƒ³ç€ä¸€ä¸Šæ¥å°±ä¼˜åŒ–ï¼Œå°±æœ€ç¹ççš„åˆ—ä¸¾å‡ºæ‰€æœ‰çš„å¯èƒ½ï¼Œä¸€ä¸ªä¸€ä¸ªçš„å†™å‡ºè½¬ç§»æ–¹ç¨‹

class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m=len(s)
        n=len(p)
        dp=[[False for _ in range(n+1)]for _ in range(m+1)]#dp[i][j]è¡¨ç¤ºp[0:j]æ˜¯å¦ä¸s[0:i]åŒ¹é…
        for i in range(m+1):
            for j in range(n+1):
                #pä¸ºç©ºä¸²
                if j==0:
                    #å½“ä¸”ä»…å½“sä¹Ÿä¸ºç©ºä¸²æ—¶ï¼Œæ‰åŒ¹é…
                    if i==0:
                        dp[i][j]=True
                #pä¸ä¸ºç©ºåºŠ
                else:
                    #åˆ¤æ–­å½“å‰pçš„æœ€åä¸€ä½p[j-1]
                    if p[j-1]==".":
                        #å‰ææ˜¯å½“å‰sæœ‰é•¿åº¦
                        if i>0:
                            #æ— è®ºå½“å‰sçš„æœ€åä¸€ä½s[i-1]æ˜¯ä»€ä¹ˆï¼Œéƒ½æ˜¯åŒ¹é…çš„
                            dp[i][j]=dp[i-1][j-1]
                    elif p[j-1]=="*":#è¿˜éœ€è¦åˆ¤æ–­p[j-2]æ˜¯ä»€ä¹ˆ
                        #å‰ææ˜¯å½“å‰çš„pçš„é•¿åº¦æ˜¯å¤§äºç­‰äº2çš„
                        if j>1:
                            #åˆ†ä¸¤ç§æƒ…å†µï¼š*å‘æŒ¥ä½œç”¨ï¼Œé‡å¤å‰é¢çš„å­—ç¬¦å¤§äº0æ¬¡, *ä¸å‘æŒ¥ä½œç”¨,å³æœ€åä¸¤ä¸ªå­—ç¬¦æ²¡å•¥ç”¨
                            #å³å¯èƒ½æ˜¯è¿™ä¸¤ç§ä¸­çš„ä¸€ç§ä½¿å¾—åŒ¹é…ï¼Œä¹Ÿå¯èƒ½ä¸¤ç§æƒ…å†µä¸‹éƒ½ä¸ä¼šä½¿å¾—åŒ¹é…,å³æ˜¯æ‰€æœ‰å¯èƒ½çš„åˆé›†
                            #å› ä¸ºæ²¡æœ‰è¿ç»­çš„*ï¼Œæ‰€æœ‰p[j-2]ä¸å¯èƒ½æ˜¯*
                            #æ‰€ä»¥åªæœ‰ä¸¤ç§æƒ…å†µï¼Œ. æˆ–è€…æ™®é€šå­—ç¬¦ï¼Œç”±äº.å¯ä»¥åŒ¹é…ä»»æ„çš„å­—ç¬¦ï¼Œæ‰€ä»¥p[j-2]æ— è®ºæ˜¯.è¿˜æ˜¯æ™®é€šå­—ç¬¦ï¼Œå¯¹æ¯”äºsæ¥è¯´éƒ½æ˜¯ä¸€æ ·çš„
                            #å¼€å§‹è®¨è®º
                            #*å‘æŒ¥ä½œç”¨ï¼Œé‡å¤å‰é¢çš„å­—ç¬¦å¤§äº0æ¬¡,åˆ™éœ€è¦æ¯”è¾ƒs
                            if i>0:
                                if p[j-2]==".":#åˆ™æ— è®ºs[i-1]æ˜¯å•¥ï¼Œéƒ½èƒ½åŒ¹é…ä¸Š
                                    dp[i][j]|=dp[i-1][j]#ä¸çŸ¥é“é‡å¤å‡ æ¬¡ï¼Œp[j-2]p[j-1]å¯èƒ½è¿˜å¯ä»¥ç»§ç»­ç”¨æ‰€ä»¥è¿˜æ˜¯p[0:j]
                                else:
                                    if p[j-2]==s[i-1]:
                                        dp[i][j]|=dp[i-1][j]#ä¸çŸ¥é“é‡å¤å‡ æ¬¡ï¼Œp[j-2]p[j-1]å¯èƒ½è¿˜å¯ä»¥ç»§ç»­ç”¨æ‰€ä»¥è¿˜æ˜¯p[0:j]
                            #*ä¸å‘æŒ¥ä½œç”¨,å³æœ€åä¸¤ä¸ªå­—ç¬¦æ²¡å•¥ç”¨
                            dp[i][j]|=dp[i][j-2]#å³P[0:j-2]

                            #|=çš„æ„æ€æ˜¯dp[i][j]æ˜¯ä»è¿™ä¸‰è€…ä¸­çš„ä»»æ„ä¸€ä¸ªæ¼”å˜è€Œæ¥çš„ï¼Œéƒ½æœ‰å¯èƒ½
                    else:
                        #å½“å‰pçš„æœ€åä¸€ä½æ˜¯å¸¸è§„å­—æ¯
                        #å‰ææ˜¯å½“å‰sæœ‰é•¿åº¦
                        if i>0:
                            #åˆ¤æ–­å½“å‰sçš„æœ€åä¸€ä½æ˜¯å¦ç­‰äºpçš„æœ€åä¸€ä½
                            if p[j-1]==s[i-1]:
                                dp[i][j]=dp[i-1][j-1]
        return dp[m][n]       
```

##  158. <a name='-1'></a>55 Jump Game

[å°æ˜](https://www.bilibili.com/video/BV14K4y1b7Fw?spm_id_from=333.999.0.0)

[å®˜æ–¹](https://www.bilibili.com/video/BV1be411s7XX?spm_id_from=333.999.0.0)

```py
# é¦–é€‰whileå¾ªç¯ğŸ˜
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)
        i = 0

        while cover >= i:
            cover = max(cover, i+nums[i])
            if cover >= n -  1:
                return True
            i += 1
        return False



# ç²¾ç®€ä¸€ä¸‹çš„forå¾ªç¯ğŸ˜
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)

        for i in range(n):
            if i <= cover: # æ˜“é”™ç‚¹ï¼šåœ¨åˆ¤æ–­ä¸‹ä¸€ä¸ªcoverå‰ï¼Œå…ˆè¦åˆ¤æ–­iæ˜¯å¦èƒ½å¤Ÿåˆ°è¾¾
                cover = max(cover, i+nums[i])
                # if cover == i:
                    # return False # æ˜“é”™ç‚¹ï¼šåº”è¯¥è€ƒè™‘ç‰¹æ®Šæƒ…å†µ[0,1,2]

                if cover >= n -  1:
                    return True
        return False
```

```py
object Solution {
    def canJump(nums: Array[Int]): Boolean = {
        
        // We should look at this probelm in REVERSE ORDER:
        // The target is to check whether we can arrive at the last index,
        // then we should reversely check the elements,
        // meanwhile, update the smallest index that we must arrive (`target`) in order to arrive at the last index
        
        // For example, if the i-2 index index is 2,
        // we know we can make it as long as the earlier elements can send us to i-2 index.
        // My target should be updated to i-2 index rather than the last index.
        
        val n = nums.length 
     
        var target = n-1 // the initial target
        var i = n - 2
        
        // update the target
        while (i > 0) {
            if (nums(i) + i >= target) {
                target = i
            }
            i -= 1
        }
        
        // check if the first element can trigger the "chain effect"
        if (nums(0) >= target) {
            true
        } else {
            false
        }
 
    }
}
```

```scala


/**
* my first commitment: backtracking + dp - top-down
* memo:
*   1. cache array record which position could jump to destination
*   2. run the loop of jump step size  backward
*/

object Solution1-1 {
    sealed trait Index
    case object Good extends Index 
    case object Bad extends Index
    case object Unknown extends Index
  
    def canJump(nums: Array[Int]): Boolean = {
        val cache = Array.fill[Index](nums.length)(Unknown)
        cache(cache.length-1) = Good
        dfs(nums, 0, cache)

    }
  
    def dfs(nums: Array[Int], pos: Int, cache: Array[Index]): Boolean = {
      if (cache(pos) != Unknown) {
        return cache(pos) == Good
      }
      
      val furthestJump = ((nums.length - 1) - pos) min nums(pos) // don't jump exceed array's length
      val ret = (furthestJump to 1 by -1).collectFirst {  // 1 to  furthestJump would lead to TLE
        case j if dfs(nums, pos + j, cache) =>  true
      }.getOrElse(false)
      
      
      if (ret) cache(pos) = Good else cache(pos) = Bad
      ret
    }
}

/**
* backtracking: DP bottom-up: more simpler
* memo
* 1. solve problem from tail to head
* 2. cache value: true for GOOD position, false for Bad position
* 3. if cache(0) is true, we could jump to last position from position zero
*/

object Solution1-2 {
    def canJump(nums: Array[Int]): Boolean = {
      val cache = Array.ofDim[Boolean](nums.length)
      cache(cache.length - 1) = true
      
      (nums.length - 2 to 0 by -1).foreach { pos =>
        val furthestJump = ((nums.length - 1) - pos) min nums(pos)
        (furthestJump to 1 by -1).collectFirst {
          case step if cache(pos + step) => 
          cache(pos) = true
          cache(pos)
        }.getOrElse(false)
      }
      cache(0)
    }
}


/**
* Greedy - check each position could jump to last good position
* memo:
*  1. solve problem backward
*  2. record last good position which could jump to last position within multi-hop
*  3. check zero position could jump to last position by checking last position equals to zero
* time complexity: O(N)
*/

object Solution2-1 {
    def canJump(nums: Array[Int]): Boolean = {
      var lastPosition = nums.length - 1
      
      (nums.length - 2 to 0 by -1).foreach{ pos =>
        if((nums(pos) +  pos) >= lastPosition) {
          lastPosition = pos
        }
        
      }
      lastPosition == 0
    }
}


/**
* Greedy: check max reach position
* memo
*  1. record max reach position: if current position is larger than max reach position, it means we couldn't jump to current position and it wouldn't be able to jump to last position
* time complexity: O(N)
*/

object Solution3-1 {
    def canJump(nums: Array[Int]): Boolean = {
      var maxReachPos = nums(0)
      nums.indices.forall { pos =>  
          if (pos > maxReachPos) false  
          else {
            maxReachPos = maxReachPos max (pos + nums(pos))
            true
          }
        }        
    }
}

```

##  159. <a name='-1'></a>1047. åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ç›¸é‚»é‡å¤é¡¹

```py
class Solution:
    def removeDuplicates(self, s: str) -> str:
        stk = list()
        for ch in s:
            if stk and stk[-1] == ch:
                stk.pop()
            else:
                stk.append(ch)
        return "".join(stk)

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/shan-chu-zi-fu-chuan-zhong-de-suo-you-xi-4ohr/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```py
class Solution(object):
    def removeDuplicates(self, S):
        """
        :type S: str
        :rtype: str
        """
        # åˆå§‹åŒ–æ ˆ
        stack = []
        # éå†æ ˆå…ƒç´ 
        for e in S:
            if stack and stack[-1] == e:
                stack.pop()
            else:
                stack.append(e)
        return "".join(stack)
ä½ å¥½ï¼è¯·æ•™ä¸€ä¸‹if stack and stack[-1] == e: å’Œ if e in stack and stack[-1] == e:ä¸ºä»€ä¹ˆæ€§èƒ½å·®è·è¿™ä¹ˆå¤§ï¼Ÿä¸€ä¸ªæœ‰70+msä¸€ä¸ªæœ‰150+ms
 if stackï¼Œåªéœ€è¦åˆ¤æ–­stackæ˜¯å¦ä¸ºç©ºï¼Œä¸ä¸ºç©ºåˆ™æ‰§è¡Œã€‚if e in stackï¼Œéœ€è¦éå†stackï¼Œåˆ¤æ–­æ˜¯å¦æœ‰å…ƒç´ å’Œeç›¸åŒï¼Œç›´åˆ°æ‰¾åˆ°ç›¸åŒçš„ï¼Œæ‰§è¡Œï¼Œæˆ–è€…éå†å®Œä»æ²¡æœ‰ç›¸åŒçš„ï¼Œä¸æ‰§è¡Œã€‚

 Pythonï¼š

# æ–¹æ³•ä¸€ï¼Œä½¿ç”¨æ ˆï¼Œæ¨èï¼
class Solution:
    def removeDuplicates(self, s: str) -> str:
        res = list()
        for item in s:
            if res and res[-1] == item:
                res.pop()
            else:
                res.append(item)
        return "".join(res)  # å­—ç¬¦ä¸²æ‹¼æ¥
# æ–¹æ³•äºŒï¼Œä½¿ç”¨åŒæŒ‡é’ˆæ¨¡æ‹Ÿæ ˆï¼Œå¦‚æœä¸è®©ç”¨æ ˆå¯ä»¥ä½œä¸ºå¤‡é€‰æ–¹æ³•ã€‚
class Solution:
    def removeDuplicates(self, s: str) -> str:
        res = list(s)
        slow = fast = 0
        length = len(res)

        while fast < length:
            # å¦‚æœä¸€æ ·ç›´æ¥æ¢ï¼Œä¸ä¸€æ ·ä¼šæŠŠåé¢çš„å¡«åœ¨slowçš„ä½ç½®
            res[slow] = res[fast]
            
            # å¦‚æœå‘ç°å’Œå‰ä¸€ä¸ªä¸€æ ·ï¼Œå°±é€€ä¸€æ ¼æŒ‡é’ˆ
            if slow > 0 and res[slow] == res[slow - 1]:
                slow -= 1
            else:
                slow += 1
            fast += 1
            
        return ''.join(res[0: slow])
```

##  160. <a name='-1'></a>91. Decode Ways

[èŠ±èŠ±é…±](https://www.bilibili.com/video/BV1Lb411y7ec?spm_id_from=333.999.0.0)

[å°æ˜](https://www.bilibili.com/video/BV1Pf4y1G7M5?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        
        @cache
        def dp(i):
            if i == 0: 
                if '1' <= s[i] <= '9':
                    return 1
                else:
                    return 0
            if i == -1: 
                return 1 
                # æ˜“é”™ç‚¹ï¼šreturn 1ï¼Œè€Œä¸æ˜¯return 0ï¼Œæ¯”å¦‚â€˜12â€™ï¼Œdp(i-2)åº”è¯¥è¦æ˜¯1çš„
            if i >= 1:
                res = 0
                if '1' <= s[i] <= '9':
                    res = dp(i-1)
                if '10' <= s[i-1:i+1] <= '26':
                    res += dp(i-2)
                return res
        
        return dp(len(s) - 1)
```

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp0 = 1 # è¿™é‡Œdp=0æˆ–è€…æ˜¯dp=1éƒ½å¯ä»¥ï¼Œå› ä¸ºåœ¨ç¬¬ä¸€è½®çš„å¾ªç¯è¿‡åä¼šæ›´æ–°
        dp1 = 1
        for i in range(n):
            res = 0
            if '1' <= s[i] <= '9':
                res = dp1
            if i > 0 and '10' <= s[i-1:i+1] <= '26':
                res += dp0
            dp1, dp0 = res, dp1
        return dp1
```

```scala


/**
* my first commitment dynamic programming
* memo:
* 1.subproblem dp(i) represents the decode ways of the sub-string which length is i 
* 2. dp(i) could be sum from dp(i-1) or dp(i-2) if s(i -1, i) or s(i-2, i) are valid coding
*  idx:   0 1 2 3 4 5 6 7
*  length 1 2 3 4 5 6 7 8
&  value  1 2 1 3 2 5 8 3
*   
*   dp(1) => "1"
*   dp(2) => "12" :
*            valid("12") + dp(0)
*            valid("2") + dp(1)
*   dp(3) => "121" :
*           valid("21") + dp(1)
*           valid("1) + dp(2)
*
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def numDecodings(s: String): Int = {
      if(s == null || s.length == 0) return 0 
      val dp = Array.ofDim[Int](s.length + 1)
      dp(0) = 1
      dp(1) = if (s(0) == '0') 0 else 1
      (2 to s.length).foreach { idx =>
        val single = s.slice(idx-1, idx).toInt
        val tens = s.slice(idx-2, idx).toInt
        if (0 < single && single <= 9)
          dp(idx) += dp(idx-1)
        if (10 <= tens && tens <= 26)
          dp(idx) += dp(idx-2)
      
      }
      dp.last
    }
}
/**
* instead of using slice, handle single and tens by hands
* memo
*  1. char as digit
*/

object Solution1-1 {
    def numDecodings(s: String): Int = {
      if(s == null || s.length == 0) return 0 
      val dp = Array.ofDim[Int](s.length + 1)
      dp(0) = 1
      dp(1) = if (s(0) == '0') 0 else 1
      (2 to s.length).foreach { idx =>
        val single = s(idx-1).asDigit
        val tens = s(idx-2).asDigit * 10 + single
        if (0 < single && single <= 9)
          dp(idx) += dp(idx-1)
        if (10 <= tens && tens <= 26)
          dp(idx) += dp(idx-2)
      }
      
      dp.last
      
    }
}

/**
*  dp - only keep dp(i-1) and dp(i-2)
* time complexity: O(2N)
* space complexity: O(1)
*/

object Solution1-3 {
    def numDecodings(s: String): Int = {
      if (s == null && s.isEmpty) return 0
      (2 to s.length).foldLeft((1, if(s(0) == '0') 0 else 1)) {
      /**
      * pre = dp(i-1)
      * prepre = dp(i-2) 
      */
        case ((prepre, pre), idx) =>
          val decodeOne = if(decodeSingle(s, idx)) pre else 0
          val decodeTwo = if(decodeTens(s, idx)) prepre else 0
          (pre, decodeOne + decodeTwo)
      }._2
    }
  
    def decodeSingle(s: String, idx: Int): Boolean = s(idx - 1) != '0'
  
    def decodeTens(s: String, idx: Int): Boolean = (s(idx - 2) == '1' ) || (s(idx - 2) == '2' && s(idx-1) <= '6' )
    
}



```



# 9 day (å¾—åˆ† = 2åˆ†) 83

##  161. <a name='Offer42.'></a>å‰‘æŒ‡ Offer 42. è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ
##  162. <a name='II-1'></a>445. ä¸¤æ•°ç›¸åŠ  II
##  163. <a name='II-1'></a>213. æ‰“å®¶åŠ«èˆ II
##  164. <a name='9.36'></a>è¡¥å……é¢˜9. 36è¿›åˆ¶åŠ æ³•
##  165. <a name='Offer45.'></a>å‰‘æŒ‡ Offer 45. æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°
##  166. <a name='-1'></a>509. æ–æ³¢é‚£å¥‘æ•°
##  167. <a name='-1'></a>295. æ•°æ®æµçš„ä¸­ä½æ•°
##  168. <a name='Offer61.'></a>å‰‘æŒ‡ Offer 61. æ‰‘å…‹ç‰Œä¸­çš„é¡ºå­
##  169. <a name='-1'></a>106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
##  170. <a name='-1'></a>678. æœ‰æ•ˆçš„æ‹¬å·å­—ç¬¦ä¸²
##  171. <a name='Offer39.'></a>å‰‘æŒ‡ Offer 39. æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—
##  172. <a name='-1'></a>86. åˆ†éš”é“¾è¡¨
##  173. <a name='-1'></a>114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨
##  174. <a name='Offer29.'></a>å‰‘æŒ‡ Offer 29. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ
##  175. <a name='-1'></a>16. æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ
##  176. <a name='-1'></a>450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹
##  177. <a name='K-1'></a>347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ 
##  178. <a name='Offer53-I.I'></a>å‰‘æŒ‡ Offer 53 - I. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾æ•°å­— I
##  179. <a name='-1'></a>344. åè½¬å­—ç¬¦ä¸²
##  180. <a name='-1'></a>191. ä½1çš„ä¸ªæ•°


# 10 day (å¾—åˆ† = 2åˆ†) 85

##  181. <a name='-1'></a>443. å‹ç¼©å­—ç¬¦ä¸²
##  182. <a name='N'></a>400. ç¬¬Nä¸ªæ•°å­—
##  183. <a name='-1'></a>242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯
##  184. <a name='-1'></a>100. ç›¸åŒçš„æ ‘
##  185. <a name='-1'></a>459. é‡å¤çš„å­å­—ç¬¦ä¸²
##  186. <a name='-1'></a>442. æ•°ç»„ä¸­é‡å¤çš„æ•°æ®
##  187. <a name='-1'></a>120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ
##  188. <a name='-1'></a>268. ç¼ºå¤±æ•°å­—
##  189. <a name='-1'></a>887. é¸¡è›‹æ‰è½
##  190. <a name='Offer34.'></a>å‰‘æŒ‡ Offer 34. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„
##  191. <a name='III-1'></a>557. åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯ III
##  192. <a name='14.'></a>è¡¥å……é¢˜14. é˜¿æ‹‰ä¼¯æ•°å­—è½¬ä¸­æ–‡æ•°å­—
##  193. <a name='Excel'></a>168. Excelè¡¨åˆ—åç§°
##  194. <a name='-1'></a>1095. å±±è„‰æ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼
##  195. <a name='-1'></a>670. æœ€å¤§äº¤æ¢
##  196. <a name='Offer11.'></a>å‰‘æŒ‡ Offer 11. æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—
##  197. <a name='II-1'></a>210. è¯¾ç¨‹è¡¨ II
##  198. <a name='-1'></a>525. è¿ç»­æ•°ç»„
##  199. <a name='Offer48.'></a>å‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²
##  200. <a name='III-1'></a>556. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  III


# 11 day (å¾—åˆ† = 2åˆ†) 87

##  201. <a name='-1'></a>111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦
##  202. <a name='-1'></a>37. è§£æ•°ç‹¬
##  203. <a name='-1'></a>134. åŠ æ²¹ç«™
##  204. <a name='22.IP'></a>è¡¥å……é¢˜22. IPåœ°å€ä¸æ•´æ•°çš„è½¬æ¢
##  205. <a name='-1'></a>876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹
##  206. <a name='II-1'></a>63. ä¸åŒè·¯å¾„ II
##  207. <a name='Excel-1'></a>171. Excelè¡¨åˆ—åºå·
##  208. <a name='-1'></a>17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ
##  209. <a name='-1'></a>494. ç›®æ ‡å’Œ
##  210. <a name='Offer03.'></a>å‰‘æŒ‡ Offer 03. æ•°ç»„ä¸­é‡å¤çš„æ•°å­—
##  211. <a name='Offer24.'></a>å‰‘æŒ‡ Offer 24. åè½¬é“¾è¡¨
##  212. <a name='Offer33.'></a>å‰‘æŒ‡ Offer 33. äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—
##  213. <a name='K-1'></a>862. å’Œè‡³å°‘ä¸º K çš„æœ€çŸ­å­æ•°ç»„
##  214. <a name='-1'></a>343. æ•´æ•°æ‹†åˆ†
##  215. <a name='-1'></a>673. æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°
##  216. <a name='17.24.'></a>é¢è¯•é¢˜ 17.24. æœ€å¤§å­çŸ©é˜µ
##  217. <a name='-1'></a>611. æœ‰æ•ˆä¸‰è§’å½¢çš„ä¸ªæ•°
##  218. <a name='II-1'></a>45. è·³è·ƒæ¸¸æˆ II
##  219. <a name='II-1'></a>154. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ II
##  220. <a name='-1'></a>85. æœ€å¤§çŸ©å½¢


# 12 day (å¾—åˆ† = 2åˆ†) 89

##  221. <a name='-1'></a>679. 24 ç‚¹æ¸¸æˆ
##  222. <a name='-1'></a>108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘
##  223. <a name='-1'></a>222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
##  224. <a name='-1'></a>84. æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢
##  225. <a name='-1'></a>71. ç®€åŒ–è·¯å¾„
##  226. <a name='II-'></a>167. ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„
##  227. <a name='-1'></a>622. è®¾è®¡å¾ªç¯é˜Ÿåˆ—
##  228. <a name='Z'></a>6. Z å­—å½¢å˜æ¢
##  229. <a name='-1'></a>96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘
##  230. <a name='-1'></a>547. çœä»½æ•°é‡ï¼ˆåŸæœ‹å‹åœˆï¼‰
##  231. <a name='II-1'></a>264. ä¸‘æ•° II
##  232. <a name='-1'></a>706. è®¾è®¡å“ˆå¸Œæ˜ å°„
##  233. <a name='-1'></a>97. äº¤é”™å­—ç¬¦ä¸²
##  234. <a name='-1'></a>410. åˆ†å‰²æ•°ç»„çš„æœ€å¤§å€¼
##  235. <a name='-1'></a>44. é€šé…ç¬¦åŒ¹é…
##  236. <a name='-1'></a>18. å››æ•°ä¹‹å’Œ
##  237. <a name='-1'></a>405. æ•°å­—è½¬æ¢ä¸ºåå…­è¿›åˆ¶æ•°
##  238. <a name='8.'></a>è¡¥å……é¢˜8. è®¡ç®—æ•°ç»„çš„å°å’Œ
##  239. <a name='K-1'></a>863. äºŒå‰æ ‘ä¸­æ‰€æœ‰è·ç¦»ä¸º K çš„ç»“ç‚¹
##  240. <a name='III-1'></a>337. æ‰“å®¶åŠ«èˆ III


# 13 day (å¾—åˆ† = 1åˆ†) 90

##  241. <a name='-1'></a>166. åˆ†æ•°åˆ°å°æ•°
##  242. <a name='08.12.'></a>é¢è¯•é¢˜ 08.12. å…«çš‡å
##  243. <a name='-1'></a>73. çŸ©é˜µç½®é›¶
##  244. <a name='Offer46.'></a>å‰‘æŒ‡ Offer 46. æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²
##  245. <a name='II-1'></a>503. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II
##  246. <a name='-1'></a>763. åˆ’åˆ†å­—æ¯åŒºé—´
##  247. <a name='K-1'></a>340. è‡³å¤šåŒ…å« K ä¸ªä¸åŒå­—ç¬¦çš„æœ€é•¿å­ä¸²
##  248. <a name='-1'></a>130. è¢«å›´ç»•çš„åŒºåŸŸ
##  249. <a name='II-1'></a>117. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II
##  250. <a name='Offer07.'></a>å‰‘æŒ‡ Offer 07. é‡å»ºäºŒå‰æ ‘
##  251. <a name='K-1'></a>378. æœ‰åºçŸ©é˜µä¸­ç¬¬Kå°çš„å…ƒç´ 
##  252. <a name='Offer32-III.III'></a>å‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III
##  253. <a name='-1'></a>77. ç»„åˆ
##  254. <a name='-1'></a>528. æŒ‰æƒé‡éšæœºé€‰æ‹©
##  255. <a name='-1'></a>279. å®Œå…¨å¹³æ–¹æ•°
##  256. <a name='-1'></a>257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„
##  257. <a name='K-1'></a>692. å‰Kä¸ªé«˜é¢‘å•è¯
##  258. <a name='Offer50.'></a>å‰‘æŒ‡ Offer 50. ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
##  259. <a name='II-1'></a>137. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— II
##  260. <a name='21.'></a>è¡¥å……é¢˜21. å­—ç¬¦ä¸²ç›¸å‡


# 14 day (å¾—åˆ† = 1åˆ†) 91

##  261. <a name='-1'></a>354. ä¿„ç½—æ–¯å¥—å¨ƒä¿¡å°é—®é¢˜
##  262. <a name='II-1'></a>253. ä¼šè®®å®¤ II
##  263. <a name='-1'></a>628. ä¸‰ä¸ªæ•°çš„æœ€å¤§ä¹˜ç§¯
##  264. <a name='-1'></a>674. æœ€é•¿è¿ç»­é€’å¢åºåˆ—
##  265. <a name='Offer57-II.s'></a>å‰‘æŒ‡ Offer 57 - II. å’Œä¸ºsçš„è¿ç»­æ­£æ•°åºåˆ—
##  266. <a name='-1'></a>315. è®¡ç®—å³ä¾§å°äºå½“å‰å…ƒç´ çš„ä¸ªæ•°
##  267. <a name='II-1'></a>107. äºŒå‰æ ‘çš„å±‚æ¬¡éå† II
##  268. <a name='-1'></a>172. é˜¶ä¹˜åçš„é›¶
##  269. <a name='-1'></a>647. å›æ–‡å­ä¸²
##  270. <a name='III-1'></a>260. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— III
##  271. <a name='IV'></a>188. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IV
##  272. <a name='Offer35.'></a>å‰‘æŒ‡ Offer 35. å¤æ‚é“¾è¡¨çš„å¤åˆ¶
##  273. <a name='-1'></a>12. æ•´æ•°è½¬ç½—é©¬æ•°å­—
##  274. <a name='-1'></a>386. å­—å…¸åºæ’æ•°
##  275. <a name='-1'></a>752. æ‰“å¼€è½¬ç›˜é”
##  276. <a name='K-1'></a>395. è‡³å°‘æœ‰Kä¸ªé‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²
##  277. <a name='-1'></a>231. 2çš„å¹‚
##  278. <a name='-1'></a>977. æœ‰åºæ•°ç»„çš„å¹³æ–¹
##  279. <a name='III-1'></a>437. è·¯å¾„æ€»å’Œ III
##  280. <a name='-1'></a>617. åˆå¹¶äºŒå‰æ ‘


# 15 day (å¾—åˆ† = 1åˆ†) 92

##  281. <a name='k'></a>60. ç¬¬kä¸ªæ’åˆ—
##  282. <a name='strStr'></a>28. å®ç° strStr()
##  283. <a name='-1'></a>204. è®¡æ•°è´¨æ•°
##  284. <a name='Offer65.'></a>å‰‘æŒ‡ Offer 65. ä¸ç”¨åŠ å‡ä¹˜é™¤åšåŠ æ³•
##  285. <a name='-1'></a>416. åˆ†å‰²ç­‰å’Œå­é›†
##  286. <a name='N-1'></a>51. Nçš‡å
##  287. <a name='24.'></a>è¡¥å……é¢˜24. åŒæ ˆæ’åº
##  288. <a name='-1'></a>680. éªŒè¯å›æ–‡å­—ç¬¦ä¸² â…¡
##  289. <a name='Offer38.'></a>å‰‘æŒ‡ Offer 38. å­—ç¬¦ä¸²çš„æ’åˆ—
##  290. <a name='-1'></a>701. äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ
##  291. <a name='-1'></a>530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®
##  292. <a name='k-1'></a>698. åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†
##  293. <a name='-1'></a>173. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨
##  294. <a name='-1'></a>426. å°†äºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºæ’åºçš„åŒå‘é“¾è¡¨
##  295. <a name='-1'></a>836. çŸ©å½¢é‡å 
##  296. <a name='-1'></a>99. æ¢å¤äºŒå‰æœç´¢æ ‘
##  297. <a name='-1'></a>316. å»é™¤é‡å¤å­—æ¯
##  298. <a name='-1'></a>109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘
##  299. <a name='-1'></a>115. ä¸åŒçš„å­åºåˆ—
##  300. <a name='-1'></a>1312. è®©å­—ç¬¦ä¸²æˆä¸ºå›æ–‡ä¸²çš„æœ€å°‘æ’å…¥æ¬¡æ•°



