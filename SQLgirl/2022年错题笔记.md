```py
æ³¨æ„ï¼špopitem ä¸æ˜¯ popitemsï¼Œä¹Ÿä¸æ˜¯pop
        if len(self.cache) == self.capacity:
            self.cache.popitem(last = False)
```

```py
æ³¨æ„ï¼šåˆ¤æ–­capacity è¦åœ¨ pop(key) ä¹‹å
        if key in self.cache:
            self.cache.pop(key)
        if len(self.cache) == self.capacity:
            self.cache.popitem(last = False)
```

```py
while True:
    try:
        n = int(input())
        nums = [int(i) for i in input().split()]
        print(upper(nums,n))
    except:
        break
```

```py
éƒ½å¯¹ï¼š

class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head: 
            return None
        cur = head
        cnt = 0
        while cur and cnt != k:
            cur = cur.next
            cnt += 1
        cur = self.reverseKGroup(cur,k)
        if cnt == k:
            while cnt:
                headnxt = head.next
                head.next = cur
                cur = head
                head =  headnxt
                cnt -= 1
            head = cur
        return head

class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        cur = head
        cnt = 0
        while cur and cnt != k: # ğŸ˜ while å¾ªç¯, cur
            cur = cur.next
            cnt += 1
        if cnt == k:
            cur = self.reverseKGroup(cur,k)
            while cnt: # ğŸ˜ while å¾ªç¯
                headnxt = head.next
                head.next = cur
                cur = head
                head = headnxt
                cnt -= 1
            head = cur # æ˜“é”™ç‚¹: è¿™ä¸€æ­¥ä¸èƒ½æ¼
        return head # head è¿›æ¥ï¼Œhead è¿”å›
```